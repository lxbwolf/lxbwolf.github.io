<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaobin&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxb.wiki/"/>
  <updated>2025-02-08T07:52:09.893Z</updated>
  <id>https://lxb.wiki/</id>
  
  <author>
    <name>lxb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React useEffect() Hook</title>
    <link href="https://lxb.wiki/42f8026c/"/>
    <id>https://lxb.wiki/42f8026c/</id>
    <published>2024-05-18T14:16:21.000Z</published>
    <updated>2025-02-08T07:52:09.893Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#side-effect-是什么">Side Effect 是什么</a></li><li><a href="#hook-的作用">Hook 的作用</a></li><li><a href="#useeffect-的用法">useEffect() 的用法</a></li><li><a href="#useeffect-的第二个参数">useEffect() 的第二个参数</a></li><li><a href="#useeffect-的用途">useEffect() 的用途</a></li><li><a href="#useeffect-的返回值">useEffect() 的返回值</a></li></ul><!-- tocstop --><h2><span id="side-effect-是什么">Side Effect 是什么</span></h2><p>函数式编程将那些跟数据计算无关的操作，都称为 <strong>side effect</strong> 。如果函数内部直接包含产生  side effect 的操作，就不再是纯函数了. 纯函数内部只有通过间接的手段（即通过其他函数调用），才能包含 side effect</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202502081529923.png" alt></p><h2><span id="hook-的作用">Hook 的作用</span></h2><p><strong>hook 就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。</strong> 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入。</p><p>由于副效应非常多，所以钩子有许多种。React 为许多常见的操作（副效应），都提供了专用的钩子。</p><ul><li><code>useState()</code>：保存状态</li><li><code>useContext()</code>：保存上下文</li><li><code>useRef()</code>：保存引用</li><li>……</li></ul><p>上面这些钩子，都是引入某种特定的副效应，而 <strong><code>useEffect()</code> 是通用的副效应钩子</strong> 。找不到对应的钩子时，就可以用它。</p><h2><span id="useeffect-的用法">useEffect() 的用法</span></h2><p>例如，希望组件加载以后，网页标题（<code>document.title</code>）会随之改变。那么，改变网页标题这个操作，就是组件的副效应，必须通过 <code>useEffect()</code> 来实现。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>useEffect()</code>的参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，React 就会执行这个函数。</p><h2><span id="useeffect-的第二个参数">useEffect() 的第二个参数</span></h2><p>如果不希望 <code>useEffect()</code> 每次渲染都执行，可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会重新渲染。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`Hello, <span class="subst">$&#123;props.name&#125;</span>`</span>;</span><br><span class="line">  &#125;, [props.<span class="property">name</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面例子中，<code>useEffect()</code>的第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项（<code>props.name</code>）。只有该变量发生变化时，副效应函数才会执行。</p><p>如果第二个参数是一个空数组，就表明副效应参数没有任何依赖项。因此，副效应函数这时只会在组件加载进入 DOM 后执行一次，后面组件重新渲染，就不会再次执行。</p><h2><span id="useeffect-的用途">useEffect() 的用途</span></h2><p>只要是副效应，都可以使用<code>useEffect()</code>引入。它的常见用途有下面几种。</p><ul><li>获取数据（data fetching）</li><li>事件监听或订阅（setting up a subscription）</li><li>改变 DOM（changing the DOM）</li><li>输出日志（logging）</li></ul><p>下面是从远程服务器获取数据的例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">        <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></blockquote><p>上面例子中，<code>useState()</code>用来生成一个状态变量（<code>data</code>），保存获取的数据；<code>useEffect()</code>的副效应函数内部有一个 async 函数，用来从服务器异步获取数据。拿到数据以后，再用<code>setData()</code>触发组件的重新渲染。</p><p>由于获取数据只需要执行一次，所以上例的<code>useEffect()</code>的第二个参数为一个空数组。</p><h2><span id="useeffect-的返回值">useEffect() 的返回值</span></h2><p>副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应。</p><p><code>useEffect()</code>允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，<code>useEffect()</code>就不用返回任何值。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.<span class="property">source</span>]);</span><br></pre></td></tr></table></figure></blockquote><p>上面例子中，<code>useEffect()</code>在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。</p><p>实际使用中，由于副效应函数默认是每次渲染都会执行，所以清理函数不仅会在组件卸载时执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。</p>]]></content>
    
    <summary type="html">
    
      React Hooks
    
    </summary>
    
    
      <category term="FE" scheme="https://lxb.wiki/categories/FE/"/>
    
    
      <category term="react" scheme="https://lxb.wiki/tags/react/"/>
    
      <category term="hooks" scheme="https://lxb.wiki/tags/hooks/"/>
    
  </entry>
  
  <entry>
    <title>Vue 2.x 使用高德地图JS API 2.0加载起点终点路径轨迹</title>
    <link href="https://lxb.wiki/b7826aa4/"/>
    <id>https://lxb.wiki/b7826aa4/</id>
    <published>2024-05-01T13:51:18.000Z</published>
    <updated>2025-02-08T07:22:42.710Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#需求">需求</a></li><li><a href="#在-html-文件中引入地图-js">在 html 文件中引入地图 js</a></li><li><a href="#主页面">主页面</a></li><li><a href="#地图组件">地图组件</a></li><li><a href="#代码解析">代码解析</a></li><li><a href="#调起地图h5-组件">调起地图H5 组件</a></li></ul><!-- tocstop --><h2><span id="需求">需求</span></h2><ol><li><p>在地图中显示行驶轨迹，自定义标记点图标<br>地图厂商使用高德地图，使用目前最新的高德地图JSAPI 2.0</p></li><li><p>在自己的 H5 中调起多个地图app，显示标记点位置<br>由于地图 APP 并不支持在自己的网页中直接打开，因此需要通过地图 URI API 调用厂商H5地图，在厂商H5地图调起地图app</p></li></ol><h2><span id="在-html-文件中引入地图-js">在 html 文件中引入地图 js</span></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://webapi.amap.com/maps?v=2.0&amp;key=申请的key值&amp;plugin=AMap.Driving&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2><span id="主页面">主页面</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;index&quot;&gt;</span><br><span class="line">    &lt;template &gt;</span><br><span class="line">      &lt;v-map :data=&quot;dataList&quot;&gt;&lt;/v-map&gt;</span><br><span class="line">      &lt;v-detail :statrLocation=&quot;statrLocation&quot; :endLocation=&quot;endLocation&quot;/&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Map from &#x27;./mMap.vue&#x27;  // 地图</span><br><span class="line">import Detail from &#x27;./detail.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;index&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dataList: [],</span><br><span class="line">      statrLocation: &#123;&#125;,</span><br><span class="line">      endLocation: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;v-map&quot;: Map,</span><br><span class="line">    &quot;v-detail&quot;: Detail</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">  this.dataList = [</span><br><span class="line">      &#123;</span><br><span class="line">        longitude: 116.478346,</span><br><span class="line">        latitude: 39.997361</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        longitude: 116.402796,</span><br><span class="line">        latitude: 39.936915</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">    this.statrLocation = this.dataList[0]</span><br><span class="line">    this.endLocation = this.dataList[this.dataList.length-1]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">.index &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background: #fcf9f2;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2><span id="地图组件">地图组件</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">// mMap.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;m-map&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;map-box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;data&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      map: &#123;&#125;,</span><br><span class="line">      lineArr: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.initMap()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    initMap() &#123;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.map = new AMap.Map(&#x27;map-box&#x27;, &#123;</span><br><span class="line">          resizeEnable: true, //是否监控地图容器尺寸变化</span><br><span class="line">          zoom: 14, //初始化地图层级</span><br><span class="line">          center: [116.397428, 39.90923], //初始化地图中心点</span><br><span class="line">          animateEnable: true// 地图平移过程中是否使用动画</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        if(this.lineArr.length) &#123;</span><br><span class="line">          this.drawLine()  //绘制路线</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    drawLine()&#123;</span><br><span class="line">      AMap.convertFrom(this.lineArr, &#x27;gps&#x27;, (status, result) =&gt; &#123;</span><br><span class="line">        if (result.info === &#x27;ok&#x27;) &#123;</span><br><span class="line">          const paths = result.locations;</span><br><span class="line"></span><br><span class="line">          this.map.clearMap()</span><br><span class="line"></span><br><span class="line">          this.startMarker = new AMap.Marker(&#123;</span><br><span class="line">            map: this.map,</span><br><span class="line">            position: paths[0],  //起点经纬度</span><br><span class="line">            icon: new AMap.Icon(&#123;            </span><br><span class="line">              image: require(&#x27;@/assets/img/icon/icon-start.png&#x27;),</span><br><span class="line">              size: new AMap.Size(120, 120),  //图标所处区域大小</span><br><span class="line">              imageSize: new AMap.Size(120,120) //图标大小</span><br><span class="line">            &#125;),   //起点ico</span><br><span class="line">            offset: new AMap.Pixel(-60, -60),</span><br><span class="line">            autoRotation: true,</span><br><span class="line">            // angle:-90,</span><br><span class="line">          &#125;);</span><br><span class="line">          </span><br><span class="line">          this.endMarker = new AMap.Marker(&#123;</span><br><span class="line">            map: this.map,</span><br><span class="line">            position: paths[paths.length-1], //终点经纬度</span><br><span class="line">            icon: new AMap.Icon(&#123;            </span><br><span class="line">              image: require(&#x27;@/assets/img/icon/icon-end.png&#x27;),</span><br><span class="line">              size: new AMap.Size(60, 60),  //图标所处区域大小</span><br><span class="line">              imageSize: new AMap.Size(60,60) //图标大小</span><br><span class="line">            &#125;),   //终点ico</span><br><span class="line">            offset: new AMap.Pixel(-30, -30),</span><br><span class="line">            autoRotation: true,</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          // 绘制轨迹</span><br><span class="line">          var polyline = new AMap.Polyline(&#123;</span><br><span class="line">            map: this.map,</span><br><span class="line">            path: paths,</span><br><span class="line">            showDir: true,</span><br><span class="line">            strokeColor: &#x27;#28F&#x27;, //线颜色</span><br><span class="line">            // strokeOpacity: 1,     //线透明度</span><br><span class="line">            strokeWeight: 6, //线宽</span><br><span class="line">            // strokeStyle: &quot;solid&quot;  //线样式</span><br><span class="line">          &#125;);</span><br><span class="line">          this.map.add([this.startMarker, this.endMarker]);</span><br><span class="line">          this.map.setFitView();  //自适应缩放级别</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      handler(newValue, oldValue) &#123;</span><br><span class="line">        this.lineArr = [];</span><br><span class="line">        if(newValue.length) &#123;</span><br><span class="line">          newValue.map((item, index) =&gt; &#123;</span><br><span class="line">            if( item.longitude != null &amp;&amp; item.latitude != null ) &#123;</span><br><span class="line">              this.lineArr.push(new AMap.LngLat(item.longitude,item.latitude));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          this.drawLine();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang =&quot;scss&quot;&gt;</span><br><span class="line">@import &#x27;@/assets/scss/mixin.scss&#x27;;</span><br><span class="line">.m-map &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  #map-box &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2><span id="代码解析">代码解析</span></h2><p>在使用中发现标记点位置显示不对，存在一定的偏移，需要将其他坐标转为高德坐标方法. 在绘制轨迹之前先转换为高德坐标，然后再删除地图上所有的覆盖物，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AMap</span>.<span class="title function_">convertFrom</span>(<span class="variable language_">this</span>.<span class="property">lineArr</span>, <span class="string">&#x27;gps&#x27;</span>, <span class="function">(<span class="params">status, result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (result.<span class="property">info</span> === <span class="string">&#x27;ok&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> paths = result.<span class="property">locations</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">clearMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以使用专门处理地理坐标系的js库<a href="https://github.com/hujiulong/gcoord">gcoord</a>，用来修正百度地图、高德地图及其它互联网地图坐标系不统一的问题。</p><h2><span id="调起地图h5-组件">调起地图H5 组件</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">// detail.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;m-detail-box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;m-btn-wrapper&quot;&gt;</span><br><span class="line">      &lt;van-button class=&quot;open-btn&quot; round  @click=&quot;openShow = true&quot;&gt;导航至车辆当前位置&lt;/van-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;van-action-sheet </span><br><span class="line">      class=&quot;m-sheet-box&quot;</span><br><span class="line">      v-model=&quot;openShow&quot; </span><br><span class="line">      :actions=&quot;actions&quot; </span><br><span class="line">      cancel-text=&quot;取消&quot;</span><br><span class="line">      close-on-click-action</span><br><span class="line">      @select=&quot;onSelect&quot; </span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  Toast</span><br><span class="line">&#125; from &#x27;vant&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    statrLocation: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    endLocation: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      openShow: false,</span><br><span class="line">      actions: [</span><br><span class="line">      &#123; name: &#x27;使用苹果地图导航&#x27;, value: &#x27;iosamap&#x27;, color: &#x27;#007AFF&#x27; &#125;, </span><br><span class="line">        &#123; name: &#x27;使用百度地图导航&#x27;, value: &#x27;bmap&#x27;, color: &#x27;#007AFF&#x27; &#125;, </span><br><span class="line">        &#123; name: &#x27;使用高德地图导航&#x27;, value: &#x27;amap&#x27;, color: &#x27;#007AFF&#x27; &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onSelect(item) &#123;</span><br><span class="line">      this.openShow = false;</span><br><span class="line">      let startLocation = this.startLocation</span><br><span class="line">      let endLocation = this.endLocation</span><br><span class="line">      </span><br><span class="line">      if (endLocation.longitude &amp;&amp; endLocation.latitude) &#123;</span><br><span class="line">        let url = &#x27;&#x27;</span><br><span class="line">        switch (item.value) &#123;</span><br><span class="line">          case &#x27;iosamap&#x27;:</span><br><span class="line">            url = `iosamap://navi?sourceApplication=applicationName&amp;backScheme=applicationScheme&amp;poiname=$&#123;location&#125;&amp;poiid=BGVIS&amp;lat=$&#123;endLocation.latitude&#125;&amp;lon=$&#123;endLocation.longitude&#125;&amp;dev=1&amp;style=2`</span><br><span class="line">            break;</span><br><span class="line">          case &#x27;bmap&#x27;:</span><br><span class="line">            // 单点标注</span><br><span class="line">            url = `http://api.map.baidu.com/marker?location=$&#123;endLocation.latitude&#125;,$&#123;endLocation.longitude&#125;&amp;title=车辆位置&amp;content=实时定位&amp;output=html&amp;coord_type=wgs84&amp;src=webapp.baidu.openAPIdemo`</span><br><span class="line">            </span><br><span class="line">            // 路径规划</span><br><span class="line">            // url = `http://api.map.baidu.com/direction?origin=latlng:$&#123;startLocation.latitude&#125;,$&#123;startLocation.longitude&#125;|name:我的位置&amp;destination=latlng:$&#123;endLocation.latitude&#125;,$&#123;endLocation.longitude&#125;|name:实时定位&amp;mode=driving&amp;coord_type=wgs84&amp;src=webapp.baidu.openAPIdemo`</span><br><span class="line">            break;</span><br><span class="line">          case &#x27;amap&#x27;:</span><br><span class="line">            // 单点标注</span><br><span class="line">            url = `https://uri.amap.com/marker?position=$&#123;endLocation.longitude&#125;,$&#123;endLocation.latitude&#125;&amp;name=实时定位&amp;src=mypage&amp;coordinate=wgs84&amp;callnative=1`</span><br><span class="line"></span><br><span class="line">            // 路径规划</span><br><span class="line">            // url = `https://uri.amap.com/navigation?from=$&#123;startLocation.longitude&#125;,$&#123;startLocation.latitude&#125;,我的位置&amp;to=$&#123;endLocation.longitude&#125;,$&#123;endLocation.latitude&#125;,实时定位&amp;mode=car&amp;policy=1&amp;coordinate=wgs84&amp;callnative=1`</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        window.open(url)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Toast(&#123;</span><br><span class="line">          message: &#x27;暂无车辆定位&#x27;,</span><br><span class="line">          type: &#x27;fail&#x27;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    clearInterval(this.timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &quot;@/assets/scss/mixin.scss&quot;;</span><br><span class="line"></span><br><span class="line">.m-detail-box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  padding: 20px 0 0;</span><br><span class="line">  border-radius: 20px 20px 0px 0px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: #FEFFFE;</span><br><span class="line">  box-shadow: 0 4px 40px 4px rgba(135, 119, 145, 0.36);</span><br><span class="line">  z-index: 160;</span><br><span class="line"></span><br><span class="line">  .van-cell-group &#123;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">      border: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .van-cell &#123;</span><br><span class="line">    padding: 12px 24px;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    font-weight: 600;</span><br><span class="line"></span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">      left: 24px;</span><br><span class="line">      right: 24px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-cell__title &#123;</span><br><span class="line">      flex: none;</span><br><span class="line">      color: #757AB5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-cell__value &#123;</span><br><span class="line">      color: #292929;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .m-btn-wrapper &#123;</span><br><span class="line">    border-top: 1px solid #EFF2F9;</span><br><span class="line">    background: #FFF;</span><br><span class="line"></span><br><span class="line">    .open-btn &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      margin: 10px auto;</span><br><span class="line">      padding: 14px;</span><br><span class="line">      width: 90%;</span><br><span class="line">      font-size: 18px;</span><br><span class="line">      color: #FEFFFE;</span><br><span class="line">      background: #85D4D9;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /deep/.van-overlay &#123;</span><br><span class="line">    background: rgba(33, 34, 51, 0.5);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .m-sheet-box &#123;</span><br><span class="line">    padding: 0 8px;</span><br><span class="line">    background: transparent;</span><br><span class="line"></span><br><span class="line">    .van-action-sheet__content &#123;</span><br><span class="line">      border-radius: 14px;</span><br><span class="line">      background: rgba(255, 255, 255, 0.92);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-action-sheet__gap &#123;</span><br><span class="line">      height: 20px;</span><br><span class="line">      background: transparent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-action-sheet__cancel &#123;</span><br><span class="line">      margin-bottom: 20px;</span><br><span class="line">      border-radius: 14px;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">      color: #007AFF;</span><br><span class="line">      background: rgba(255, 255, 255, 0.92);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用高德地图 API 加载起点终点路径轨迹
    
    </summary>
    
    
      <category term="FE" scheme="https://lxb.wiki/categories/FE/"/>
    
    
      <category term="vue" scheme="https://lxb.wiki/tags/vue/"/>
    
      <category term="amap" scheme="https://lxb.wiki/tags/amap/"/>
    
      <category term="地图" scheme="https://lxb.wiki/tags/%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>家庭用电插座</title>
    <link href="https://lxb.wiki/0565b4f5/"/>
    <id>https://lxb.wiki/0565b4f5/</id>
    <published>2024-04-11T05:48:31.000Z</published>
    <updated>2025-02-02T12:10:22.403Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#10a和16a插座的区别">10a和16a插座的区别</a><ul><li><a href="#1-外观区别">1、外观区别</a></li><li><a href="#2-使用区别">2、使用区别</a></li><li><a href="#3-插座金属">3、插座金属</a></li><li><a href="#4-承受范围">4、承受范围</a></li></ul></li><li><a href="#哪些电器用16a插座">哪些电器用16a插座</a></li></ul><!-- tocstop --><h2><span id="10a和16a插座的区别">10a和16a插座的区别</span></h2><h3><span id="1-外观区别">1、外观区别</span></h3><p>主要是插孔间距的尺寸区别。16a插座三插孔的孔距比10a插座更大。所以不同标准的插孔和插头并不能适用。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202407112150581.png" alt></p><p>10a插座为五眼插：1个三眼、1个二眼，而16a插座是一个三眼插，比10a三眼插宽广些。</p><h3><span id="2-使用区别">2、使用区别</span></h3><p>16a插头和10a插头不通用，10a插头插不到16a插座里去，当然反过来也是不行的。</p><h3><span id="3-插座金属">3、插座金属</span></h3><p>16a插座承载电流大于10a插座，用到的铜也比较多，而10a插座用的材料也有所不同。</p><p>16a插座需要布置4平方毫米以上规格的铜线，而10a插座最好布置2.5平方毫米铜线。</p><h3><span id="4-承受范围">4、承受范围</span></h3><p>16a插座可以承受3000瓦以内电器功率，而10a插座功率控制在2200瓦以内，不然容易发生意外。</p><h2><span id="哪些电器用16a插座">哪些电器用16a插座</span></h2><p>家里常用的大功率电器主要是空调、电磁炉、热水器</p><p>16a插座是承受范围比较大的插座，家居中一般主要在空调电器上使用，所以我们经常可以见到空调的隔壁安装的是一个不一样的插座，这是对用电安全的需求</p>]]></content>
    
    <summary type="html">
    
      家庭用电插座 10A 16A
    
    </summary>
    
    
      <category term="Life" scheme="https://lxb.wiki/categories/Life/"/>
    
    
      <category term="用电" scheme="https://lxb.wiki/tags/%E7%94%A8%E7%94%B5/"/>
    
      <category term="插座" scheme="https://lxb.wiki/tags/%E6%8F%92%E5%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 14.4 引发Java 应用崩溃</title>
    <link href="https://lxb.wiki/a520e262/"/>
    <id>https://lxb.wiki/a520e262/</id>
    <published>2024-03-15T06:05:49.000Z</published>
    <updated>2025-02-02T11:48:02.448Z</updated>
    
    <content type="html"><![CDATA[<p>根据Java官方发布的文章，由于macOS上运行的进程可能会访问受保护内存区域中的内存。在 macOS 14.4 更新之前，在某些情况下，macOS 内核会通过向进程发送信号 SIGBUS 或 SIGSEGV 来响应这些受保护的内存访问。然后该进程可以选择处理该信号并继续执行。而在最新 macOS 14.4 中，当线程在写入模式下运行时，如果尝试对受保护的内存区域进行内存访问，macOS 将发送信号SIGKILL。该进程无法处理该信号，并且该进程将无条件终止。</p><p>目前该问题主要受影响的Mac机型和Java版本包括：</p><ul><li>Mac机型：M1、M2、M3（Apple Silicon m* 芯片）</li><li>Java版本：Java 8 - Java 22 所有版本</li></ul><p>如果还在使用Intel芯片的话，这次不受影响。</p><p>官方文章 <a href="https://blogs.oracle.com/java/post/java-on-macos-14-4">Java users on macOS 14 running on Apple silicon systems should skip macOS 14.4 and update directly to macOS 14.4.1 (oracle.com)</a></p><p>在x上，Java开发领域的一些大v们，也发现了这个问题，并提醒大家不要升级。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202405091709429.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202405091712272.png" alt></p><p>其他资料</p><p><a href="https://lobste.rs/s/onr9sb/java_users_on_macos_14_running_on_apple">Java users on macOS 14 running on Apple silicon systems should consider delaying the macOS 14.4 update | Lobsters</a></p>]]></content>
    
    <summary type="html">
    
      MacOS 14.4 引发 Java 应用崩溃
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="mac" scheme="https://lxb.wiki/tags/mac/"/>
    
      <category term="jdk" scheme="https://lxb.wiki/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>重定向广告</title>
    <link href="https://lxb.wiki/cb9b2c66/"/>
    <id>https://lxb.wiki/cb9b2c66/</id>
    <published>2024-03-04T05:27:13.000Z</published>
    <updated>2025-02-02T11:48:02.458Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="为什么在京东搜索的商品会展示在抖音广告上">为什么在京东搜索的商品，会展示在抖音广告上</span></h2><p>不知道你是不是也会遇到这个情况，你刚才说想要个戴森吹风机，头条APP里的广告就展示了戴森的广告。</p><p>当你在京东的搜索框里搜索了蒸锅后，你的其他软件可能就被蒸锅攻陷了。</p><p>头条广告里看到苏泊尔蒸锅的广告，刷抖音时能看到苏泊尔的广告，上个知乎还能看到苏泊尔的广告……。是不是感觉自己完全陷入了恶性循环，进了套路里。</p><p>甚至是，你从两部手机切换过后，还是会看到苏泊尔蒸锅的广告！</p><p>如果你认为是巧合，那就大错特错了，其实这是广告界常用的产品，叫做<strong>重定向广告</strong>。</p><p>这个操作对广告主来说那是极好的，实际上是却给人带来了极大的恐惧感。就好比你在微信的聊天记录，公开到了所有产品上，被所有人无情鞭策。</p><p>互联网时代信息公开透明，但却让人们少了隐私。</p><h3><span id="为什么主流产品都这么干">为什么主流产品都这么干</span></h3><p>思考一个场景：</p><p>假设你在京东搜索电视机，可能你是有购买意向的，但最后没有下单转化。对于平台来说，损失了一个客户。如果，同时有几万人都有这个行为，那对平台来说就损失很大了。</p><p>所以，平台要做两件事。</p><p><strong>一是在站内，做二次营销。</strong></p><p>比如弹出搜索的专属红包，或专属优惠券，用红包权益进行二次刺激。</p><p>如下图每日优鲜的截图，搜索之后，进入商详页，会直接给相关的优惠券，刺激下单转化。据说让利10元，可以提升转化率40%以上。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042139107.png" alt></p><p><strong>二是在站外，做重定向广告</strong>。</p><p>它就像定位器一样，无时不刻找到你并给你展示广告。假如你离开了网站，平台就会有这个方法牢牢拴住你。</p><p>比如在京东搜索蒸锅，马上在头条就会投放蒸锅的广告，而且每次的广告品牌可能也会不一样</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042139685.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042140887.png" alt></p><p>据 Google Adwords提供的数据，在30天内为同一个用户展示7~10次广告的转化效果最好，做到这个程度的广告收益可以达到三倍以上。</p><p>站内浏览广告并购买的用户仅为5%，有95%的用户流失掉了，拉回并转化这些用户，则是重定向广告的使命。</p><p>坦福大学商学院的营销学教授Navdeep Sahni曾经做过一个实验，他利用各种重定向活动对 <a href="http://BuildDirect.com">http://BuildDirect.com</a> 的23w用户进行访问观测。</p><p>在观测期间，有的用户零广告观看，有的用户观看15次以上，经过4周的试验后，得出结论：重定向广告增加了他们返回网站的可能性接近15％，很大一部分人因为重定向广告，改变了行为。</p><h3><span id="整个过程是什么样子的">整个过程是什么样子的</span></h3><p>其实，整个过程并不复杂</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042141865.png" alt></p><p>假如你作为电商网站的产品经理，如果想要接入重定向广告能力，需要做这几步，</p><h4><span id="1-在你的网站埋入统计追踪代码">1. 在你的网站埋入统计追踪代码</span></h4><p>有些是广告联盟提供的是插件或者SDK，比如 Avazu DSP提供的就是一个插件，给到其他商家店铺。</p><p>这份代码主要目的是为了把用户的信息记录到浏览器或手机本地的cookie里，其投放平台读取这份cookie，其中包含用户id，电话号，基本信息，访问信息等。</p><p>当然，cookie不是万能的，还会引入其他的手段继续识别用户身份，比如设备识别码，手机信息，web浏览器、操作系统、屏幕分辨率、时区、语言、插件、字体等</p><p>这些信息可以确定唯一的用户身份，当你换设备的时候，其实已经通过这些信息再一次进行了关联。</p><p><strong>逃？那是不可能的，细思极恐吧！</strong></p><h4><span id="2-在线竞价">2. 在线竞价</span></h4><p>先普及一下广告业务的竞价排名。简单来讲，就是通过价格优势来竞争广告位。</p><p>比如百度的广告，你出价“起点学院”的广告词，虽然你是起点学院的负责人老曹，但是并不一定能够拿到这个词，因为友商三节课花的价钱更高，拿到了“起点学院”这个词。</p><p>当用户在百度搜索“起点学院”时，出现的是三节课的推广（当然，这并不会发生）。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042141152.png" alt></p><p>我们回到重定向广告的竞价，其实一个道理，用户在淘宝搜索蒸锅，也在京东搜索的蒸锅，那到底是展示淘宝的推广还是京东的推广呢？</p><p>还是一决雌雄吧，<strong>我们靠竞价说话，谁价格高，广告联盟就出谁的广告</strong>。</p><h4><span id="3-展示广告">3. 展示广告</span></h4><p>凡是和广告联盟对接的流量平台， 都可以承接广告。当流量平台识别出用户id后，自动替换掉默认出的广告图，打上个性化广告。</p><p>下面的是Avazu DSP可以投放的流量平台，用户在这些流量渠道即可看到重定向广告。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042142982.png" alt></p><p>当重定向发展到第二阶段时，由原来的搜索1对1关系，扩散到1对多的关系。算法的引入，可以更精准预测了用户的购买需求。</p><p>比如本来搜索的是大疆无人机，那么推荐一些和大疆相关的其他商品，增加购买的可能性。</p><h3><span id="细思极恐的东西">细思极恐的东西</span></h3><p>作为一个吃瓜群众，莫名其妙的就被广告主割了韭菜，防不胜防，也无法防。</p><p>在2017年，苹果推出了新功能叫<strong>智能反追踪</strong>，并集成在 Safari浏览器中，为了保护用户的隐私不被泄露。</p><p>不过，苹果受不住利益的诱惑，在可以保住底裤的同时，今年又推出了隐私保护广告点击归因，其旨在即能保护用户隐私，还能给广告主信息进行广告投放。</p><p>简单来说，是用户把自己的信息存储到了cookie中，或者存储到手机设备中，广告主可以识别这些信息对应到人，但是却无法解析到更多其他信息了。</p><p>这个做法和阿里的数据银行比较相似，用户的详细数据是明确禁止外部传播的，数据银行给品牌产出的数据仅仅是人群包，人群包只能在内部有权限的业务识别，保障了数据的安全性。</p><h2><span id="微信刚聊完就收到商品推荐电商app在监视我吗">微信刚聊完就收到商品推荐，电商App在监视我吗</span></h2><p>当你搜索、点击、浏览、收藏、购买了某件商品后，紧接着就会收到网站或电商平台的相关广告推送，这已经不是什么新鲜事了，你在互联网上的一举一动，在商家眼里就是大数据和用户画像。</p><p>但是，当你的微信聊天记录、和同事面对面说话时的聊天内容、手机相册里的照片也会被电商APP用于推荐广告时，你会感到害怕吗？</p><p>近日有用户称，自己在微信群聊中讨论过一款雨伞，随后就收到了电商平台的短信推送。不仅如此，不少用户反映自己的手机相册、面对面聊天中的内容都有可能已被“窃听”，因为收到了与此相关的精准广告推送。</p><p>事实上，一些应用软件在安装时就获取了用户位置、相机、麦克风等诸多权限，你的所有信息和随后的浏览、搜索行为都会成为一个一个的数据库文件，最终组成有标签、有画像的“另一个自己”。不光地域、性别、消费习惯，商家还能知道你手机里装了哪些APP。</p><p>从技术上来看，分析提取文字、图片、语音、视频等内容中的商品信息并做精准推荐并无难度，可能泄露个人信息的“重灾区”主要集中在应用软件、输入法、公开WiFi、运营商等方面。对于电商广告投放平台来说，接入第三方数据库的行为非常普遍，基本可以算是标配。</p><h3><span id="1-无处不在的精准推荐">1 无处不在的精准推荐</span></h3><p>近日，用户A称，8月14日下午，有朋友在微信群里询问“赤峰有没有蕉下伞专柜”，他回答称“不太清楚”。第二天上午，他就收到当当网的短信，推送了“蕉下小黑伞清仓99元”的购买链接。</p><p>用户A表示，除了在微信群里和朋友互动之外，他没有在任何地方搜索、浏览过雨伞。“收到当当短信的那一刻，直觉告诉我，我被监控了。”</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042145625.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042145049.png" alt></p><p>事后，当当网客服表示，当当网每期的推送是根据平台的促销活动随机发出，用户在当当网的搜索和购买记录平台能获取，但在其它平台上的痕迹并不能获取到。微信团队尚未对此事给出回复。</p><p>用户A的案例只是“被监控”的一种情况，用户B则是相册信息被读取。她穿了一套新衣服，拍了一些照片存在手机相册里，随后她打开淘宝首页，推荐的商品均是该款衣服或类似款式。</p><p>汪雨表示，她有一次在跟淘宝客服进行售后交涉时候需要上传照片，所以打开了淘宝访问相册的权限，“我授权该权限是出于购物沟通服务的目的，并没有同意平台用我的相册内容推送广告，更不知道他会不会转给第三方或用作其它用途。”</p><p>类似的情况时有发生，有用户称刚发布一条表示希望阿迪达斯可以把某款鞋的设计师请回来，并配了相关图片，随后就收到了该鞋的推荐广告。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042146371.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042147558.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042147249.png" alt></p><p>以上种种案例表明，除了我们日常搜索、浏览、购物之外，相册照片、微信私人聊天记录和群聊记录、物理对话、在社交平台上发布的文字和图片等，都有可能被广告盯上，在互联网包围下的我们仿佛变成了“透明人”。</p><h3><span id="2-应用软件-输入法-wi-fi-成信息泄露重灾区">2 应用软件、输入法、Wi-Fi 成信息泄露重灾区</span></h3><p>电商平台是怎么获取用户数据的？</p><p>对于相册照片被读取的情况，淘宝或者这些大平台的隐私协议都写了会获取用户的内容，这中间是有灰色地带的，有可能一些软件借着正当业务需求获得了用户权限之后，再用于广告投放或其它用途，但它用隐私条款巧妙回避了法律责任，打了擦边球。一些软件获取了用户的相册、话筒权限后，识别照片、语音是一件很容易的事。</p><p>一些第三方输入法，包括为了提升用户体验开启的云词库等都可能是信息泄露的方式，输入法在免费给用户使用的同时也可能在做一些盈利的事。</p><p>公开WiFi也是泄露个人信息的一大风险，很多时候免费连WiFi或者手机开启了WiFi模式，就会自动去检索附近的热点，一旦碰上，WiFi都可以收取一定程度的数据。</p><p>此外，安卓手机上的很多应用可以开启特殊权限，是隐私泄露的重灾区。它们可能通过一些应用获取到信息，包括聊天消息上传到云端，AI快速精准识别关键字，推送信息给广告商。</p><h3><span id="3-网络行为怎么变成广告推荐">3 网络行为怎么变成广告推荐？</span></h3><p>拿输入法来说，输入法的数据类似于一个第三方DMP（数据管理平台），拿到这个数据后，还要进行一次数据库匹配，例如和一部手机的Device  ID匹配，如果发现用户之前输入过某品牌的雨伞，就可以推送这款产品给用户。而电商广告投放平台接入第三方DMP的行为非常普遍，基本可以算是标配。</p><p>百度、阿里、腾讯等都会将平台上的用户行为打标签做成数据库对第三方开放，付费后就能共享信息。</p><p>“我们的广告投放主要通过大数据分析，比如通过阿里数据库得到一部分喜欢网购的人的标签，包括他们的购物习惯、消费行为、地域，比如一个用户常浏览汽车、珠宝等品类，消费客单价较高，可能会被定位成高端消费群体，我们找到这些人平时刷什么样的平台，针对性地去投放广告。” </p><p>具体的投放方式可以基于地理位置，或是依据数据定向投放。</p><p>另一种方式是可以通过一些数据知道这些人的设备里下载了哪些APP，如果很大比例的人下载了某一款，就可以去该平台投放广告。举例来说，假如某平台有5000万注册用户，经检测发现这些人中有大部分下载了知乎、豆瓣，第三方广告商就可以去这两个平台上投放广告，再结合用户在百度的浏览记录、淘宝的购买记录等，就会有一个更加精准的用户画像。</p><p>腾讯广告投放包括微信和广点通（覆盖微信之外的QQ、腾讯新闻、QQ浏览器、天天快报等腾讯旗下产品），微信上目前的广告是公众号内文和末尾广告、朋友圈广告、小程序贴片广告，公众号是随机投放，按点击付费一次0.5元起。 </p><p>“腾讯大数据会分析用户的行为，比如用户经常会浏览、搜索、点击、购买支付的是哪些内容，腾讯旗下各产品之间的信息是互通的，所有发生的用户行为就会形成一个用户画像，做成一个标签，比如最终得出某用户的健身情况、学历教育、对美妆护肤的喜好等。”</p><p>朋友圈广告投放是先根据品牌需求定向筛选用户，再按广告曝光次数收费，北京和上海这样的核心城市是0.1元/次曝光，广州、深圳、苏州、杭州是重点城市，0.06元/次曝光，下一级普通城市0.03元/次曝光。</p><p>也就是说，如果刷朋友圈的时候看到了某品牌的广告，不管有没有点击，都算一次广告曝光，北京的用户刷到一个广告就为微信贡献了1毛钱广告费。</p><p>“各种拉票软件、会议软件、文献提供者、新闻阅读软件等的第一步都是要得到用户的各种数据获取的授权才能运用，这些APP从诞生之日起都有着强制性、偷窥目的的恶意，不少隐蔽性非常强，或者存在强制性获取个人信息的情况。”</p>]]></content>
    
    <summary type="html">
    
      重定向广告
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="广告" scheme="https://lxb.wiki/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>Pyenv工具</title>
    <link href="https://lxb.wiki/e1d73156/"/>
    <id>https://lxb.wiki/e1d73156/</id>
    <published>2024-01-08T05:10:47.000Z</published>
    <updated>2025-02-02T11:48:02.438Z</updated>
    
    <content type="html"><![CDATA[<p>Python 版本管理工具的主要作用是帮助开发者在同一台机器上管理多个 Python 版本和环境。这对于开发和部署不同项目非常有用，因为不同项目可能依赖不同的 Python 版本或者不同的包版本。具体来说，Python 版本管理工具应有以下功能：</p><p>（1）避免依赖冲突，不同的项目可能依赖不同版本的库，使用版本管理工具可以创建独立的虚拟环境，避免依赖冲突。</p><p>（2）简化开发流程，开发者可以轻松地在不同的 Python 版本之间切换，而不需要重新安装或配置 Python。</p><p>（3）便于部署，减少冲突。在开发环境中使用与生产环境相同的 Python 版本和依赖，可以减少部署时出现的问题。</p><p>（4）共享环境配置，提高开发环境一致性。可以将环境配置文件（如 <code>requirements.txt</code> 或 <code>pyproject.toml</code>）共享给团队成员，确保大家使用相同的开发环境。</p><h2><span id="一-工具选择">一、工具选择</span></h2><p>常见的管理工具有 Pyenv 和 Conda。Pyenv 是当前最流行的 Python 版本管理工具，支持多种 Python 版本，如 CPython、Anaconda、PyPy 等，功能全面且简单易用。Conda 最初由 Anaconda, Inc. 开发，主要用于 Python 和 R 编程语言的软件包（含 Python）及环境管理，特别适合跨平台、多语言项目，Python 版本管理只是其一小部分功能，若仅用于管理 Python 版本，Conda 有些大材小用，且系统较复杂、学习成本略高。相比之下，Pyenv 是常规项目 Python 版本管理的最优选择。</p><p>以下详细介绍 Pyenv 的使用方法。</p><h2><span id="二-pyenv-安装">二、Pyenv 安装</span></h2><p><strong>建议：</strong> 先卸载系统内置的 Python，否则可能导致 pyenv 设置不生效。</p><h3><span id="1-windows">1. Windows</span></h3><p>pyenv 本身是为 Unix 系统设计的。你可以使用 <a href="https://github.com/pyenv-win/pyenv-win">pyenv-win</a> 这个项目，它是 pyenv 的 Windows 版本。</p><p>你需要在 PowerShell 中执行以下命令安装 pyenv-win：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest -UseBasicParsing -Uri <span class="string">&quot;https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1&quot;</span> -OutFile <span class="string">&quot;./install-pyenv-win.ps1&quot;</span>; &amp;<span class="string">&quot;./install-pyenv-win.ps1&quot;</span></span><br></pre></td></tr></table></figure><p>重新打开 PowerShell，运行 pyenv –version 检查安装是否成功。</p><h3><span id="2-linux">2. Linux</span></h3><p>你可以使用以下命令来安装 <code>pyenv</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://pyenv.run | bash</span><br></pre></td></tr></table></figure><p>之后再将 pyenv 配置到环境变量中并使之生效，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>上述配置仅能使 pyenv 在 bash 环境生效，更多 shell 环境配置请参考：<a href="https://github.com/pyenv/pyenv?tab=readme-ov-file#set-up-your-shell-environment-for-pyenv">Set up your shell environment for Pyenv</a>。配置的本质在于将$PYENV_ROOT 下的 shims 和 bin 目录配置到 PATH 变量中，且 shims 需配置在前。配置后的 PATH 如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $PATH /root/.pyenv/shims:/root/.pyenv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br></pre></td></tr></table></figure><h2><span id="三-pyenv-基本用法">三、Pyenv 基本用法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看帮助文档 </span></span><br><span class="line">pyenv</span><br><span class="line"><span class="comment">## 查看某个命令帮助文档</span></span><br><span class="line">pyenv install --<span class="built_in">help</span></span><br><span class="line"><span class="comment">## 查看版本</span></span><br><span class="line">pyenv version</span><br><span class="line"><span class="comment">## 检查 Python 是否正常运行 </span></span><br><span class="line">python -c <span class="string">&quot;import sys; print(sys.executable)&quot;</span> </span><br><span class="line"><span class="comment">## 查看已安装的 Python 版本 </span></span><br><span class="line">pyenv versions </span><br><span class="line"><span class="comment">## 查看当前使用的 Python 版本 </span></span><br><span class="line">pyenv version </span><br><span class="line"><span class="comment">## 查看所有可用的 Python 版 </span></span><br><span class="line">pyenv install --list</span><br><span class="line"><span class="comment">## 安装指定版本 </span></span><br><span class="line">pyenv install 3.9.1 </span><br><span class="line"><span class="comment">## 验证</span></span><br><span class="line">python --version</span><br><span class="line"><span class="comment">## 卸载指定版本 </span></span><br><span class="line">pyenv uninstall 3.9.1</span><br><span class="line"><span class="comment">## 全局指定 Python 版本（影响所有项目） </span></span><br><span class="line">pyenv global 3.9.1 </span><br><span class="line"><span class="comment">## 局部指定 Python 版本（仅影响当前项目目录），指定后在当前项目目录内创建 .python-version 文件，保存版本信息## 优先级高于 global</span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.1 </span><br><span class="line"><span class="comment">## 会话级指定 Python 版本（影响所有项目） </span></span><br><span class="line">pyenv shell 3.9.1</span><br><span class="line"><span class="comment">## 查看 python 的安装目录</span></span><br><span class="line">pyenv <span class="built_in">which</span> python </span><br><span class="line"><span class="comment">## 重新生成 pyenv 的 shims 目录中的可执行文件</span></span><br><span class="line">pyenv <span class="built_in">rehash</span></span><br></pre></td></tr></table></figure><p>Python 安装常见问题，可参考：<a href="https://github.com/pyenv/pyenv/wiki/Common-build-problems">Python common build problems</a></p><h2><span id="四-pyenv-核心原理-shims">四、Pyenv 核心原理 -Shims</span></h2><p>pyenv 通过 Shims 实现了对不同 Python 版本的透明管理和切换。</p><h3><span id="1-工作原理">1. 工作原理</span></h3><p>上述环境配置中，在 PATH 环境变量最前面插入一个 shims 目录，<code>$(pyenv root)/shims:$(pyenv root)/bin:/usr/local/bin:/usr/bin:/bin</code>。通过一个称为 rehashing 的过程，pyenv 在该目录中维护垫片，以匹配每个已安装的 Python 版本中的每个 Python 命令，如： python、pip 等。</p><p>Shims 是轻量级可执行文件，它只是将你的命令传递给 pyenv。因此，在安装了 pyenv 的情况下，当你运行 pip 时，你的操作系统将执行以下操作：</p><p>（1）搜索 PATH 环境变量，寻找 pip 可执行文件</p><p>（2）在 <code>$(pyenv root)/shims</code> 中找到 pip</p><p>（3）运行名为 pip 的 shim，它将命令传递给 pyenv</p><h3><span id="2-作用">2. 作用</span></h3><p>（1）通过使用 Shims，pyenv 可以实现对不同项目使用不同 Python 版本的灵活管理，而不需要手动修改环境变量或路径。</p><p>（2）你可以方便地在全局、目录级别甚至是 shell 会话级别设置或切换 Python 版本，极大地方便了开发和测试工作。</p><h3><span id="3-示例">3. 示例</span></h3><p>（1）假设你在项目 A 中使用 Python 3.8，而在项目 B 中使用 Python 3.9。通过 pyenv 和 Shims，你可以在项目目录中分别设置 Python 版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目 A 目录中 </span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.8.10 </span><br><span class="line"><span class="comment"># 在项目 B 目录中</span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.5</span><br></pre></td></tr></table></figure><p>（2）当你在项目 A 目录中运行 <code>python</code> 命令时，Shims 会确保调用的是 Python 3.8.10，而在项目 B 目录中则会调用 Python 3.9.5。</p><p>通过这种方式，Shims 实现了对不同 Python 版本的透明管理和切换。</p><h2><span id="五-pyenv-初始化操作源码解读">五、Pyenv 初始化操作源码解读</span></h2><h3><span id="1-pyenv-init-">1. <code>pyenv init -</code></span></h3><p>用于初始化 pyenv，使其在当前 shell 会话中工作。运行后，执行如下命令（相关说明附在注释中）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.PATH 变量处理</span></span><br><span class="line"><span class="comment">## 该脚本将当前的 PATH 变量拆分为一个数组 paths，并赋予</span></span><br><span class="line"><span class="comment">## 通过遍历 paths 数组，检查每个路径是否为 &#x27;/root/.pyenv/shims&#x27;，如果是，则将其移除</span></span><br><span class="line">PATH=<span class="string">&quot;<span class="subst">$(bash --norc -ec &#x27;IFS=:; paths=($PATH)</span>; </span></span><br><span class="line"><span class="string">for i in <span class="variable">$&#123;!paths[@]&#125;</span>; do </span></span><br><span class="line"><span class="string">if [[ <span class="variable">$&#123;paths[i]&#125;</span> == &quot;</span><span class="string">&#x27;&#x27;</span>/root/.pyenv/shims<span class="string">&#x27;&#x27;</span><span class="string">&quot; ]]; then unset &#x27;\&#x27;&#x27;paths[i]&#x27;\&#x27;&#x27;; </span></span><br><span class="line"><span class="string">fi; done; </span></span><br><span class="line"><span class="string">echo &quot;</span><span class="variable">$&#123;paths[*]&#125;</span><span class="string">&quot;&#x27;)&quot;</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 更新 PATH 变量</span></span><br><span class="line"><span class="comment">## 将 &#x27;/root/.pyenv/shims&#x27; 添加到 PATH 变量的最前面</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/root/.pyenv/shims:<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">## 设置 PYENV_SHELL 环境变量为 bash，sh 环境下，输出的是 shell</span></span><br><span class="line"><span class="built_in">export</span> PYENV_SHELL=bash</span><br><span class="line"><span class="comment">## sh 环境下，无该行代码，bash 环境下执行改行的作用是：source 命令加载 pyenv 的自动补全脚本</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;/root/.pyenv/libexec/../completions/pyenv.bash&#x27;</span> </span><br><span class="line"><span class="comment">## 通过 command 命令执行 pyenv rehash（主要作用是重新生成 pyenv 的 shims 目录中的可执行文件），并将错误输出重定向到 /dev/null</span></span><br><span class="line"><span class="built_in">command</span> pyenv <span class="built_in">rehash</span> 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 定义一个 pyenv 函数，该函数根据不同的子命令执行不同的操作</span></span><br><span class="line"><span class="comment">## 如果子命令是 activate、deactivate、rehash 或 shell，则通过 eval 执行 pyenv &quot;sh-$command&quot;</span></span><br><span class="line"><span class="comment">## 对于其他子命令，直接调用 command pyenv &quot;$command&quot; &quot;$@&quot;</span></span><br><span class="line"><span class="function"><span class="title">pyenv</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> <span class="built_in">command</span></span><br><span class="line">  <span class="built_in">command</span>=<span class="string">&quot;<span class="variable">$&#123;1:-&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$command</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  activate|deactivate|<span class="built_in">rehash</span>|shell)</span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv <span class="string">&quot;sh-<span class="variable">$command</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">command</span> pyenv <span class="string">&quot;<span class="variable">$command</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="2-pyenv-init-path">2. pyenv init –path</span></h3><p>用于设置 PYENV_ROOT 环境变量，使得 pyenv 可以找到安装的 Python 版本。<code>pyenv init -</code> 包含 <code>pyenv init --path</code> 操作。</p><p>sh 或 bash 环境运行后，执行如下命令（相关说明附在注释中）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 该脚本将当前的 PATH 变量拆分为一个数组 paths，并赋予</span></span><br><span class="line"><span class="comment">## 通过遍历 paths 数组，检查每个路径是否为 &#x27;/root/.pyenv/shims&#x27;，如果是，则将其移除</span></span><br><span class="line">PATH=<span class="string">&quot;<span class="subst">$(bash --norc -ec &#x27;IFS=:; paths=($PATH)</span>; </span></span><br><span class="line"><span class="string">for i in <span class="variable">$&#123;!paths[@]&#125;</span>; do </span></span><br><span class="line"><span class="string">if [[ <span class="variable">$&#123;paths[i]&#125;</span> == &quot;</span><span class="string">&#x27;&#x27;</span>/root/.pyenv/shims<span class="string">&#x27;&#x27;</span><span class="string">&quot; ]]; then unset &#x27;\&#x27;&#x27;paths[i]&#x27;\&#x27;&#x27;; </span></span><br><span class="line"><span class="string">fi; done; </span></span><br><span class="line"><span class="string">echo &quot;</span><span class="variable">$&#123;paths[*]&#125;</span><span class="string">&quot;&#x27;)&quot;</span></span><br><span class="line"><span class="comment">## 将 &#x27;/root/.pyenv/shims&#x27; 添加到 PATH 变量的最前面</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/root/.pyenv/shims:<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">## 通过 command 命令执行 pyenv rehash，并将错误输出重定向到 /dev/null</span></span><br><span class="line"><span class="built_in">command</span> pyenv <span class="built_in">rehash</span> 2&gt;/dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Pyenv
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="python" scheme="https://lxb.wiki/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch集群原理</title>
    <link href="https://lxb.wiki/fe48575b/"/>
    <id>https://lxb.wiki/fe48575b/</id>
    <published>2023-12-20T06:05:31.000Z</published>
    <updated>2025-02-02T11:48:02.398Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1-集群分布式原理">1 集群分布式原理</span></h2><p>ES集群可以根据节点数， 动态调整主分片与副本数， 做到整个集群有效均衡负载。</p><p>单节点状态下：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181548073.png" alt></p><p>两个节点状态下， 副本数为1：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181549769.png" alt></p><p>三个节点状态下， 副本数为1：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181550937.png" alt></p><p>三个节点状态下， 副本数为2：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181550352.png" alt></p><h2><span id="2-分片处理机制">2 分片处理机制</span></h2><p>设置分片大小的时候， 需预先做好容量规划， 如果节点数过多， 分片数过小， 那么新的节点将无法分片， 不能做到水平扩展， 并且单个分片数据量太大， 导致数据重新分配耗时过大。</p><p>假设一个集群中有一个主节点、两个数据节点。orders索引的分片分布情况如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> orders </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;number_of_shards&quot;</span>:<span class="number">2</span>, ## 主分片 <span class="number">2</span></span><br><span class="line"><span class="string">&quot;number_of_replicas&quot;</span>:<span class="number">2</span> ## 副分片总数 <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181551701.png" alt></p><p>整个集群中存在P0和P1两个主分片， P0对应的两个R0副本分片， P1对应的是两个R1副本分片。</p><h2><span id="3-新建索引处理流程">3 新建索引处理流程</span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181552857.png" alt></p><ol><li>写入的请求会进入主节点， 如果是NODE2副本接收到写请求， 会将它转发至主节点。</li><li>主节点接收到请求后， 根据documentId做取模运算（外部没有传递documentId，则会采用内部自增ID）， 如果取模结果为P0，则会将写请求转发至NODE3处理。</li><li>NODE3节点写请求处理完成之后， 采用异步方式， 将数据同步至NODE1和NODE2节点。</li></ol><h2><span id="4-读取索引处理流程">4 读取索引处理流程</span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181553285.png" alt></p><ol><li>读取的请求进入MASTER节点， 会根据取模结果， 将请求转发至不同的节点。</li><li>如果取模结果为R0，内部还会有负载均衡处理机制，如果上一次的读取请求是在NODE1的R0， 那么当前请求会转发至NODE2的R0， 保障每个节点都能够均衡的处理请求数据。</li><li>读取的请求如果是直接落至副本节点， 副本节点会做判断， 若有数据则返回，没有的话会转发至其他节点处理。</li></ol>]]></content>
    
    <summary type="html">
    
      ElasticSearch集群
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="elastic" scheme="https://lxb.wiki/tags/elastic/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch集群节点</title>
    <link href="https://lxb.wiki/dbb730e9/"/>
    <id>https://lxb.wiki/dbb730e9/</id>
    <published>2023-12-18T06:01:13.000Z</published>
    <updated>2025-02-02T11:48:02.450Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主节点或候选主节点">主节点（或候选主节点）</span></h2><p>主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作， 主节点负荷相对较轻， 客户端请求可以直接发往任何节点， 由对应节点负责分发和返回处理结果。</p><p>一个节点启动之后， 采用 Zen Discovery机制去寻找集群中的其他节点， 并与之建立连接， 集群会从候选主节点中选举出一个主节点， 并且一个集群只能选举一个主节点， 在某些情况下， 由于网络通信丢包等问题， 一个集群可能会出现多个主节点， 称为“脑裂现象”， 脑裂会存在丢失数据的可能， 因为主节点拥有最高权限， 它决定了什么时候可以创建索引， 分片如何移动等， 如果存在多个主节点， 就会产生冲突， 容易产生数据丢失。要尽量避免这个问题， 可以通过 discovery.zen.minimum_master_nodes 来设置最少可工作的候选主节点个数。  建议设置为（候选主节点/2） + 1 比如三个候选主节点，该配置项为 （3/2）+1 ,来保证集群中有半数以上的候选主节点， 没有足够的master候选节点， 就不会进行master节点选举，减少脑裂的可能。</p><p>主节点的参数设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.master = <span class="literal">true</span></span><br><span class="line">node.data = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2><span id="数据节点">数据节点</span></h2><p>数据节点负责数据的存储和CRUD等具体操作，数据节点对机器配置要求比较高、，首先需要有足够的磁盘空间来存储数据，其次数据操作对系统CPU、Memory和IO的性能消耗都很大。通常随着集群的扩大，需要增加更多的数据节点来提高可用性。</p><p>数据节点的参数设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="property">master</span> = <span class="literal">false</span></span><br><span class="line">node.<span class="property">data</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2><span id="客户端节点">客户端节点</span></h2><p>客户端节点不做候选主节点， 也不做数据节点的节点，只负责请求的分发、汇总等等，增加客户端节点类型更多是为了负载均衡的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="property">master</span> = <span class="literal">false</span></span><br><span class="line">node.<span class="property">data</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2><span id="提取节点预处理节点">提取节点（预处理节点）</span></h2><p>能执行预处理管道，有自己独立的任务要执行， 在索引数据之前可以先对数据做预处理操作， 不负责数据存储也不负责集群相关的事务。</p><h2><span id="协调节点">协调节点</span></h2><p>协调节点，是一种角色，而不是真实的Elasticsearch的节点，不能通过配置项来指定哪个节点为协调节点。集群中的任何节点，都可以充当协调节点的角色。当一个节点A收到用户的查询请求后，会把查询子句分发到其它的节点，然后合并各个节点返回的查询结果，最后返回一个完整的数据集给用户。在这个过程中，节点A扮演的就是协调节点的角色。</p><p>ES的一次请求非常类似于Map-Reduce操作。在ES中对应的也是两个阶段，称之为scatter-gather。客户端发出一个请求到集群的任意一个节点，这个节点就是所谓的协调节点，它会把请求转发给含有相关数据的节点(scatter阶段)，这些数据节点会在本地执行请求然后把结果返回给协调节点。协调节点将这些结果汇总(reduce)成一个单一的全局结果集(gather阶段) 。</p><h2><span id="部落节点">部落节点</span></h2><p>在多个集群之间充当联合客户端， 它是一个特殊的客户端 ， 可以连接多个集群，在所有连接的集群上执行搜索和其他操作。 部落节点从所有连接的集群中检索集群状态并将其合并成全局集群状态。 掌握这一信息，就可以对所有集群中的节点执行读写操作，就好像它们是本地的。 请注意，部落节点需要能够连接到每个配置的集群中的每个单个节点。</p>]]></content>
    
    <summary type="html">
    
      ElasticSearch集群
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="elastic" scheme="https://lxb.wiki/tags/elastic/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Mapping 参数</title>
    <link href="https://lxb.wiki/7a9a148e/"/>
    <id>https://lxb.wiki/7a9a148e/</id>
    <published>2023-11-20T05:47:07.000Z</published>
    <updated>2025-02-02T11:48:02.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 Elasticsearch 6.6.0</p></blockquote><h2><span id="analyzer">analyzer</span></h2><p>指定分词器(分析器更合理)，对索引和查询都有效。如下，指定ik分词的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="normalizer">normalizer</span></h2><p>normalizer用于解析前的标准化配置，比如把所有的字符转化为小写等。例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PUT index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;normalizer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;my_normalizer&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">          <span class="string">&quot;char_filter&quot;</span>: [],</span><br><span class="line">          <span class="string">&quot;filter&quot;</span>: [<span class="string">&quot;lowercase&quot;</span>, <span class="string">&quot;asciifolding&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;foo&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;normalizer&quot;</span>: <span class="string">&quot;my_normalizer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;BÀR&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;baz&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST index/_refresh</span><br><span class="line"></span><br><span class="line">GET index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;BAR&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BÀR经过normalizer过滤以后转换为bar，文档1和文档2会被搜索到。</p><h2><span id="boost">boost</span></h2><p>boost字段用于设置字段的权重，比如，关键字出现在title字段的权重是出现在content字段中权重的2倍，设置mapping如下，其中content字段的默认权重是1.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;boost&quot;</span>: 2 </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，在查询时指定权重也是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;quick brown fox&quot;</span>,</span><br><span class="line">                <span class="string">&quot;boost&quot;</span>: 2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐在查询时指定boost，第一中在mapping中写死，如果不重新索引文档，权重无法修改，使用查询可以实现同样的效果。</p><h2><span id="coerce">coerce</span></h2><p>coerce属性用于清除脏数据，coerce的默认值是true。整型数字5有可能会被写成字符串“5”或者浮点数5.0.coerce属性可以用来清除脏数据：</p><ul><li>字符串会被强制转换为整数</li><li>浮点数被强制转换为整数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;number_one&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;number_two&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">          <span class="string">&quot;coerce&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;number_one&quot;</span>: <span class="string">&quot;10&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;number_two&quot;</span>: <span class="string">&quot;10&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapping中指定number_one字段是integer类型，虽然插入的数据类型是String，但依然可以插入成功。number_two字段关闭了coerce，因此插入失败。</p><h2><span id="copy_to">copy_to</span></h2><p>copy_to属性用于配置自定义的_all字段。换言之，就是多个字段可以合并成一个超级字段。比如，first_name和last_name可以合并为full_name字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;first_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;last_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;first_name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last_name&quot;</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;full_name&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="doc_values">doc_values</span></h2><p>doc_values是为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;status_code&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>:       <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;session_id&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>:       <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;doc_values&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注:text类型不支持doc_values。</p><h2><span id="dynamic">dynamic</span></h2><p>dynamic属性用于检测新发现的字段，有三个取值：</p><ul><li>true:新发现的字段添加到映射中。（默认）</li><li>flase:新检测的字段被忽略。必须显式添加新字段。</li><li>strict:如果检测到新字段，就会引发异常并拒绝文档。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;social_networks&quot;</span>: &#123; </span><br><span class="line">              <span class="string">&quot;dynamic&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="string">&quot;properties&quot;</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：取值如果为strict (非布尔值)要加引号。</p><p>文档中有一个之前没有出现过的字段被添加到ELasticsearch之后，文档的type mapping中会自动添加一个新的字段。这个可以通过dynamic属性去控制，dynamic属性为false会忽略新增的字段、dynamic属性为strict会抛出异常。如果dynamic为true的话，ELasticsearch会自动根据字段的值推测出来类型进而确定mapping：</p><table><thead><tr><th>JSON格式的数据</th><th>自动推测的字段类型</th></tr></thead><tbody><tr><td>null</td><td>没有字段被添加</td></tr><tr><td>true or false</td><td>boolean类型</td></tr><tr><td>floating类型数字</td><td>floating类型</td></tr><tr><td>integer</td><td>long类型</td></tr><tr><td>JSON对象</td><td>object类型</td></tr><tr><td>数组</td><td>由数组中第一个非空值决定</td></tr><tr><td>string</td><td>有可能是date类型（开启日期检测)、double或long类型、text类型、keyword类型</td></tr></tbody></table><p>日期检测默认是检测符合以下日期格式的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&quot;strict_date_optional_time&quot;</span>,<span class="string">&quot;yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z&quot;</span>]</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create_date&quot;</span>: <span class="string">&quot;2015/09/02&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_mapping</span><br></pre></td></tr></table></figure><p>mapping 如下，可以看到create_date为date类型：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;my_index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;my_type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;create_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>关闭日期检测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;date_detection&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create&quot;</span>: <span class="string">&quot;2015/09/02&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次查看mapping，create字段已不再是date类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_mapping</span><br><span class="line">返回结果：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;my_index&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;date_detection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;create&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="string">&quot;ignore_above&quot;</span>: 256</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义日期检测的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic_date_formats&quot;</span>: [<span class="string">&quot;MM/dd/yyyy&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create_date&quot;</span>: <span class="string">&quot;09/25/2015&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启数字类型自动检测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;numeric_detection&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;my_float&quot;</span>:   <span class="string">&quot;1.0&quot;</span>, </span><br><span class="line">  <span class="string">&quot;my_integer&quot;</span>: <span class="string">&quot;1&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="enabled">enabled</span></h2><p>ELasticseaech默认会索引所有的字段，enabled设为false的字段，es会跳过字段内容，该字段只能从_source中获取，但是不可搜。而且字段可以是任意类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;session&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;user_id&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:  <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;last_updated&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;session_data&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/session/session_1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;kimchy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;session_data&quot;</span>: &#123; </span><br><span class="line">    <span class="string">&quot;arbitrary_object&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;some_array&quot;</span>: [ <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, &#123; <span class="string">&quot;baz&quot;</span>: 2 &#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;last_updated&quot;</span>: <span class="string">&quot;2015-12-06T18:20:22&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/session/session_2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;jpountz&quot;</span>,</span><br><span class="line">  <span class="string">&quot;session_data&quot;</span>: <span class="string">&quot;none&quot;</span>, </span><br><span class="line">  <span class="string">&quot;last_updated&quot;</span>: <span class="string">&quot;2015-12-06T18:22:13&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fielddata">fielddata</span></h2><p>搜索要解决的问题是“包含查询关键词的文档有哪些？”，聚合恰恰相反，聚合要解决的问题是“文档包含哪些词项”，大多数字段再索引时生成doc_values，但是text字段不支持doc_values。</p><p>取而代之，text字段在查询时会生成一个fielddata的数据结构，fielddata在字段首次被聚合、排序、或者使用脚本的时候生成。ELasticsearch通过读取磁盘上的倒排记录表重新生成文档词项关系，最后在Java堆内存中排序。</p><p>text字段的fielddata属性默认是关闭的，开启fielddata非常消耗内存。在你开启text字段以前，想清楚为什么要在text类型的字段上做聚合、排序操作。大多数情况下这么做是没有意义的。</p><p>“New York”会被分析成“new”和“york”，在text类型上聚合会分成“new”和“york”2个桶，也许你需要的是一个“New York”。这是可以加一个不分词的keyword字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;my_field&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;keyword&quot;</span>: &#123; </span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的mapping中实现了通过my_field字段做全文搜索，my_field.keyword做聚合、排序和使用脚本。</p><h2><span id="format">format</span></h2><p>format属性主要用于格式化日期：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:   <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内置的日期格式：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html</a></p><h2><span id="ignore_above">ignore_above</span></h2><p>ignore_above用于指定字段索引和存储的长度最大值，超过最大值的会被忽略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignore_above&quot;</span>: 15</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Syntax error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Syntax error with some long stacktrace&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 0, </span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;messages&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;message&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapping中指定了ignore_above字段的最大长度为15，第一个文档的字段长小于15，因此索引成功，第二个超过15，因此不索引，返回结果只有”Syntax error”,结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;messages&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2><span id="ignore_malformed">ignore_malformed</span></h2><p>ignore_malformed可以忽略不规则数据，对于login字段，有人可能填写的是date类型，也有人填写的是邮件格式。给一个字段索引不合适的数据类型发生异常，导致整个文档索引失败。如果ignore_malformed参数设为true，异常会被忽略，出异常的字段不会被索引，其它字段正常索引。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;number_one&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignore_malformed&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;number_two&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>:       <span class="string">&quot;Some text value&quot;</span>,</span><br><span class="line">  <span class="string">&quot;number_one&quot;</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>:       <span class="string">&quot;Some text value&quot;</span>,</span><br><span class="line">  <span class="string">&quot;number_two&quot;</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中number_one接受integer类型，ignore_malformed属性设为true，因此文档一种number_one字段虽然是字符串但依然能写入成功；number_two接受integer类型，默认ignore_malformed属性为false，因此写入失败。</p><h2><span id="include_in_all">include_in_all</span></h2><p>include_in_all属性用于指定字段是否包含在_all字段里面，默认开启，除索引时index属性为no。<br>例子如下，title和content字段包含在_all字段里，date不包含。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>include_in_all也可用于字段级别，如下my_type下的所有字段都排除在_all字段之外，author.first_name 和author.last_name 包含在in _all中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>:          &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;first_name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">            <span class="string">&quot;last_name&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;editor&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;first_name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;, </span><br><span class="line">            <span class="string">&quot;last_name&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">true</span> &#125; </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="index">index</span></h2><p>index属性指定字段是否索引，不索引也就不可搜索，取值可以为true或者false。</p><h2><span id="index_options">index_options</span></h2><p>index_options控制索引时存储哪些信息到倒排索引中，接受以下配置：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>docs</td><td>只存储文档编号</td></tr><tr><td>freqs</td><td>存储文档编号和词项频率</td></tr><tr><td>positions</td><td>文档编号、词项频率、词项的位置被存储，偏移位置可用于临近搜索和短语查询</td></tr><tr><td>offsets</td><td>文档编号、词项频率、词项的位置、词项开始和结束的字符位置都被存储，offsets设为true会使用Postings highlighter</td></tr></tbody></table><h2><span id="fields">fields</span></h2><p>fields可以让同一文本有多种不同的索引方式，比如一个String类型的字段，可以使用text类型做全文检索，使用keyword类型做聚合和排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;city&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: &#123; </span><br><span class="line">              <span class="string">&quot;type&quot;</span>:  <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;city&quot;</span>: <span class="string">&quot;York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;city&quot;</span>: <span class="string">&quot;york&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;city.raw&quot;</span>: <span class="string">&quot;asc&quot;</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Cities&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;city.raw&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="norms">norms</span></h2><p>norms参数用于标准化文档，以便查询时计算文档的相关性。norms虽然对评分有用，但是会消耗较多的磁盘空间，如果不需要对某个字段进行评分，最好不要开启norms。</p><h2><span id="null_value">null_value</span></h2><p>值为null的字段不索引也不可以搜索，null_value参数可以让值为null的字段显式的可索引、可搜索。例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;status_code&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:       <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;null_value&quot;</span>: <span class="string">&quot;NULL&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;status_code&quot;</span>: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;status_code&quot;</span>: [] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NULL&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档1可以被搜索到，因为status_code的值为null，文档2不可以被搜索到，因为status_code为空数组，但不是null。</p><h2><span id="position_increment_gap">position_increment_gap</span></h2><p>为了支持近似或者短语查询，text字段被解析的时候会考虑此项的位置信息。举例，一个字段的值为数组类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;names&quot;: [ &quot;John Abraham&quot;, &quot;Lincoln Smith&quot;]</span><br></pre></td></tr></table></figure><p>为了区别第一个字段和第二个字段，Abraham和Lincoln在索引中有一个间距，默认是100。例子如下，这是查询”Abraham Lincoln”是查不到的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/groups/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;names&quot;</span>: [ <span class="string">&quot;John Abraham&quot;</span>, <span class="string">&quot;Lincoln Smith&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/groups/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;names&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Abraham Lincoln&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定间距大于100可以查询到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/groups/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;names&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Abraham Lincoln&quot;</span>,</span><br><span class="line">                <span class="string">&quot;slop&quot;</span>: 101 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mapping中通过position_increment_gap参数指定间距：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;groups&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;names&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;position_increment_gap&quot;</span>: 0 </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="properties">properties</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;manager&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;employees&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;nested&quot;</span>,</span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的文档结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;region&quot;</span>: <span class="string">&quot;US&quot;</span>,</span><br><span class="line">  <span class="string">&quot;manager&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice White&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: 30</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;employees&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: 34</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Peter Brown&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: 26</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对manager.name、manager.age做搜索、聚合等操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;manager.name&quot;: &quot;Alice White&quot; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;Employees&quot;: &#123;</span><br><span class="line">      &quot;nested&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;employees&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;Employee Ages&quot;: &#123;</span><br><span class="line">          &quot;histogram&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;employees.age&quot;, </span><br><span class="line">            &quot;interval&quot;: 5</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="search_analyzer">search_analyzer</span></h2><p>大多数情况下索引和搜索的时候应该指定相同的分析器，确保query解析以后和索引中的词项一致。但是有时候也需要指定不同的分析器，例如使用edge_ngram过滤器实现自动补全。</p><p>默认情况下查询会使用analyzer属性指定的分析器，但也可以被search_analyzer覆盖。例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;autocomplete_filter&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;edge_ngram&quot;</span>,</span><br><span class="line">          <span class="string">&quot;min_gram&quot;</span>: 1,</span><br><span class="line">          <span class="string">&quot;max_gram&quot;</span>: 20</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;autocomplete&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">          <span class="string">&quot;tokenizer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">          <span class="string">&quot;filter&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">            <span class="string">&quot;autocomplete_filter&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;autocomplete&quot;</span>, </span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Quick Brown Fox&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Quick Br&quot;</span>, </span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="similarity">similarity</span></h2><ul><li>BM25 ：ES和Lucene默认的评分模型</li><li>classic ：TF/IDF评分</li><li>boolean：布尔模型评分<br>例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;default_field&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;classic_field&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;similarity&quot;</span>: <span class="string">&quot;classic&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;boolean_sim_field&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;similarity&quot;</span>: <span class="string">&quot;boolean&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>default_field自动使用BM25评分模型，classic_field使用TF/IDF经典评分模型，boolean_sim_field使用布尔评分模型。</p><h2><span id="store">store</span></h2><p>默认情况下，自动是被索引的也可以搜索，但是不存储，这也没关系，因为_source字段里面保存了一份原始文档。在某些情况下，store参数有意义，比如一个文档里面有title、date和超大的content字段，如果只想获取title和date，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;store&quot;</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;store&quot;</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>:   <span class="string">&quot;Some short title&quot;</span>,</span><br><span class="line">  <span class="string">&quot;date&quot;</span>:    <span class="string">&quot;2015-01-01&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;A very long content field...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;stored_fields&quot;</span>: [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;date&quot;</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>: 1,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;date&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;2015-01-01T00:00:00.000Z&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;Some short title&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stored fields返回的总是数组，如果想返回原始字段，还是要从_source中取。</p><h2><span id="term_vector">term_vector</span></h2><p>词向量包含了文本被解析以后的以下信息：</p><ul><li>词项集合</li><li>词项位置</li><li>词项的起始字符映射到原始文档中的位置。</li></ul><p>term_vector参数有以下取值：</p><table><thead><tr><th>参数取值</th><th>含义</th></tr></thead><tbody><tr><td>no</td><td>默认值，不存储词向量</td></tr><tr><td>yes</td><td>只存储词项集合</td></tr><tr><td>with_positions</td><td>存储词项和词项位置</td></tr><tr><td>with_offsets</td><td>词项和字符偏移位置</td></tr><tr><td>with_positions_offsets</td><td>存储词项、词项位置、字符偏移位置</td></tr></tbody></table><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:        <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;term_vector&quot;</span>: <span class="string">&quot;with_positions_offsets&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;brown fox&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="动态mapping-_default_">动态Mapping <code>_default_</code></span></h2><p>在mapping中使用<em>default</em>字段，那么其它字段会自动继承<em>default</em>中的设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;_default_&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: &#123;&#125;, </span><br><span class="line">    <span class="string">&quot;blogpost&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 mapping 中，<code>_default_</code> 中关闭了 <code>_all</code> 字段，<code>user</code>会继承 <code>_default_</code> 中的配置，因此 <code>user</code> 中的 <code>_all</code> 字段也是关闭的，<code>blogpost</code> 中开启 <code>_all</code>，覆盖了 <code>_default</code> 的默认配置。</p><p>当<em>default</em>被更新以后，只会对后面新加的文档产生作用。</p><h2><span id="dynamic_templates">dynamic_templates</span></h2><p>动态模板可以根据字段名称设置mapping，如下对于string类型的字段，设置mapping为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mapping&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>但是匹配字段名称为long_<em>格式的，不匹配</em>_text格式的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;longs_as_strings&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;match&quot;</span>:   <span class="string">&quot;long_*&quot;</span>,</span><br><span class="line">            <span class="string">&quot;unmatch&quot;</span>: <span class="string">&quot;*_text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;long_num&quot;</span>: <span class="string">&quot;5&quot;</span>, </span><br><span class="line">  <span class="string">&quot;long_text&quot;</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure><p>写入文档以后，long_num字段为long类型，long_text 仍为string类型。</p>]]></content>
    
    <summary type="html">
    
      Elasticsearch Mapping 参数
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="elastic" scheme="https://lxb.wiki/tags/elastic/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch元数据</title>
    <link href="https://lxb.wiki/afde4b9b/"/>
    <id>https://lxb.wiki/afde4b9b/</id>
    <published>2023-11-16T05:39:36.000Z</published>
    <updated>2025-02-02T11:48:02.430Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="meta-fields元数据">Meta-Fields(元数据)</span></h2><blockquote><p>本文基于 Elasticsearch 6.6.0</p></blockquote><h3><span id="_all">_all</span></h3><p>_all字段是把其它字段拼接在一起的超级字段，所有的字段用空格分开，_all字段会被解析和索引，但是不存储。当你只想返回包含某个关键字的文档但是不明确地搜某个字段的时候就需要使用_all字段。<br>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/blog/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>:    <span class="string">&quot;Master Java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>:     <span class="string">&quot;learn java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Tom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_all字段包含:[ “Master”, “Java”, “learn”, “Tom” ]</p><p>搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_all&quot;</span>: <span class="string">&quot;Java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>: 0.39063013,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>: 0.39063013,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Master Java&quot;</span>,</span><br><span class="line">          <span class="string">&quot;content&quot;</span>: <span class="string">&quot;learn java&quot;</span>,</span><br><span class="line">          <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Tom&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用copy_to自定义_all字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PUT myindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mytype&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:    <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_content&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:    <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_content&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;full_content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:    <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT myindex/mytype/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Master Java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;learn Java&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET myindex/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;full_content&quot;</span>: <span class="string">&quot;java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_field_names">_field_names</span></h3><p>_field_names字段用来存储文档中的所有非空字段的名字，这个字段常用于exists查询。例子如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2?refresh=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;This is another document&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;This document has a body&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_field_names&quot;</span>: [ <span class="string">&quot;body&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会返回第二条文档，因为第一条文档没有title字段。<br>同样，可以使用exists查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;exists&quot;</span> : &#123; <span class="string">&quot;field&quot;</span> : <span class="string">&quot;body&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_id">_id</span></h3><p>每条被索引的文档都有一个_type和_id字段，_id可以用于term查询、temrs查询、match查询、query_string查询、simple_query_string查询，但是不能用于聚合、脚本和排序。例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_id&quot;</span>: [ <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_index">_index</span></h3><p>多索引查询时，有时候只需要在特地索引名上进行查询，_index字段提供了便利，也就是说可以对索引名进行term查询、terms查询、聚合分析、使用脚本和排序。</p><p><code>_index</code>是一个虚拟字段，不会真的加到索引中，对_index进行term、terms查询(也包括match、query_string、simple_query_string)，但是不支持prefix、wildcard、regexp和fuzzy查询。</p><p>举例，2个索引2条文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT index_1/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document in index 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index_2/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document in index 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对索引名做查询、聚合、排序并使用脚本新增字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET index_1,index_2/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: [<span class="string">&quot;index_1&quot;</span>, <span class="string">&quot;index_2&quot;</span>] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;indices&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;_index&quot;</span>, </span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index_name&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">        <span class="string">&quot;inline&quot;</span>: <span class="string">&quot;doc[&#x27;_index&#x27;]&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_meta">_meta</span></h3><h3><span id="_parent">_parent</span></h3><p>_parent用于指定同一索引中文档的父子关系。下面例子中现在mapping中指定文档的父子关系，然后索引父文档，索引子文档时指定父id，最后根据子文档查询父文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_parent&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;my_child&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_parent&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;my_parent&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT my_index/my_parent/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is a parent document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_child/2?parent=1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is a child document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_child/3?parent=1&amp;refresh=<span class="literal">true</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is another child document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET my_index/my_parent/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;has_child&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;my_child&quot;</span>,</span><br><span class="line">      <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;child document&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_routing">_routing</span></h3><p>路由参数，ELasticsearch通过以下公式计算文档应该分到哪个分片上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard_num = <span class="built_in">hash</span>(_routing) % num_primary_shards</span><br></pre></td></tr></table></figure><p>默认的_routing值是文档的_id或者_parent，通过_routing参数可以设置自定义路由。例如，想把user1发布的博客存储到同一个分片上，索引时指定routing参数，查询时在指定路由上查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1?routing=user1&amp;refresh=<span class="literal">true</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/my_type/1?routing=user1</span><br></pre></td></tr></table></figure><p>在查询的时候通过routing参数查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_routing&quot;</span>: [ <span class="string">&quot;user1&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search?routing=user1,user2 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;document&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Mapping中指定routing为必须的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_routing&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;required&quot;</span>: <span class="literal">true</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index2/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;No routing value provided&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_source">_source</span></h3><p>存储的文档的原始值。默认_source字段是开启的，也可以关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT tweets</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一般情况下不要关闭，除非你不想做以下操作：</p><ul><li>使用update、update_by_query、reindex</li><li>使用高亮</li><li>数据备份、改变mapping、升级索引</li><li>通过原始字段debug查询或者聚合</li></ul><h3><span id="_type">_type</span></h3><p>每条被索引的文档都有一个_type和_id字段，可以根据_type进行查询、聚合、脚本和排序。例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/type_1/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with type 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/type_2/2?refresh=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with type 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_type&quot;</span>: [ <span class="string">&quot;type_1&quot;</span>, <span class="string">&quot;type_2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;_type&quot;</span>, </span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_type&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">        <span class="string">&quot;inline&quot;</span>: <span class="string">&quot;doc[&#x27;_type&#x27;]&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="_uid">_uid</span></h3><p><code>_uid</code> 即 <code>_type</code> + <code>_id</code> 的组合，可用于查询、聚合、脚本和排序。例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2?refresh=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_uid&quot;</span>: [ <span class="string">&quot;my_type#1&quot;</span>, <span class="string">&quot;my_type#2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;UIDs&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;_uid&quot;</span>, </span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_uid&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;UID&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">         <span class="string">&quot;inline&quot;</span>: <span class="string">&quot;doc[&#x27;_uid&#x27;]&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Elasticsearch元数据
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="elastic" scheme="https://lxb.wiki/tags/elastic/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch的数据类型</title>
    <link href="https://lxb.wiki/ce28e9ad/"/>
    <id>https://lxb.wiki/ce28e9ad/</id>
    <published>2023-11-12T05:56:53.000Z</published>
    <updated>2025-02-02T11:48:02.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 Elasticsearch 6.6.0</p></blockquote><h2><span id="1-核心数据类型">1 核心数据类型</span></h2><h2><span id="11-字符串类型-string不再支持">1.1 字符串类型 - string(不再支持)</span></h2><p>(1) 使用示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>&#125;, // 全文本</span><br><span class="line">                <span class="string">&quot;tags&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span>&#125;// 关键字, 不分词</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) ES 5.6.10中的响应信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! Deprecation: The [string] field is deprecated, please use [text] or [keyword] instead on [tags]</span></span><br><span class="line"><span class="comment">#! Deprecation: The [string] field is deprecated, please use [text] or [keyword] instead on [title]</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;shards_acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;index&quot;</span>: <span class="string">&quot;website&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) ES 6.6.0中的响应信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">        <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;No handler for type [string] declared on field [title]&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;Failed to parse mapping [blog]: No handler for type [string] declared on field [title]&quot;</span>,</span><br><span class="line">    <span class="string">&quot;caused_by&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">      <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;No handler for type [string] declared on field [title]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可知string类型的field已经被移除了, 我们需要用text或keyword类型来代替string.</strong></p><h3><span id="111-文本类型-text">1.1.1 文本类型 - text</span></h3><p>在Elasticsearch 5.4 版本开始, text取代了需要分词的string.</p><p>—— <strong>当一个字段需要用于全文搜索(会被分词), 比如产品名称、产品描述信息, 就应该使用text类型.</strong></p><blockquote><p>text的内容会被分词, 可以设置是否需要存储: <code>&quot;index&quot;: &quot;true|false&quot;</code>.<br>text类型的字段不能用于排序, 也很少用于聚合.</p></blockquote><p>使用示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;summary&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="112-关键字类型-keyword">1.1.2 关键字类型 - keyword</span></h3><p>在Elasticsearch 5.4 版本开始, keyword取代了不需要分词的string.</p><p>—— <strong>当一个字段需要按照精确值进行过滤、排序、聚合等操作时, 就应该使用keyword类型.</strong></p><blockquote><p>keyword的内容不会被分词, 可以设置是否需要存储: <code>&quot;index&quot;: &quot;true|false&quot;</code>.</p></blockquote><p>使用示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;tags&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="12-数字类型-8种">1.2 数字类型 - 8种</span></h2><p>数字类型有如下分类:</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>byte</td><td>有符号的8位整数, 范围: [-128 ~ 127]</td></tr><tr><td>short</td><td>有符号的16位整数, 范围: [-32768 ~ 32767]</td></tr><tr><td>integer</td><td>有符号的32位整数, 范围: [−231 ~ 231-1]</td></tr><tr><td>long</td><td>有符号的64位整数, 范围: [−263 ~ 263-1]</td></tr><tr><td>float</td><td>32位单精度浮点数</td></tr><tr><td>double</td><td>64位双精度浮点数</td></tr><tr><td>half_float</td><td>16位半精度IEEE 754浮点类型</td></tr><tr><td>scaled_float</td><td>缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734</td></tr></tbody></table><p>使用注意事项:</p><blockquote><p>尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;<br>优先考虑使用带缩放因子的浮点类型.</p></blockquote><p>使用示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT shop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;book&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;quantity&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>&#125;,  // <span class="built_in">integer</span>类型</span><br><span class="line">                <span class="string">&quot;price&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;</span>,       // scaled_float类型</span><br><span class="line">                    <span class="string">&quot;scaling_factor&quot;</span>: 100</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="13-日期类型-date">1.3 日期类型 - date</span></h2><p>JSON没有日期数据类型, 所以在ES中, 日期可以是:</p><ul><li>包含格式化日期的字符串, “2018-10-01”, 或”2018/10/01 12:10:30”.</li><li>代表时间毫秒数的长整型数字.</li><li>代表时间秒数的整数.</li></ul><blockquote><p>如果时区未指定, 日期将被转换为UTC格式, 但存储的却是长整型的毫秒值.<br>可以自定义日期格式, 若未指定, 则使用默认格式: <code>strict_date_optional_time||epoch_millis</code></p></blockquote><p>(1) 使用日期格式示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 添加映射</span><br><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;pub_date&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>&#125;   // 日期类型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加数据</span><br><span class="line">PUT website/blog/11</span><br><span class="line">&#123; <span class="string">&quot;pub_date&quot;</span>: <span class="string">&quot;2018-10-10&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT website/blog/12</span><br><span class="line">&#123; <span class="string">&quot;pub_date&quot;</span>: <span class="string">&quot;2018-10-10T12:00:00Z&quot;</span> &#125;// Solr中默认使用的日期格式</span><br><span class="line"></span><br><span class="line">PUT website/blog/13</span><br><span class="line">&#123; <span class="string">&quot;pub_date&quot;</span>: <span class="string">&quot;1589584930103&quot;</span> &#125;// 时间的毫秒值</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2) 多种日期格式:</p><blockquote><p>多个格式使用双竖线<code>||</code>分隔, 每个格式都会被依次尝试, 直到找到匹配的.<br>第一个格式用于将时间毫秒值转换为对应格式的字符串.</p></blockquote><p>使用示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 添加映射</span><br><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,  // 可以接受如下类型的格式</span><br><span class="line">                    <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="14-布尔类型-boolean">1.4 布尔类型 - boolean</span></h2><p>可以接受表示真、假的字符串或数字:</p><ul><li>真值: true, “true”, “on”, “yes”, “1”…</li><li>假值: false, “false”, “off”, “no”, “0”, “”(空字符串), 0.0, 0</li></ul><h2><span id="15-二进制型-binary">1.5 二进制型 - binary</span></h2><p>二进制类型是Base64编码字符串的二进制值, 不以默认的方式存储, 且不能被搜索. 有2个设置项:</p><blockquote><p>(1) <code>doc_values</code>: 该字段是否需要存储到磁盘上, 方便以后用来排序、聚合或脚本查询. 接受<code>true</code>和<code>false</code>(默认);<br>(2) <code>store</code>: 该字段的值是否要和<code>_source</code>分开存储、检索, 意思是除了<code>_source</code>中, 是否要单独再存储一份. 接受<code>true</code>或<code>false</code>(默认).</p></blockquote><p>使用示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 添加映射</span><br><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;blob&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;binary&quot;</span>&#125;   // 二进制</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 添加数据</span><br><span class="line">PUT website/blog/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Some binary blog&quot;</span>,</span><br><span class="line">    <span class="string">&quot;blob&quot;</span>: <span class="string">&quot;hED903KSrA084fRiD5JLgY==&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意: Base64编码的二进制值不能嵌入换行符<code>\n</code>, 逗号(<code>0x2c</code>)等符号.</p></blockquote><h2><span id="16-范围类型-range">1.6 范围类型 - range</span></h2><p>range类型支持以下几种:</p><table><thead><tr><th>类型</th><th>范围</th></tr></thead><tbody><tr><td>integer_range</td><td>−231 ~ 231−1</td></tr><tr><td>long_range</td><td>−263 ~ 263−1</td></tr><tr><td>float_range</td><td>32位单精度浮点型</td></tr><tr><td>double_range</td><td>64位双精度浮点型</td></tr><tr><td>date_range</td><td>64位整数, 毫秒计时</td></tr><tr><td>ip_range</td><td>IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在</td></tr></tbody></table><p>(1) 添加映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT company</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;department&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;expected_number&quot;</span>: &#123;  // 预期员工数</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer_range&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;time_frame&quot;</span>: &#123;       // 发展时间线</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date_range&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;ip_whitelist&quot;</span>: &#123;     // ip白名单</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ip_range&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2) 添加数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT company/department/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;expected_number&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;gte&quot;</span> : 10,</span><br><span class="line">        <span class="string">&quot;lte&quot;</span> : 20</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;time_frame&quot;</span> : &#123; </span><br><span class="line">        <span class="string">&quot;gte&quot;</span> : <span class="string">&quot;2018-10-01 12:00:00&quot;</span>, </span><br><span class="line">        <span class="string">&quot;lte&quot;</span> : <span class="string">&quot;2018-11-01&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&quot;ip_whitelist&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) 查询数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET company/department/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;expected_number&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: 12</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET company/department/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;time_frame&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;gte&quot;</span>: <span class="string">&quot;208-08-01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;lte&quot;</span>: <span class="string">&quot;2018-12-01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;relation&quot;</span>: <span class="string">&quot;within&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;company&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;department&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;expected_number&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;time_frame&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-10-01 12:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-11-01&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ip_whitelist&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="2-复杂数据类型">2 复杂数据类型</span></h2><h2><span id="21-数组类型-array">2.1 数组类型 - array</span></h2><p>ES中没有专门的数组类型, 直接使用[]定义即可;</p><p><strong>数组中所有的值必须是同一种数据类型, 不支持混合数据类型的数组</strong>:</p><blockquote><p>① 字符串数组: [“one”, “two”];<br>② 整数数组: [1, 2];<br>③ 由数组组成的数组: [1, [2, 3]], 等价于[1, 2, 3];<br>④ 对象数组: [{“name”: “Tom”, “age”: 20}, {“name”: “Jerry”, “age”: 18}].</p></blockquote><p>注意:</p><blockquote><ul><li>动态添加数据时, 数组中第一个值的类型决定整个数组的类型;</li><li>不支持混合数组类型, 比如[1, “abc”];</li><li>数组可以包含null值, 空数组[]会被当做missing field —— 没有值的字段.</li></ul></blockquote><h2><span id="22-对象类型-object">2.2 对象类型 - object</span></h2><p>JSON文档是分层的: 文档可以包含内部对象, 内部对象也可以包含内部对象.</p><p>(1) 添加示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT employee/developer/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ma_shoufeng&quot;</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;region&quot;</span>: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">        <span class="string">&quot;location&quot;</span>: &#123;<span class="string">&quot;province&quot;</span>: <span class="string">&quot;GuangDong&quot;</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;GuangZhou&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2) 存储方式:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>                       <span class="string">&quot;ma_shoufeng&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address.region&quot;</span><span class="punctuation">:</span>             <span class="string">&quot;China&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address.location.province&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;GuangDong&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;address.location.city&quot;</span><span class="punctuation">:</span>      <span class="string">&quot;GuangZhou&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) 文档的映射结构类似为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;developer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;, </span><br><span class="line">                <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;region&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;,</span><br><span class="line">                        <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                                <span class="string">&quot;province&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;,</span><br><span class="line">                                <span class="string">&quot;city&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="23-嵌套类型-nested">2.3 嵌套类型 - nested</span></h2><p>嵌套类型是对象数据类型的一个特例, 可以让array类型的对象被独立索引和搜索.</p><h3><span id="231-对象数组是如何存储的">2.3.1 对象数组是如何存储的</span></h3><p>① 添加数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT game_of_thrones/role/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;stark&quot;</span>,</span><br><span class="line"><span class="string">&quot;performer&quot;</span>: [</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Snow&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;Sansa&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Stark&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 内部存储结构:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span>          <span class="string">&quot;stark&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;performer.first&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;john&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sansa&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;performer.last&quot;</span><span class="punctuation">:</span>  <span class="punctuation">[</span> <span class="string">&quot;snow&quot;</span><span class="punctuation">,</span> <span class="string">&quot;stark&quot;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>③ 存储分析:</p><p>可以看出, user.first和user.last会被平铺为多值字段, 这样一来, John和Snow之间的关联性就丢失了.</p><p>在查询时, 可能出现John Stark的结果.</p><h3><span id="232-用nested类型解决object类型的不足">2.3.2 用nested类型解决object类型的不足</span></h3><p>如果需要对以最对象进行索引, 且保留数组中每个对象的独立性, 就应该使用嵌套数据类型.</p><p>—— 嵌套对象实质是将每个对象分离出来, 作为隐藏文档进行索引.</p><p>① 创建映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT game_of_thrones</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;performer&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;nested&quot;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 添加数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT game_of_thrones/role/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;group&quot;</span> : <span class="string">&quot;stark&quot;</span>,</span><br><span class="line">    <span class="string">&quot;performer&quot;</span> : [</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Snow&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;Sansa&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Stark&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>③ 检索数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET game_of_thrones/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;nested&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;path&quot;</span>: <span class="string">&quot;performer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">                        &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;performer.first&quot;</span>: <span class="string">&quot;John&quot;</span> &#125;&#125;,</span><br><span class="line">                        &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;performer.last&quot;</span>:  <span class="string">&quot;Snow&quot;</span> &#125;&#125; </span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="string">&quot;inner_hits&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;fields&quot;</span>: &#123;<span class="string">&quot;performer.first&quot;</span>: &#123;&#125;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="3-地理数据类型">3 地理数据类型</span></h2><h2><span id="31-地理点类型-geo-point">3.1 地理点类型 - geo point</span></h2><p>地理点类型用于存储地理位置的经纬度对, 可用于:</p><blockquote><ul><li>查找一定范围内的地理点;</li><li>通过地理位置或相对某个中心点的距离聚合文档;</li><li>将距离整合到文档的相关性评分中;</li><li>通过距离对文档进行排序.</li></ul></blockquote><p>(1) 添加映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;developer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;location&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2) 存储地理位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 方式一: 纬度 + 经度键值对</span><br><span class="line">PUT employee/developer/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;小蛮腰-键值对地理点参数&quot;</span>, </span><br><span class="line">    <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lat&quot;</span>: 23.11, <span class="string">&quot;lon&quot;</span>: 113.33// 纬度: latitude, 经度: longitude</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二: <span class="string">&quot;纬度, 经度&quot;</span>的字符串参数</span><br><span class="line">PUT employee/developer/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;小蛮腰-字符串地理点参数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: <span class="string">&quot;23.11, 113.33&quot;</span> // 纬度, 经度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式三: [<span class="string">&quot;经度, 纬度&quot;</span>] 数组地理点参数</span><br><span class="line">PUT employee/developer/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;小蛮腰-数组参数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: [ 113.33, 23.11 ] // 经度, 纬度</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) 查询示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;geo_bounding_box&quot;</span>: &#123; </span><br><span class="line">            <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;top_left&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 24, <span class="string">&quot;lon&quot;</span>: 113 &#125;,// 地理盒子模型的上-左边</span><br><span class="line">                <span class="string">&quot;bottom_right&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 22, <span class="string">&quot;lon&quot;</span>: 114 &#125;// 地理盒子模型的下-右边</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="32-地理形状类型-geo_shape">3.2 地理形状类型 - geo_shape</span></h2><p>是多边形的复杂形状. 使用较少, 这里省略.</p><h2><span id="4-专门数据类型">4 专门数据类型</span></h2><h2><span id="41-ip类型">4.1 IP类型</span></h2><p>IP类型的字段用于存储IPv4或IPv6的地址, 本质上是一个长整型字段.</p><p>(1) 添加映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;customer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;ip_addr&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ip&quot;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2) 添加数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUT employee/customer/1</span><br><span class="line">&#123; <span class="string">&quot;ip_addr&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) 查询数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET employee/customer/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;ip_addr&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="42-计数数据类型-token_count">4.2 计数数据类型 - token_count</span></h2><p>token_count类型用于统计字符串中的单词数量.</p><p>本质上是一个整数型字段, 接受并分析字符串值, 然后索引字符串中单词的个数.</p><p>(1) 添加映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;customer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: &#123; </span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;length&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;token_count&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2) 添加数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT employee/customer/1</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Snow&quot;</span> &#125;</span><br><span class="line">PUT employee/customer/2</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tyrion Lannister&quot;</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) 查询数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET employee/customer/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;name.length&quot;</span>: 2 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.6/mapping-types.html">Elasticsearch 6.6 官方文档 - Field datatypes</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      elastic的数据类型
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="elastic" scheme="https://lxb.wiki/tags/elastic/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.21 新增特性</title>
    <link href="https://lxb.wiki/f002ff66/"/>
    <id>https://lxb.wiki/f002ff66/</id>
    <published>2023-10-20T05:42:04.000Z</published>
    <updated>2025-02-02T11:48:02.401Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="新的内置函数">新的内置函数</span></h2><p>1.21添加了三个新的内置函数：<code>min</code>、<code>max</code>和<code>clear</code>。</p><p><code>min</code>、<code>max</code>如其字面意思，用了选出一组变量里（数量大于等于1，只有一个变量的时候就返回那个变量的值）最大的或者最小的值。两个函数定义是这样的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">cmp</span>.<span class="title">Ordered</span>]<span class="params">(x T, y ...T)</span></span> T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span>[<span class="title">T</span> <span class="title">cmp</span>.<span class="title">Ordered</span>]<span class="params">(x T, y ...T)</span></span> T</span><br></pre></td></tr></table></figure><p>注意那个类型约束，这是新的标准库里提供的，原型如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说只有基于所有除了map，chan，slice以及复数之外的基本类型的变量才能使用这两个函数。或者换句话说，只有可以使用<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>==</code>和<code>!=</code>进行比较的类型才可以使用min和max。</p><p>有了min和max，可以把许多自己手写的代码替换成新的内置函数，可以少写一些帮助函数。而且使用新的内置函数还有一个好处，在变量个数比较少的时候还有编译器的优化可用，比自己写min函数性能上要稍好一些。</p><p>使用上也很简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxIntValue := max(<span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment">// 7 type int</span></span><br><span class="line">minIntValue := min(<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment">// 1 type int</span></span><br></pre></td></tr></table></figure><p>目前max和min都不支持slice的解包操作：<code>max(1, numbers...)</code>。</p><p>对于clear来说事情比min和max复杂。clear只接受slice和map，如果是对泛型的类型参数使用clear，那么类型参数的type set必须是map或者slice，否则编译报错。</p><p>clear的定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clear</span>[<span class="title">T</span> ~[]<span class="title">Type</span> | ~<span class="title">map</span>[<span class="title">Type</span>]<span class="title">Type1</span>]<span class="params">(t T)</span></span></span><br></pre></td></tr></table></figure><p>对于参数是map的情况，clear会删除所有map里的元素（不过由于golang的map本身的特性，map存储的数据会被正常销毁，但map已经分配的空间不会释放）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">3</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 5</span></span><br><span class="line">clear(m)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而对于slice，它的行为又不同了：会把slice里所有元素变回零值。看个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>) <span class="comment">// 故意给个大的cap便于观察</span></span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;...)</span><br><span class="line">fmt.Println(s) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// len: 5; cap: 100</span></span><br><span class="line">clear(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// len: 5; cap: 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就比较反直觉了，毕竟clear首先想到的应该是把所有元素删除。那它的意义是什么呢？对于map来说意义是很明确的，但对于slice来说就有点绕弯了：</p><p><strong>slice的真实大小是cap所显示的那个大小，如果只是用<code>s := s[:0]</code>来把所有元素“删除”，那么这些元素实际上还是留在内存里的，直到s本身被gc回收或者往s里添加新元素把之前的对象覆盖掉，否则这些对象是不会被回收掉的，这一方面可以提高内存的利用率，另一方面也会带来泄露的问题（比如存储的是指针类型或者包含指针类型的值的时候，因为指针还存在，所以被指向的对象始终有一个有效的引用导致无法被回收），所以golang选择了折中的办法：把所有已经存在的元素设置成0值</strong></p><p>如果想安全的正常删除slice的所有元素，有想复用slice的内存，该怎么办？答案是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="number">100</span>) <span class="comment">// 故意给个大的cap便于观察</span></span><br><span class="line">s = <span class="built_in">append</span>(s, []T&#123;*<span class="built_in">new</span>(T), *<span class="built_in">new</span>(T)&#125;...)</span><br><span class="line"></span><br><span class="line">clear(s)</span><br><span class="line">s = s[:<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>如果没有内置函数clear，那么我们得自己循环一个个赋值处理。而有clear的好处是，编译器会直接用memset把slice的内存里的数据设置为0，比循环会快很多。有兴趣的可以看看clear在slice上的实现：<a href="https://github.com/golang/go/blob/master/src/runtime/mbarrier.go#L330">代码在这</a> 。</p><h2><span id="类型推导">类型推导</span></h2><p>以前类似这样的代码在某些情况下没法正常进行推导：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func F<span class="selector-attr">[T ~E[]</span>, E any](t T, callable func(E))</span><br><span class="line"></span><br><span class="line">func generic<span class="selector-attr">[E any]</span>(e E) &#123;&#125;</span><br><span class="line"><span class="built_in">F</span>(t, generic) <span class="comment">// before go1.21: error; after go1.21: ok</span></span><br></pre></td></tr></table></figure><p>理论上只要能推导出E的类型，那么<code>F</code>和<code>generic</code>的所有类型参数都能推导出来，哪怕<code>generic</code>本身是个泛型函数。以前想正常使用就得这么写：<code>F(t, generic[Type])</code>。</p><p>所以与其说是新特性，不如说是对类型推导的bug修复。</p><p>针对类型推导还有其他一些修复和报错信息的内容优化，但这些都没上面这个变化大，所以恕不赘述。</p><h2><span id="panic的行为变化">panic的行为变化</span></h2><p>1.21开始如果goroutine里有panic，那么这个goroutine里的defer里调用的recover必然不会返回nil值。</p><p>这导致了一个问题：recover的返回值是传给panic的参数的值，<code>panic(nil)</code>这样的代码怎么办？</p><p>先要提醒一下，<code>panic(nil)</code>本身是无意义的，且会导致recover的调用方无法判断究竟发生了什么，所以一直是被各类linter包括<code>go vet</code>命令警告的。然而这么写语法上完全正确，所以只有警告并不能解决问题。</p><p>解决办法是，如果现在使用<code>panic(nil)</code>或者<code>panic(值为nil的接口)</code>，recover会收到一个新类型的error：<code>*runtime.PanicNilError</code>。</p><p>总体上算是解决了问题，然而它把有类型的但值是nil的接口也给转换了，虽然从最佳实践的角度来讲panic一个空值的接口是不应该的，但多少还是会给使用上带来一些麻烦。</p><p>所以目前想要禁用这一行为的话，可以设置环境变量：<code>export GODEBUG=panicnil=1</code>。如果go.mod里声明的go版本小于等于1.20，这个环境变量的功能自动启用。</p><p>对于modules的变化，会在下一节讲解。</p><h2><span id="modules的变化">modules的变化</span></h2><p>最大的变化是现在mod文件里写的go版本号的意义改变了。</p><p>变成了：mod文件里写的go的版本意味着这个mod最低支持的golang版本是多少。</p><p>比如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/apocelipes/flatmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.21</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>意味着这个modules最低要求go的版本是<code>go1.21.0</code>，而且可以注意到，现在patch版本也算在内里，所以一个声明为<code>go 1.21.1</code>的modules没法被1.21.0版本的go编译。</p><p>这么做的好处是能严格控制自己的程序和库可以在哪些版本的golang上运行，且可以推动库版本和golang本身版本的升级。</p><p>如果严格按照官方要求使用语义版本来控制自己的modules的话，这个改动没有什么明显的坏处，唯一的缺点是只有1.21及更高版本的go工具链才有这样的功能。</p><p>这个变更对<code>go.work</code>文件同样适用。</p><h2><span id="包初始化顺序的改变">包初始化顺序的改变</span></h2><p>现在按新的顺序来初始化包：</p><ol><li>把所有的packages按导入路径进行排序（字符串字典顺序）存进一个列表</li><li>按要求和顺序找到列表里第一个符合条件的package，要求是这个package所有的import的包都已经完成初始化</li><li>初始化这个找到的包然后把它移出列表，接着重复第二步</li><li>列表为空的时候初始化流程结束</li></ol><p>这样做的好处是包的初始化顺序终于有明确的标准化的定义了，坏处有两点：</p><ol><li>以前的程序如果依赖于特定的初始化顺序，那么在新版本会出问题</li><li>现在可以通过修改package的导入路径（主要能改的部分是包的名字）和控制导入的包来做到让A包始终在B包之前初始化，因此B包的初始化流程里可以对A包公开出来的接口或者数据进行修改，这样做耦合性很高也不安全，尤其是B包如果是某个包含恶意代码的包的话。</li></ol><p>我们能做的只有遵守最佳实践：不要依赖特定的包直接的初始化顺序；以及在使用某个第三方库前要仔细考量。</p><h2><span id="编译器和runtime的变化">编译器和runtime的变化</span></h2><p>runtime的变化上，gc一如既往地得到了小幅度优化，现在对于gc压力较大的程序来说gc延迟和内存占用都会有所减少。</p><p>cgo也有优化，现在cgo函数调用最大可以比原先快一个数量级。</p><p>编译器的变化上比较显著的是这个：PGO已经可以正式投入生产使用。<a href="https://go.dev/doc/pgo">使用教程</a>。</p><p>PGO可以带来6%左右的性能提升，1.21凭借PGO和上个版本的优化现在不仅没有了泛型带来的编译速度减低，相比以前还有细微提升。</p><p>还有最后一个变化，这个和编译器关系：现在没有被使用的全局的map类型的变量（需要达到一定大小，且初始化的语句中没有任何副作用会产生），现在编译完成的程序里不会在包含这个变量。因为map本身占用内存且初始化需要花费一定时间（map越大花的时间越多）。这个好处是很实在的，既可以减小产生的二进制可执行文件的大小，又可以提升运行性能。但有个缺点，如果有什么程序要依赖编译好的可执行文件内部的某些数据的话，这个变更可能会带来麻烦，普通用户可以忽略这点。</p><h2><span id="新标准库">新标准库</span></h2><p>这个版本添加了大把的新标准库，一起来看看。</p><h3><span id="logslog和testingslogtest">log/slog和testing/slogtest</span></h3><p>官方提供的结构化日志库。</p><p>可以通过实现<code>slog.Handler</code>来定义自己的日志处理器，可以把日志转换成json等格式。标准库自带了很多预定义的处理器，比如json的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br><span class="line">logger.Info(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;&quot;time&quot;:&quot;2023-08-09T15:28:26.000000000+09:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;hello&quot;,&quot;count&quot;:3&#125;</span></span><br></pre></td></tr></table></figure><p>简单得说，就是个简化版的zap，如果想使用最基础的结构化日志的功能，又不想引入zap这样的库，那么slog是个很好的选择。</p><p>testing/slogtest里有帮助函数用来测试自己实现的日志处理器是否符合标准库的要求。</p><h3><span id="slices和maps">slices和maps</span></h3><p>把<code>golang.org/x/exp/slices</code>和<code>golang.org/x/exp/maps</code>引入了标准库。</p><p>slices库提供了排序、二分查找、拼接、增删改查等常用功能，sort这个标准库目前可以停止使用用slices来替代了。</p><p>maps提供了常见的对map的增删改查拼接合并等功能。</p><p>两个库使用泛型，且针对golang的slice和map进行了细致入微的优化，性能上比自己写的版本有更多优势，比标准库sort更是有数量级的碾压。</p><p>这两个库本来1.20就该被接收进标准库了，但因为需要重新设计api和进行优化，所以拖到1.21了。</p><h3><span id="cmp">cmp</span></h3><p>这个也是早该进入标准库的，但拖到了现在。随着slices、maps和新内置函数都进入了新版本，这个库想不接收也不行了。</p><p>这个库一共有三个东西：<code>Ordered</code>、<code>Less</code>、<code>Compare</code>。</p><p>最重要的是<code>Ordered</code>，它是所有可以使用内置运算符进行比较的类型的集合。</p><p><code>Less</code>和<code>Ordered</code>顾名思义用来比大小的，且只能比<code>Ordered</code>类型的大小。</p><p>之所以还有单独造出这两个函数，是因为他们对Nan有检查，比如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less reports whether x is less than y.</span></span><br><span class="line"><span class="comment">// For floating-point types, a NaN is considered less than any non-NaN,</span></span><br><span class="line"><span class="comment">// and -0.0 is not less than (is equal to) 0.0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Less</span>[<span class="title">T</span> <span class="title">Ordered</span>]<span class="params">(x, y T)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (isNaN(x) &amp;&amp; !isNaN(y)) || x &lt; y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以在泛型函数里不知道要比较的数据的类型是不是有float的时候，用cmp里提供的函数是最安全的</strong>。这就是他俩存在的意义。</p><p>但如果可以100%确定没有float存在，那么就不应该用<code>Less</code>等，应该直接用运算符去比较，因为大家都看到，Less和直接比较相比效率是较低的。</p><h2><span id="已有的标准库的变化">已有的标准库的变化</span></h2><p>因为是速览，所以我只挑重点说。</p><h3><span id="bytes">bytes</span></h3><p><code>bytes.Buffer</code>添加了<code>AvailableBuffer</code>和<code>Available</code>两个方法，分别返回目前可用的buf切片和可用的长度。主要可以配合<code>strconv.AppendInt</code>来使用，直接把数据写入buffer对应的内存里，可以提升性能。<strong>不要对<code>AvailableBuffer</code>返回的切片扩容，否则必然踩坑</strong>。</p><h3><span id="context">context</span></h3><p>新的<code>context.WithoutCancel</code>会把原来的<code>context.Context</code>复制一份，并去除cancel函数，这意味着原先被复制的上下文取消了这个新的上下文也将继续存在。例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">newCtx := context.WithoutCancel(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&lt;-ctx.Done() <span class="comment">// ok, ctx has cancled.</span></span><br><span class="line">&lt;-newCtx.Done() <span class="comment">// error: dead lock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会死锁，是因为<code>newCtx</code>没有被取消，Done返回的chan会永远阻塞住。而且更根本的，<code>newCtx</code>无法被取消。</p><p>新增了<code>context.WithDeadlineCause</code>和<code>context.WithTimeoutCause</code>，可以增加超时上下文被取消时的信息：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d := time.Now().Add(shortDuration)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d, &amp;MyError&#123;<span class="string">&quot;my message&quot;</span>&#125;)</span><br><span class="line">cancel()</span><br><span class="line">context.Cause(ctx) <span class="comment">// --&gt; &amp;MyError&#123;&quot;my message&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>虽然不如<code>context.WithCancelCause</code>灵活，但也很实用。</p><h3><span id="cryptosha256">crypto/sha256</span></h3><p>现在在x86_64平台上计算sha256会尽量利用硬件指令（simd和x86_64平台的SHA256ROUND等指令），这带来了3-4倍的性能提升。</p><h3><span id="net">net</span></h3><p>现在golang在Linux上已经初步支持Multipath TCP。有关Multipath TCP的信息可以在这查阅：<a href="https://www.multipath-tcp.org/">https://www.multipath-tcp.org/</a></p><h3><span id="reflect">reflect</span></h3><p>ValueOf现在会根据逃逸分析把值分配在栈上，以前都是直接分配到堆上的。对于比较小的类型来说可以获得10%以上的性能提升。利好很多使用反射的ORM框架。</p><p>新增了<code>Value.Clear</code>，对应第一节的clear内置函数，如果type不是map或者slice的话这个函数和其他反射的方法一样会panic。</p><h3><span id="runtime">runtime</span></h3><p>最值得一提的变化是新增了<code>runtime.Pinner</code>。</p><p>它的能力是可以让某个go的对象不会gc回收，一直到<code>Unpin</code>方法被调用。这个是为了方便cgo代码里让c使用go的对象而设计的。</p><p><strong>不要滥用这个接口，如果想告诉gc某个对象暂时不能回收，应该正确使用<code>runtime.KeepAlive</code></strong>。</p><p>runtime/trace现在有了很大的性能提升，因此观察程序行为的时候开销更小，更接近程序真实的负载。</p><h3><span id="sync">sync</span></h3><p>添加了<code>OnceFunc</code>、<code>OnceValue</code>、<code>OnceValues</code>这三个帮助函数。主要是为了简化代码。</p><p>1.21前：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initFlag sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSomeThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">initFlag.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">真正的初始化逻辑</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 后续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在变成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doInit = sync.OnceFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">真正的初始化逻辑</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSomeThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">doInit()</span><br><span class="line"><span class="comment">// 后续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新代码要简单点。</p><p><code>OnceValue</code>、<code>OnceValues</code>是函数带返回值的版本，支持一个和两个返回值的函数。</p><h3><span id="errors">errors</span></h3><p>新增了<code>errors.ErrUnsupported</code>。这个错误表示当前操作系统、硬件、协议、或者文件系统不支持某种操作。</p><p>目前os，filepath，syscall，io里的一些函数已经会返回这个错误，可以用<code>errors.Is(err, errors.ErrUnsupported)</code>来检查。</p><h3><span id="unicode">unicode</span></h3><p>升级到了最新的Unicode 15.0.0。</p><h2><span id="平台支持变化">平台支持变化</span></h2><p>新增了wasip1支持，这是一个对WASI（WebAssembly System Interface）的初步支持。</p><p>对于macOS，go1.21需要macOS 10.15 Catalina及以上版本。</p><p>龙芯上golang现在支持将代码编译为c的动态和静态链接库，基本上在龙芯上已经可以尝试投入生产环境了。</p><p>发版日志 <a href="https://go.dev/doc/go1.21">Go 1.21 Release Notes - The Go Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      Go 1.21 新增特性
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 三: Lucene 的索引文件格式</title>
    <link href="https://lxb.wiki/552b0416/"/>
    <id>https://lxb.wiki/552b0416/</id>
    <published>2023-09-03T06:05:28.000Z</published>
    <updated>2025-02-02T11:48:02.455Z</updated>
    
    <content type="html"><![CDATA[<p>Lucene的索引里面存了些什么，如何存放的，也即Lucene的索引文件格式，是读懂Lucene源代码的一把钥匙。</p><p>当我们真正进入到Lucene源代码之中的时候，我们会发现:</p><ul><li>Lucene的索引过程，就是按照全文检索的基本过程，将倒排表写成此文件格式的过程。</li><li>Lucene的搜索过程，就是按照此文件格式将索引进去的信息读出来，然后计算每篇文档打分(score)的过程。</li></ul><p>参考官网 <a href="http://lucene.apache.org/java/2_9_0/fileformats.html">Apache Lucene - Index File Formats</a>。</p><h2><span id="一-基本概念"><strong>一、基本概念</strong></span></h2><p>下图就是Lucene生成的索引的一个实例：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262111476.png" alt></p><p>Lucene的索引结构是有层次结构的，主要分以下几个层次：</p><ul><li>索引(Index)：<ul><li>在Lucene中一个索引是放在一个文件夹中的。</li><li>如上图，同一文件夹中的所有的文件构成一个Lucene索引。</li></ul></li><li>段(Segment)：<ul><li>一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。</li><li>如上图，具有相同前缀文件的属同一个段，图中共两个段 “_0” 和 “_1”。</li><li>segments.gen和segments_5是段的元数据文件，也即它们保存了段的属性信息。</li></ul></li><li>文档(Document)：<ul><li>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。</li><li>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。</li></ul></li><li>域(Field)：<ul><li>一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。</li><li>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。</li></ul></li><li>词(Term)：<ul><li>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</li></ul></li></ul><p>Lucene的索引结构中，即保存了正向信息，也保存了反向信息。</p><p>所谓正向信息：</p><ul><li>按层次保存了从索引，一直到词的包含关系：索引(Index) –&gt; 段(segment) –&gt; 文档(Document) –&gt; 域(Field) –&gt; 词(Term)</li><li>也即此索引包含了那些段，每个段包含了那些文档，每个文档包含了那些域，每个域包含了那些词。</li><li>既然是层次结构，则每个层次都保存了本层次的信息以及下一层次的元信息，也即属性信息，比如一本介绍中国地理的书，应该首先介绍中国地理的概况，以及中国包含多少个省，每个省介绍本省的基本概况及包含多少个市，每个市介绍本市的基本概况及包含多少个县，每个县具体介绍每个县的具体情况。</li><li>如上图，包含正向信息的文件有：<ul><li>segments_N保存了此索引包含多少个段，每个段包含多少篇文档。</li><li>XXX.fnm保存了此段包含了多少个域，每个域的名称及索引方式。</li><li>XXX.fdx，XXX.fdt保存了此段包含的所有文档，每篇文档包含了多少域，每个域保存了那些信息。</li><li>XXX.tvx，XXX.tvd，XXX.tvf保存了此段包含多少文档，每篇文档包含了多少域，每个域包含了多少词，每个词的字符串，位置等信息。</li></ul></li></ul><p>所谓反向信息：</p><ul><li>保存了词典到倒排表的映射：词(Term) –&gt; 文档(Document)</li><li>如上图，包含反向信息的文件有：<ul><li>XXX.tis，XXX.tii保存了词典(Term Dictionary)，也即此段包含的所有的词按字典顺序的排序。</li><li>XXX.frq保存了倒排表，也即包含每个词的文档ID列表。</li><li>XXX.prx保存了倒排表中每个词在包含此词的文档中的位置。</li></ul></li></ul><p>在了解Lucene索引的详细结构之前，先看看Lucene索引中的基本数据类型。</p><h2><span id="二-基本类型"><strong>二、基本类型</strong></span></h2><p>Lucene索引文件中，用以下基本类型来保存信息：</p><ul><li>Byte：是最基本的类型，长8位(bit)。</li><li>UInt32：由4个Byte组成。</li><li>UInt64：由8个Byte组成。</li><li>VInt：<ul><li>变长的整数类型，它可能包含多个Byte，对于每个Byte的8位，其中后7位表示数值，最高1位表示是否还有另一个Byte，0表示没有，1表示有。</li><li>越前面的Byte表示数值的低位，越后面的Byte表示数值的高位。</li><li>例如130化为二进制为 1000, 0010，总共需要8位，一个Byte表示不了，因而需要两个Byte来表示，第一个Byte表示后7位，并且在最高位置1来表示后面还有一个Byte，所以为(1) 0000010，第二个Byte表示第8位，并且最高位置0来表示后面没有其他的Byte了，所以为(0) 0000001。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262118850.png" alt></p><ul><li>Chars：是UTF-8编码的一系列Byte。</li><li>String：一个字符串首先是一个VInt来表示此字符串包含的字符的个数，接着便是UTF-8编码的字符序列Chars。</li></ul><h2><span id="三-基本规则"><strong>三、基本规则</strong></span></h2><p>Lucene为了使的信息的存储占用的空间更小，访问速度更快，采取了一些特殊的技巧，然而在看Lucene文件格式的时候，这些技巧却容易使我们感到困惑，所以有必要把这些特殊的技巧规则提取出来介绍一下。</p><h3><span id="1-前缀后缀规则prefixsuffix"><strong>1. 前缀后缀规则(Prefix+Suffix)</strong></span></h3><p>Lucene在反向索引中，要保存词典(Term Dictionary)的信息，所有的词(Term)在词典中是按照字典顺序进行排列的，然而词典中包含了文档中的几乎所有的词，并且有的词还是非常的长的，这样索引文件会非常的大，所谓前缀后缀规则，即当某个词和前一个词有共同的前缀的时候，后面的词仅仅保存前缀在词中的偏移(offset)，以及除前缀以外的字符串(称为后缀)。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262121854.png" alt></p><p>比如要存储如下词:term，termagancy，termagant，terminal，</p><p>如果按照正常方式来存储，需要的空间如下：</p><p>[VInt = 4] [t][e][r][m]，</p><p>[VInt = 10][t][e][r][m][a][g][a][n][c][y]，</p><p>[VInt = 9][t][e][r][m][a][g][a][n][t]，</p><p>[VInt = 8][t][e][r][m][i][n][a][l]</p><p>共需要35个Byte.</p><p>如果应用前缀后缀规则，需要的空间如下：</p><p>[VInt = 4] [t][e][r][m]，</p><p>[VInt = 4 (offset)][VInt = 6][a][g][a][n][c][y]，</p><p>[VInt = 8 (offset)][VInt = 1][t]，</p><p>[VInt = 4 (offset)][VInt = 4][i][n][a][l]</p><p>共需要22个Byte。</p><p>大大缩小了存储空间，尤其是在按字典顺序排序的情况下，前缀的重合率大大提高。</p><h3><span id="2-差值规则delta"><strong>2. 差值规则(Delta)</strong></span></h3><p>在Lucene的反向索引中，需要保存很多整型数字的信息，比如文档ID号，比如词(Term)在文档中的位置等等。</p><p>由上面介绍，我们知道，整型数字是以VInt的格式存储的。随着数值的增大，每个数字占用的Byte的个数也逐渐的增多。所谓差值规则(Delta)就是先后保存两个整数的时候，后面的整数仅仅保存和前面整数的差即可。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262129662.png" alt></p><p>比如要存储如下整数：16386，16387，16388，16389</p><p>如果按照正常方式来存储，需要的空间如下：</p><p>[(1) 000, 0010][(1) 000, 0000][(0) 000, 0001]，</p><p>[(1) 000, 0011][(1) 000, 0000][(0) 000, 0001]，</p><p>[(1) 000, 0100][(1) 000, 0000][(0) 000, 0001]，</p><p>[(1) 000, 0101][(1) 000, 0000][(0) 000, 0001]</p><p>供需12个Byte。</p><p>如果应用差值规则来存储，需要的空间如下：</p><p>[(1) 000, 0010][(1) 000, 0000][(0) 000, 0001]，</p><p>[(0) 000, 0001]，</p><p>[(0) 000, 0001]，</p><p>[(0) 000, 0001]</p><p>共需6个Byte。</p><p>大大缩小了存储空间，而且无论是文档ID，还是词在文档中的位置，都是按从小到大的顺序，逐渐增大的。</p><h3><span id="3-或然跟随规则a-b"><strong>3. 或然跟随规则(A, B?)</strong></span></h3><p>Lucene的索引结构中存在这样的情况，某个值A后面可能存在某个值B，也可能不存在，需要一个标志来表示后面是否跟随着B。</p><p>一般的情况下，在A后面放置一个Byte，为0则后面不存在B，为1则后面存在B，或者0则后面存在B，1则后面不存在B。</p><p>但这样要浪费一个Byte的空间，其实一个Bit就可以了。</p><p>在Lucene中，采取以下的方式：A的值左移一位，空出最后一位，作为标志位，来表示后面是否跟随B，所以在这种情况下，A/2是真正的A原来的值。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262134351.png" alt></p><p>如果去读Apache Lucene - Index File Formats这篇文章，会发现很多符合这种规则的：</p><ul><li>.frq文件中的DocDelta[, Freq?]，DocSkip,PayloadLength?</li><li>.prx文件中的PositionDelta,Payload? (但不完全是，如下表分析)</li></ul><p>当然还有一些带?的但不属于此规则的：</p><ul><li>.frq文件中的SkipChildLevelPointer?，是多层跳跃表中，指向下一层表的指针，当然如果是最后一层，此值就不存在，也不需要标志。</li><li>.tvf文件中的Positions?, Offsets?。<ul><li>在此类情况下，带?的值是否存在，并不取决于前面的值的最后一位。</li><li>而是取决于Lucene的某项配置，当然这些配置也是保存在Lucene索引文件中的。</li><li>如Position和Offset是否存储，取决于.fnm文件中对于每个域的配置(TermVector.WITH_POSITIONS和TermVector.WITH_OFFSETS)</li></ul></li></ul><p>为什么会存在以上两种情况，其实是可以理解的：</p><ul><li>对于符合或然跟随规则的，是因为对于每一个A，B是否存在都不相同，当这种情况大量存在的时候，从一个Byte到一个Bit如此8倍的空间节约还是很值得的。</li><li>对于不符合或然跟随规则的，是因为某个值的是否存在的配置对于整个域(Field)甚至整个索引都是有效的，而非每次的情况都不相同，因而可以统一存放一个标志。</li></ul><blockquote><p> 文章中对如下格式的描述令人困惑：</p></blockquote><blockquote><p> Positions –&gt; &lt;PositionDelta,Payload?&gt; <sup zoompage-fontsize="12">Freq</sup></p></blockquote><blockquote><p> Payload –&gt; &lt;PayloadLength?,PayloadData&gt;</p></blockquote><blockquote><p> PositionDelta和Payload是否适用或然跟随规则呢？如何标识PayloadLength是否存在呢？</p></blockquote><blockquote><p> 其实PositionDelta和Payload并不符合或然跟随规则，Payload是否存在，是由.fnm文件中对于每个域的配置中有关Payload的配置决定的(FieldOption.STORES_PAYLOADS) 。</p></blockquote><blockquote><p> 当Payload不存在时，PayloadDelta本身不遵从或然跟随原则。</p></blockquote><blockquote><p> 当Payload存在时，格式应该变成如下：Positions –&gt; &lt;PositionDelta,PayloadLength?,PayloadData&gt; <sup zoompage-fontsize="12">Freq</sup></p></blockquote><blockquote><p> 从而PositionDelta和PayloadLength一起适用或然跟随规则。</p></blockquote><h3><span id="4-跳跃表规则skip-list"><strong>4. 跳跃表规则(Skip list)</strong></span></h3><p>为了提高查找的性能，Lucene在很多地方采取的跳跃表的数据结构。</p><p>跳跃表(Skip List)是如图的一种数据结构，有以下几个基本特征：</p><ul><li>元素是按顺序排列的，在Lucene中，或是按字典顺序排列，或是按从小到大顺序排列。</li><li>跳跃是有间隔的(Interval)，也即每次跳跃的元素数，间隔是事先配置好的，如图跳跃表的间隔为3。</li><li>跳跃表是由层次的(level)，每一层的每隔指定间隔的元素构成上一层，如图跳跃表共有2层。</li></ul><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262141098.png" alt></p><p>需要注意一点的是，在很多数据结构或算法书中都会有跳跃表的描述，原理都是大致相同的，但是定义稍有差别：</p><ul><li>对间隔(Interval)的定义： 如图中，有的认为间隔为2，即两个上层元素之间的元素数，不包括两个上层元素；有的认为是3，即两个上层元素之间的差，包括后面上层元素，不包括前面的上层元素；有的认为是4，即除两个上层元素之间的元素外，既包括前面，也包括后面的上层元素。Lucene是采取的第二种定义。</li><li>对层次(Level)的定义：如图中，有的认为应该包括原链表层，并从1开始计数，则总层次为3，为1，2，3层；有的认为应该包括原链表层，并从0计数，为0，1，2层；有的认为不应该包括原链表层，且从1开始计数，则为1，2层；有的认为不应该包括链表层，且从0开始计数，则为0，1层。Lucene采取的是最后一种定义。</li></ul><p>跳跃表比顺序查找，大大提高了查找速度，如查找元素72，原来要访问2，3，7，12，23，37，39，44，50，72总共10个元素，应用跳跃表后，只要首先访问第1层的50，发现72大于50，而第1层无下一个节点，然后访问第2层的94，发现94大于72，然后访问原链表的72，找到元素，共需要访问3个元素即可。</p><p>然而Lucene在具体实现上，与理论又有所不同，在具体的格式中，会详细说明。</p><h2><span id="四-具体格式"><strong>四、具体格式</strong></span></h2><p>上面曾经交代过，Lucene保存了从Index到Segment到Document到Field一直到Term的正向信息，也包括了从Term到Document映射的反向信息，还有其他一些Lucene特有的信息。下面对这三种信息一一介绍。</p><h3><span id="41-正向信息"><strong>4.1. 正向信息</strong></span></h3><p><code>Index –&gt; Segments (segments.gen, segments_N) –&gt; Field(fnm, fdx, fdt) –&gt; Term (tvx, tvd, tvf)</code></p><p>上面的层次结构不是十分的准确，因为segments.gen和segments_N保存的是段(segment)的元数据信息(metadata)，其实是每个Index一个的，而段的真正的数据信息，是保存在域(Field)和词(Term)中的。</p><h4><span id="411-段的元数据信息segments_n"><strong>4.1.1. 段的元数据信息(segments_N)</strong></span></h4><p>一个索引(Index)可以同时存在多个segments_N(至于如何存在多个segments_N，在描述完详细信息之后会举例说明)，然而当我们要打开一个索引的时候，我们必须要选择一个来打开，那如何选择哪个segments_N呢？</p><p>Lucene采取以下过程：</p><ul><li><p>其一，在所有的segments_N中选择N最大的一个。基本逻辑参照SegmentInfos.getCurrentSegmentGeneration(File[] files)，其基本思路就是在所有以segments开头，并且不是segments.gen的文件中，选择N最大的一个作为genA。</p></li><li><p>其二，打开segments.gen，其中保存了当前的N值。其格式如下，读出版本号(Version)，然后再读出两个N，如果两者相等，则作为genB。</p></li></ul><p>  <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272228421.png" alt></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexInput</span> <span class="variable">genInput</span> <span class="operator">=</span> directory.openInput(IndexFileNames.SEGMENTS_GEN);<span class="comment">//&quot;segments.gen&quot;  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> genInput.readInt();<span class="comment">//读出版本号  </span></span><br><span class="line"><span class="keyword">if</span> (version == FORMAT_LOCKLESS) &#123;<span class="comment">//如果版本号正确  </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">gen0</span> <span class="operator">=</span> genInput.readLong();<span class="comment">//读出第一个N  </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">gen1</span> <span class="operator">=</span> genInput.readLong();<span class="comment">//读出第二个N  </span></span><br><span class="line">    <span class="keyword">if</span> (gen0 == gen1) &#123;<span class="comment">//如果两者相等则为genB  </span></span><br><span class="line">        genB = gen0;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其三，在上述得到的genA和genB中选择最大的那个作为当前的N，方才打开segments_N文件。其基本逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (genA &gt; genB)  </span><br><span class="line">    gen = genA;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    gen = genB;</span><br></pre></td></tr></table></figure></li></ul><p>如下图是segments_N的具体格式：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272230529.png" alt></p><ul><li>Format：<ul><li>索引文件格式的版本号。</li><li>由于Lucene是在不断开发过程中的，因而不同版本的Lucene，其索引文件格式也不尽相同，于是规定一个版本号。</li><li>Lucene 2.1此值-3，Lucene 2.9时，此值为-9。</li><li>当用某个版本号的IndexReader读取另一个版本号生成的索引的时候，会因为此值不同而报错。</li></ul></li><li>Version：<ul><li>索引的版本号，记录了IndexWriter将修改提交到索引文件中的次数。</li><li>其初始值大多数情况下从索引文件里面读出，仅仅在索引开始创建的时候，被赋予当前的时间，已取得一个唯一值。</li><li>其值改变在 <code>IndexWriter.commit-&gt;IndexWriter.startCommit-&gt;SegmentInfos.prepareCommit-&gt;SegmentInfos.write-&gt;writeLong(++version)</code></li><li>其初始值之所最初取一个时间，是因为我们并不关心IndexWriter将修改提交到索引的具体次数，而更关心到底哪个是最新的。IndexReader中常比较自己的version和索引文件中的version是否相同来判断此IndexReader被打开后，还有没有被IndexWriter更新。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在DirectoryReader中有一下函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCurrent</span><span class="params">()</span> <span class="keyword">throws</span> CorruptIndexException, IOException &#123;  </span><br><span class="line">  <span class="keyword">return</span> SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NameCount<ul><li>是下一个新段(Segment)的段名。</li><li>所有属于同一个段的索引文件都以段名作为文件名，一般为_0.xxx, _0.yyy,  _1.xxx, _1.yyy ……</li><li>新生成的段的段名一般为原有最大段名加一。</li><li>如同的索引，NameCount读出来是2，说明新的段为_2.xxx, _2.yyy</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272232711.png" alt></p><ul><li>SegCount<ul><li>段(Segment)的个数。</li><li>如上图，此值为2。</li></ul></li><li>SegCount个段的元数据信息：<ul><li>SegName<ul><li>段名，所有属于同一个段的文件都有以段名作为文件名。</li><li>如上图，第一个段的段名为”_0”，第二个段的段名为”_1”</li></ul></li><li>SegSize<ul><li>此段中包含的文档数</li><li>然而此文档数是包括已经删除，又没有optimize的文档的，因为在optimize之前，Lucene的段中包含了所有被索引过的文档，而被删除的文档是保存在.del文件中的，在搜索的过程中，是先从段中读到了被删除的文档，然后再用.del中的标志，将这篇文档过滤掉。</li><li>如下的代码形成了上图的索引，可以看出索引了两篇文档形成了_0段，然后又删除了其中一篇，形成了_0_1.del，又索引了两篇文档形成_1段，然后又删除了其中一篇，形成_1_1.del。因而在两个段中，此值都是2。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriter</span>(FSDirectory.open(INDEX\_DIR), <span class="keyword">new</span> <span class="title class_">StandardAnalyzer</span>(Version.LUCENE\_CURRENT), <span class="literal">true</span>, IndexWriter.MaxFieldLength.LIMITED);  </span><br><span class="line">writer.setUseCompoundFile(<span class="literal">false</span>);  </span><br><span class="line">indexDocs(writer, docDir);<span class="comment">//docDir中只有两篇文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文档一为：Students should be allowed to go out with their friends, but not allowed to drink beer.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文档二为：My friend Jerry went to school to see his students but found them drunk which is not allowed.</span></span><br><span class="line"></span><br><span class="line">writer.commit();<span class="comment">//提交两篇文档，形成\_0段。</span></span><br><span class="line"></span><br><span class="line">writer.deleteDocuments(<span class="keyword">new</span> <span class="title class_">Term</span>(<span class="string">&quot;contents&quot;</span>, <span class="string">&quot;school&quot;</span>));<span class="comment">//删除文档二  </span></span><br><span class="line">writer.commit();<span class="comment">//提交删除，形成\_0\_1.del  </span></span><br><span class="line">indexDocs(writer, docDir);<span class="comment">//再次索引两篇文档，Lucene不能判别文档与文档的不同，因而算两篇新的文档。  </span></span><br><span class="line">writer.commit();<span class="comment">//提交两篇文档，形成\_1段  </span></span><br><span class="line">writer.deleteDocuments(<span class="keyword">new</span> <span class="title class_">Term</span>(<span class="string">&quot;contents&quot;</span>, <span class="string">&quot;school&quot;</span>));<span class="comment">//删除第二次添加的文档二  </span></span><br><span class="line">writer.close();<span class="comment">//提交删除，形成\_1\_1.del</span></span><br></pre></td></tr></table></figure><ul><li><ul><li>DelGen<ul><li>.del文件的版本号</li><li>Lucene中，在optimize之前，删除的文档是保存在.del文件中的。</li><li>在Lucene 2.9中，文档删除有以下几种方式：<ul><li>IndexReader.deleteDocument(int docID)是用IndexReader按文档号删除。</li><li>IndexReader.deleteDocuments(Term term)是用IndexReader删除包含此词(Term)的文档。</li><li>IndexWriter.deleteDocuments(Term term)是用IndexWriter删除包含此词(Term)的文档。</li><li>IndexWriter.deleteDocuments(Term[] terms)是用IndexWriter删除包含这些词(Term)的文档。</li><li>IndexWriter.deleteDocuments(Query query)是用IndexWriter删除能满足此查询(Query)的文档。</li><li>IndexWriter.deleteDocuments(Query[] queries)是用IndexWriter删除能满足这些查询(Query)的文档。</li><li>原来的版本中Lucene的删除一直是由IndexReader来完成的，在Lucene 2.9中虽可以用IndexWriter来删除，但是其实真正的实现是在IndexWriter中，保存了readerpool，当IndexWriter向索引文件提交删除的时候，仍然是从readerpool中得到相应的IndexReader，并用IndexReader来进行删除的。下面的代码可以说明：</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IndexWriter.applyDeletes()</span><br><span class="line">-&gt; DocumentsWriter.applyDeletes(SegmentInfos)</span><br><span class="line">  -&gt; reader.deleteDocument(doc);</span><br></pre></td></tr></table></figure><ul><li><ul><li><ul><li><ul><li>DelGen是每当IndexWriter向索引文件中提交删除操作的时候，加1，并生成新的.del文件。</li></ul></li></ul></li></ul></li></ul><table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">IndexWriter.commit()</p><p zoompage-fontsize="14">-&gt; IndexWriter.applyDeletes()</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp; -&gt; IndexWriter$ReaderPool.release(SegmentReader)</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; SegmentReader(IndexReader).commit()</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; SegmentReader.doCommit(Map)</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; SegmentInfo.advanceDelGen()</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; if (delGen == NO) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delGen = YES;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delGen++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">IndexWriter writer = new IndexWriter(FSDirectory.open(INDEX_DIR), new StandardAnalyzer(Version.LUCENE_CURRENT), true, IndexWriter.MaxFieldLength.LIMITED);<br>writer.setUseCompoundFile(false);</p><p zoompage-fontsize="14">indexDocs(writer, docDir);//索引两篇文档，一篇包含"school"，另一篇包含"beer"<br>writer.commit();//提交两篇文档到索引文件，形成段(Segment) "_0"<br>writer.deleteDocuments(new Term("contents", "school"));//删除包含"school"的文档，其实是删除了两篇文档中的一篇。<br>writer.commit();//提交删除到索引文件，形成"_0_1.del"<br>writer.deleteDocuments(new Term("contents", "beer"));//删除包含"beer"的文档，其实是删除了两篇文档中的另一篇。<br>writer.commit();//提交删除到索引文件，形成"_0_2.del"<br>indexDocs(writer, docDir);//索引两篇文档，和上次的文档相同，但是Lucene无法区分，认为是另外两篇文档。<br>writer.commit();//提交两篇文档到索引文件，形成段"_1"<br>writer.deleteDocuments(new Term("contents", "beer"));//删除包含"beer"的文档，其中段"_0"已经无可删除，段"_1"被删除一篇。<br>writer.close();//提交删除到索引文件，形成"_1_1.del"</p><p zoompage-fontsize="14">形成的索引文件如下：</p><p zoompage-fontsize="14"><a href="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022112703.png" rel="noopener" zoompage-fontsize="14"><img title="image" height="431" alt="image" src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022112703.png" width="204"></a></p></td></tr></tbody></table><ul><li><ul><li><p>DocStoreOffset</p></li><li><p>DocStoreSegment</p></li><li><p>DocStoreIsCompoundFile</p><ul><li>对于域(Stored Field)和词向量(Term Vector)的存储可以有不同的方式，即可以每个段(Segment)单独存储自己的域和词向量信息，也可以多个段共享域和词向量，把它们存储到一个段中去。</li><li>如果DocStoreOffset为-1，则此段单独存储自己的域和词向量，从存储文件上来看，如果此段段名为XXX，则此段有自己的XXX.fdt，XXX.fdx，XXX.tvf，XXX.tvd，XXX.tvx文件。DocStoreSegment和DocStoreIsCompoundFile在此处不被保存。</li><li>如果DocStoreOffset不为-1，则DocStoreSegment保存了共享的段的名字，比如为YYY，DocStoreOffset则为此段的域及词向量信息在共享段中的偏移量。则此段没有自己的XXX.fdt，XXX.fdx，XXX.tvf，XXX.tvd，XXX.tvx文件，而是将信息存放在共享段的YYY.fdt，YYY.fdx，YYY.tvf，YYY.tvd，YYY.tvx文件中。</li><li>DocumentsWriter中有两个成员变量：String segment是当前索引信息存放的段，String docStoreSegment是域和词向量信息存储的段。两者可以相同也可以不同，决定了域和词向量信息是存储在本段中，还是和其他的段共享。</li><li>IndexWriter.flush(boolean triggerMerge, boolean flushDocStores, boolean flushDeletes)中第二个参数flushDocStores会影响到是否单独或是共享存储。其实最终影响的是DocumentsWriter.closeDocStore()。每当flushDocStores为false时，closeDocStore不被调用，说明下次添加到索引文件中的域和词向量信息是同此次共享一个段的。直到flushDocStores为true的时候，closeDocStore被调用，从而下次添加到索引文件中的域和词向量信息将被保存在一个新的段中，不同此次共享一个段(在这里需要指出的是Lucene的一个很奇怪的实现，虽然下次域和词向量信息是被保存到新的段中，然而段名却是这次被确定了的，在initSegmentName中当docStoreSegment == null时，被置为当前的segment，而非下一个新的segment，docStoreSegment = segment，于是会出现如下面的例子的现象)。</li><li>好在共享域和词向量存储并不是经常被使用到，实现也或有缺陷，暂且解释到此。</li></ul><p>IndexWriter writer = new IndexWriter(FSDirectory.open(INDEX_DIR), new StandardAnalyzer(Version.LUCENE_CURRENT), true, IndexWriter.MaxFieldLength.LIMITED);<br>writer.setUseCompoundFile(false);</p></li></ul></li></ul><pre><code>indexDocs(writer, docDir);  writer.flush();</code></pre><p>//flush生成segment “_0”，并且flush函数中，flushDocStores设为false，也即下个段将同本段共享域和词向量信息，这时DocumentsWriter中的docStoreSegment= “_0”。</p><pre><code>indexDocs(writer, docDir);  writer.commit();</code></pre><p>//commit生成segment “_1”，由于上次flushDocStores设为false，于是段”_1”的域以及词向量信息是保存在”_0”中的，在这个时刻，段”_1”并不生成自己的”_1.fdx”和”_1.fdt”。然而在commit函数中，flushDocStores设为true，也即下个段将单独使用新的段来存储域和词向量信息。然而这时，DocumentsWriter中的docStoreSegment= “_1”，也即当段”_2”存储其域和词向量信息的时候，是存在”_1.fdx”和”_1.fdt”中的，而段”_1”的域和词向量信息却是存在”_0.fdt”和”_0.fdx”中的，这一点非常令人困惑。 如图writer.commit的时候，_1.fdt和_1.fdx并没有形成。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022114233.png" alt></p><pre><code>indexDocs(writer, docDir);  writer.flush();</code></pre><p>//段”_2”形成，由于上次flushDocStores设为true，其域和词向量信息是新创建一个段保存的，却是保存在_1.fdt和_1.fdx中的，这时候才产生了此二文件。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022115773.png" alt></p><pre><code>indexDocs(writer, docDir);  writer.flush();</code></pre><p>//段”_3”形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_1.fdt和_1.fdx中的</p><pre><code>indexDocs(writer, docDir);  writer.commit();</code></pre><p>//段”_4”形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_1.fdt和_1.fdx中的。然而函数commit中flushDocStores设为true，也意味着下一个段将新创建一个段保存域和词向量信息，此时DocumentsWriter中docStoreSegment= “_4”，也表明了虽然段”_4”的域和词向量信息保存在了段”_1”中，将来的域和词向量信息却要保存在段”_4”中。此时”_4.fdx”和”_4.fdt”尚未产生。   </p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022115627.png" alt></p><pre><code>indexDocs(writer, docDir);  writer.flush();</code></pre><p>//段”_5”形成，由于上次flushDocStores设为true，其域和词向量信息是新创建一个段保存的，却是保存在_4.fdt和_4.fdx中的，这时候才产生了此二文件。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022116165.png" alt></p><pre><code>indexDocs(writer, docDir);  writer.commit();  writer.close();</code></pre><p>//段”_6”形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_4.fdt和_4.fdx中的</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022116777.png" alt></p><ul><li><ul><li>HasSingleNormFile<ul><li>在搜索的过程中，标准化因子(Normalization Factor)会影响文档最后的评分。</li><li>不同的文档重要性不同，不同的域重要性也不同。因而每个文档的每个域都可以有自己的标准化因子。</li><li>如果HasSingleNormFile为1，则所有的标准化因子都是存在.nrm文件中的。</li><li>如果HasSingleNormFile不是1，则每个域都有自己的标准化因子文件.fN</li></ul></li><li>NumField<ul><li>域的数量</li></ul></li><li>NormGen<ul><li>如果每个域有自己的标准化因子文件，则此数组描述了每个标准化因子文件的版本号，也即.fN的N。</li></ul></li><li>IsCompoundFile<ul><li>是否保存为复合文件，也即把同一个段中的文件按照一定格式，保存在一个文件当中，这样可以减少每次打开文件的个数。</li><li>是否为复合文件，由接口IndexWriter.setUseCompoundFile(boolean)设定。 </li><li>非符合文件同符合文件的对比如下图：</li></ul></li></ul></li><li><ul><li>DeletionCount<ul><li>记录了此段中删除的文档的数目。</li></ul></li><li>HasProx<ul><li>如果至少有一个段omitTf为false，也即词频(term freqency)需要被保存，则HasProx为1，否则为0。</li></ul></li><li>Diagnostics<ul><li>调试信息。</li></ul></li></ul></li><li><p>User map data</p><ul><li>保存了用户从字符串到字符串的映射Map</li></ul></li><li><p>CheckSum</p><ul><li>此文件segment_N的校验和。</li></ul></li></ul><p>读取此文件格式参考SegmentInfos.read(Directory directory, String segmentFileName):</p><ul><li><p>int format = input.readInt();</p></li><li><p>version = input.readLong(); // read version</p></li><li><p>counter = input.readInt(); // read counter</p></li><li><p>for (int i = input.readInt(); i &gt; 0; i–) // read segmentInfos</p><ul><li>add(new SegmentInfo(directory, format, input));<ul><li>name = input.readString();</li><li>docCount = input.readInt();</li><li>delGen = input.readLong();</li><li>docStoreOffset = input.readInt();</li><li>docStoreSegment = input.readString();</li><li>docStoreIsCompoundFile = (1 == input.readByte());</li><li>hasSingleNormFile = (1 == input.readByte());</li><li>int numNormGen = input.readInt();</li><li>normGen = new long[numNormGen];</li><li>for(int j=0;j</li><li>normGen[j] = input.readLong();</li></ul></li><li>isCompoundFile = input.readByte();</li><li>delCount = input.readInt();</li><li>hasProx = input.readByte() == 1;</li><li>diagnostics = input.readStringStringMap();</li></ul></li><li><p>userData = input.readStringStringMap();</p></li><li><p>final long checksumNow = input.getChecksum();</p></li><li><p>final long checksumThen = input.readLong();</p></li></ul><h4><span id="412-域field的元数据信息fnm"><strong>4.1.2. 域(Field)的元数据信息(.fnm)</strong></span></h4><p>一个段(Segment)包含多个域，每个域都有一些元数据信息，保存在.fnm文件中，.fnm文件的格式如下：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022117877.png" alt></p><ul><li>FNMVersion<ul><li>是fnm文件的版本号，对于Lucene 2.9为-2</li></ul></li><li>FieldsCount<ul><li>域的数目</li></ul></li><li>一个数组的域(Fields)<ul><li>FieldName：域名，如”title”，”modified”，”content”等。</li><li>FieldBits:一系列标志位，表明对此域的索引方式<ul><li>最低位：1表示此域被索引，0则不被索引。所谓被索引，也即放到倒排表中去。<ul><li>仅仅被索引的域才能够被搜到。</li><li>Field.Index.NO则表示不被索引。</li><li>Field.Index.ANALYZED则表示不但被索引，而且被分词，比如索引”hello world”后，无论是搜”hello”，还是搜”world”都能够被搜到。</li><li>Field.Index.NOT_ANALYZED表示虽然被索引，但是不分词，比如索引”hello world”后，仅当搜”hello world”时，能够搜到，搜”hello”和搜”world”都搜不到。</li><li>一个域出了能够被索引，还能够被存储，仅仅被存储的域是搜索不到的，但是能通过文档号查到，多用于不想被搜索到，但是在通过其它域能够搜索到的情况下，能够随着文档号返回给用户的域。</li><li>Field.Store.Yes则表示存储此域，Field.Store.NO则表示不存储此域。</li></ul></li><li>倒数第二位：1表示保存词向量，0为不保存词向量。<ul><li>Field.TermVector.YES表示保存词向量。</li><li>Field.TermVector.NO表示不保存词向量。</li></ul></li><li>倒数第三位：1表示在词向量中保存位置信息。<ul><li>Field.TermVector.WITH_POSITIONS</li></ul></li><li>倒数第四位：1表示在词向量中保存偏移量信息。<ul><li>Field.TermVector.WITH_OFFSETS</li></ul></li><li>倒数第五位：1表示不保存标准化因子<ul><li>Field.Index.ANALYZED_NO_NORMS</li><li>Field.Index.NOT_ANALYZED_NO_NORMS</li></ul></li><li>倒数第六位：是否保存payload</li></ul></li></ul></li></ul><p>要了解域的元数据信息，还要了解以下几点：</p><ul><li>位置(Position)和偏移量(Offset)的区别<ul><li>位置是基于词Term的，偏移量是基于字母或汉字的。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022117067.png" alt></p><ul><li>索引域(Indexed)和存储域(Stored)的区别<ul><li>一个域为什么会被存储(store)而不被索引(Index)呢？在一个文档中的所有信息中，有这样一部分信息，可能不想被索引从而可以搜索到，但是当这个文档由于其他的信息被搜索到时，可以同其他信息一同返回。</li><li>举个例子，读研究生时，您好不容易写了一篇论文交给您的导师，您的导师却要他所第一作者而您做第二作者，然而您导师不想别人在论文系统中搜索您的名字时找到这篇论文，于是在论文系统中，把第二作者这个Field的Indexed设为false，这样别人搜索您的名字，永远不知道您写过这篇论文，只有在别人搜索您导师的名字从而找到您的文章时，在一个角落表述着第二作者是您。</li></ul></li><li>payload的使用<ul><li>我们知道，索引是以倒排表形式存储的，对于每一个词，都保存了包含这个词的一个链表，当然为了加快查询速度，此链表多用跳跃表进行存储。</li><li>Payload信息就是存储在倒排表中的，同文档号一起存放，多用于存储与每篇文档相关的一些信息。当然这部分信息也可以存储域里(stored Field)，两者从功能上基本是一样的，然而当要存储的信息很多的时候，存放在倒排表里，利用跳跃表，有利于大大提高搜索速度。</li><li>Payload的存储方式如下图：</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022122309.png" alt></p><ul><li><ul><li>Payload主要有以下几种用法：<ul><li>存储每个文档都有的信息：比如有的时候，我们想给每个文档赋一个我们自己的文档号，而不是用Lucene自己的文档号。于是我们可以声明一个特殊的域(Field)”_ID”和特殊的词(Term)”_ID”，使得每篇文档都包含词”_ID”，于是在词”_ID”的倒排表里面对于每篇文档又有一项，每一项都有一个payload，于是我们可以在payload里面保存我们自己的文档号。每当我们得到一个Lucene的文档号的时候，就能从跳跃表中查找到我们自己的文档号。</li></ul></li></ul></li></ul><p>//声明一个特殊的域和特殊的词</p><p>public static final String ID_PAYLOAD_FIELD = “_ID”;</p><p>public static final String ID_PAYLOAD_TERM = “_ID”;</p><p>public static final Term ID_TERM = new Term(ID_PAYLOAD_TERM, ID_PAYLOAD_FIELD);</p><p>//声明一个特殊的TokenStream，它只生成一个词(Term)，就是那个特殊的词，在特殊的域里面。</p><p>static class SinglePayloadTokenStream extends TokenStream {<br>    private Token token;<br>    private boolean returnToken = false;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SinglePayloadTokenStream(String idPayloadTerm) &#123;  </span><br><span class="line">    <span class="type">char</span>[] term = idPayloadTerm.toCharArray();  </span><br><span class="line">    token = <span class="keyword">new</span> <span class="title class_">Token</span>(term, <span class="number">0</span>, term.length, <span class="number">0</span>, term.length);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setPayloadValue</span><span class="params">(<span class="type">byte</span>[] value)</span> &#123;  </span><br><span class="line">    token.setPayload(<span class="keyword">new</span> <span class="title class_">Payload</span>(value));  </span><br><span class="line">    returnToken = <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="keyword">if</span> (returnToken) &#123;  </span><br><span class="line">        returnToken = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> token;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>}</p><p>//对于每一篇文档，都让它包含这个特殊的词，在特殊的域里面</p><p>SinglePayloadTokenStream singlePayloadTokenStream = new SinglePayloadTokenStream(ID_PAYLOAD_TERM);<br>singlePayloadTokenStream.setPayloadValue(long2bytes(id));<br>doc.add(new Field(ID_PAYLOAD_FIELD, singlePayloadTokenStream));</p><p>//每当得到一个Lucene的文档号时，通过以下的方式得到payload里面的文档号</p><p>long id = 0;<br>TermPositions tp = reader.termPositions(ID_PAYLOAD_TERM);<br>boolean ret = tp.skipTo(docID);<br>tp.nextPosition();<br>int payloadlength = tp.getPayloadLength();<br>byte[] payloadBuffer = new byte[payloadlength];<br>tp.getPayload(payloadBuffer, 0);<br>id = bytes2long(payloadBuffer);<br>tp.close();</p><ul><li><ul><li><ul><li>影响词的评分<ul><li>在Similarity抽象类中有函数public float scorePayload(byte [] payload, int offset, int length)  可以根据payload的值影响评分。</li></ul></li></ul></li></ul></li><li>读取域元数据信息的代码如下：</li></ul><p>FieldInfos.read(IndexInput, String)</p><ul><li>int firstInt = input.readVInt();</li><li>size = input.readVInt();</li><li>for (int i = 0; i &lt; size; i++)<ul><li>String name = input.readString();</li><li>byte bits = input.readByte();</li><li>boolean isIndexed = (bits &amp; IS_INDEXED) != 0;</li><li>boolean storeTermVector = (bits &amp; STORE_TERMVECTOR) != 0;</li><li>boolean storePositionsWithTermVector = (bits &amp; STORE_POSITIONS_WITH_TERMVECTOR) != 0;</li><li>boolean storeOffsetWithTermVector = (bits &amp; STORE_OFFSET_WITH_TERMVECTOR) != 0;</li><li>boolean omitNorms = (bits &amp; OMIT_NORMS) != 0;</li><li>boolean storePayloads = (bits &amp; STORE_PAYLOADS) != 0;</li><li>boolean omitTermFreqAndPositions = (bits &amp; OMIT_TERM_FREQ_AND_POSITIONS) != 0;</li></ul></li></ul><h4><span id="413-域field的数据信息fdtfdx"><strong>4.1.3. 域(Field)的数据信息(.fdt，.fdx)</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022125684.png" alt></p><ul><li>域数据文件(fdt):<ul><li>真正保存存储域(stored field)信息的是fdt文件</li><li>在一个段(segment)中总共有segment size篇文档，所以fdt文件中共有segment size个项，每一项保存一篇文档的域的信息</li><li>对于每一篇文档，一开始是一个fieldcount，也即此文档包含的域的数目，接下来是fieldcount个项，每一项保存一个域的信息。</li><li>对于每一个域，fieldnum是域号，接着是一个8位的byte，最低一位表示此域是否分词(tokenized)，倒数第二位表示此域是保存字符串数据还是二进制数据，倒数第三位表示此域是否被压缩，再接下来就是存储域的值，比如new Field(“title”, “lucene in action”, Field.Store.Yes, …)，则此处存放的就是”lucene in action”这个字符串。</li></ul></li><li>域索引文件(fdx)<ul><li>由域数据文件格式我们知道，每篇文档包含的域的个数，每个存储域的值都是不一样的，因而域数据文件中segment size篇文档，每篇文档占用的大小也是不一样的，那么如何在fdt中辨别每一篇文档的起始地址和终止地址呢，如何能够更快的找到第n篇文档的存储域的信息呢？就是要借助域索引文件。</li><li>域索引文件也总共有segment size个项，每篇文档都有一个项，每一项都是一个long，大小固定，每一项都是对应的文档在fdt文件中的起始地址的偏移量，这样如果我们想找到第n篇文档的存储域的信息，只要在fdx中找到第n项，然后按照取出的long作为偏移量，就可以在fdt文件中找到对应的存储域的信息。</li></ul></li><li>读取域数据信息的代码如下：</li></ul><p>Document FieldsReader.doc(int n, FieldSelector fieldSelector)</p><ul><li>long position = indexStream.readLong();//indexStream points to “.fdx”</li><li>fieldsStream.seek(position);//fieldsStream points to “fdt”</li><li>int numFields = fieldsStream.readVInt();</li><li>for (int i = 0; i &lt; numFields; i++)<ul><li>int fieldNumber = fieldsStream.readVInt();</li><li>byte bits = fieldsStream.readByte();</li><li>boolean compressed = (bits &amp; FieldsWriter.FIELD_IS_COMPRESSED) != 0;</li><li>boolean tokenize = (bits &amp; FieldsWriter.FIELD_IS_TOKENIZED) != 0;</li><li>boolean binary = (bits &amp; FieldsWriter.FIELD_IS_BINARY) != 0;</li><li>if (binary)<ul><li>int toRead = fieldsStream.readVInt();</li><li>final byte[] b = new byte[toRead];</li><li>fieldsStream.readBytes(b, 0, b.length);</li><li>if (compressed)<ul><li>int toRead = fieldsStream.readVInt();</li><li>final byte[] b = new byte[toRead];</li><li>fieldsStream.readBytes(b, 0, b.length);</li><li>uncompress(b),</li></ul></li></ul></li><li>else<ul><li>fieldsStream.readString()</li></ul></li></ul></li></ul><h4><span id="413-词向量term-vector的数据信息tvxtvdtvf"><strong>4.1.3. 词向量(Term Vector)的数据信息(.tvx，.tvd，.tvf)</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022135786.png" alt></p><p>词向量信息是从索引(index)到文档(document)到域(field)到词(term)的正向信息，有了词向量信息，我们就可以得到一篇文档包含那些词的信息。</p><ul><li>词向量索引文件(tvx)<ul><li>一个段(segment)包含N篇文档，此文件就有N项，每一项代表一篇文档。</li><li>每一项包含两部分信息：第一部分是词向量文档文件(tvd)中此文档的偏移量，第二部分是词向量域文件(tvf)中此文档的第一个域的偏移量。</li></ul></li><li>词向量文档文件(tvd)<ul><li>一个段(segment)包含N篇文档，此文件就有N项，每一项包含了此文档的所有的域的信息。</li><li>每一项首先是此文档包含的域的个数NumFields，然后是一个NumFields大小的数组，数组的每一项是域号。然后是一个(NumFields - 1)大小的数组，由前面我们知道，每篇文档的第一个域在tvf中的偏移量在tvx文件中保存，而其他(NumFields - 1)个域在tvf中的偏移量就是第一个域的偏移量加上这(NumFields - 1)个数组的每一项的值。</li></ul></li><li>词向量域文件(tvf)<ul><li>此文件包含了此段中的所有的域，并不对文档做区分，到底第几个域到第几个域是属于那篇文档，是由tvx中的第一个域的偏移量以及tvd中的(NumFields - 1)个域的偏移量来决定的。</li><li>对于每一个域，首先是此域包含的词的个数NumTerms，然后是一个8位的byte，最后一位是指定是否保存位置信息，倒数第二位是指定是否保存偏移量信息。然后是NumTerms个项的数组，每一项代表一个词(Term)，对于每一个词，由词的文本TermText，词频TermFreq(也即此词在此文档中出现的次数)，词的位置信息，词的偏移量信息。</li></ul></li><li>读取词向量数据信息的代码如下：</li></ul><p>TermVectorsReader.get(int docNum, String field, TermVectorMapper)</p><ul><li>int fieldNumber = fieldInfos.fieldNumber(field);//通过field名字得到field号</li><li>seekTvx(docNum);//在tvx文件中按docNum文档号找到相应文档的项</li><li>long tvdPosition = tvx.readLong();//找到tvd文件中相应文档的偏移量</li><li>tvd.seek(tvdPosition);//在tvd文件中按偏移量找到相应文档的项</li><li>int fieldCount = tvd.readVInt();//此文档包含的域的个数。</li><li>for (int i = 0; i &lt; fieldCount; i++) //按域号查找域<ul><li>number = tvd.readVInt();</li><li>if (number == fieldNumber)<ul><li>found = i;</li></ul></li></ul></li><li>position = tvx.readLong();//在tvx中读出此文档的第一个域在tvf中的偏移量</li><li>for (int i = 1; i &lt;= found; i++)<ul><li>position += tvd.readVLong();//加上所要找的域在tvf中的偏移量</li></ul></li><li>tvf.seek(position);</li><li>int numTerms = tvf.readVInt();</li><li>byte bits = tvf.readByte();</li><li>storePositions = (bits &amp; STORE_POSITIONS_WITH_TERMVECTOR) != 0;</li><li>storeOffsets = (bits &amp; STORE_OFFSET_WITH_TERMVECTOR) != 0;</li><li>for (int i = 0; i &lt; numTerms; i++)<ul><li>start = tvf.readVInt();</li><li>deltaLength = tvf.readVInt();</li><li>totalLength = start + deltaLength;</li><li>tvf.readBytes(byteBuffer, start, deltaLength);</li><li>term = new String(byteBuffer, 0, totalLength, “UTF-8”);</li><li>if (storePositions)<ul><li>positions = new int[freq];</li><li>int prevPosition = 0;</li><li>for (int j = 0; j &lt; freq; j++)<ul><li>positions[j] = prevPosition + tvf.readVInt();</li><li>prevPosition = positions[j];</li></ul></li></ul></li><li>if (storeOffsets)<ul><li>offsets = new TermVectorOffsetInfo[freq];</li><li>int prevOffset = 0;</li><li>for (int j = 0; j &lt; freq; j++)</li><li>int startOffset = prevOffset + tvf.readVInt();</li><li>int endOffset = startOffset + tvf.readVInt();</li><li>offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);</li><li>prevOffset = endOffset;</li></ul></li></ul></li></ul><h3><span id="42-反向信息"><strong>4.2. 反向信息</strong></span></h3><p>反向信息是索引文件的核心，也即反向索引。</p><p>反向索引包括两部分，左面是词典(Term Dictionary)，右面是倒排表(Posting List)。</p><p>在Lucene中，这两部分是分文件存储的，词典是存储在tii，tis中的，倒排表又包括两部分，一部分是文档号及词频，保存在frq中，一部分是词的位置信息，保存在prx中。</p><ul><li>Term Dictionary (tii, tis)<ul><li>–&gt; Frequencies (.frq)</li><li>–&gt; Positions (.prx)</li></ul></li></ul><h4><span id="421-词典tis及词典索引tii信息"><strong>4.2.1. 词典(tis)及词典索引(tii)信息</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022136378.png" alt></p><p>在词典中，所有的词是按照字典顺序排序的。</p><ul><li>词典文件(tis)<ul><li>TermCount：词典中包含的总的词数</li><li>IndexInterval：为了加快对词的查找速度，也应用类似跳跃表的结构，假设IndexInterval为4，则在词典索引(tii)文件中保存第4个，第8个，第12个词，这样可以加快在词典文件中查找词的速度。</li><li>SkipInterval：倒排表无论是文档号及词频，还是位置信息，都是以跳跃表的结构存在的，SkipInterval是跳跃的步数。</li><li>MaxSkipLevels：跳跃表是多层的，这个值指的是跳跃表的最大层数。</li><li>TermCount个项的数组，每一项代表一个词，对于每一个词，以前缀后缀规则存放词的文本信息(PrefixLength + Suffix)，词属于的域的域号(FieldNum)，有多少篇文档包含此词(DocFreq)，此词的倒排表在frq，prx中的偏移量(FreqDelta, ProxDelta)，此词的倒排表的跳跃表在frq中的偏移量(SkipDelta)，这里之所以用Delta，是应用差值规则。</li></ul></li><li>词典索引文件(tii)<ul><li>词典索引文件是为了加快对词典文件中词的查找速度，保存每隔IndexInterval个词。</li><li>词典索引文件是会被全部加载到内存中去的。</li><li>IndexTermCount = TermCount / IndexInterval：词典索引文件中包含的词数。</li><li>IndexInterval同词典文件中的IndexInterval。</li><li>SkipInterval同词典文件中的SkipInterval。</li><li>MaxSkipLevels同词典文件中的MaxSkipLevels。</li><li>IndexTermCount个项的数组，每一项代表一个词，每一项包括两部分，第一部分是词本身(TermInfo)，第二部分是在词典文件中的偏移量(IndexDelta)。假设IndexInterval为4，此数组中保存第4个，第8个，第12个词。。。</li></ul></li><li>读取词典及词典索引文件的代码如下：</li></ul><p>origEnum = new SegmentTermEnum(directory.openInput(segment + “.” + IndexFileNames.TERMS_EXTENSION,readBufferSize), fieldInfos, false);//用于读取tis文件</p><ul><li>int firstInt = input.readInt();</li><li>size = input.readLong();</li><li>indexInterval = input.readInt();</li><li>skipInterval = input.readInt();</li><li>maxSkipLevels = input.readInt();</li></ul><p>SegmentTermEnum indexEnum = new SegmentTermEnum(directory.openInput(segment + “.” + IndexFileNames.TERMS_INDEX_EXTENSION, readBufferSize), fieldInfos, true);//用于读取tii文件</p><ul><li>indexTerms = new Term[indexSize];</li><li>indexInfos = new TermInfo[indexSize];</li><li>indexPointers = new long[indexSize];</li><li>for (int i = 0; indexEnum.next(); i++)<ul><li>indexTerms[i] = indexEnum.term();</li><li>indexInfos[i] = indexEnum.termInfo();</li><li>indexPointers[i] = indexEnum.indexPointer;</li></ul></li></ul><h4><span id="422-文档号及词频frq信息"><strong>4.2.2. 文档号及词频(frq)信息</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022137895.png" alt></p><p>文档号及词频文件里面保存的是倒排表，是以跳跃表形式存在的。</p><ul><li>此文件包含TermCount个项，每一个词都有一项，因为每一个词都有自己的倒排表。</li><li>对于每一个词的倒排表都包括两部分，一部分是倒排表本身，也即一个数组的文档号及词频，另一部分是跳跃表，为了更快的访问和定位倒排表中文档号及词频的位置。</li><li>对于文档号和词频的存储应用的是差值规则和或然跟随规则，Lucene的文档本身有以下几句话，比较难以理解，在此解释一下：</li></ul><p>For example, the TermFreqs for a term which occurs once in document seven and three times in document eleven, with omitTf false, would be the following sequence of VInts:</p><p>15, 8, 3</p><p>If omitTf were true it would be this sequence of VInts instead:</p><p>7,4</p><p>首先我们看omitTf=false的情况，也即我们在索引中会存储一个文档中term出现的次数。</p><p>例子中说了，表示在文档7中出现1次，并且又在文档11中出现3次的文档用以下序列表示：15，8，3.</p><p>那这三个数字是怎么计算出来的呢？</p><p>首先，根据定义TermFreq –&gt; DocDelta[, Freq?]，一个TermFreq结构是由一个DocDelta后面或许跟着Freq组成，也即上面我们说的A+B？结构。</p><p>DocDelta自然是想存储包含此Term的文档的ID号了，Freq是在此文档中出现的次数。</p><p>所以根据例子，应该存储的完整信息为[DocID = 7, Freq = 1] [DocID = 11,  Freq = 3](见全文检索的基本原理章节)。</p><p>然而为了节省空间，Lucene对编号此类的数据都是用差值来表示的，也即上面说的规则2，Delta规则，于是文档ID就不能按完整信息存了，就应该存放如下：</p><p>[DocIDDelta = 7, Freq = 1][DocIDDelta = 4 (11-7), Freq = 3]</p><p>然而Lucene对于A+B?这种或然跟随的结果，有其特殊的存储方式，见规则3，即A+B?规则，如果DocDelta后面跟随的Freq为1，则用DocDelta最后一位置1表示。</p><p>如果DocDelta后面跟随的Freq大于1，则DocDelta得最后一位置0，然后后面跟随真正的值，从而对于第一个Term，由于Freq为1，于是放在DocDelta的最后一位表示，DocIDDelta = 7的二进制是000 0111，必须要左移一位，且最后一位置一，000 1111 = 15，对于第二个Term，由于Freq大于一，于是放在DocDelta的最后一位置零，DocIDDelta = 4的二进制是0000 0100，必须要左移一位，且最后一位置零，0000 1000 = 8，然后后面跟随真正的Freq = 3。</p><p>于是得到序列：[DocDleta = 15][DocDelta = 8, Freq = 3]，也即序列，15，8，3。</p><p>如果omitTf=true，也即我们不在索引中存储一个文档中Term出现的次数，则只存DocID就可以了，因而不存在A+B?规则的应用。</p><p>[DocID = 7][DocID = 11]，然后应用规则2，Delta规则，于是得到序列[DocDelta = 7][DocDelta = 4 (11 - 7)]，也即序列，7，4.</p><ul><li>对于跳跃表的存储有以下几点需要解释一下：<ul><li>跳跃表可根据倒排表本身的长度(DocFreq)和跳跃的幅度(SkipInterval)而分不同的层次，层次数为NumSkipLevels = Min(MaxSkipLevels, floor(log(DocFreq/log(SkipInterval)))).</li><li>第Level层的节点数为DocFreq/(SkipInterval^(Level + 1))，level从零计数。</li><li>除了最低层之外，其他层都有SkipLevelLength来表示此层的二进制长度(而非节点的个数)，方便读取某一层的跳跃表到缓存里面。</li><li>高层在前，低层在后，当读完所有的高层后，剩下的就是最低一层，因而最后一层不需要SkipLevelLength。这也是为什么Lucene文档中的格式描述为 <sup zoompage-fontsize="12">NumSkipLevels-1</sup>, SkipLevel，也即低NumSKipLevels-1层有SkipLevelLength，最后一层只有SkipLevel，没有SkipLevelLength。</li><li>除最低层以外，其他层都有SkipChildLevelPointer来指向下一层相应的节点。</li><li>每一个跳跃节点包含以下信息：文档号，payload的长度，文档号对应的倒排表中的节点在frq中的偏移量，文档号对应的倒排表中的节点在prx中的偏移量。</li><li>虽然Lucene的文档中有以下的描述，然而实验的结果却不是完全准确的：</li></ul></li></ul><p>Example: SkipInterval = 4, MaxSkipLevels = 2, DocFreq = 35. Then skip level 0 has 8 SkipData entries, containing the 3<sup zoompage-fontsize="12">rd</sup>, 7<sup zoompage-fontsize="12">th</sup>, 11<sup zoompage-fontsize="12">th</sup>, 15<sup zoompage-fontsize="12">th</sup>, 19<sup zoompage-fontsize="12">th</sup>, 23<sup zoompage-fontsize="12">rd</sup>, 27<sup zoompage-fontsize="12">th</sup>, and 31<sup zoompage-fontsize="12">st</sup> document numbers in TermFreqs. Skip level 1 has 2 SkipData entries, containing the 15<sup zoompage-fontsize="12">th</sup> and 31<sup zoompage-fontsize="12">st</sup> document numbers in TermFreqs.</p><p>按照描述，当SkipInterval为4，且有35篇文档的时候，Skip level = 0应该包括第3，第7，第11，第15，第19，第23，第27，第31篇文档，Skip level = 1应该包括第15，第31篇文档。</p><p>然而真正的实现中，跳跃表节点的时候，却向前偏移了，偏移的原因在于下面的代码：</p><ul><li>FormatPostingsDocsWriter.addDoc(int docID, int termDocFreq)<ul><li>final int delta = docID - lastDocID;</li><li>if ((++df % skipInterval) == 0)<ul><li>skipListWriter.setSkipData(lastDocID, storePayloads, posWriter.lastPayloadLength);</li><li>skipListWriter.bufferSkip(df);</li></ul></li></ul></li></ul><p>从代码中，我们可以看出，当SkipInterval为4的时候，当docID = 0时，++df为1，1%4不为0，不是跳跃节点，当docID = 3时，++df=4，4%4为0，为跳跃节点，然而skipData里面保存的却是lastDocID为2。</p><p>所以真正的倒排表和跳跃表中保存一下的信息：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022137901.png" alt></p><h4><span id="423-词位置prx信息"><strong>4.2.3. 词位置(prx)信息</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022138998.png" alt></p><p>词位置信息也是倒排表，也是以跳跃表形式存在的。</p><ul><li>此文件包含TermCount个项，每一个词都有一项，因为每一个词都有自己的词位置倒排表。</li><li>对于每一个词的都有一个DocFreq大小的数组，每项代表一篇文档，记录此文档中此词出现的位置。这个文档数组也是和frq文件中的跳跃表有关系的，从上面我们知道，在frq的跳跃表节点中有ProxSkip，当SkipInterval为3的时候，frq的跳跃表节点指向prx文件中的此数组中的第1，第4，第7，第10，第13，第16篇文档。</li><li>对于每一篇文档，可能包含一个词多次，因而有一个Freq大小的数组，每一项代表此词在此文档中出现一次，则有一个位置信息。</li><li>每一个位置信息包含：PositionDelta(采用差值规则)，还可以保存payload，应用或然跟随规则。</li></ul><h3><span id="43-其他信息"><strong>4.3. 其他信息</strong></span></h3><h4><span id="431-标准化因子文件nrm"><strong>4.3.1. 标准化因子文件(nrm)</strong></span></h4><p>为什么会有标准化因子呢？从第一章中的描述，我们知道，在搜索过程中，搜索出的文档要按与查询语句的相关性排序，相关性大的打分(score)高，从而排在前面。相关性打分(score)使用向量空间模型(Vector Space Model)，在计算相关性之前，要计算Term Weight，也即某Term相对于某Document的重要性。在计算Term Weight时，主要有两个影响因素，一个是此Term在此文档中出现的次数，一个是此Term的普通程度。显然此Term在此文档中出现的次数越多，此Term在此文档中越重要。</p><p>这种Term Weight的计算方法是最普通的，然而存在以下几个问题：</p><ul><li>不同的文档重要性不同。有的文档重要些，有的文档相对不重要，比如对于做软件的，在索引书籍的时候，我想让计算机方面的书更容易搜到，而文学方面的书籍搜索时排名靠后。</li><li>不同的域重要性不同。有的域重要一些，如关键字，如标题，有的域不重要一些，如附件等。同样一个词(Term)，出现在关键字中应该比出现在附件中打分要高。</li><li>根据词(Term)在文档中出现的绝对次数来决定此词对文档的重要性，有不合理的地方。比如长的文档词在文档中出现的次数相对较多，这样短的文档比较吃亏。比如一个词在一本砖头书中出现了10次，在另外一篇不足100字的文章中出现了9次，就说明砖头书应该排在前面码？不应该，显然此词在不足100字的文章中能出现9次，可见其对此文章的重要性。</li></ul><p>由于以上原因，Lucene在计算Term Weight时，都会乘上一个标准化因子(Normalization Factor)，来减少上面三个问题的影响。</p><p>标准化因子(Normalization Factor)是会影响随后打分(score)的计算的，Lucene的打分计算一部分发生在索引过程中，一般是与查询语句无关的参数如标准化因子，大部分发生在搜索过程中，会在搜索过程的代码分析中详述。</p><p>标准化因子(Normalization Factor)在索引过程总的计算如下：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139227.png" alt></p><p>它包括三个参数：</p><ul><li>Document boost：此值越大，说明此文档越重要。</li><li>Field boost：此域越大，说明此域越重要。</li><li>lengthNorm(field) = (1.0 / Math.sqrt(numTerms))：一个域中包含的Term总数越多，也即文档越长，此值越小，文档越短，此值越大。</li></ul><p>从上面的公式，我们知道，一个词(Term)出现在不同的文档或不同的域中，标准化因子不同。比如有两个文档，每个文档有两个域，如果不考虑文档长度，就有四种排列组合，在重要文档的重要域中，在重要文档的非重要域中，在非重要文档的重要域中，在非重要文档的非重要域中，四种组合，每种有不同的标准化因子。</p><p>于是在Lucene中，标准化因子共保存了(文档数目乘以域数目)个，格式如下：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139297.png" alt></p><ul><li>标准化因子文件(Normalization Factor File: nrm)：<ul><li>NormsHeader：字符串“NRM”外加Version，依Lucene的版本的不同而不同。</li><li>接着是一个数组，大小为NumFields，每个Field一项，每一项为一个Norms。</li><li>Norms也是一个数组，大小为SegSize，即此段中文档的数量，每一项为一个Byte，表示一个浮点数，其中0<del>2为尾数，3</del>8为指数。</li></ul></li></ul><h4><span id="432-删除文档文件del"><strong>4.3.2. 删除文档文件(del)</strong></span></h4><p> <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139282.png" alt></p><ul><li>被删除文档文件(Deleted Document File: .del)<ul><li>Format：在此文件中，Bits和DGaps只能保存其中之一，-1表示保存DGaps，非负值表示保存Bits。</li><li>ByteCount：此段中有多少文档，就有多少个bit被保存，但是以byte形式计数，也即Bits的大小应该是byte的倍数。</li><li>BitCount：Bits中有多少位被至1，表示此文档已经被删除。</li><li>Bits：一个数组的byte，大小为ByteCount，应用时被认为是byte*8个bit。</li><li>DGaps：如果删除的文档数量很小，则Bits大部分位为0，很浪费空间。DGaps采用以下的方式来保存稀疏数组：比如第十，十二，三十二个文档被删除，于是第十，十二，三十二位设为1，DGaps也是以byte为单位的，仅保存不为0的byte，如第1个byte，第4个byte，第1个byte十进制为20，第4个byte十进制为1。于是保存成DGaps，第1个byte，位置1用不定长正整数保存，值为20用二进制保存，第2个byte，位置4用不定长正整数保存，用差值为3，值为1用二进制保存，二进制数据不用差值表示。</li></ul></li></ul><h2><span id="五-总体结构"><strong>五、总体结构</strong></span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139069.png" alt></p><ul><li>图示为Lucene索引文件的整体结构：<ul><li>属于整个索引(Index)的segment.gen，segment_N，其保存的是段(segment)的元数据信息，然后分多个segment保存数据信息，同一个segment有相同的前缀文件名。</li><li>对于每一个段，包含域信息，词信息，以及其他信息(标准化因子，删除文档)</li><li>域信息也包括域的元数据信息，在fnm中，域的数据信息，在fdx，fdt中。</li><li>词信息是反向信息，包括词典(tis, tii)，文档号及词频倒排表(frq)，词位置倒排表(prx)。</li></ul></li></ul><p>大家可以通过看源代码，相应的Reader和Writer来了解文件结构，将更为透彻。</p><p>参考资料</p><ul><li><a href="https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html">https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html</a></li><li><a href="https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html">https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      Lucene 的索引文件格式
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="lucene" scheme="https://lxb.wiki/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 二: Lucene 的总体架构</title>
    <link href="https://lxb.wiki/1c70c347/"/>
    <id>https://lxb.wiki/1c70c347/</id>
    <published>2023-09-02T05:59:04.000Z</published>
    <updated>2025-02-02T11:48:02.404Z</updated>
    
    <content type="html"><![CDATA[<p>Lucene总的来说是：</p><ul><li>一个高效的，可扩展的，全文检索库。</li><li>全部用Java实现，无须配置。</li><li>仅支持纯文本文件的索引(Indexing)和搜索(Search)。</li><li>不负责由其他格式的文件抽取纯文本文件，或从网络中抓取文件的过程。</li></ul><p>在Lucene in action中，Lucene 的架构和过程如下图，</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252200930.png" alt></p><p><strong>说明Lucene是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。</strong></p><p>让我们更细一些看Lucene的各组件：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252202412.png" alt></p><ul><li><strong>被索引的文档用Document对象表示。</strong></li><li><strong>IndexWriter通过函数addDocument将文档添加到索引中，实现创建索引的过程。</strong></li><li><strong>Lucene的索引是应用反向索引。</strong></li><li><strong>当用户有请求时，Query代表用户的查询语句。</strong></li><li><strong>IndexSearcher通过函数search搜索Lucene Index。</strong></li><li><strong>IndexSearcher计算term weight和score并且将结果返回给用户。</strong></li><li><strong>返回给用户的文档集合用TopDocsCollector表示。</strong></li></ul><p>那么如何应用这些组件呢？</p><p>让我们再详细到对Lucene API 的调用实现索引和搜索过程。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252203512.png" alt></p><ul><li>索引过程如下：<ul><li><strong>创建一个IndexWriter用来写索引文件，它有几个参数，INDEX_DIR就是索引文件所存放的位置，Analyzer便是用来对文档进行词法分析和语言处理的。</strong></li><li><strong>创建一个Document代表我们要索引的文档。</strong></li><li><strong>将不同的Field加入到文档中。我们知道，一篇文档有多种信息，如题目，作者，修改时间，内容等。不同类型的信息用不同的Field来表示，在本例子中，一共有两类信息进行了索引，一个是文件路径，一个是文件内容。其中FileReader的SRC_FILE就表示要索引的源文件。</strong></li><li><strong>IndexWriter调用函数addDocument将索引写到索引文件夹中。</strong></li></ul></li><li>搜索过程如下：<ul><li><strong>IndexReader将磁盘上的索引信息读入到内存，INDEX_DIR就是索引文件存放的位置。</strong></li><li><strong>创建IndexSearcher准备进行搜索。</strong></li><li><strong>创建Analyer用来对查询语句进行词法分析和语言处理。</strong></li><li><strong>创建QueryParser用来对查询语句进行语法分析。</strong></li><li><strong>QueryParser调用parser进行语法分析，形成查询语法树，放到Query中。</strong></li><li><strong>IndexSearcher调用search对查询语法树Query进行搜索，得到结果TopScoreDocCollector。</strong></li></ul></li></ul><p>以上便是Lucene API函数的简单调用。</p><p>然而当进入Lucene的源代码后，发现Lucene有很多包，关系错综复杂。</p><p>然而通过下图，我们不难发现，Lucene的各源码模块，都是对普通索引和搜索过程的一种实现。</p><p>此图是上一节介绍的全文检索的流程对应的Lucene实现的包结构。(参照<a href="http://www.lucene.com.cn/about.htm中文章《开放源代码的全文检索引擎Lucene》">http://www.lucene.com.cn/about.htm中文章《开放源代码的全文检索引擎Lucene》</a>)</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252206421.png" alt></p><ul><li><strong>Lucene的analysis模块主要负责词法分析及语言处理而形成Term。</strong></li><li><strong>Lucene的index模块主要负责索引的创建，里面有IndexWriter。</strong></li><li><strong>Lucene的store模块主要负责索引的读写。</strong></li><li><strong>Lucene的QueryParser主要负责语法分析。</strong></li><li><strong>Lucene的search模块主要负责对索引的搜索。</strong></li><li><strong>Lucene的similarity模块主要负责对相关性打分的实现。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      lucene 的总体架构
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="lucene" scheme="https://lxb.wiki/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 一: 全文检索的基本原理</title>
    <link href="https://lxb.wiki/5e159a30/"/>
    <id>https://lxb.wiki/5e159a30/</id>
    <published>2023-09-01T05:20:39.000Z</published>
    <updated>2025-02-02T11:48:02.439Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="一-总论">一、总论</span></h2><p>根据<a href="http://lucene.apache.org/java/docs/index.html">http://lucene.apache.org/java/docs/index.html</a>定义：</p><p><strong>Lucene 是一个高效的，基于Java 的全文检索库。</strong></p><p>所以在了解Lucene之前要费一番工夫了解一下全文检索。</p><p>那么什么叫做全文检索呢？这要从我们生活中的数据说起。</p><p>我们生活中的数据总体分为两种：<strong>结构化数据</strong>和<strong>非结构化数据</strong>。</p><ul><li><strong>结构化数据：</strong> 指具有固定格式或有限长度的数据，如数据库，元数据等。</li><li><strong>非结构化数据：</strong> 指不定长或无固定格式的数据，如邮件，word文档等。</li></ul><p>当然有的地方还会提到第三种，半结构化数据，如XML，HTML等，当根据需要可按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。</p><p><strong>非结构化数据又一种叫法叫全文数据。</strong></p><p>按照数据的分类，搜索也分为两种：</p><ul><li><strong>对结构化数据的搜索</strong>：如对数据库的搜索，用SQL语句。再如对元数据的搜索，如利用windows搜索对文件名，类型，修改时间进行搜索等。</li><li><strong>对非结构化数据的搜索</strong>：如利用windows的搜索也可以搜索文件内容，Linux下的grep命令，再如用Google和百度可以搜索大量内容数据。</li></ul><p>对非结构化数据也即对全文数据的搜索主要有两种方法：</p><p>一种是<strong>顺序扫描法(Serial Scanning)：</strong> 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。如果你有一个80G硬盘，如果想在上面找到一个内容包含某字符串的文件，不花他几个小时，怕是做不到。Linux下的grep命令也是这一种方式。大家可能觉得这种方法比较原始，但对于小数据量的文件，这种方法还是最直接，最方便的。但是对于大量的文件，这种方法就很慢了。</p><p>有人可能会说，对非结构化数据顺序扫描很慢，对结构化数据的搜索却相对较快（由于结构化数据有一定的结构可以采取一定的搜索算法加快速度），那么把我们的非结构化数据想办法弄得有一定结构不就行了吗？</p><p>这种想法很天然，却构成了全文检索的基本思路，也即将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</p><p>这部分从非结构化数据中提取出的然后重新组织的信息，我们称之<strong>索引</strong>。</p><p>这种说法比较抽象，举几个例子就很容易明白，比如字典，字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。</p><p><strong>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</strong></p><p>下面这幅图来自《Lucene in action》，但却不仅仅描述了Lucene的检索过程，而是描述了全文检索的一般过程。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252124676.png" alt></p><p>全文检索大体分两个过程，<strong>索引创建(Indexing)</strong>和<strong>搜索索引(Search)</strong>。</p><ul><li>索引创建：将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。</li><li>搜索索引：就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。</li></ul><p>于是全文检索就存在三个重要问题：</p><p><strong>1.</strong> <strong>索引里面究竟存些什么？(Index)</strong></p><p><strong>2.</strong> <strong>如何创建索引？(Indexing)</strong></p><p><strong>3.</strong> <strong>如何对索引进行搜索？(Search)</strong></p><p>下面我们顺序对每个个问题进行研究。</p><h2><span id="二-索引里面究竟存些什么">二、索引里面究竟存些什么</span></h2><p>索引里面究竟需要存些什么呢？</p><p>首先我们来看为什么顺序扫描的速度慢：</p><p>其实是由于我们想要搜索的信息和非结构化数据中所存储的信息不一致造成的。</p><p>非结构化数据中所存储的信息是每个文件包含哪些字符串，也即已知文件，欲求字符串相对容易，也即是从文件到字符串的映射。而我们想搜索的信息是哪些文件包含此字符串，也即已知字符串，欲求文件，也即从字符串到文件的映射。两者恰恰相反。于是如果索引总能够保存从字符串到文件的映射，则会大大提高搜索速度。</p><p>由于从字符串到文件的映射是文件到字符串映射的反向过程，于是保存这种信息的索引称为<strong>反向索引</strong>。</p><p>反向索引的所保存的信息一般如下：</p><p>假设我的文档集合里面有100篇文档，为了方便表示，我们为文档编号从1到100，得到下面的结构</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252127189.png" alt></p><p>左边保存的是一系列字符串，称为<strong>词典</strong>。</p><p>每个字符串都指向包含此字符串的文档(Document)链表，此文档链表称为<strong>倒排表</strong>(Posting List)。</p><p>有了索引，便使保存的信息和要搜索的信息一致，可以大大加快搜索的速度。</p><p>比如说，我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档，我们只需要以下几步：</p><p>1. 取出包含字符串“lucene”的文档链表。</p><p>2. 取出包含字符串“solr”的文档链表。</p><p>3. 通过合并链表，找出既包含“lucene”又包含“solr”的文件。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252128442.png" alt></p><p>看到这个地方，有人可能会说，全文检索的确加快了搜索的速度，但是多了索引的过程，两者加起来不一定比顺序扫描快多少。的确，加上索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个很大量的数据创建索引也是一个很慢的过程。</p><p>然而两者还是有区别的，顺序扫描是每次都要扫描，而创建索引的过程仅仅需要一次，以后便是一劳永逸的了，每次搜索，创建索引的过程不必经过，仅仅搜索创建好的索引就可以了。</p><p><strong>这也是全文搜索相对于顺序扫描的优势之一：一次索引，多次使用。</strong></p><h2><span id="三-如何创建索引">三、如何创建索引</span></h2><p>全文检索的索引创建过程一般有以下几步：</p><h3><span id="第一步一些要索引的原文档document"><strong>第一步：一些要索引的原文档(Document)。</strong></span></h3><p>为了方便说明索引创建过程，这里特意用两个文件为例：</p><p>文件一：Students should be allowed to go out with their friends, but not allowed to drink beer.</p><p>文件二：My friend Jerry went to school to see his students but found them drunk which is not allowed.</p><h3><span id="第二步将原文档传给分词组件tokenizer"><strong>第二步：将原文档传给分词组件(Tokenizer)。</strong></span></h3><p><strong>分词组件(Tokenizer)会做以下几件事情(此过程称为Tokenize)：</strong></p><p><strong>1.</strong> <strong>将文档分成一个一个单独的单词。</strong></p><p><strong>2.</strong> <strong>去除标点符号。</strong></p><p><strong>3.</strong> <strong>去除停词(Stop word)。</strong></p><p>所谓停词(Stop word)就是一种语言中最普通的一些单词，由于没有特别的意义，因而大多数情况下不能成为搜索的关键词，因而创建索引时，这种词会被去掉而减少索引的大小。</p><p>英语中挺词(Stop word)如：“the”,“a”，“this”等。</p><p>对于每一种语言的分词组件(Tokenizer)，都有一个停词(stop word)集合。</p><p><strong>经过分词(Tokenizer)后得到的结果称为词元(Token)。</strong></p><p>在我们的例子中，便得到以下词元(Token)：</p><p>“Students”，“allowed”，“go”，“their”，“friends”，“allowed”，“drink”，“beer”，“My”，“friend”，“Jerry”，“went”，“school”，“see”，“his”，“students”，“found”，“them”，“drunk”，“allowed”。</p><h3><span id="第三步将得到的词元token传给语言处理组件linguistic-processor"><strong>第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。</strong></span></h3><p>语言处理组件(linguistic processor)主要是对得到的词元(Token)做一些同语言相关的处理。</p><p><strong>对于英语，语言处理组件(Linguistic Processor)一般做以下几点：</strong></p><p><strong>1.</strong> <strong>变为小写(Lowercase)。</strong></p><p><strong>2.</strong> <strong>将单词缩减为词根形式，如“cars”到“car”等。这种操作称为：stemming。</strong></p><p><strong>3.</strong> <strong>将单词转变为词根形式，如“drove”到“drive”等。这种操作称为：lemmatization。</strong></p><p><strong>Stemming 和 lemmatization的异同：</strong></p><ul><li>相同之处：Stemming和lemmatization都要使词汇成为词根形式。</li><li>两者的方式不同：<ul><li>Stemming采用的是“缩减”的方式：“cars”到“car”，“driving”到“drive”。</li><li>Lemmatization采用的是“转变”的方式：“drove”到“drove”，“driving”到“drive”。</li></ul></li><li>两者的算法不同：<ul><li>Stemming主要是采取某种固定的算法来做这种缩减，如去除“s”，去除“ing”加“e”，将“ational”变为“ate”，将“tional”变为“tion”。</li><li>Lemmatization主要是采用保存某种字典的方式做这种转变。比如字典中有“driving”到“drive”，“drove”到“drive”，“am, is, are”到“be”的映射，做转变时，只要查字典就可以了。</li></ul></li><li>Stemming和lemmatization不是互斥关系，是有交集的，有的词利用这两种方式都能达到相同的转换。</li></ul><p><strong>语言处理组件(linguistic processor)的结果称为词(Term)。</strong></p><p>在我们的例子中，经过语言处理，得到的词(Term)如下：</p><p>“student”，“allow”，“go”，“their”，“friend”，“allow”，“drink”，“beer”，“my”，“friend”，“jerry”，“go”，“school”，“see”，“his”，“student”，“find”，“them”，“drink”，“allow”。</p><p>也正是因为有语言处理的步骤，才能使搜索drove，而drive也能被搜索出来。</p><h3><span id="第四步将得到的词term传给索引组件indexer"><strong>第四步：将得到的词(Term)传给索引组件(Indexer)。</strong></span></h3><p><strong>索引组件(Indexer)主要做以下几件事情：</strong></p><p><strong>1. 利用得到的词(Term)创建一个字典。</strong></p><p>在我们的例子中字典如下：</p><table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14">Term</td><td zoompage-fontsize="14">Document ID</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">their</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">beer</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">my</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">jerry</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">school</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">see</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">his</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">find</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">them</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">2</td></tr></tbody></table><p><strong>2.</strong> <strong>对字典按字母顺序进行排序。</strong></p><table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14">Term</td><td zoompage-fontsize="14">Document ID</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">beer</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">find</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">his</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">jerry</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">my</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">school</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">see</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">their</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">them</td><td zoompage-fontsize="14">2</td></tr></tbody></table><p><strong>3.</strong> <strong>合并相同的词(Term)成为文档倒排(Posting List)链表。</strong></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252135690.png" alt></p><p>在此表中，有几个定义：</p><ul><li>Document Frequency 即文档频次，表示总共有多少文件包含此词(Term)。</li><li>Frequency 即词频率，表示此文件中包含了几个此词(Term)。</li></ul><p>所以对词(Term) “allow”来讲，总共有两篇文档包含此词(Term)，从而词(Term)后面的文档链表总共有两项，第一项表示包含“allow”的第一篇文档，即1号文档，此文档中，“allow”出现了2次，第二项表示包含“allow”的第二个文档，是2号文档，此文档中，“allow”出现了1次。</p><p>到此为止，索引已经创建好了，我们可以通过它很快的找到我们想要的文档。</p><p>而且在此过程中，我们惊喜地发现，搜索“drive”，“driving”，“drove”，“driven”也能够被搜到。因为在我们的索引中，“driving”，“drove”，“driven”都会经过语言处理而变成“drive”，在搜索时，如果您输入“driving”，输入的查询语句同样经过我们这里的一到三步，从而变为查询“drive”，从而可以搜索到想要的文档。</p><h2><span id="三-如何对索引进行搜索">三、如何对索引进行搜索？</span></h2><p>到这里似乎我们可以宣布“我们找到想要的文档了”。</p><p>然而事情并没有结束，找到了仅仅是全文检索的一个方面。不是吗？如果仅仅只有一个或十个文档包含我们查询的字符串，我们的确找到了。然而如果结果有一千个，甚至成千上万个呢？那个又是您最想要的文件呢？</p><p>打开Google吧，比如说您想在微软找份工作，于是您输入“Microsoft job”，您却发现总共有22600000个结果返回。好大的数字呀，突然发现找不到是一个问题，找到的太多也是一个问题。在如此多的结果中，如何将最相关的放在最前面呢？</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252137104.png" alt></p><p>当然Google做的很不错，您一下就找到了jobs at Microsoft。想象一下，如果前几个全部是“Microsoft does a good job at software industry…”将是多么可怕的事情呀。</p><p>如何像Google一样，在成千上万的搜索结果中，找到和查询语句最相关的呢？</p><p>如何判断搜索出的文档和查询语句的相关性呢？</p><p>这要回到我们第三个问题：如何对索引进行搜索？</p><p>搜索主要分为以下几步：</p><h3><span id="第一步用户输入查询语句"><strong>第一步：用户输入查询语句。</strong></span></h3><p>查询语句同我们普通的语言一样，也是有一定语法的。</p><p>不同的查询语句有不同的语法，如SQL语句就有一定的语法。</p><p>查询语句的语法根据全文检索系统的实现而不同。最基本的有比如：AND, OR, NOT等。</p><p>举个例子，用户输入语句：lucene AND learned NOT hadoop。</p><p>说明用户想找一个包含lucene和learned然而不包括hadoop的文档。</p><h3><span id="第二步对查询语句进行词法分析语法分析及语言处理"><strong>第二步：对查询语句进行词法分析，语法分析，及语言处理。</strong></span></h3><p>由于查询语句有语法，因而也要进行语法分析，语法分析及语言处理。</p><p><strong>1. 词法分析主要用来识别单词和关键字。</strong></p><p>如上述例子中，经过词法分析，得到单词有lucene，learned，hadoop, 关键字有AND, NOT。</p><p>如果在词法分析中发现不合法的关键字，则会出现错误。如lucene AMD learned，其中由于AND拼错，导致AMD作为一个普通的单词参与查询。</p><p><strong>2. 语法分析主要是根据查询语句的语法规则来形成一棵语法树。</strong></p><p>如果发现查询语句不满足语法规则，则会报错。如lucene NOT AND learned，则会出错。</p><p>如上述例子，lucene AND learned NOT hadoop形成的语法树如下：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252139825.png" alt></p><p><strong>3. 语言处理同索引过程中的语言处理几乎相同。</strong></p><p>如learned变成learn等。</p><p>经过第二步，我们得到一棵经过语言处理的语法树。</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252139377.png" alt></p><h3><span id="第三步搜索索引得到符合语法树的文档"><strong>第三步：搜索索引，得到符合语法树的文档。</strong></span></h3><p>此步骤有分几小步：</p><ol><li>首先，在反向索引表中，分别找出包含lucene，learn，hadoop的文档链表。</li><li>其次，对包含lucene，learn的链表进行合并操作，得到既包含lucene又包含learn的文档链表。</li><li>然后，将此链表与hadoop的文档链表进行差操作，去除包含hadoop的文档，从而得到既包含lucene又包含learn而且不包含hadoop的文档链表。</li><li>此文档链表就是我们要找的文档。</li></ol><h3><span id="第四步根据得到的文档和查询语句的相关性对结果进行排序"><strong>第四步：根据得到的文档和查询语句的相关性，对结果进行排序。</strong></span></h3><p>虽然在上一步，我们得到了想要的文档，然而对于查询结果应该按照与查询语句的相关性进行排序，越相关者越靠前。</p><p>如何计算文档和查询语句的相关性呢？</p><p>不如我们把查询语句看作一片短小的文档，对文档与文档之间的相关性(relevance)进行打分(scoring)，分数高的相关性好，就应该排在前面。</p><p>那么又怎么对文档之间的关系进行打分呢？</p><p><strong>这可不是一件容易的事情，首先我们看一看判断人之间的关系吧。</strong></p><p><strong>首先</strong>看一个人，往往有很多<strong>要素</strong>，如性格，信仰，爱好，衣着，高矮，胖瘦等等。</p><p><strong>其次</strong>对于人与人之间的关系，<strong>不同的要素重要性不同</strong>，性格，信仰，爱好可能重要些，衣着，高矮，胖瘦可能就不那么重要了，所以具有相同或相似性格，信仰，爱好的人比较容易成为好的朋友，然而衣着，高矮，胖瘦不同的人，也可以成为好的朋友。</p><p>因而判断人与人之间的关系，<strong>首先要找出哪些要素对人与人之间的关系最重要</strong>，比如性格，信仰，爱好。<strong>其次要判断两个人的这些要素之间的关系</strong>，比如一个人性格开朗，另一个人性格外向，一个人信仰佛教，另一个信仰上帝，一个人爱好打篮球，另一个爱好踢足球。我们发现，两个人在性格方面都很积极，信仰方面都很善良，爱好方面都爱运动，因而两个人关系应该会很好。</p><p><strong>我们再来看看公司之间的关系吧。</strong></p><p><strong>首先</strong>看一个公司，有很多人组成，如总经理，经理，首席技术官，普通员工，保安，门卫等。</p><p><strong>其次对于公司与公司之间的关系，不同的人重要性不同</strong>，总经理，经理，首席技术官可能更重要一些，普通员工，保安，门卫可能较不重要一点。所以如果两个公司总经理，经理，首席技术官之间关系比较好，两个公司容易有比较好的关系。然而一位普通员工就算与另一家公司的一位普通员工有血海深仇，怕也难影响两个公司之间的关系。</p><p>因而判断公司与公司之间的关系，<strong>首先要找出哪些人对公司与公司之间的关系最重要</strong>，比如总经理，经理，首席技术官。<strong>其次要判断这些人之间的关系</strong>，不如两家公司的总经理曾经是同学，经理是老乡，首席技术官曾是创业伙伴。我们发现，两家公司无论总经理，经理，首席技术官，关系都很好，因而两家公司关系应该会很好。</p><p>分析了两种关系，下面看一下<strong>如何判断文档之间的关系</strong>了。</p><p><strong>首先，一个文档有很多词(Term)组成</strong>，如search, lucene, full-text, this, a, what等。</p><p><strong>其次对于文档之间的关系，不同的Term重要性不同</strong>，比如对于本篇文档，search, Lucene, full-text就相对重要一些，this, a , what可能相对不重要一些。所以如果两篇文档都包含search, Lucene，fulltext，这两篇文档的相关性好一些，然而就算一篇文档包含this, a, what，另一篇文档不包含this, a, what，也不能影响两篇文档的相关性。</p><p>因而判断文档之间的关系，首先找出哪些词(Term)对文档之间的关系最重要，如search, Lucene, fulltext。然后判断这些词(Term)之间的关系。</p><p><strong>找出词(Term)对文档的重要性的过程称为计算词的权重(Term weight)的过程。</strong></p><p>计算词的权重(term weight)有两个参数，第一个是词(Term)，第二个是文档(Document)。</p><p>词的权重(Term weight)表示此词(Term)在此文档中的重要程度，越重要的词(Term)有越大的权重(Term weight)，因而在计算文档之间的相关性中将发挥更大的作用。</p><p><strong>判断词(Term)之间的关系从而得到文档相关性的过程应用一种叫做向量空间模型的算法(Vector Space Model)。</strong></p><p>下面仔细分析一下这两个过程：</p><h4><span id="1-计算权重term-weight的过程"><strong>1. 计算权重(Term weight)的过程。</strong></span></h4><p>影响一个词(Term)在一篇文档中的重要性主要有两个因素：</p><ul><li>Term Frequency (tf)：即此Term在此文档中出现了多少次。tf 越大说明越重要。</li><li>Document Frequency (df)：即有多少文档包含次Term。df 越大说明越不重要。</li></ul><p>容易理解吗？词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“搜索”这个词，在本文档中出现的次数很多，说明本文档主要就是讲这方面的事的。然而在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，这是由第二个因素进行调整，第二个因素说明，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。</p><p>这也如我们程序员所学的技术，对于程序员本身来说，这项技术掌握越深越好（掌握越深说明花时间看的越多，tf越大），找工作时越有竞争力。然而对于所有程序员来说，这项技术懂得的人越少越好（懂得的人少df小），找工作越有竞争力。人的价值在于不可替代性就是这个道理。</p><p>道理明白了，我们来看看公式：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252144198.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252145148.png" alt></p><p>这仅仅只term weight计算公式的简单典型实现。实现全文检索系统的人会有自己的实现，Lucene就与此稍有不同。</p><h4><span id="2-判断term之间的关系从而得到文档相关性的过程也即向量空间模型的算法vsm"><strong>2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。</strong></span></h4><p>我们把文档看作一系列词(Term)，每一个词(Term)都有一个权重(Term weight)，不同的词(Term)根据自己在文档中的权重来影响文档相关性的打分计算。</p><p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量。</p><p>Document = {term1, term2, …… ,term N}</p><p>Document Vector = {weight1, weight2, …… ,weight N}</p><p>同样我们把查询语句看作一个简单的文档，也用向量来表示。</p><p>Query = {term1, term 2, …… , term N}</p><p>Query Vector = {weight1, weight2, …… , weight N}</p><p>我们把所有搜索出的文档向量及查询向量放到一个N维空间中，每个词(term)是一维。</p><p>如图：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252148225.png" alt></p><p>我们认为两个向量之间的夹角越小，相关性越大。</p><p>所以我们计算夹角的余弦值作为相关性的打分，夹角越小，余弦值越大，打分越高，相关性越大。</p><p>有人可能会问，查询语句一般是很短的，包含的词(Term)是很少的，因而查询向量的维数很小，而文档很长，包含词(Term)很多，文档向量维数很大。你的图中两者维数怎么都是N呢？</p><p>在这里，既然要放到相同的向量空间，自然维数是相同的，不同时，取二者的并集，如果不含某个词(Term)时，则权重(Term Weight)为0。</p><p>相关性打分公式如下：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252151747.png" alt></p><p>举个例子，查询语句有11个Term，共有三篇文档搜索出来。其中各自的权重(Term weight)，如下表格。</p><table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><br></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t1</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t2</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t3</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t4</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t5</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t6</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t7</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t8</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t9</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t10</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t11</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">D1</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">D2</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.954</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">D3</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">Q</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td></tr></tbody></table><p>于是计算，三篇文档同查询语句的相关性打分分别为：</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252152826.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252152014.png" alt></p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252153180.png" alt></p><p>于是文档二相关性最高，先返回，其次是文档一，最后是文档三。</p><p>到此为止，我们可以找到我们最想要的文档了。</p><p>说了这么多，其实还没有进入到Lucene，而仅仅是信息检索技术(Information retrieval)中的基本理论，然而当我们看过Lucene后我们会发现，Lucene是对这种基本理论的一种基本的的实践。所以在以后分析Lucene的文章中，会常常看到以上理论在Lucene中的应用。</p><p>在进入Lucene之前，对上述索引创建和搜索过程所一个总结，如图：</p><p>此图参照<a href="http://www.lucene.com.cn/about.htm">http://www.lucene.com.cn/about.htm</a>中文章《开放源代码的全文检索引擎Lucene》</p><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252155722.png" alt></p><p><strong>1. 索引过程：</strong></p><p><strong>1)</strong> <strong>有一系列被索引文件</strong></p><p><strong>2)</strong> <strong>被索引文件经过语法分析和语言处理形成一系列词(Term)。</strong></p><p><strong>3)</strong> <strong>经过索引创建形成词典和反向索引表。</strong></p><p><strong>4)</strong> <strong>通过索引存储将索引写入硬盘。</strong></p><p><strong>2. 搜索过程：</strong></p><p><strong>a)</strong> <strong>用户输入查询语句。</strong></p><p><strong>b)</strong> <strong>对查询语句经过语法分析和语言分析得到一系列词(Term)。</strong></p><p><strong>c)</strong> <strong>通过语法分析得到一个查询树。</strong></p><p><strong>d)</strong> <strong>通过索引存储将索引读入到内存。</strong></p><p><strong>e)</strong> <strong>利用查询树搜索索引，从而得到每个词(Term)的文档链表，对文档链表进行交，差，并得到结果文档。</strong></p><p><strong>f)</strong> <strong>将搜索到的结果文档对查询的相关性进行排序。</strong></p><p><strong>g)</strong> <strong>返回查询结果给用户。</strong></p>]]></content>
    
    <summary type="html">
    
      全文检索的基本原理
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="lucene" scheme="https://lxb.wiki/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>Mac常用设置命令</title>
    <link href="https://lxb.wiki/ef867fbd/"/>
    <id>https://lxb.wiki/ef867fbd/</id>
    <published>2023-08-20T06:47:19.000Z</published>
    <updated>2025-02-02T11:48:02.405Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="取消-4-位数密码限制">取消 4 位数密码限制</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwpolicy -clearaccountpolicies</span><br></pre></td></tr></table></figure><h2><span id="允许安装任意来源的-app">允许安装任意来源的 App</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> spctl --master-disable</span><br></pre></td></tr></table></figure><h2><span id="xcode-命令行工具">xcode 命令行工具</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><h2><span id="程序坞">程序坞</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置启动坞动画时间设置为 0.5 秒 </span></span><br><span class="line">defaults write com.apple.dock autohide-time-modifier -<span class="built_in">float</span> 0.5 &amp;&amp; killall Dock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动坞响应时间最短</span></span><br><span class="line">defaults write com.apple.dock autohide-delay -int 0 &amp;&amp; killall Dock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复启动坞默认动画时间</span></span><br><span class="line">defaults delete com.apple.dock autohide-time-modifier &amp;&amp; killall Dock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认启动坞响应时间</span></span><br><span class="line">defaults delete com.apple.Dock autohide-delay &amp;&amp; killall Dock</span><br></pre></td></tr></table></figure><h2><span id="启动台自定义行和列">启动台自定义行和列</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置列数</span></span><br><span class="line">defaults write com.apple.dock springboard-columns -int 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置行数</span></span><br><span class="line">defaults write com.apple.dock springboard-rows -int 6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Dock 生效</span></span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure><h2><span id="恢复默认的列数和行数">恢复默认的列数和行数</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows Default</span><br><span class="line">defaults write com.apple.dock springboard-columns Default</span><br></pre></td></tr></table></figure><h2><span id="重启-dock-生效">重启 Dock 生效</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Mac常用设置命令
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="mac" scheme="https://lxb.wiki/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>【译】Linux 中退出码的含义</title>
    <link href="https://lxb.wiki/e28c7f9c/"/>
    <id>https://lxb.wiki/e28c7f9c/</id>
    <published>2023-08-03T06:12:42.000Z</published>
    <updated>2025-02-02T11:48:02.447Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-中退出码的含义">Linux 中退出码的含义</span></h1><p><img src="https://img.linux.net.cn/data/attachment/album/202308/03/154628oloxp7sl6s1z4pbl.jpg" alt></p><blockquote><p>揭开 Linux 中退出码的神秘面纱。了解什么是退出码，以及为什么和如何使用它们。</p></blockquote><p>退出码（退出状态）可以告诉我们最后一次执行的命令的状态。在命令结束以后，我们可以知道命令是成功完成的还是以错误结束的。</p><p><strong>其基本思想是，程序返回退出代码 <code>0</code> 时表示执行成功，没有问题。代码 <code>1</code> 或 <code>0</code> 以外的任何代码都被视为不成功。</strong></p><p>退出码除了 0 和 1 外还有很多值，我将在本文介绍它们。</p><h3><span id="linux-shell-中的各种退出码">Linux Shell 中的各种退出码</span></h3><p>我们来快速了解一下 Linux Shell 中的主要退出码：</p><table><thead><tr><th align="left">退出码</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>0</code></td><td align="left">命令成功执行</td></tr><tr><td align="left"><code>1</code></td><td align="left">通用错误代码</td></tr><tr><td align="left"><code>2</code></td><td align="left">命令（或参数）使用不当</td></tr><tr><td align="left"><code>126</code></td><td align="left">权限被拒绝（或）无法执行</td></tr><tr><td align="left"><code>127</code></td><td align="left">未找到命令，或 <code>PATH</code> 错误</td></tr><tr><td align="left"><code>128+n</code></td><td align="left">命令被信号从外部终止，或遇到致命错误</td></tr><tr><td align="left"><code>130</code></td><td align="left">通过 <code>Ctrl+C</code> 或 <code>SIGINT</code> 终止（_终止代码 2 或键盘中断_）</td></tr><tr><td align="left"><code>143</code></td><td align="left">通过 <code>SIGTERM</code> 终止（_默认终止_）</td></tr><tr><td align="left"><code>255/*</code></td><td align="left">退出码超过了 0-255 的范围，因此重新计算（LCTT 译注：超过 255 后，用退出码对 256 取模）</td></tr></tbody></table><blockquote><p>📋 <code>130</code>（<code>SIGINT</code> 或 <code>^C</code>）和 <code>143</code>（<code>SIGTERM</code>）等终止信号是非常典型的，它们属于 <code>128+n</code> 信号，其中 <code>n</code> 代表终止码。</p></blockquote><p>在简单了解了退出码之后，我们来看看它们的用法。</p><h3><span id="获取退出码">获取退出码</span></h3><p>前一个命令执行的退出码存储在 <a href="https://linuxhandbook.com:443/bash-special-variables/">特殊变量</a> <code>$?</code> 中。你可以通过运行以下命令来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>我们在所有演示中都将使用它来获取退出代码。</p><p>请注意，<code>exit</code> 命令支持以带着前一条命令相同的退出码退出。</p><h3><span id="退出码-0">退出码 0</span></h3><p>退出码 <code>0</code> 表示命令执行无误，这是完成命令的理想状态。</p><p>例如，我们运行这样一条基本命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neofetch </span><br><span class="line"></span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_0.png" alt></p><p>这个退出码 <code>0</code> 表示特定命令已成功执行，仅此而已。让我们再演示几个例子。</p><p>你可以尝试 <a href="https://itsfoss.com/how-to-find-the-process-id-of-a-program-and-kill-it-quick-tip/">终止一个进程</a>；它也会返回代码 <code>0</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill lxappearance</span><br></pre></td></tr></table></figure><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_0.gif" alt></p><p>查看文件内容也会返回退出码 0，这<strong>仅</strong>意味着 <code>cat</code> 命令执行成功。</p><h3><span id="退出码-1">退出码 1</span></h3><p>退出码 <code>1</code> 也很常见。它通常表示命令以一般错误结束。</p><p>例如，在没有 sudo 权限的情况下使用 <a href="https://itsfoss.com/package-manager/">软件包管理器</a>，就会返回代码 <code>1</code>。在 Arch Linux 中，如果我运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy</span><br></pre></td></tr></table></figure><p>它会返回 <code>1</code>， 表示上一条命令运行出错。</p><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_1.png" alt="exit code 1 (impermissible operation resulted in this code)"></p><blockquote><p>📋 如果你在基于 Ubuntu 的发行版中尝试这样做（不使用 <code>sudo</code> 执行 <code>apt update</code>），运行后会得到错误码 <code>100</code>，表示你是在没有权限的情况下运行 <code>apt</code>。<code>100</code> 不是标准错误码，而是 <code>apt</code> 特有的错误码。</p></blockquote><p>虽然这是一般的理解，但我们也可以将其解释为 “不被允许的操作”。</p><p>除以 <code>0</code> 等操作也会返回错误码 <code>1</code>。</p><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_1-division_by_0-.png" alt="Division by zero results in code 1"></p><h3><span id="退出码-2">退出码 2</span></h3><p>这个退出码出现在当执行的命令有语法错误时。滥用命令参数也会导致此错误。</p><p>一般来说，它表示由于使用不当，命令无法执行。</p><p>例如，我在一个本应只有一个连字符的选项上添加了两个连字符，那么此时会出现退出码 2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --z file.txt</span><br></pre></td></tr></table></figure><p><img src="https://itsfoss.com/content/images/2023/06/exit_status_2-misusing_arguments--1.png" alt="Invalid argument resulted in exit code 2"></p><p>当权限被拒绝时，比如访问 <code>/root</code> 文件夹，就会出现错误码 <code>2</code>。</p><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_2-permission_denied-.png" alt="Permission denied gives out code 2"></p><h3><span id="退出码-126">退出码 126</span></h3><p>126 是一个特殊的退出码，它用于表示命令或脚本因权限错误而未被执行。</p><p>当你尝试执行没有执行权限的 Shell 脚本时，就会出现这个错误。</p><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_126.png" alt></p><p>请注意，该退出码只出现在没有足够权限的脚本或命令的“_执行_”中，这与一般的<strong>权限被拒绝</strong>错误不同。</p><p>因此，不要把它与你之前看到的退出码为 <code>2</code> 的示例混淆。在那个示例中，运行的是 <code>ls</code> 命令，权限问题出自它试图执行的目录。而本例中权限问题来自脚本本身。</p><h3><span id="退出码-127">退出码 127</span></h3><p>这是另一个常见的退出码。退出码 <code>127</code> 指的是“<a href="https://itsfoss.com/bash-command-not-found/">未找到命令</a>”。它通常发生在执行的命令有错别字或所需的可执行文件不在 <code>$PATH</code> 变量中时。</p><p>例如，当我尝试执行一个不带路径的脚本时，经常会看到这个错误。</p><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_127.png" alt="Script executed without the path gives &quot;command not found&quot; or code 127"></p><p>当你想运行的可执行文件不在 <code>$PATH</code> 变量中时，也会出现退出码 <code>127</code>。你可以通过 <a href="https://itsfoss.com/add-directory-to-path-linux/">在 PATH 变量中添加命令的目录</a> 来纠正这种情况。</p><p>当你输入不存在的命令时，也会得到这样的退出码。</p><p><img src="https://itsfoss.com/content/images/2023/06/exit_code_127-command_not_found--1.png" alt="Unmount is not a command, and Screenfetch is not installed, which resulted in code 127"></p><h3><span id="退出码-128n-系列">退出码 128+n 系列</span></h3><p>当应用程序或命令因致命错误而终止或执行失败时，将产生 128 系列退出码（<code>128+n</code>），其中 <code>n</code> 为信号编号。</p><p><code>n</code> 包括所有类型的终止代码，如 <code>SIGTERM</code>、<code>SIGKILL</code> 等。</p><h4><span id="退出码-130-或-sigint">退出码 130 或 SIGINT</span></h4><p>在通过终止信号 <code>2</code> 或按下 <code>Ctrl+C</code> 中断进程时，会发出 <code>SIGINT</code>（键盘中断信号）。</p><p>因为终止信号是 <code>2</code>，所以我们得到的退出码是 <code>130</code>（128+2）。下面的视频演示了 <code>lxappearance</code> 的中断信号。</p><p><img src="https:/itsfoss.com/content/media/2023/06/exit_code_128-n-SIGINT-_compressed.mp4" alt></p><h4><span id="退出码-137-或-sigkill">退出码 137 或 SIGKILL</span></h4><p><code>SIGKILL</code>（立即终止信号）表示终止信号 <code>9</code>。这是终止应用程序时最不应该使用的方法。</p><p>因为终止信号为 <code>9</code>，因此我们得到的退出代码为 <code>137</code>（128+9）。</p><p><img src="https://itsfoss.com/content/media/2023/06/exit_code_128-n-SIGKILL-_compressed.mp4" alt></p><h4><span id="退出码-143-或-sigterm">退出码 143 或 SIGTERM</span></h4><p><code>SIGTERM</code> 是进程在未指定参数的情况下被杀死时的默认行为。</p><p><code>SIGTERM</code> 的终止信号为 <code>15</code>，因此该信号的退出码为 <code>143</code>（128+15）。</p><p><img src="https://itsfoss.com/content/media/2023/06/exit_code_128-n-SIGTERM-_compressed-1.mp4" alt></p><p>还有一些你以前可能不知道的终止信号，它们也有自己类似的退出码。你可以在这里查看它们：</p><blockquote><p>📋 请注意，如果进程在启动它的同一会话中终止，这些信号可能不会出现。如果要重现这些信号，请从不同的 shell 终止。</p><p>就个人而言，信号 <code>128</code> 是无法重现的。</p></blockquote><h3><span id="当退出码超过了-255-会怎样">当退出码超过了 255 会怎样?</span></h3><p>最新版本的 Bash 甚至保留了超过 255 的原始退出码的值，但一般来说，如果代码超过 255，就会被重新计算。</p><p>也就是说，代码 <code>256</code> 会变成 <code>0</code>，<code>257</code> 会变成 <code>1</code>，<code>383</code> 会变成 <code>127</code>，以此类推。为确保更好的兼容性，请将退出码保持在 <code>0</code> 至 <code>255</code> 之间。</p><h3><span id="结语">结语</span></h3><p>希望你对 Linux Shell 中的退出码有所了解。在排查各种问题时，使用它们会非常方便。</p><p>如果你要在 Shell 脚本中使用这些代码，请确保你了解每个代码的含义，以便更容易地排除故障。</p><p>这就是本文的全部内容。如有遗漏，请在评论区告诉我。</p><p><em>（题图：MJ/719ff711-1b9f-4aa9-a82e-980704acbdd8）</em></p><hr><p>via: <a href="https://itsfoss.com/linux-exit-codes/">https://itsfoss.com/linux-exit-codes/</a></p><p>作者：<a href="https://itsfoss.com/author/pranav/">Pranav Krishna</a><br>选题：<a href="https://github.com/lkxed/">lkxed</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      Linux 中退出码的含义
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="翻译" scheme="https://lxb.wiki/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="linux" scheme="https://lxb.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【译】Lucene 查询语法</title>
    <link href="https://lxb.wiki/f8737bfa/"/>
    <id>https://lxb.wiki/f8737bfa/</id>
    <published>2023-06-28T07:02:47.000Z</published>
    <updated>2025-02-02T11:48:02.446Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description">Query Parser Syntax</a></p><h2><span id="概览">概览</span></h2><p>Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（词法分析器，使用 JavaCC 将字符串翻译成 Lucene 查询语句）提供一种功能丰富的查询语言。</p><p>一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。本文档描述的是当前版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 <code>docs/queryparsersyntax.html</code> 文档。</p><p>在选择使用这个查询解析器之前，请考虑以下 3 点：</p><ol><li>如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。</li><li>没有被识别为token的域最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句。查询解析器所使用的分析器是专门用于将人类输入的文本转换成词（terms）的。由程序生成的值，如日期、关键字等等，也应该由程序添加到查询中。</li><li>从查询形式来看，如果域的值是普通文本，则应该使用查询解析器。所有其它值类型，比如：日期范围、关键字等等，最好通过查询 API 直接添加。如果一个域的值仅限于一个有限的集合（可以通过一个下拉菜单指定），则不应该添加到查询字符串（后续会被解析）中，而是应该作为一个 TermQuery 子句添加到查询中。</li></ol><h2><span id="词terms">词（Terms）</span></h2><p>一个查询语句可以拆解成 词（terms） 和 操作符（operators）。词又分为两种：单个词（single Terms）和短语（Phrases）。</p><p>单个词是指 ”test“ 或 ”Hello“ 这类单词。</p><p>短语是指以双引号包围起来的一组单词，比如：”hello dolly“。</p><p>多个词（Multiple terms）可以使用布尔操作符组合在一起，实现一个更加复杂的查询（如下文所示）。</p><p>备注：用于创建索引的解析器也会用于解析查询字符串中的词和短语。因此，选择合适的解析器很重要，否则解析器可能会被查询字符串中的词干扰。</p><h2><span id="域fields">域（Fields）</span></h2><p>Lucene 支持分多个字段/域的数据。搜索时，可以指定一个域，也可以使用默认域。域的名称以及默认域与具体实现相关。</p><p>输入域的名称，后跟一个冒号（:），再跟目标搜索词，即可对任意一个域进行搜索。</p><p>举例来说，假设一个 Lucene 索引包含 2 个域：title 和 text，text 是默认域。若想查找标题为 ”The Right Way“ 且文本内容包含 ”don’t go this way“ 的文档，可以输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title:&quot;The Right Way&quot; AND text:go</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:&quot;The Right Way&quot; AND go</span><br></pre></td></tr></table></figure><p>因为 text 是默认域，所以域标识符可以省略。</p><p>注意：指定的域仅对紧跟其后的词生效，因此，如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:The Right Way</span><br></pre></td></tr></table></figure><p>将对 title 域仅查找 ”The“，并对默认域（当前这个例子中是指 text 域）查找 ”Right“ 和 ”Way“。</p><h2><span id="词修饰语term-modifiers">词修饰语（Term Modifiers）</span></h2><p>Lucene 支持修饰查询词（modifying query terms）来提供多种搜索方式。</p><h3><span id="通配符搜索"><em>通配符搜索</em></span></h3><p>Lucene 支持对单个词(single terms)（不是短语查询 phrase queries）进行单个字符和多个字符的通配搜索。</p><p>使用 <code>?</code> 符号进行单个字符的通配搜索。</p><p>使用 <code>*</code> 符号进行多个字符的通配搜索。</p><p>单字符通配搜索用于查找替换单个字符即可匹配的词。举例来说，若要搜索 ”text“ 或 ”test“，可以如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">te?t</span><br></pre></td></tr></table></figure><p>多字符通配搜索用于查找替换0个或多个字符即可匹配的词。举例来说，若要搜索 ”test“、”tests“ 或 ”tester“，可以如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test*</span><br></pre></td></tr></table></figure><p>也可以对词的中间部分进行通配搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">te*t</span><br></pre></td></tr></table></figure><p><strong>备注： <code>*</code> 或 <code>?</code> 符号不能用作搜索语句的第一个字符。</strong></p><h3><span id="正则表达式搜索"><em>正则表达式搜索</em></span></h3><p>Lucene 支持正则表达式搜索，匹配斜杠（<code>/</code>） 之间的模式。正则表达式的语法在不同的发布版本之间可能会有差异，目前支持的语法在 <a href="http://lucene.apache.org/core/8_2_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true">RegExp</a> 类文档中有说明。举例来说，查找包含 ”moat“ 或 ”boat“ 的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[mb]oat/</span><br></pre></td></tr></table></figure><h3><span id="模糊搜索"><em>模糊搜索</em></span></h3><p>Lucene 支持基于 Damerau-Levenshtein 编辑距离的模糊搜索。在单个词的最后添加波浪符（~）即可进行模糊搜索。举例来说，使用模糊搜索查找在拼写上与 ”roam“ 近似的词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roam~</span><br></pre></td></tr></table></figure><p>这个查询语句会找到 foam 和 roams 这类词。</p><p>模糊搜索可以通过一个额外（可选）的参数来指定允许的最大编辑次数。这个参数值界于 0 和 2 之间，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roam~1</span><br></pre></td></tr></table></figure><p>如果未指定该参数，则默认使用 2 个编辑距离。</p><p><strong>以前，这里还允许使用浮点数。现在这个语法已被考虑弃用，将于 Lucene 5.0 中移除。</strong></p><h3><span id="邻近搜索"><em>邻近搜索</em></span></h3><p>Lucene 支持查找指定距离的邻近词。在短语的最后添加拨浪符（~）即可进行邻近搜索。举例来说，在文档中搜索 ”apache“ 和 ”jakarta“ 相距 10 个词的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot;~10</span><br></pre></td></tr></table></figure><h3><span id="范围搜索"><em>范围搜索</em></span></h3><p>范围查询可以匹配到域的值在范围查询语句指定的上下界之间的所有文档。对于上下界的值，范围查询可以包含也可以不包含。排序是按照字典序进行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_date:[20020101 TO 20030101]</span><br></pre></td></tr></table></figure><p>这个查询语句会查找 mod_date 域的值在 20020101 和 20030101 （包含上下界） 之间的文档。注意：范围查询对非日期的域也可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:&#123;Aida TO Carmen&#125;</span><br></pre></td></tr></table></figure><p>这个查询语句能查找到 title 域的值在 Aida 和 Carmen （不包含上下界）之间的所有文档。</p><p>中括号表示范围查询包含上下界，花括号表示范围查询不包含上下界。</p><h3><span id="相关性查询boosting-a-term"><em>相关性查询（Boosting a term）</em></span></h3><p>Lucene 会基于文档中找到的词对匹配到的文档设置相关性的级别。可以在目标搜索词之后紧接一个脱字符 “^”，后跟一个加权系数（一个数字）来提升该搜索词的相关性权重。加权系数越高，查询命中的文档与该词的相关性越强。</p><p>你可以通过对某词进行加权来控制文档的相关性。例如，假设你正在搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jakarta apache</span><br></pre></td></tr></table></figure><p>然后希望搜索结果和词 ”jakarta“ 的相关性更强一些，则可以使用 ”^“ 符号后跟一个加权系数对这个词进行加权，即如下这样查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jakarta^4 apache</span><br></pre></td></tr></table></figure><p>这会使得查找到的文档和词 ”jakarta“ 看起来相关性更强一些。你也可以对短语进行加权，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot;^4 &quot;Apache Lucene&quot;</span><br></pre></td></tr></table></figure><p>默认加权系数是 1。加权系统可以小于 1（比如：0.2），但必须大于 0。</p><h2><span id="布尔操作符">布尔操作符</span></h2><p>布尔操作符允许使用逻辑操作符组合多个词。Lucene 支持的布尔操作符包含 <code>AND</code>、<code>+</code>、<code>OR</code>、<code>NOT</code> 及 <code>-</code></p><p><strong>（备注：布尔操作符必须全部是大写字母）。</strong></p><h3><span id="or"><em>OR</em></span></h3><p>“OR” 操作符是默认的连接操作符。这意味着如果两个词之间没有布尔操作符，则lucene会使用 “OR” 操作符。OR 操作符链接两个词，并匹配包含其中任意一个词的文档。这相当于集合的并集操作。“||” 符合可用于替代单词 “OR”。</p><p>比如，使用如下查询语句来搜索包含 “jakarta apache” 或仅是 “jakarta” 的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot; jakarta</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot; OR jakarta</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="and">AND</span></h3><p>“AND” 操作符会匹配文本内容中同时存在两个要查询的词（因为 AND 是二元操作符）的文档。这相当于集合的交集操作。“&amp;&amp;” 符号可用于替代单词 “AND”。</p><p>比如，使用如下查询语句来搜索包含 “jakarta apache” 和 “Apache Lucene” 的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot; AND “Apache Lucene”</span><br></pre></td></tr></table></figure><h3><span id>+</span></h3><p>“+”（必需）操作符要求文档的某个域中包含 “+” 符号之后的词。</p><p>比如，使用如下查询语句来搜索（必须）包含 “jakarta” 以及可能包含 “lucene”（包不包含都可以）的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+jakarta lucene</span><br></pre></td></tr></table></figure><h3><span id="not">NOT</span></h3><p>”NOT“ 操作符会排除包含”NOT“之后的词的文档。这相当于集合的差集操作。也可以用”!“ 符号代替 ”NOT“。</p><p>比如，使用如下查询语句搜索包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot; NOT &quot;Apache Lucene&quot;</span><br></pre></td></tr></table></figure><p><strong>备注：“NOT” 操作符不可以用于单个词。例如，如下搜索不会返回任何结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT &quot;jakarta apache&quot;</span><br></pre></td></tr></table></figure><h3><span id="-">-</span></h3><p>”-“（禁止）操作符会排除包含”-“符号之后的词的文档。</p><p>比如，使用如下查询语句来查询包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;jakarta apache&quot; -&quot;Apache Lucene&quot;</span><br></pre></td></tr></table></figure><h2><span id="分组">分组</span></h2><p>Lucene 支持使用圆括号对子句进行分组，构成子查询。这对于控制一个查询语句的布尔逻辑非常有用。</p><p>比如，使用如下查询语句来搜索包含 “jakarta” 或 “apache”，同时包含 “website” 的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(jakarta OR apache) AND website</span><br></pre></td></tr></table></figure><p>这样查询语句就没有了歧义：必须包含 ”website“，同时包含“jakarta” 或 ”apache“其中之一。</p><h2><span id="域分组">域分组</span></h2><p>Lucene 支持使用圆括号对单个域的多个子句进行分组。</p><p>例如，若想搜索一个 title 中包含单词“return”同时包含短语“pink panther”，可以使用如下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:(+return +&quot;pink panther&quot;)</span><br></pre></td></tr></table></figure><h2><span id="特殊字符转义">特殊字符转义</span></h2><p>Lucene 支持对查询语法使用的特殊字符进行转义。目前这些特殊字符如下列表所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - &amp;&amp; || ! ( ) &#123; &#125; [ ] ^ &quot; ~ * ? : \ /</span><br></pre></td></tr></table></figure><p>在特殊字符之前加 <code>\</code> 来转义。例如，使用如下查询语句来搜索 <code>(1+1):2</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\(1\+1\)\:2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Lucene 查询语法
    
    </summary>
    
    
      <category term="Lang" scheme="https://lxb.wiki/categories/Lang/"/>
    
    
      <category term="lucene" scheme="https://lxb.wiki/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>jq命令</title>
    <link href="https://lxb.wiki/5380c2ad/"/>
    <id>https://lxb.wiki/5380c2ad/</id>
    <published>2023-06-21T05:55:55.000Z</published>
    <updated>2025-02-02T11:48:02.456Z</updated>
    
    <content type="html"><![CDATA[<p>一个灵活的轻量级命令行JSON处理器</p><h3><span id="补充说明">补充说明</span></h3><p>jq 是 stedolan 开发的一个轻量级的和灵活的命令行JSON处理器，源码请参考 <a href="https://github.com/stedolan/jq">jq 项目主页</a></p><p>jq 用于处理JSON输入，将给定过滤器应用于其JSON文本输入并在标准输出上将过滤器的结果生成为JSON。</p><p>最简单的过滤器是<code>.</code>，它将jq的输入未经修改地复制到其输出中（格式设置除外）。</p><p>请注意，jq 当前仅支持64位双精度浮点数（IEEE754）。</p><h3><span id="安装">安装</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian系，如 Ubuntu sudo apt-get install jq # RedHat系, 如 CentOS yum install jq</span></span><br></pre></td></tr></table></figure><h3><span id="语法">语法</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq [options] &lt;jq filter&gt; [file...] jq [options] --args &lt;jq filter&gt; [strings...] jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]</span><br></pre></td></tr></table></figure><h3><span id="选项">选项</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-c 紧凑而不是漂亮的输出; -n 使用`null`作为单个输入值; -e 根据输出设置退出状态代码; -s 将所有输入读取（吸取）到数组中；应用过滤器; -r 输出原始字符串，而不是JSON文本; -R 读取原始字符串，而不是JSON文本; -C 为JSON着色; -M 单色（不要为JSON着色）; -S 在输出上排序对象的键; --tab 使用制表符进行缩进; --arg a v 将变量<span class="variable">$a</span>设置为value&lt;v&gt;; --argjson a v 将变量<span class="variable">$a</span>设置为JSON value&lt;v&gt;; --slurpfile a f 将变量<span class="variable">$a</span>设置为从&lt;f&gt;读取的JSON文本数组; --rawfile a f 将变量<span class="variable">$a</span>设置为包含&lt;f&gt;内容的字符串; --args 其余参数是字符串参数，而不是文件; --jsonargs 其余的参数是JSON参数，而不是文件; -- 终止参数处理;</span><br></pre></td></tr></table></figure><h3><span id="例子">例子</span></h3><p><code>.</code>: 以漂亮的方式输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;foo&quot;: &#123; &quot;bar&quot;: &#123; &quot;baz&quot;: 123 &#125; &#125; &#125;&#x27;</span> | jq <span class="string">&#x27;.&#x27;</span> &#123; <span class="string">&quot;foo&quot;</span>: &#123; <span class="string">&quot;bar&quot;</span>: &#123; <span class="string">&quot;baz&quot;</span>: 123 &#125; &#125; &#125; </span><br></pre></td></tr></table></figure><p><code>.foo, .foo.bar, .foo?</code>: 获取一个键的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27;</span> | jq <span class="string">&#x27;.foo&#x27;</span> 42</span><br></pre></td></tr></table></figure><p><code>.[], .[]?, .[2], .[10:15]</code>: 数组运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]&#x27;</span> | jq <span class="string">&#x27;.[1]&#x27;</span> &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;XML&quot;</span>, <span class="string">&quot;good&quot;</span>: <span class="literal">false</span> &#125; </span><br></pre></td></tr></table></figure><p><code>[], &#123;&#125;</code>: 构造一个数组/对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ Primer&quot;, &quot;More JQ&quot;]&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;user, title: .titles[]&#125;&#x27;</span> &#123; <span class="string">&quot;user&quot;</span>: <span class="string">&quot;stedolan&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;JQ Primer&quot;</span> &#125; &#123; <span class="string">&quot;user&quot;</span>: <span class="string">&quot;stedolan&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;More JQ&quot;</span> &#125; </span><br></pre></td></tr></table></figure><p><code>length</code>: 计算一个值的长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[[1,2], &quot;string&quot;, &#123;&quot;a&quot;:2&#125;, null]&#x27;</span> | jq <span class="string">&#x27;.[] | length&#x27;</span> 2 6 1 0 </span><br></pre></td></tr></table></figure><p><code>keys</code>: 取出数组中的键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;: 3&#125;&#x27;</span> | jq <span class="string">&#x27;keys&#x27;</span> [ <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span> ] </span><br></pre></td></tr></table></figure><p><code>,</code>: 使用多个过滤器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;foo&quot;: 42, &quot;bar&quot;: &quot;something else&quot;, &quot;baz&quot;: true&#125;&#x27;</span> | jq <span class="string">&#x27;.foo, .bar&#x27;</span> 42 <span class="string">&quot;something else&quot;</span> </span><br></pre></td></tr></table></figure><p><code>|</code>: 通过管道将一个过滤器的输出当做下一个过滤器的输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]&#x27;</span> | jq <span class="string">&#x27;.[] | .name&#x27;</span> <span class="string">&quot;JSON&quot;</span> <span class="string">&quot;XML&quot;</span> </span><br></pre></td></tr></table></figure><p><code>select(foo)</code>: 如果foo返回true，则输入保持不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[1,5,3,0,7]&#x27;</span> | jq <span class="string">&#x27;map(select(. &gt;= 2))&#x27;</span> [ 5, 3, 7 ] </span><br></pre></td></tr></table></figure><p><code>map(foo)</code>: 每个输入调用过滤器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[1,2,3]&#x27;</span> | jq <span class="string">&#x27;map(.+1)&#x27;</span> [ 2, 3, 4 ] </span><br></pre></td></tr></table></figure><p><code>if-then-else-end</code>: 条件判断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;2&#x27;</span> | jq <span class="string">&#x27;if . == 0 then &quot;zero&quot; elif . == 1 then &quot;one&quot; else &quot;many&quot; end&#x27;</span> <span class="string">&quot;many&quot;</span> </span><br></pre></td></tr></table></figure><p><code>\(foo)</code>: 在字符串中插入值并进行运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;42&#x27;</span> | jq <span class="string">&#x27;&quot;The input was \(.), which is one less than \(.+1)&quot;&#x27;</span> <span class="string">&quot;The input was 42, which is one less than 43&quot;</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      jq命令
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://lxb.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS守护进程优化建议</title>
    <link href="https://lxb.wiki/62d417da/"/>
    <id>https://lxb.wiki/62d417da/</id>
    <published>2023-06-04T06:03:49.000Z</published>
    <updated>2025-02-02T11:48:02.417Z</updated>
    
    <content type="html"><![CDATA[<p><strong>/sbin/launchd</strong><br>系统及用户进程管理器，它是内核装载成功后在OS环境下启动的第一个进程，是Mac OS最重要的进程之一。你无法禁用它。</p><p><strong>/usr/libexec/kextd</strong><br>内核扩展服务，响应内核或用户进程的请求，比如装载或卸载内核扩展或提供内核扩展信息给它们。这是Mac的关键守护进程，请不要去禁用它。</p><p><strong>/usr/sbin/notifyd</strong><br>消息服务，这是Mac OS消息系统的组成部分之一。我们知道，操作系统的很多组件需要依赖异步消息来通信，这个服务能保证它们正常工作。请不要去禁用它。</p><p><strong>/usr/sbin/diskarbitrationd</strong><br>磁盘仲裁服务，作用是为磁盘卷或其他存储部件进行挂载，取消挂载或弹出（比如光驱和dmg）。最常见的就是USB移动硬盘，MP3，IPHONE，IPAD等。<br>它的原理是当内核发现有新硬件插入时，内核先识别该硬件，如果能识别，则为硬件装载驱动，并通知 diskarbitrationd 挂载它。取消挂载同理。<br>如果这个服务被禁用，所有即插即用存储设备都会出现异常。建议不要禁用它。</p><p><strong>/usr/libexec/configd</strong><br>保存计算机和系统环境的动态配置信息。为需要用到这些信息的进程提供变更通知。比如网络服务（tcp/ip或wins更新等）。<br>如果这个服务被禁用，网络和一些需要动态配置信息的组件将会出现异常。建议不要禁用它。</p><p><strong>/usr/sbin/syslogd</strong><br>系统日志服务，用于记录系统或软件的消息日志，是系统或软件崩溃时查错的关键途径。某些工具也可能依赖与日志在提供服务。<br>如果这个服务被禁用，所有的消息日志都将停止记录，并可能导致某些软件工作异常。建议不要禁用它。</p><p><strong>/usr/sbin/DirectoryService</strong><br>目录信息收集中心，它会收集各种目录的用户，用户组，权限和路径信息，并在应用程序需要时，反馈给它们。目录的介质主要是指本地磁 盘，LDAP，Netinfo, Active Directory, NIS, Bonjour/Rendesvous/, AppleTalk, Samba FS(SMB)等。<br>如果这个服务被禁用，可能会导致部分程序性能降低或出现异常。建议不要禁用它。</p><p><strong>/usr/sbin/distnoted</strong><br>提供分布式的消息服务，类似notifyd，但它主要是处理系统外部的一些消息，比如 itune与iphone, ipad, itouch的连接及消息传递功能。<br>如果你有使用Apple的即插即用设备，为了保证其功能正常使用，建议你不要禁用它。如果没有apple设备，保险期间，还是留着它吧。</p><p><strong>/usr/sbin/ntpd</strong><br>时间同步服务，负责与time.apple.com同步操作系统的时间。这个是基础功能，请不要禁用它。</p><p><strong>/System/Library/PrivateFrameworks/MobileDevice.framework/Versions/A/Resources/usbmuxd</strong><br>USB多路传输服务，为iphone和itouch提供原生的传输支持（无需越狱）。如果你没有iphone或ipod touch，<strong>可以禁用这个服务</strong>。</p><p><strong>/usr/sbin/securityd</strong><br>Mac OS安全验证模块，它保存了系统的安全信息，可以仲裁一些加密操作，为软件提供安全验证。系统安全是大事，请不要禁用它。</p><p><strong>/usr/sbin/mDNSResponder</strong><br>DNS多播响应器，与DNS服务相关，附属作用是为你搜索局域网里的共享设备。包括mac, windows, ichat, ipad等等，并且会显示在finder的右侧菜单中。<br>请不要禁用它，否则你的DNS将失效，并导致无法访问网络。</p><p><strong>/System/Library/CoreServices/loginwindow.app/Contents/MacOS/loginwindow</strong><br>Mac OS用户登陆进程，展示登陆或注销界面，验证用户密码输入，启动Finder, Dock, 和一切需要启动时启动的第三方应用程序都是这个进程的责任。<br>请不要禁用它。</p><p><strong>/usr/sbin/KernelEventAgent</strong><br>处理文件系统的状态。比如“您的磁盘看上去已经满了，您是否需要删除一些数据，以保证系统正常启动”或“一个服务器已经很久没有响应，您是否想需要重新连接它”等。请不要禁用它。</p><p><strong>/usr/libexec/hidd</strong><br>人体学输入设备（HID）支持进程。比如键盘，鼠标，机密狗，蓝牙等。请不要禁用它。</p><p><strong>/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/Support/fseventsd</strong><br>文件系统事件系统，它可以广播文件的创建，删除等事件给Mac OS下的所有应用程序，届时，应用程序可以做出一些应对措施。请不要禁用它。</p><p><strong>/sbin/dynamic_pager</strong><br>Mac OS下的虚拟内存。当你的物理内存不够用时，就会使用虚拟内存，有的时候，密钥等一些使用频率不高的信息也会直接从物理内存中移除并存入虚拟内存。在 Unix系统（Mac）下，不论你的物理内存有多大，都不要尝试禁用虚拟内存。因为Unix的内存管理策略是尽可能多地使用内存，再大的内存都回随着时间 慢慢被耗光。</p><p><strong>autofsd</strong><br>自动挂载各种网络文件系统。比如NFS, SMB, AFS等。配置文件在 /etc/auto_master和/etc/auto_home，使用方式详见：<br><a href="http://commandlinemac.blogspot.com/2009/09/introduction-to-autofs-in-mac-os-x.html">http://commandlinemac.blogspot.com/2009/09/introduction-to-autofs-in-mac-os-x.html</a><br>如果你不使用任何网络文件系统，<strong>可以禁用这个服务</strong>。</p><p><strong>/System/Library/CoreServices/coreservicesd</strong><br>核心服务守护进程，禁用它可能导致系统停止运转或崩溃。请不要禁用它。</p><p><strong>/usr/sbin/coreaudiod</strong><br>音频服务，提供声音相关的支持。请不要禁用它。</p><p><strong>System/Library/Frameworks/ApplicationServices.framework/Frameworks/CoreGraphics.framework/Resources/WindowServer</strong><br>Mac OS的GUI界面系统。负责所有应用程序的窗口显示。请不要禁用它。</p><p><strong>/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/cvmsServ</strong><br>OPGL服务进程，用到高级图形API的程序需要用到它。比如游戏，支持滑动或谈出特效的软件。请不要禁用它。</p><p><strong>/System/Library/CoreServices/Dock.app/Contents/MacOS/Dock</strong><br>Mac OS经典的任务栏。请不要禁用它。</p><p><strong>/System/Library/CoreServices/SystemUIServer.app/Contents/MacOS/SystemUIServer</strong><br>Mac OS的菜单栏。请不要禁用它。</p><p><strong>/System/Library/CoreServices/Finder.app/Contents/MacOS/Finder</strong><br>Mac OS的资源管理器。请不要禁用它。</p><p><strong>/usr/sbin/pboard</strong><br>剪贴板支持。除非你不想用复制，黏贴。请不要禁用它。</p><p><strong>/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ATS.framework/Support/fontd</strong><br>字体服务进程。请不要禁用它。</p><p><strong>/usr/libexec/UserEventAgent</strong><br>高级别的系统事件处理器。请不要禁用它。</p><p><strong>/System/Library/CoreServices/Menu Extras/TextInput.menu/Contents/SharedSupport/TISwitcher.app/Contents/MacOS/TISwitcher</strong><br>输入法切换服务。除非你不想使用中文输入法，否则，请不要禁用它。</p><p><strong>/usr/libexec/taskgated</strong><br>task_for_pid是用来帮助某些想控制其他进程的执行的进程实现功能的服务。taskgated会被内核呼叫，用来确认”控制“这个行为是否可以发生。它本身也有权限验证的功能。请不要禁用该服务。</p><p><strong>AirPortBaseStationAgent</strong><br>这个是Apple的无线基站设备搜索服务。如果你没有apple的无线基站设备，<strong>可以禁用它</strong>。</p><p><strong>Spotlight</strong><br>如果你不喜欢用spotlight，<strong>可以禁用它</strong>。详见文末给出的“Mac OS启动服务优化高级篇（launchd tuning）”里的优化方法。</p><p><strong>/usr/sbin/blued</strong><br>蓝牙支持服务。如果你不想使用蓝牙，<strong>可以禁用它</strong>。</p><p><strong>cupsd</strong><br>打印机支持。如果你不想用打印机，<strong>可以禁用该服务</strong>。</p><p><strong>SharedServices.Agent</strong><br>Apple的MobileMe服务，如果你不使用，<strong>可以禁用该服务</strong>。</p>]]></content>
    
    <summary type="html">
    
      Mac OS守护进程优化建议
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="mac" scheme="https://lxb.wiki/tags/mac/"/>
    
  </entry>
  
</feed>
