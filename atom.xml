<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxb.wiki/"/>
  <updated>2020-10-18T10:28:10.155Z</updated>
  <id>https://lxb.wiki/</id>
  
  <author>
    <name>Xiaobin.Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10大静态网站生成工具</title>
    <link href="https://lxb.wiki/690c8418/"/>
    <id>https://lxb.wiki/690c8418/</id>
    <published>2020-10-02T10:26:55.000Z</published>
    <updated>2020-10-18T10:28:10.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-大静态网站生成工具"><a href="#10-大静态网站生成工具" class="headerlink" title="10 大静态网站生成工具"></a>10 大静态网站生成工具</h1><p><img src="https://img.linux.net.cn/data/attachment/album/202010/01/123903lx1q0w2oh1lxx7wh.jpg" alt></p><blockquote><p>在寻找部署静态网页的方法吗？这几个开源的静态网站生成工具可以帮你迅速部署界面优美、功能强大的静态网站，无需掌握复杂的 HTML 和 CSS 技能。</p></blockquote><h3 id="静态网站是什么？"><a href="#静态网站是什么？" class="headerlink" title="静态网站是什么？"></a>静态网站是什么？</h3><p>技术上来讲，静态网站是指网页不是由服务器动态生成的。HTML、CSS 和 JavaScript 文件就静静地躺在服务器的某个路径下，它们的内容与终端用户接收到的版本是一样的。原始的源码文件已经提前编译好了，源码在每次请求后都不会变化。</p><p>Linux.CN 是一个依赖多个数据库的动态网站，当有浏览器的请求时，网页就会生成并提供服务。大部分网站是动态的，你与这些网站互动时，大量的内容会经常改变。</p><p>静态网站有一些好处，比如加载时间更短，请求的服务器资源更少、更安全（值得商榷）。</p><p>传统上，静态网站更适合于创建只有少量网页、内容变化不频繁的小网站。</p><p>然而，随着静态网站生成工具出现后，静态网站的适用范围越来越大。你还可以使用这些工具搭建博客网站。</p><p>我整理了几个开源的静态网站生成工具，这些工具可以帮你搭建界面优美的网站。</p><h3 id="最好的开源静态网站生成工具"><a href="#最好的开源静态网站生成工具" class="headerlink" title="最好的开源静态网站生成工具"></a>最好的开源静态网站生成工具</h3><p>请注意，静态网站不会提供很复杂的功能。如果你需要复杂的功能，那么你可以参考适用于动态网站的<a href="https://itsfoss.com/open-source-cms/" target="_blank" rel="noopener">最佳开源 CMS</a>列表。</p><h4 id="1、Jekyll"><a href="#1、Jekyll" class="headerlink" title="1、Jekyll"></a>1、Jekyll</h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2018/01/jekyll-screenshot.jpg?resize=800%2C450&ssl=1" alt></p><p>Jekyll 是用 <a href="https://www.ruby-lang.org/en/" target="_blank" rel="noopener">Ruby</a> 写的最受欢迎的开源静态生成工具之一。实际上，Jekyll 是 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub 页面</a> 的引擎，它可以让你免费用 GitHub 托管网站。</p><p>你可以很轻松地跨平台配置 Jekyll，包括 Ubuntu。它利用 <a href="https://github.com/Shopify/liquid/wiki" target="_blank" rel="noopener">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki" target="_blank" rel="noopener">Liquid</a>（模板语言）、HTML 和 CSS 来生成静态的网页文件。如果你要搭建一个没有广告或推广自己工具或服务的产品页的博客网站，它是个不错的选择。</p><p>它还支持从常见的 CMS（<ruby>内容管理系统<rt>Content management system</rt></ruby>）如 Ghost、WordPress、Drupal 7 迁移你的博客。你可以管理永久链接、类别、页面、文章，还可以自定义布局，这些功能都很强大。因此，即使你已经有了一个网站，如果你想转成静态网站，Jekyll 会是一个完美的解决方案。你可以参考<a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">官方文档</a>或 <a href="https://github.com/jekyll/jekyll" target="_blank" rel="noopener">GitHub 页面</a>了解更多内容。</p><ul><li><a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a></li></ul><h4 id="2、Hugo"><a href="#2、Hugo" class="headerlink" title="2、Hugo"></a>2、Hugo</h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hugo.jpg?resize=800%2C414&ssl=1" alt></p><p>Hugo 是另一个很受欢迎的用于搭建静态网站的开源框架。它是用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>写的。</p><p>它运行速度快、使用简单、可靠性高。如果你需要，它也可以提供更高级的主题。它还提供了一些有用的快捷方式来帮助你轻松完成任务。无论是组合展示网站还是博客网站，Hogo 都有能力管理大量的内容类型。</p><p>如果你想使用 Hugo，你可以参照它的<a href="https://gohugo.io/getting-started/" target="_blank" rel="noopener">官方文档</a>或它的 <a href="https://github.com/gohugoio/hugo" target="_blank" rel="noopener">GitHub 页面</a>来安装以及了解更多相关的使用方法。如果需要的话，你还可以将 Hugo 部署在 GitHub 页面或任何 CDN 上。</p><ul><li><a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a></li></ul><h4 id="3、Hexo"><a href="#3、Hexo" class="headerlink" title="3、Hexo"></a>3、Hexo</h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hexo.jpg?resize=800%2C213&ssl=1" alt></p><p>Hexo 是一个有趣的开源框架，基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>。像其他的工具一样，你可以用它搭建相当快速的网站，不仅如此，它还提供了丰富的主题和插件。</p><p>它还根据用户的每个需求提供了强大的 API 来扩展功能。如果你已经有一个网站，你可以用它的<a href="https://hexo.io/api/migrator.html" target="_blank" rel="noopener">迁移</a>扩展轻松完成迁移工作。</p><p>你可以参照<a href="https://hexo.io/docs/" target="_blank" rel="noopener">官方文档</a>或 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">GitHub 页面</a> 来使用 Hexo。</p><ul><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li></ul><h4 id="4、Gatsby"><a href="#4、Gatsby" class="headerlink" title="4、Gatsby"></a>4、Gatsby</h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/gatsbyjs.png?resize=800%2C388&ssl=1" alt></p><p>Gatsby 是一个越来越流行的开源网站生成框架。它使用 <a href="https://reactjs.org/" target="_blank" rel="noopener">React.js</a> 来生成快速、界面优美的网站。</p><p>几年前在一个实验性的项目中，我曾经非常想尝试一下这个工具，它提供的成千上万的新插件和主题的能力让我印象深刻。与其他静态网站生成工具不同的是，你可以使用 Gatsby 生成一个网站，并在不损失任何功能的情况下获得静态网站的好处。</p><p>它提供了与很多流行的服务的整合功能。当然，你可以不使用它的复杂的功能，或将其与你选择的流行 CMS 配合使用，这也会很有趣。你可以查看他们的<a href="https://www.gatsbyjs.com/docs/" target="_blank" rel="noopener">官方文档</a>或它的 <a href="https://github.com/gatsbyjs/gatsby" target="_blank" rel="noopener">GitHub 页面</a>了解更多内容。</p><ul><li><a href="https://www.gatsbyjs.com/" target="_blank" rel="noopener">Gatsby</a></li></ul><h4 id="5、VuePress"><a href="#5、VuePress" class="headerlink" title="5、VuePress"></a>5、VuePress</h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/VuePress.jpg?resize=800%2C498&ssl=1" alt></p><p>VuePress 是由 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 支持的静态网站生成工具，而 Vue.js 是一个开源的渐进式 JavaScript 框架。</p><p>如果你了解 HTML、CSS 和 JavaScript，那么你可以无压力地使用 VuePress。你应该可以找到几个有用的插件和主题来为你的网站建设开个头。此外，看起来 Vue.js 的更新一直很活跃，很多开发者都在关注 Vue.js，这是一件好事。</p><p>你可以参照他们的<a href="https://vuepress.vuejs.org/guide/" target="_blank" rel="noopener">官方文档</a>和 <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener">GitHub 页面</a>了解更多。</p><ul><li><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener">VuePress</a></li></ul><h4 id="6、Nuxt-js"><a href="#6、Nuxt-js" class="headerlink" title="6、Nuxt.js"></a>6、Nuxt.js</h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/nuxtjs.jpg?resize=800%2C415&ssl=1" alt></p><p>Nuxt.js 使用了 Vue.js 和 Node.js，但它致力于模块化，并且有能力依赖服务端而非客户端。不仅如此，它的目标是为开发者提供直观的体验，并提供描述性错误，以及详细的文档等。</p><p>正如它声称的那样，在你用来搭建静态网站的所有工具中，Nuxt.js 可以做到功能和灵活性两全其美。他们还提供了一个 <a href="https://template.nuxtjs.org/" target="_blank" rel="noopener">Nuxt 线上沙盒</a>，让你不费吹灰之力就能直接测试它。</p><p>你可以查看它的 <a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">GitHub 页面</a>和<a href="https://nuxtjs.org/" target="_blank" rel="noopener">官方网站</a>了解更多。</p><ul><li><a href="https://nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a></li></ul><h4 id="7、Docusaurus"><a href="#7、Docusaurus" class="headerlink" title="7、Docusaurus"></a>7、Docusaurus</h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/docusaurus.jpg?resize=800%2C278&ssl=1" alt></p><p>Docusaurus 是一个有趣的开源静态网站生成工具，为搭建文档类网站量身定制。它还是 <a href="https://opensource.facebook.com/" target="_blank" rel="noopener">Facebook 开源计划</a>的一个项目。</p><p>Docusaurus 是用 React 构建的。你可以使用所有的基本功能，像文档版本管理、文档搜索和翻译大多是预先配置的。如果你想为你的产品或服务搭建一个文档网站，那么可以试试 Docusaurus。</p><p>你可以从它的 <a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener">GitHub 页面</a>和它的<a href="https://docusaurus.io/" target="_blank" rel="noopener">官网</a>获取更多信息。</p><ul><li><a href="https://docusaurus.io/" target="_blank" rel="noopener">Docusaurus</a></li></ul><h4 id="8、Eleventy"><a href="#8、Eleventy" class="headerlink" title="8、Eleventy"></a>8、Eleventy</h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/eleventy.png?resize=800%2C375&ssl=1" alt></p><p>Eleventy 自称是 Jekyll 的替代品，旨在以更简单的方法来制作更快的静态网站。</p><p>它似乎很容易上手，而且它还提供了适当的文档来帮助你。如果你想找一个简单的静态网站生成工具，Eleventy 似乎会是一个有趣的选择。</p><p>你可以参照它的 <a href="https://github.com/11ty/eleventy/" target="_blank" rel="noopener">GitHub 页面</a>和<a href="https://www.11ty.dev/" target="_blank" rel="noopener">官网</a>来了解更多的细节。</p><ul><li><a href="https://www.11ty.dev/" target="_blank" rel="noopener">Eleventy</a></li></ul><h4 id="9、Publii"><a href="#9、Publii" class="headerlink" title="9、Publii"></a>9、Publii</h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/publii.jpg?resize=800%2C311&ssl=1" alt></p><p>Publii 是一个令人印象深刻的开源 CMS，它能使生成一个静态网站变得很容易。它是用 <a href="https://www.electronjs.org" target="_blank" rel="noopener">Electron</a> 和 Vue.js 构建的。如果有需要，你也可以把你的文章从 WorkPress 网站迁移过来。此外，它还提供了与 GitHub 页面、Netlify 及其它类似服务的一键同步功能。</p><p>如果你利用 Publii 生成一个静态网站，你还可以得到一个所见即所得的编辑器。你可以从<a href="https://getpublii.com/" target="_blank" rel="noopener">官网</a>下载它，或者从它的 <a href="https://github.com/GetPublii/Publii" target="_blank" rel="noopener">GitHub 页面</a>了解更多信息。</p><ul><li><a href="https://getpublii.com/" target="_blank" rel="noopener">Publii</a></li></ul><h4 id="10、Primo"><a href="#10、Primo" class="headerlink" title="10、Primo"></a>10、Primo</h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/primo-af.jpg?resize=800%2C394&ssl=1" alt></p><p>一个有趣的开源静态网站生成工具，目前开发工作仍很活跃。虽然与其他的静态生成工具相比，它还不是一个成熟的解决方案，有些功能还不完善，但它是一个独特的项目。</p><p>Primo 旨在使用可视化的构建器帮你构建和搭建网站，这样你就可以轻松编辑和部署到任意主机上。</p><p>你可以参照<a href="https://primo.af/" target="_blank" rel="noopener">官网</a>或查看它的 <a href="https://github.com/primo-app/primo-desktop" target="_blank" rel="noopener">GitHub 页面</a>了解更多信息。</p><ul><li><a href="https://primo.af/" target="_blank" rel="noopener">Primo</a></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>还有很多文章中没有列出的网站生成工具。然而，我试图提到最好的静态生成器，为您提供最快的加载时间，最好的安全性和令人印象深刻的灵活性。</p><p>列表中没有你最喜欢的工具？在下面的评论中告诉我。</p><hr><p>via: <a href="https://itsfoss.com/open-source-static-site-generators/" target="_blank" rel="noopener">https://itsfoss.com/open-source-static-site-generators/</a></p><p>作者：<a href="https://itsfoss.com/author/ankush/" target="_blank" rel="noopener">Ankush Das</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10-大静态网站生成工具&quot;&gt;&lt;a href=&quot;#10-大静态网站生成工具&quot; class=&quot;headerlink&quot; title=&quot;10 大静态网站生成工具&quot;&gt;&lt;/a&gt;10 大静态网站生成工具&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img.linux.ne
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="工具" scheme="https://lxb.wiki/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lambda 表达式</title>
    <link href="https://lxb.wiki/e4d97659/"/>
    <id>https://lxb.wiki/e4d97659/</id>
    <published>2020-08-20T23:13:27.000Z</published>
    <updated>2020-10-21T15:58:46.732Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#基础">基础</a></li><li><a href="#泛型-lambda">泛型 Lambda</a></li></ul><!-- tocstop --><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p><h3><span id="基础">基础</span></h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) <span class="keyword">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h4><span id="1-值捕获">1. 值捕获</span></h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，<strong>被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = copy_value();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stored_value = "</span> &lt;&lt; stored_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2-引用捕获">2. 引用捕获</span></h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = copy_value();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stored_value = "</span> &lt;&lt; stored_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-隐式捕获"><strong>3. 隐式捕获</strong></span></h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;] 引用捕获, 让编译器自行推导捕获列表</li><li>[=] 值捕获, 让编译器执行推导引用列表</li></ul><h4><span id="4-表达式捕获"><strong>4. 表达式捕获</strong></span></h4><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>important</code> 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值， 在表达式中初始化。</p><h3><span id="泛型-lambda">泛型 Lambda</span></h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。 这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。</p><p>幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始， Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#泛型-lambda&quot;&gt;泛型 Lambda&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;p&gt;Lambda 表达式是现代 C++ 中最
      
    
    </summary>
    
    
      <category term="C++" scheme="https://lxb.wiki/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Pillow 库</title>
    <link href="https://lxb.wiki/ab6bf24d/"/>
    <id>https://lxb.wiki/ab6bf24d/</id>
    <published>2020-08-01T13:10:55.000Z</published>
    <updated>2020-09-27T16:28:44.800Z</updated>
    
    <content type="html"><![CDATA[<p>Pillow(PIL) 库中的 Image 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; im = Image.open(&quot;lena.ppm&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from __future__ import print_function</span><br><span class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</span><br><span class="line">PPM (512, 512) RGB</span><br></pre></td></tr></table></figure><p>format 这个属性代表图片文件的扩展名, 如果图片文件打开失败, 则其值为None. size 这个属性代表图片的大小, 以像素为单位, 使用包含两个元素的元组来返回. mode 这个属性代表图片的band属性, 一般情况(黑白)下为 “L”, 当图片是彩色的时候是 “RGB”, 如果图片经过压缩, 则是 “CMYK”.</p><h3 id="PIL中所涉及的基本概念"><a href="#PIL中所涉及的基本概念" class="headerlink" title="PIL中所涉及的基本概念"></a>PIL中所涉及的基本概念</h3><p>通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。</p><h3 id="PIL中有九种不同模式。"><a href="#PIL中有九种不同模式。" class="headerlink" title="PIL中有九种不同模式。"></a>PIL中有九种不同模式。</h3><p>分别为1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。</p><p><strong>模式 1</strong><br>二值图像</p><p>模式“1”为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.mode</span><br><span class="line"> </span><br><span class="line">&apos;RGB&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1 = lena.convert(&quot;1&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.mode</span><br><span class="line"> </span><br><span class="line">&apos;1&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.size</span><br><span class="line"> </span><br><span class="line">(512, 512)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.getpixel((10,10))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((10,120))</span><br><span class="line"> </span><br><span class="line">0</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((130,120))</span><br><span class="line"> </span><br><span class="line">255</span><br></pre></td></tr></table></figure><p><strong>模式 L</strong></p><p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度</p><p><strong>模式 P</strong></p><p>模式“P”为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的</p><p><strong>模式“RGBA”</strong></p><p>模式“RGBA”为32位彩色图像，它的每个像素用32个bit表示，其中24bit表示红色、绿色和蓝色三个通道，另外8bit表示alpha通道，即透明通道。</p><p>从实例中可以看到，使用当前这个方式将“RGB”图像转为“RGBA”图像时，alpha通道全部设置为255，即完全不透明。</p><p><strong>模式“CMYK”</strong></p><p>模式“CMYK”为32位彩色图像，它的每个像素用32个bit表示。模式“CMYK”就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</p><p>四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：Key Plate(blacK) = 定位套版色（黑色）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk =lena.convert(&quot;CMYK&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.mode</span><br><span class="line"> </span><br><span class="line">&apos;CMYK&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_cmyk.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(58, 144, 177, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(59, 145, 178, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(196, 110, 77)</span><br></pre></td></tr></table></figure><p>从实例中可以得知PIL中“RGB”转换为“CMYK”的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = 255 - R</span><br><span class="line">M = 255 - G</span><br><span class="line">Y = 255 - B</span><br><span class="line">K = 0</span><br></pre></td></tr></table></figure><p>由于该转换公式比较简单，转换后的图像颜色有些失真。</p><p><strong>模式“YCbCr”</strong></p><p>模式“YCbCr”为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。</p><p>模式“RGB”转换为“YCbCr”的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y= 0.257*R+0.504*G+0.098*B+16</span><br><span class="line">Cb = -0.148*R-0.291*G+0.439*B+128</span><br><span class="line">Cr = 0.439*R-0.368*G-0.071*B+128</span><br></pre></td></tr></table></figure><p><strong>模式“I”</strong></p><p>模式“I”为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“I”模式是按照下面的公式转换的：</p><p><code>I = R * 299/1000 + G * 587/1000 + B * 114/1000</code></p><p><strong>模式“F”</strong></p><p>模式“F”为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“F”模式是按照下面的公式转换的：</p><p><code>F = R * 299/1000+ G * 587/1000 + B * 114/1000</code></p><h3 id="请注意，GIF文件总是以灰度形式读取。（-L-）或调色板模式（-P-）图像。"><a href="#请注意，GIF文件总是以灰度形式读取。（-L-）或调色板模式（-P-）图像。" class="headerlink" title="请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。"></a>请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pillow(PIL) 库中的 Image 类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Pic" scheme="https://lxb.wiki/categories/Pic/"/>
    
    
      <category term="Pic" scheme="https://lxb.wiki/tags/Pic/"/>
    
      <category term="Python" scheme="https://lxb.wiki/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>gif图片文件信息</title>
    <link href="https://lxb.wiki/2bf7952d/"/>
    <id>https://lxb.wiki/2bf7952d/</id>
    <published>2020-07-28T13:25:36.000Z</published>
    <updated>2020-09-27T16:32:23.911Z</updated>
    
    <content type="html"><![CDATA[<p>一个GIF文件主要由以下几部分组成。</p><ul><li>文件头</li><li>图像帧信息</li><li>注释</li></ul><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>GIF格式文件头和一般文件头差别不大，也包含有</p><ul><li>格式声明</li><li>逻辑屏幕描述块</li><li>全局调色盘</li></ul><p><strong>格式声明</strong></p><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/tnZGrhTk4dcOLQJXeHsDogOyXd92N3VtovhRvPDl9xmZGq04CPVHTiboiamvbknPv3ogwpxuf9KDWVusicGPaWXOg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p>Signature 为“GIF”3 个字符；Version 为“87a”或“89a”3 个字符。</p><p><strong>逻辑屏幕描述块</strong></p><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/tnZGrhTk4dcOLQJXeHsDogOyXd92N3VtB20zKIDrePvrWOoK8JzPGISiaNF2qVXHhcZze9hicKFONu46BB8u1RcA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p><p>前两字节为像素单位的宽、高，用以标识图片的视觉尺寸。</p><p>Packet里是调色盘信息，分别来看——</p><p>Global Color Table Flag 为全局颜色表标志，即为1时表明全局颜色表有定义。</p><p>Color Resolution 代表颜色表中每种基色位长（需要+1），为111时，每个颜色用8bit表示，即我们熟悉的RGB表示法，一个颜色三字节。</p><p>Sort Flag 表示是否对颜色表里的颜色进行优先度排序，把常用的排在前面，这个主要是为了适应一些颜色解析度低的早期渲染器，现在已经很少使用了。</p><p>Global Color Table 表示颜色表的长度，计算规则是值+1作为2的幂，得到的数字就是颜色表的项数，取最大值111时，项数=256，也就是说GIF格式最多支持256色的位图，再乘以Color Resolution算出的字节数，就是调色盘的总长度。</p><p>这四个字段一起定义了调色盘的信息。</p><p>Background color Index 定义了图像透明区域的背景色在调色盘里的索引。</p><p>Pixel Aspect Ratio 定义了像素宽高比，一般为0。</p><h4 id="帧信息描述"><a href="#帧信息描述" class="headerlink" title="帧信息描述"></a>帧信息描述</h4><p>帧信息描述就是每一帧的图像信息和相关标志位</p><p>大部分GIF存储时采用了公共区域排除和透明区域叠加的优化</p><p><strong>帧数据说明</strong></p><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/tnZGrhTk4dcOLQJXeHsDogOyXd92N3VtKP4gCwmicIZYlOgNgibkDbjGRsS0nGJdM3HlfjsWWxeXVmDhrpMzRYfg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个GIF文件主要由以下几部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件头&lt;/li&gt;
&lt;li&gt;图像帧信息&lt;/li&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;文件头&quot;&gt;&lt;a href=&quot;#文件头&quot; class=&quot;headerlink&quot; title=&quot;文件头&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Pic" scheme="https://lxb.wiki/categories/Pic/"/>
    
    
      <category term="GIF" scheme="https://lxb.wiki/tags/GIF/"/>
    
  </entry>
  
  <entry>
    <title>URL特殊字符处理</title>
    <link href="https://lxb.wiki/c587a198/"/>
    <id>https://lxb.wiki/c587a198/</id>
    <published>2020-07-09T22:45:47.000Z</published>
    <updated>2020-08-24T22:55:09.093Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> hexVals[<span class="number">16</span>] = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> CURLEncode::csUnsafeString= <span class="string">"\"&lt;&gt;%\\^[]`+$,@:;/!#?=&amp;"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> csRet;</span><br><span class="line">    csRet += <span class="string">"%"</span>;</span><br><span class="line">    csRet += decToHex(val, <span class="number">16</span>);   </span><br><span class="line">    <span class="keyword">return</span>  csRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decToHex</span><span class="params">(<span class="keyword">char</span> num, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>     temp=<span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">string</span>  csTmp;</span><br><span class="line">    <span class="keyword">int</span> num_char;</span><br><span class="line">    num_char = (<span class="keyword">int</span>) num;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// ISO-8859-1 </span></span><br><span class="line">    <span class="comment">// IF THE IF LOOP IS COMMENTED, THE CODE WILL FAIL TO GENERATE A </span></span><br><span class="line">    <span class="comment">// PROPER URL ENCODE FOR THE CHARACTERS WHOSE RANGE IN 127-255(DECIMAL)</span></span><br><span class="line">    <span class="keyword">if</span> (num_char &lt; <span class="number">0</span>)</span><br><span class="line">        num_char = <span class="number">256</span> + num_char;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (num_char &gt;= radix)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = num_char % radix;</span><br><span class="line">        num_char = (<span class="keyword">int</span>)<span class="built_in">floor</span>((num_char / radix) * <span class="number">1.0</span>);</span><br><span class="line">        csTmp = hexVals[temp];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    csTmp += hexVals[num_char];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(csTmp.length() &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        csTmp += <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> strdecToHex = csTmp;</span><br><span class="line">    <span class="comment">// Reverse the String</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(strdecToHex.begin(), strdecToHex.end());</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> strdecToHex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnsafe</span><span class="params">(<span class="keyword">char</span> compareChar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bcharfound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> tmpsafeChar;</span><br><span class="line">    <span class="keyword">int</span> m_strLen = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    m_strLen = csUnsafeString.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ichar_pos = <span class="number">0</span>; ichar_pos &lt; m_strLen ;ichar_pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpsafeChar = csUnsafeString[ichar_pos]; </span><br><span class="line">        <span class="keyword">if</span>(tmpsafeChar == compareChar)</span><br><span class="line">        &#123; </span><br><span class="line">            bcharfound = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> char_ascii_value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//char_ascii_value = __toascii(compareChar);</span></span><br><span class="line">    char_ascii_value = (<span class="keyword">int</span>) compareChar;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(bcharfound == <span class="literal">false</span> &amp;&amp;  char_ascii_value &gt; <span class="number">32</span> &amp;&amp; char_ascii_value &lt; <span class="number">123</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// found no unsafe chars, return false       </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">URLEncode</span><span class="params">(<span class="built_in">string</span> strEncode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>  strSrc;</span><br><span class="line">    <span class="built_in">string</span>    strDest;   </span><br><span class="line"> </span><br><span class="line">    strSrc = strEncode;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strSrc.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = strSrc[i];</span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="string">' '</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ch = ch;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!isUnsafe(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Safe Character               </span></span><br><span class="line">            strDest += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get Hex Value of the Character</span></span><br><span class="line">            strDest += convert(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>url编码解码</title>
    <link href="https://lxb.wiki/fdc9c210/"/>
    <id>https://lxb.wiki/fdc9c210/</id>
    <published>2020-06-24T22:37:14.000Z</published>
    <updated>2020-08-24T22:54:43.345Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BURSIZE 2048</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex2dec</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dec2hex</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= c &amp;&amp; c &lt;= <span class="number">9</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">'0'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">10</span> &lt;= c &amp;&amp; c &lt;= <span class="number">15</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">'A'</span> - <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//编码一个url</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urlencode</span><span class="params">(<span class="keyword">char</span> url[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(url);</span><br><span class="line">    <span class="keyword">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> res[BURSIZE];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = url[i];</span><br><span class="line">        <span class="keyword">if</span> (    (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) ||</span><br><span class="line">                (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>) ||</span><br><span class="line">                (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>) || </span><br><span class="line">                c == <span class="string">'/'</span> || c == <span class="string">'.'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res[res_len++] = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (<span class="keyword">short</span> <span class="keyword">int</span>)c;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                j += <span class="number">256</span>;</span><br><span class="line">            <span class="keyword">int</span> i1, i0;</span><br><span class="line">            i1 = j / <span class="number">16</span>;</span><br><span class="line">            i0 = j - i1 * <span class="number">16</span>;</span><br><span class="line">            res[res_len++] = <span class="string">'%'</span>;</span><br><span class="line">            res[res_len++] = dec2hex(i1);</span><br><span class="line">            res[res_len++] = dec2hex(i0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[res_len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(url, res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 解码url</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urldecode</span><span class="params">(<span class="keyword">char</span> url[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(url);</span><br><span class="line">    <span class="keyword">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> res[BURSIZE];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = url[i];</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'%'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res[res_len++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = url[++i];</span><br><span class="line">            <span class="keyword">char</span> c0 = url[++i];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            num = hex2dec(c1) * <span class="number">16</span> + hex2dec(c0);</span><br><span class="line">            res[res_len++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[res_len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(url, res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> url[<span class="number">100</span>] = <span class="string">"http://'测试/@mike"</span>;</span><br><span class="line">    urlencode(url); <span class="comment">//编码后</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"http://'测试/@mike  ----&gt; %s\n"</span>, url);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">"http%3A//%27%E6%B5%8B%E8%AF%95/%40mike"</span>;</span><br><span class="line">    urldecode(buf); <span class="comment">//解码后</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"http%%3A//%%27%%E6%%B5%%8B%%E8%%AF%%95/%%40mike  ----&gt; %s\n"</span>, buf);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>从图片头信息中获取图片格式</title>
    <link href="https://lxb.wiki/be14bd28/"/>
    <id>https://lxb.wiki/be14bd28/</id>
    <published>2020-06-14T22:26:23.000Z</published>
    <updated>2020-08-24T22:54:23.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图片文件头标识分析"><a href="#图片文件头标识分析" class="headerlink" title="图片文件头标识分析"></a>图片文件头标识分析</h3><p>一个图片文件的后缀名并不能说明这个图片的真正格式什么，读取图片文件的文件头标识可以获取图片的格式。用十六进制编辑器察看图片的文件头</p><p>1.JPEG</p><ul><li>文件头标识 (2 bytes): $ff, $d8 (SOI) (JPEG 文件标识) </li><li>文件结束标识 (2 bytes): $ff, $d9 (EOI)</li></ul><p>2.TGA</p><ul><li>未压缩的前5字节    00 00 02 00 00</li><li>RLE压缩的前5字节   00 00 10 00 00</li></ul><p>3.PNG</p><ul><li>文件头标识 (8 bytes)   89 50 4E 47 0D 0A 1A 0A</li></ul><p>4.GIF</p><ul><li>文件头标识 (6 bytes)   47 49 46 38 39(37) 61<pre><code>G    I    F     8    9 (7)     a</code></pre></li></ul><p>5.BMP</p><ul><li>文件头标识 (2 bytes)   42 4D<pre><code>B    M</code></pre></li></ul><p>6.PCX</p><ul><li>文件头标识 (1 bytes)   0A</li></ul><p>7.TIFF</p><ul><li>文件头标识 (2 bytes)   4D 4D 或 49 49</li></ul><p>8.ICO</p><ul><li>文件头标识 (8 bytes)   00 00 01 00 01 00 20 20</li></ul><p>9.CUR</p><ul><li>文件头标识 (8 bytes)   00 00 02 00 01 00 20 20</li></ul><p>10.IFF</p><ul><li>文件头标识 (4 bytes)   46 4F 52 4D<pre><code>F    O   R    M</code></pre></li></ul><p>11.ANI</p><ul><li>文件头标识 (4 bytes)   52 49 46 46<pre><code>R     I     F    F</code></pre></li></ul><p>根据这些文件头标识的收集，我可以写一个识别图像格式的模块了。但是在写这个模块之前可以对收集到的文件头标识进行优化，使得程序中字符串比对次数尽量的少。<br>1.JPEG我们知需要比对文件头的$ff, $d8这两个字符，而不用读取最后的两个结束标识了。<br>2.TGA，ICO，CUR只需比对第三个与第五个字符即可。<br>3.PNG比对[89][50]这两个字符。<br>4.GIF比对[47][49][46]与第五个字符。</p><p>模块代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&apos;枚举图片格式种类</span><br><span class="line">Public Enum ImageForm</span><br><span class="line">   [BMP] = 0</span><br><span class="line">   [JPEG] = 1</span><br><span class="line">   [GIF87] = 2</span><br><span class="line">   [GIF89] = 3</span><br><span class="line">   [PNG] = 4</span><br><span class="line">   [TGA Normal] = 5 &apos;TGA未压缩</span><br><span class="line">   [TGA RLE] = 6     &apos;TGA经过RLE压缩后的</span><br><span class="line">   [PCX] = 7</span><br><span class="line">   [TIFF] = 8</span><br><span class="line">   [ICO] = 9</span><br><span class="line">   [CUR] = 10</span><br><span class="line">   [IFF] = 11</span><br><span class="line">   [ANI] = 12</span><br><span class="line">   [Other] = 13</span><br><span class="line">   [FileError] = 14</span><br><span class="line">End Enum</span><br></pre></td></tr></table></figure><p>常用的图片格式有一下几种。</p><ul><li>PNG</li><li>JPEG</li><li>GIF</li><li>WebP 是 Google 制造的一个图片格式，针对网络上快速传输就行了优化</li><li>TIFF/TIF 在数字影响、遥感、医学等领域中得到了广泛的应用。TIFF文件的后缀是.tif或者.tiff</li><li>HEIC iOS11 后，苹果拍照图片的默认格式</li><li>HEIF 用于存储动态图像</li></ul><h5 id="JPGE-二进制数据前两个字节数据为"><a href="#JPGE-二进制数据前两个字节数据为" class="headerlink" title="JPGE 二进制数据前两个字节数据为"></a>JPGE 二进制数据前两个字节数据为</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">FF D8</span><br></pre></td></tr></table></figure><h5 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">89 50 4E 47 0D 0A 1A 0A</span><br></pre></td></tr></table></figure><h5 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">47 49 46 38 37 61 or</span><br><span class="line">47 49 46 38 39 61</span><br></pre></td></tr></table></figure><h5 id="TIFF"><a href="#TIFF" class="headerlink" title="TIFF"></a>TIFF</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">49 20 49 or</span><br><span class="line">49 49 2A 00 or</span><br><span class="line">4D 4D 00 2B or</span><br><span class="line">4D 4D 00 2A</span><br></pre></td></tr></table></figure><h5 id="HEIC"><a href="#HEIC" class="headerlink" title="HEIC"></a>HEIC</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">00</span><br></pre></td></tr></table></figure><h5 id="HEIF"><a href="#HEIF" class="headerlink" title="HEIF"></a>HEIF</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">00</span><br></pre></td></tr></table></figure><h5 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">52</span><br></pre></td></tr></table></figure><p>判断 Webp 为什么是截取 0-12 的长度？转换成 ASCII 之后判断的依据？</p><p>在 Google 官方介绍中找到了此图。说明的是：头文件的大小是 <code>12Bytes</code></p><p>WEBP的 header 中写明了 <code>ASCII</code> 是 <code>RIFF</code> 或者 <code>WEBP</code> Google Developer: <a href="https://developers.google.com/speed/webp/docs/riff_container" target="_blank" rel="noopener">developers.google.com/speed/webp/…</a></p><p>demo 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">enum ImageFormat &#123;</span><br><span class="line">    case Unknow</span><br><span class="line">    case JPEG</span><br><span class="line">    case PNG</span><br><span class="line">    case GIF</span><br><span class="line">    case TIFF</span><br><span class="line">    case WebP</span><br><span class="line">    case HEIC</span><br><span class="line">    case HEIF</span><br><span class="line">&#125;</span><br><span class="line">extension Data &#123;</span><br><span class="line">    func getImageFormat() -&gt; ImageFormat  &#123;</span><br><span class="line">        var buffer = [UInt8](repeating: 0, count: 1)</span><br><span class="line">        self.copyBytes(to: &amp;buffer, count: 1)</span><br><span class="line">        </span><br><span class="line">        switch buffer &#123;</span><br><span class="line">        case [0xFF]: return .JPEG</span><br><span class="line">        case [0x89]: return .PNG</span><br><span class="line">        case [0x47]: return .GIF</span><br><span class="line">        case [0x49],[0x4D]: return .TIFF</span><br><span class="line">        case [0x52] where self.count &gt;= 12:</span><br><span class="line">            if let str = String(data: self[0...11], encoding: .ascii), str.hasPrefix(&quot;RIFF&quot;), str.hasSuffix(&quot;WEBP&quot;) &#123;</span><br><span class="line">                return .WebP</span><br><span class="line">            &#125;</span><br><span class="line">        case [0x00] where self.count &gt;= 12:</span><br><span class="line">            if let str = String(data: self[8...11], encoding: .ascii) &#123;</span><br><span class="line">                let HEICBitMaps = Set([&quot;heic&quot;, &quot;heis&quot;, &quot;heix&quot;, &quot;hevc&quot;, &quot;hevx&quot;])</span><br><span class="line">                if HEICBitMaps.contains(str) &#123;</span><br><span class="line">                    return .HEIC</span><br><span class="line">                &#125;</span><br><span class="line">                let HEIFBitMaps = Set([&quot;mif1&quot;, &quot;msf1&quot;])</span><br><span class="line">                if HEIFBitMaps.contains(str) &#123;</span><br><span class="line">                    return .HEIF</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        return .Unknow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++ 代码1</strong></p><p>Image_file.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;config.h&quot;</span><br><span class="line">#include &quot;ImageFile.h&quot;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">namespace blink &#123;</span><br><span class="line"></span><br><span class="line">#define JPEG_FILE_TYPE          1</span><br><span class="line">#define BMP_FILE_TYPE           2</span><br><span class="line">#define PNG_FILE_TYPE           3</span><br><span class="line">#define GIF_FILE_TYPE           4</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">　　通过文件头标识判断图片格式，</span><br><span class="line">　　jpg： FF, D8</span><br><span class="line">　　bmp： 42 4D</span><br><span class="line">　　gif： 47 49 46 38</span><br><span class="line">　　png： 89 50 4E 47</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int check_fileType(const unsigned char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    if(buf[0] == 0xFF &amp;&amp; buf[1] == 0xd8 &amp;&amp; buf[2] == 0xFF) </span><br><span class="line">    &#123;</span><br><span class="line">        return JPEG_FILE_TYPE; </span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[0] == 0x42 &amp;&amp; buf[1] == 0x4d)</span><br><span class="line">    &#123;</span><br><span class="line">        return BMP_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[0] == 0x47 &amp;&amp; buf[1] == 0x49 &amp;&amp; buf[2] == 0x46 &amp;&amp; buf[3] == 0x38)</span><br><span class="line">    &#123;</span><br><span class="line">        return GIF_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[0] == 0x89 &amp;&amp; buf[1] == 0x50 &amp;&amp; buf[2] == 0x4e &amp;&amp; buf[3] == 0x47)</span><br><span class="line">    &#123;</span><br><span class="line">        return PNG_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*在构造函数内获取像素宽高：mwidth、mheigh*/</span><br><span class="line"></span><br><span class="line">ImageFile::ImageFile(const String&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    int type;</span><br><span class="line">    mpath = path;</span><br><span class="line">    mwidth = 0;</span><br><span class="line">    mheight = 0;</span><br><span class="line">    mtype = &quot;&quot;;</span><br><span class="line">    src = (char *)path.utf8().data();</span><br><span class="line">    int i = 0;</span><br><span class="line">    int size;</span><br><span class="line">    unsigned char *buff = NULL;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if((fp = fopen(src,&quot;rb+&quot;)) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        mtype = &quot;The file was not opened!&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fp,0,SEEK_END);</span><br><span class="line">    size = ftell(fp);</span><br><span class="line">    buff = (unsigned char*)malloc(size);</span><br><span class="line">    if(buff)</span><br><span class="line">        memset(buff,0,size);</span><br><span class="line">    fseek(fp,0,SEEK_SET);   </span><br><span class="line">    if(fread(buff,1,size,fp)!=size)</span><br><span class="line">    &#123;</span><br><span class="line">        mtype =&quot;read error!&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    type = check_fileType(buff);</span><br><span class="line">    switch(type)</span><br><span class="line">    &#123;</span><br><span class="line">        case JPEG_FILE_TYPE:</span><br><span class="line">            mtype = &quot;jpg file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0xff &amp;&amp; buff[i+1] == 0xc0)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i+7]&lt;&lt;8) | buff[i+8];</span><br><span class="line">                    mheight = (buff[i+5]&lt;&lt;8) | buff[i+6];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case BMP_FILE_TYPE:</span><br><span class="line">            mtype = &quot;bmp file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0x28 &amp;&amp; buff[i+1] == 0x00)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i+7]&lt;&lt;24) | buff[i+6]&lt;&lt;16 | buff[i+5]&lt;&lt;8 | buff[i+4];</span><br><span class="line">                    mheight = (buff[i+11]&lt;&lt;24) | buff[i+10]&lt;&lt;16 | buff[i+9]&lt;&lt;8 | buff[i+8];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case PNG_FILE_TYPE:</span><br><span class="line">            mtype = &quot;png file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0x49 &amp;&amp; buff[i+1] == 0x48)</span><br><span class="line">                &#123;</span><br><span class="line">                    mheight = (buff[i+8]&lt;&lt;24) | buff[i+9]&lt;&lt;16 | buff[i+10]&lt;&lt;8 | buff[i+11];</span><br><span class="line">                    mwidth = (buff[i+4]&lt;&lt;24) | buff[i+5]&lt;&lt;16 | buff[i+6]&lt;&lt;8 | buff[i+7];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case GIF_FILE_TYPE:</span><br><span class="line">            mtype = &quot;gif file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0x00 &amp;&amp; buff[i+1] == 0x2c)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i+7]&lt;&lt;8) | buff[i+6];</span><br><span class="line">                    mheight = (buff[i+9]&lt;&lt;8) | buff[i+8];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    free(buff);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String ImageFile::type() const</span><br><span class="line">&#123;</span><br><span class="line">    return mtype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String ImageFile::location() const</span><br><span class="line">&#123;</span><br><span class="line">    int length = mpath.length();</span><br><span class="line">    int pos = mpath.reverseFind(&apos;/&apos;);</span><br><span class="line">    </span><br><span class="line">    while (pos == length - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = mpath.reverseFind(&apos;/&apos; ,pos - 1);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pos &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return mpath.substring(0,pos + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String ImageFile::fileName() const</span><br><span class="line">&#123;</span><br><span class="line">    int length = mpath.length();</span><br><span class="line">    int pos = mpath.reverseFind(&apos;/&apos;);</span><br><span class="line">    </span><br><span class="line">    while (pos == length - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = mpath.reverseFind(&apos;/&apos; , pos - 1);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pos &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return mpath.substring(pos + 1,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ImageFile::width() const</span><br><span class="line">&#123;</span><br><span class="line">    return mwidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ImageFile::height() const</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return mheight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image_file.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ImageFile_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ImageFile_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> blink &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ImageFile</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ImageFile* <span class="title">create</span><span class="params">(<span class="keyword">const</span> String&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FILE* fS;</span><br><span class="line">        fS =fopen(path.utf8().data(),<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span>(fS !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> iLen = path.length() ;</span><br><span class="line">            <span class="keyword">int</span> iPos = path.reverseFind(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">if</span> (iPos &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String name=path.substring(iPos + <span class="number">1</span>, iLen);</span><br><span class="line">            <span class="keyword">char</span> s1[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">char</span> s2[]=<span class="string">"jpg"</span>;</span><br><span class="line">            <span class="keyword">char</span> s3[]=<span class="string">"bmp"</span>;</span><br><span class="line">            <span class="keyword">char</span> s4[]=<span class="string">"gif"</span>;</span><br><span class="line">            <span class="keyword">char</span> s5[]=<span class="string">"png"</span>;</span><br><span class="line">            <span class="keyword">char</span> s6[]=<span class="string">"jpeg"</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;name.length();i++)</span><br><span class="line">                s1[i] = name[i];</span><br><span class="line">            s1[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s1,s2,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s3,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s4,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s5,<span class="number">3</span>)==<span class="number">0</span>|| <span class="built_in">strncmp</span>(s1,s6,<span class="number">4</span>)==<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NGBImageFile(path);     <span class="comment">//路径正确且图片文件格式是以上四种，创建文件对象</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">location</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">fileName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">width</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">height</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ImageFile(<span class="keyword">const</span> String&amp; path);</span><br><span class="line">    <span class="keyword">char</span>* src;</span><br><span class="line">    String mpath;</span><br><span class="line">    String mtype;</span><br><span class="line">    <span class="keyword">double</span> mwidth;</span><br><span class="line">    <span class="keyword">double</span> mheight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace blink</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ImageFile_H</span></span></span><br></pre></td></tr></table></figure><p><strong>Qt 代码</strong></p><p>imageinfo.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#ifndef IMAGEINFO_H</span><br><span class="line">#define IMAGEINFO_H</span><br><span class="line">#include &lt;QObject&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QUrl&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;QSize&gt;</span><br><span class="line">#include &lt;QDate&gt;</span><br><span class="line">class ImageInfo : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    enum IMAGE_FORMAT&#123;</span><br><span class="line">        BMP_FORMAT,</span><br><span class="line">        JPG_FORMAT,</span><br><span class="line">        GIF_FORMAT,</span><br><span class="line">        PNG_FORMAT,</span><br><span class="line">        NVL_FORMAT</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    explicit ImageInfo(QObject *parent = 0);</span><br><span class="line">    ~ImageInfo();</span><br><span class="line">public:</span><br><span class="line">    Q_INVOKABLE QString getImageFormat(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QString getImageSize(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QSize getImageDimension(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QDate getImageDate(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QString getImageTitle(QString imageUrl);</span><br><span class="line">Q_SIGNALS:</span><br><span class="line">public Q_SLOTS :</span><br><span class="line">private:</span><br><span class="line">    int getImageFormat(std::string path);</span><br><span class="line">    long getBMPSize(std::string path);</span><br><span class="line">    long getGIFSize(std::string path);</span><br><span class="line">    long getPNGSize(std::string path);</span><br><span class="line">    long getJPGSize(std::string path);</span><br><span class="line">    QSize getBMPDimension(std::string path);</span><br><span class="line">    QSize getPNGDimension(std::string path);</span><br><span class="line">    QSize getJPGDimension(std::string path);</span><br><span class="line">    QSize getGIFDimension(std::string path);</span><br><span class="line">&#125;;</span><br><span class="line">#endif // IMAGEINFO_H</span><br></pre></td></tr></table></figure><p>imageinfo.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"imageinfo.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileInfo&gt;</span></span></span><br><span class="line"></span><br><span class="line">ImageInfo::ImageInfo(QObject *parent) :</span><br><span class="line">    QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"---------------------------- image info constructed "</span>;</span><br><span class="line">&#125;</span><br><span class="line">ImageInfo::~ImageInfo()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">QDate ImageInfo::getImageDate(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QDate date;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            date = fileinfo.lastModified().date();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从文件头中读取相应字段以判断图片格式</span></span><br><span class="line"><span class="comment">//详情参看: http://www.garykessler.net/library/file_sigs.html</span></span><br><span class="line"><span class="keyword">int</span> ImageInfo::getImageFormat(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//BMP格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> BMPHeader[] = &#123;<span class="number">0x42</span>, <span class="number">0x4d</span>&#125;;</span><br><span class="line">    <span class="comment">//JPG,JPEG格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader1[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xdb</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader2[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader3[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe1</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader4[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe2</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader5[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe3</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader6[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe8</span>&#125;;</span><br><span class="line">    <span class="comment">//GIF格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> GIFHeader1[] = &#123;<span class="number">0x47</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x38</span>, <span class="number">0x37</span>, <span class="number">0x61</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> GIFHeader2[] = &#123;<span class="number">0x47</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x61</span>&#125;;</span><br><span class="line">    <span class="comment">//PNG格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> PNGHeader[] = &#123;<span class="number">0x89</span>, <span class="number">0x50</span>, <span class="number">0x4E</span>, <span class="number">0x47</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//以二进制方式打开文件并读取前几个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> header[<span class="number">16</span>];</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"文件路径: "</span>&lt;&lt;path.c_str();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">readf</span><span class="params">(path.c_str(), <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!readf.is_open()) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> NVL_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先读两个，判断是否BMP格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(header, BMPHeader, count) == <span class="number">0</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"BMP格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> BMP_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读两个，判断是否JPG格式、PNG格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">memcmp</span>(header, JPGHeader1, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader2, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader3, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader4, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader5, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader6, count) == <span class="number">0</span>)) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"JPG格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> JPG_FORMAT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">memcmp</span>(header, PNGHeader, count) == <span class="number">0</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"PNG格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> PNG_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读两个，判断是否GIF格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">memcmp</span>(header, GIFHeader1, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, GIFHeader2, count) == <span class="number">0</span>)) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"GIF格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> GIF_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"不属于以上任何一种格式"</span>;</span><br><span class="line">    <span class="keyword">return</span> NVL_FORMAT;</span><br><span class="line">&#125;</span><br><span class="line">QString ImageInfo::getImageFormat(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QString strFormat = <span class="string">"NA"</span>;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> path = filePath.toStdString();</span><br><span class="line">            <span class="keyword">int</span> iFormat = getImageFormat(path);</span><br><span class="line">            <span class="keyword">switch</span>(iFormat) &#123;</span><br><span class="line">            <span class="keyword">case</span> BMP_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"BMP"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JPG_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"JPG"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GIF_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"GIF"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PNG_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"PNG"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strFormat;</span><br><span class="line">&#125;</span><br><span class="line">QString ImageInfo::getImageSize(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QString strSize;</span><br><span class="line">    <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            <span class="keyword">bool</span> ret = file.open(QIODevice::ReadOnly);</span><br><span class="line">            <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size = file.size();</span><br><span class="line">            &#125;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"!!!!!"</span>&lt;&lt;size;</span><br><span class="line">    strSize = QString::number(size, <span class="number">10</span>);</span><br><span class="line">    qDebug()&lt;&lt;strSize;</span><br><span class="line">    <span class="keyword">return</span> strSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BMP文件头的第2、3字为文件大小信息</span></span><br><span class="line"><span class="keyword">long</span> ImageInfo::getBMPSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">if</span>((fid=fopen(path.c_str(),<span class="string">"rb+"</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳过图片特征码</span></span><br><span class="line">    fseek(fid, <span class="number">2</span>, SEEK_SET);</span><br><span class="line">    fread(&amp;size, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    fclose(fid);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"size="</span>&lt;&lt;size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> ImageInfo::getGIFSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> ImageInfo::getPNGSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> ImageInfo::getJPGSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">if</span>((fid = fopen(path.c_str(),<span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fid, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = ftell(fid);</span><br><span class="line">    fclose(fid);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"size="</span>&lt;&lt;size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BMP文件头的第10、11字为文件宽度信息</span></span><br><span class="line"><span class="comment">//BMP文件头的第12、13字为文件高度信息</span></span><br><span class="line">QSize ImageInfo::getBMPDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">if</span>((fid=fopen(path.c_str(),<span class="string">"rb+"</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">//读取宽度和高度</span></span><br><span class="line">    fseek(fid, <span class="number">18</span>, SEEK_SET); <span class="comment">//偏移18个字节</span></span><br><span class="line">    fread(&amp;width, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    fread(&amp;height, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    fclose(fid);</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考： http://mcljc.blog.163.com/blog/static/83949820102239610974/</span></span><br><span class="line"><span class="comment">//http://download.csdn.net/download/chp845/4255011</span></span><br><span class="line">QSize ImageInfo::getJPGDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">if</span>((fid = fopen(path.c_str(),<span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    fseek(fid,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="keyword">long</span> length = ftell(fid);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[length];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer_bakup = buffer;</span><br><span class="line">    fseek(fid, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    fread(buffer, length, <span class="number">1</span>, fid);</span><br><span class="line">    fclose(fid);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *temp = buffer + length;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *temp_ori = buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ff;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type=<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> m_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//跳过文件头中标志文件类型的两个字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">        buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((temp &gt; buffer) &amp;&amp; (type != <span class="number">0xDA</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ff = *buffer++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(ff != <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            type = *buffer++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(type == <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD7</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xC0</span>:<span class="comment">//SOF0段</span></span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            buffer++; <span class="comment">//舍弃精度值</span></span><br><span class="line">            height = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            height += *buffer++;</span><br><span class="line">            width = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            width += *buffer;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xE0</span>: <span class="comment">//APP0段</span></span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"APP0段"</span>;</span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            buffer = buffer + <span class="number">12</span>;</span><br><span class="line">            <span class="comment">//丢弃APP0标记(5bytes)、主版本号(1bytes)、次版本号(1bytes)、像素点单位(1bytes)、垂直像素点(2bytes)、 水平像素点(2bytes)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = temp_ori + m_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    <span class="comment">//记得释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer_bakup;</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PNG文件头的第9字为文件宽度信息</span></span><br><span class="line"><span class="comment">//PNG文件头的第10字为文件高度信息</span></span><br><span class="line"><span class="comment">//参考：http://blog.chinaunix.net/uid-25799257-id-3358174.html</span></span><br><span class="line">QSize ImageInfo::getPNGDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((fid=fopen(path.c_str(),<span class="string">"rb+"</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> wtmp[<span class="number">4</span>]=&#123;<span class="string">'0'</span>&#125;;   <span class="comment">//宽度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> htmp[<span class="number">4</span>]=&#123;<span class="string">'0'</span>&#125;;   <span class="comment">//高度</span></span><br><span class="line">    fseek(fid, <span class="number">16</span>, SEEK_SET);</span><br><span class="line">    fread(wtmp, <span class="number">4</span>, <span class="number">1</span>, fid);         <span class="comment">// example 00000080</span></span><br><span class="line">    fread(htmp, <span class="number">4</span>, <span class="number">1</span>, fid);         <span class="comment">// example 00000080</span></span><br><span class="line">    fclose(fid);</span><br><span class="line">    width = ((<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)wtmp[<span class="number">2</span>]) * <span class="number">256</span> + (<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)wtmp[<span class="number">3</span>];</span><br><span class="line">    height = ((<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)htmp[<span class="number">2</span>]) * <span class="number">256</span> + (<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)htmp[<span class="number">3</span>];</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GIF文件头的第4字为文件宽度信息</span></span><br><span class="line"><span class="comment">//GIF文件头的第5字为文件高度信息</span></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/zhaoweikid/article/details/156422</span></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/asaasa66/article/details/5875340</span></span><br><span class="line">QSize ImageInfo::getGIFDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">ffin</span><span class="params">(path.c_str(), <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ffin)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Can not open this file."</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;, s2[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ffin.seekg(<span class="number">6</span>);</span><br><span class="line">    ffin.read(s1, <span class="number">2</span>);</span><br><span class="line">    ffin.read(s2, <span class="number">2</span>);</span><br><span class="line">    width = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s1[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>|(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s1[<span class="number">0</span>]);</span><br><span class="line">    height = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s2[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>|(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s2[<span class="number">0</span>]);</span><br><span class="line">    ffin.close();</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line">QSize ImageInfo::getImageDimension(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QSize dimension;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> path = filePath.toStdString();</span><br><span class="line">            <span class="keyword">int</span> iFormat = getImageFormat(path);</span><br><span class="line">            <span class="keyword">switch</span>(iFormat) &#123;</span><br><span class="line">            <span class="keyword">case</span> BMP_FORMAT:</span><br><span class="line">                dimension = getBMPDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JPG_FORMAT:</span><br><span class="line">                dimension = getJPGDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GIF_FORMAT:</span><br><span class="line">                dimension = getGIFDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PNG_FORMAT:</span><br><span class="line">                dimension = getPNGDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"图片尺寸:"</span>&lt;&lt;dimension;</span><br><span class="line">    <span class="keyword">return</span> dimension;</span><br><span class="line">&#125;</span><br><span class="line">QString ImageInfo::getImageTitle(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QString title;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            title = fileinfo.baseName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;图片文件头标识分析&quot;&gt;&lt;a href=&quot;#图片文件头标识分析&quot; class=&quot;headerlink&quot; title=&quot;图片文件头标识分析&quot;&gt;&lt;/a&gt;图片文件头标识分析&lt;/h3&gt;&lt;p&gt;一个图片文件的后缀名并不能说明这个图片的真正格式什么，读取图片文件的文件头标识可以获
      
    
    </summary>
    
    
      <category term="Pic" scheme="https://lxb.wiki/categories/Pic/"/>
    
    
      <category term="Pic" scheme="https://lxb.wiki/tags/Pic/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.14 中接口的菱形组合</title>
    <link href="https://lxb.wiki/ace0b2ab/"/>
    <id>https://lxb.wiki/ace0b2ab/</id>
    <published>2020-06-01T13:00:20.000Z</published>
    <updated>2020-06-01T13:03:28.408Z</updated>
    
    <content type="html"><![CDATA[<p>按照<a href="https://github.com/golang/proposal/blob/master/design/6977-overlapping-interfaces.md" target="_blank" rel="noopener">部分重叠的接口提议</a>，Go 1.14 现在允许嵌入有部分方法重叠的接口。本文是一篇解释这次修改的简要说明。</p><p>我们先来看 io 包中的三个关键接口：io.Reader、io.Writer 和 io.Closer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在结构体中嵌入类型时，如果在结构体中声明了被嵌入的类型，那么该类型的字段和方法允许被访问<a href="也就是说，嵌入提升了类型的字段和方法。">^1</a>，对于接口来说这个处理也成立。因此下面两种方式：显式声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Read([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和使用嵌入来组成接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有区别。</p><p>你甚至可以混合使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在 Go 1.14 之前，如果你用这种方式来声明接口，你可能会得到类似这样的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">ReadCloser</span><br><span class="line">WriterCloser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% Go build interfaces.go</span><br><span class="line"><span class="built_in">command</span>-line-arguments</span><br><span class="line">./interfaces.go:27:2: duplicate method Close</span><br></pre></td></tr></table></figure><p>幸运的是，在 Go 1.14 中这不再是一个限制了，因此这个改动解决了在菱形嵌入时出现的问题。</p><p>然而，在我向本地的用户组解释这个特性时也陷入了麻烦 — 只有 Go 编译器使用 1.14（或更高版本）语言规范时才支持这个特性。</p><p>我理解的编译过程中 Go 语言规范所使用的版本的规则似乎是这样的：</p><ol><li>如果你的源码是在 GOPATH 下（或者你用 GO111MODULE=off <em>关闭</em>了 module），那么 Go 语言规范会使用你编译器的版本来编译。换句话说，如果安装了 Go 1.13，那么你的 Go 版本就是 1.13。如果你安装了 Go 1.14，那么你的版本就是 1.14。这里符合认知。</li><li>如果你的源码保存在 GOPATH 外（或你用 GO111MODULE=on 强制开启了 module），那么 Go tool 会从 go.mod 文件中获取 Go 版本。</li><li>如果 go.mod 中没有列出 Go 版本，那么语言规范会使用安装的 Go 的版本。这跟第 1 点是一致的。</li><li>如果你用的是 Go module 模式，不管是源码在 GOPATH 外还是设置了 GO111MODULE=on，但是在当前目录或所有父目录中都没有 go.mod 文件，那么 Go 语言规范会默认用 Go 1.13 版本来编译你的代码。</li></ol><p>我曾经遇到过第 4 点的情况。</p><hr><p>via: <a href="https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14" target="_blank" rel="noopener">https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14</a></p><p>作者：<a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a> </p><p>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> </p><p>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;按照&lt;a href=&quot;https://github.com/golang/proposal/blob/master/design/6977-overlapping-interfaces.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;部分重叠的接口提议
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装TT-RSS</title>
    <link href="https://lxb.wiki/afdc720c/"/>
    <id>https://lxb.wiki/afdc720c/</id>
    <published>2020-05-30T14:05:48.000Z</published>
    <updated>2020-05-30T14:07:10.012Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tt-rss.org/" target="_blank" rel="noopener">Tiny Tiny RSS</a>（TT-RSS）是一个自由开源的基于 Web 的新闻<ruby>馈送<rt>feed</rt></ruby>（RSS/Atom）阅读器和聚合工具。它非常适合那些注重隐私，并且仍然依赖 RSS 来获取日常新闻的人。TT-RSS 是自行托管的软件，因此你可以 100% 的掌控你的服务器、数据以及你的全部隐私。它还支持大量的插件、扩展和主题。你喜欢黑暗模式的界面？没问题。想基于关键词过滤发来的消息？TT-RSS 也能让你得偿所愿。</p><p><img src="https://opensource.com/sites/default/files/uploads/tt-rss.jpeg" alt="Tiny Tiny RSS screenshot" title="Tiny Tiny RSS screenshot"></p><p>现在你知道 TT-RSS 是什么了，那么为什么你可能会想用它。我会讲述要把它安装到树莓派或 Debian 10 服务器上你需要了解的所有的东西。</p><h3 id="安装和配置-TT-RSS"><a href="#安装和配置-TT-RSS" class="headerlink" title="安装和配置 TT-RSS"></a>安装和配置 TT-RSS</h3><p>要把 TT-RSS 安装到树莓派上，你还需要安装和配置最新版本的 PHP（本文撰写时 PHP 最新版本是 7.3）、后端数据库 PostgreSQL、Nginx web 服务器、Git，最后才是 TT-RSS。</p><h4 id="1、安装-PHP-7"><a href="#1、安装-PHP-7" class="headerlink" title="1、安装 PHP 7"></a>1、安装 PHP 7</h4><p>安装 PHP 7 是整个过程中最复杂的部分。幸运的是，它并不像看起来那样困难。从安装下面的支持包开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y ca-certificates apt-transport-https</span><br></pre></td></tr></table></figure><p>现在，添加存储库 PGP 密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q https://packages.sury.org/php/apt.gpg -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>下一步，把 PHP 库添加到你的 apt 源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;deb https://packages.sury.org/php/ buster main&quot; | sudo tee /etc/apt/sources.list.d/php.list</span><br></pre></td></tr></table></figure><p>然后更新你的存储库索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure><p>最后，安装 PHP 7.3（或最新版本）和一些通用组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y php7.3 php7.3-cli php7.3-fpm php7.3-opcache php7.3-curl php7.3-mbstring php7.3-pgsql php7.3-zip php7.3-xml php7.3-gd php7.3-intl</span><br></pre></td></tr></table></figure><p>上面的命令默认你使用的后端数据库是 PostgreSQL，会安装 <code>php7.3-pgsql</code>。如果你想用 MySQL 或 MariaDB，你可以把命令参数改为 <code>php7.3-mysql</code>。</p><p>下一步，确认 PHP 已安装并在你的树莓派上运行着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php -v</span><br></pre></td></tr></table></figure><p>现在是时候安装和配置 Web 服务器了。</p><h4 id="2、安装-Nginx"><a href="#2、安装-Nginx" class="headerlink" title="2、安装 Nginx"></a>2、安装 Nginx</h4><p>可以用下面的命令安装 Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y nginx</span><br></pre></td></tr></table></figure><p>修改默认的 Nginx 虚拟主机配置，这样 Web 服务器才能识别 PHP 文件以及知道如何处理它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>你可以安全地删除原文件中的所有内容，用下面的内容替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        server_name _;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">          include snippets/fastcgi-php.conf;</span><br><span class="line">          fastcgi_pass unix:/run/php/php7.3-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 <code>Ctrl+O</code> 保存修改后的配置文件，然后按 <code>Ctrl+X</code> 退出 Nano。你可以用下面的命令测试你的新配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t</span><br></pre></td></tr></table></figure><p>如果没有报错，重启 Nginx 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart nginx</span><br></pre></td></tr></table></figure><h4 id="3、安装-PostgreSQL"><a href="#3、安装-PostgreSQL" class="headerlink" title="3、安装 PostgreSQL"></a>3、安装 PostgreSQL</h4><p>接下来是安装数据库服务器。在树莓派上安装 PostgreSQL 超级简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y postgresql postgresql-client postgis</span><br></pre></td></tr></table></figure><p>输入下面的命令看一下数据库服务器安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ psql --version</span><br></pre></td></tr></table></figure><h4 id="4、创建-Tiny-Tiny-RSS-数据库"><a href="#4、创建-Tiny-Tiny-RSS-数据库" class="headerlink" title="4、创建 Tiny Tiny RSS 数据库"></a>4、创建 Tiny Tiny RSS 数据库</h4><p>在做其他事之前，你需要创建一个数数据库，用来给 TT-RSS 软件保存数据。首先，登录 PostgreSQL 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql</span><br></pre></td></tr></table></figure><p>下一步，新建一个用户，设置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER username WITH PASSWORD &apos;your_password&apos; VALID UNTIL &apos;infinity&apos;;</span><br></pre></td></tr></table></figure><p>然后创建一个给 TT-RSS 用的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE tinyrss;</span><br></pre></td></tr></table></figure><p>最后，给新建的用户赋最高权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON DATABASE tinyrss to user_name;</span><br></pre></td></tr></table></figure><p>这是安装数据库的步骤。你可以输入 <code>\q</code> 来退出 <code>psql</code> 程序。</p><h4 id="5、安装-Git"><a href="#5、安装-Git" class="headerlink" title="5、安装 Git"></a>5、安装 Git</h4><p>安装 TT-RSS 需要用 Git，所以输入下面的命令安装 Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git -y</span><br></pre></td></tr></table></figure><p>现在，进入到 Nginx 服务器的根目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/www/html</span><br></pre></td></tr></table></figure><p>下载 TT-RSS 最新源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://git.tt-rss.org/fox/tt-rss.git tt-rss</span><br></pre></td></tr></table></figure><p>注意，这一步会创建一个 <code>tt-rss</code> 文件夹。</p><h4 id="6、安装和配置Tiny-Tiny-RSS"><a href="#6、安装和配置Tiny-Tiny-RSS" class="headerlink" title="6、安装和配置Tiny Tiny RSS"></a>6、安装和配置Tiny Tiny RSS</h4><p>现在是安装和配置你的新 TT-RSS 服务器的最后时刻了。首先，确认下你在浏览器中能打开 <code>http://your.site/tt-rss/install/index.php</code>。如果浏览器显示 <code>403 Forbidden</code>，那么就证明 <code>/var/www/html</code> 文件夹的权限没有设置正确。下面的命令通常能解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 /var/www/html/ -v</span><br></pre></td></tr></table></figure><p>如果一切正常，你会看到 TT-RSS 安装页面，它会让你输入一些数据的信息。你只需要输入前面你创建的数据库用户名和密码；数据库名；主机名填 <code>localhost</code>；端口填 <code>5432</code>。</p><p>点击“Test Configuration”。如果一切正常，你会看到一个标记着“Initialize Database”的红色按钮。点击它来开始安装。结束后，你会看到一个配置文件，你可以把它复制到 TT-RSS 的目录，另存为 <code>config.php</code>。</p><p>安装过程结束后，浏览器输入 <code>http://yoursite/tt-rss/</code> 打开 TT-RSS，使用默认的凭证登录（用户名：<code>admin</code>，密码：<code>password</code>）。登录后系统会提示你修改密码。我强烈建议你尽快修改密码。</p><h3 id="配置-TT-RSS"><a href="#配置-TT-RSS" class="headerlink" title="配置 TT-RSS"></a>配置 TT-RSS</h3><p>如果一切正常，你现在就可以开始使用 TT-RSS 了。建议你新建一个非管理员用户，使用新用户名登录，并开始导入你的馈送、订阅，按照你的意愿来配置它。</p><p>最后，并且是超级重要的事，不要忘了阅读 TT-RSS 维基上的 <a href="https://tt-rss.org/wiki/UpdatingFeeds" target="_blank" rel="noopener">Updating Feeds</a> 部分。它讲述了如何创建一个简单的 systemd 服务来更新馈送。如果你跳过了这一步，你的 RSS 馈送就不会自动更新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>呵！工作量不小，但是你做完了！你现在有自己的 RSS 聚合服务器了。想了解 TT-RSS 更多的知识？我推荐你去看官方的 <a href="https://tt-rss.org/wiki/FAQ" target="_blank" rel="noopener">FAQ</a>、<a href="https://community.tt-rss.org/c/tiny-tiny-rss/support" target="_blank" rel="noopener">支持</a>论坛，和详细的<a href="https://tt-rss.org/wiki/InstallationNotes" target="_blank" rel="noopener">安装</a>笔记。如果你有任何问题，尽情地在下面评论吧。</p><hr><p>via: <a href="https://opensource.com/article/20/2/ttrss-raspberry-pi" target="_blank" rel="noopener">https://opensource.com/article/20/2/ttrss-raspberry-pi</a></p><p>作者：<a href="https://opensource.com/users/pmullins" target="_blank" rel="noopener">Patrick H. Mullins</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://tt-rss.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tiny Tiny RSS&lt;/a&gt;（TT-RSS）是一个自由开源的基于 Web 的新闻&lt;ruby&gt;馈送&lt;rt&gt;feed&lt;/rt&gt;&lt;/ruby&gt;（RSS/
      
    
    </summary>
    
    
      <category term="RPI" scheme="https://lxb.wiki/categories/RPI/"/>
    
    
      <category term="树莓派" scheme="https://lxb.wiki/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>通过禁止比较让 Go 二进制文件变小</title>
    <link href="https://lxb.wiki/27d7ea27/"/>
    <id>https://lxb.wiki/27d7ea27/</id>
    <published>2020-05-23T04:24:34.000Z</published>
    <updated>2020-05-23T04:41:28.498Z</updated>
    
    <content type="html"><![CDATA[<!-----![](https://img.linux.net.cn/data/attachment/album/202005/22/101617lcha7vvqzhh7d565.jpg)------><p>大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件就越大。这个符合直觉，毕竟如果你写的代码不去操作定义的类型，那么定义一堆类型就没有意义了。然而，链接器的部分工作就是检测没有被程序引用的函数（比如说它们是一个库的一部分，其中只有一个子集的功能被使用），然后把它们从最后的编译产出中删除。常言道，“类型越多，二进制文件越大”，对于多数 Go 程序还是正确的。</p><p>本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么<a href="https://github.com/golang/net/commit/e0ff5e5a1de5b859e2d48a2830d7933b3ab5b75f" target="_blank" rel="noopener">像这样</a>的修改会对 Go 程序的大小有重大的影响。</p><h3 id="定义两个值相等"><a href="#定义两个值相等" class="headerlink" title="定义两个值相等"></a>定义两个值相等</h3><p>Go 的语法定义了“赋值”和“相等”的概念。赋值是把一个值赋给一个标识符的行为。并不是所有声明的标识符都可以被赋值，如常量和函数就不可以。相等是通过检查标识符的内容是否相等来比较两个标识符的行为。</p><p>作为强类型语言，“相同”的概念从根源上被植入标识符的类型中。两个标识符只有是相同类型的前提下，才有可能相同。除此之外，值的类型定义了如何比较该类型的两个值。</p><p>例如，整型是用算数方法进行比较的。对于指针类型，是否相等是指它们指向的地址是否相同。映射和通道等引用类型，跟指针类似，如果它们指向相同的地址，那么就认为它们是相同的。</p><p>上面都是按位比较相等的例子，即值占用的内存的位模式是相同的，那么这些值就相等。这就是所谓的 memcmp，即内存比较，相等是通过比较两个内存区域的内容来定义的。</p><p>记住这个思路，我过会儿再来谈。</p><h3 id="结构体相等"><a href="#结构体相等" class="headerlink" title="结构体相等"></a>结构体相等</h3><p>除了整型、浮点型和指针等标量类型，还有复合类型：结构体。所有的结构体以程序中的顺序被排列在内存中。因此下面这个声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a, b, c, d int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会占用 32 字节的内存空间；<code>a</code> 占用 8 个字节，<code>b</code> 占用 8 个字节，以此类推。Go 的规则说如果结构体所有的字段都是可以比较的，那么结构体的值就是可以比较的。因此如果两个结构体所有的字段都相等，那么它们就相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">b := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">fmt.Println(a == b) // 输出 true</span><br></pre></td></tr></table></figure><p>编译器在底层使用 memcmp 来比较 <code>a</code> 的 32 个字节和 <code>b</code> 的 32 个字节。</p><h3 id="填充和对齐"><a href="#填充和对齐" class="headerlink" title="填充和对齐"></a>填充和对齐</h3><p>然而，在下面的场景下过分简单化的按位比较的策略会返回错误的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a byte</span><br><span class="line">    b uint64</span><br><span class="line">    c int16</span><br><span class="line">    d uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()</span><br><span class="line">    a := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">    b := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">    fmt.Println(a == b) // 输出 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译代码后，这个比较表达式的结果还是 <code>true</code>，但是编译器在底层并不能仅依赖比较 <code>a</code> 和 <code>b</code> 的位模式，因为结构体有<em>填充</em>。</p><p>Go 要求结构体的所有字段都对齐。2 字节的值必须从偶数地址开始，4 字节的值必须从 4 的倍数地址开始，以此类推。编译器根据字段的类型和底层平台加入了填充来确保字段都<em>对齐</em>。在填充之后，编译器实际上看到的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a byte</span><br><span class="line">    _ [7]byte // 填充</span><br><span class="line">    b uint64</span><br><span class="line">    c int16</span><br><span class="line">    _ [2]int16 // 填充</span><br><span class="line">    d uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充的存在保证了字段正确对齐，而填充确实占用了内存空间，但是填充字节的内容是未知的。你可能会认为在 Go 中 填充字节都是 0，但实际上并不是 — 填充字节的内容是未定义的。由于它们并不是被定义为某个确定的值，因此按位比较会因为分布在 <code>s</code> 的 24 字节中的 9 个填充字节不一样而返回错误结果。</p><p>Go 通过生成所谓的相等函数来解决这个问题。在这个例子中，<code>s</code> 的相等函数只比较函数中的字段略过填充部分，这样就能正确比较类型 <code>s</code> 的两个值。</p><h3 id="类型算法"><a href="#类型算法" class="headerlink" title="类型算法"></a>类型算法</h3><p>呵，这是个很大的设置，说明了为什么，对于 Go 程序中定义的每种类型，编译器都会生成几个支持函数，编译器内部把它们称作类型的算法。如果类型是一个映射的键，那么除相等函数外，编译器还会生成一个哈希函数。为了维持稳定，哈希函数在计算结果时也会像相等函数一样考虑诸如填充等因素。</p><p>凭直觉判断编译器什么时候生成这些函数实际上很难，有时并不明显，（因为）这超出了你的预期，而且链接器也很难消除没有被使用的函数，因为反射往往导致链接器在裁剪类型时变得更保守。</p><h3 id="通过禁止比较来减小二进制文件的大小"><a href="#通过禁止比较来减小二进制文件的大小" class="headerlink" title="通过禁止比较来减小二进制文件的大小"></a>通过禁止比较来减小二进制文件的大小</h3><p>现在，我们来解释一下 Brad 的修改。向类型添加一个不可比较的字段，结构体也随之变成不可比较的，从而强制编译器不再生成相等函数和哈希函数，规避了链接器对那些类型的消除，在实际应用中减小了生成的二进制文件的大小。作为这项技术的一个例子，下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    type t struct &#123;</span><br><span class="line">        // _ [0][]byte // 取消注释以阻止比较</span><br><span class="line">        a byte</span><br><span class="line">        b uint16</span><br><span class="line">        c int32</span><br><span class="line">        d uint64</span><br><span class="line">    &#125;</span><br><span class="line">    var a t</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 Go 1.14.2（darwin/amd64）编译，大小从 2174088 降到了 2174056，节省了 32 字节。单独看节省的这 32 字节似乎微不足道，但是考虑到你的程序中每个类型及其传递闭包都会生成相等和哈希函数，还有它们的依赖，这些函数的大小随类型大小和复杂度的不同而不同，禁止它们会大大减小最终的二进制文件的大小，效果比之前使用 <code>-ldflags=&quot;-s -w&quot;</code> 还要好。</p><p>最后总结一下，如果你不想把类型定义为可比较的，可以在源码层级强制实现像这样的奇技淫巧，会使生成的二进制文件变小。</p><hr><p>via: <a href="https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons" target="_blank" rel="noopener">https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons</a></p><p>作者：<a href="https://dave.cheney.net/author/davecheney" target="_blank" rel="noopener">Dave Cheney</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-----
![](https://img.linux.net.cn/data/attachment/album/202005/22/101617lcha7vvqzhh7d565.jpg)
------&gt;

&lt;p&gt;大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
      <category term="编译器" scheme="https://lxb.wiki/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="翻译" scheme="https://lxb.wiki/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Go：异步抢占</title>
    <link href="https://lxb.wiki/5698ca18/"/>
    <id>https://lxb.wiki/5698ca18/</id>
    <published>2020-05-05T07:24:46.000Z</published>
    <updated>2020-05-16T07:31:16.920Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p><p>ℹ️ 本文基于 Go 1.14。</p><p>抢占是调度器的重要部分，基于抢占调度器可以在各个协程中分配运行的时间。实际上，如果没有抢占机制，一个长时间占用 CPU 的协程会阻塞其他的协程被调度。1.14 版本引入了一项新的异步抢占的技术，赋予了调度器更大的能力和控制力。</p><p><em>我推荐你阅读我的文章<a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7" target="_blank" rel="noopener">”Go：协程和抢占“</a>来了解更多之前的特性和它的弊端。</em></p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>我们以一个需要抢占的例子来开始。下面一段代码开启了几个协程，在几个循环中没有其他的函数调用，意味着调度器没有机会抢占它们：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/01.png" alt></p><p>然而，当把这个程序的追踪过程可视化后，我们清晰地看到了协程间的抢占和切换：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/02.png" alt></p><p>我们还可以看到表示协程的每个块儿的长度都相等。所有的协程运行时间相同（约 10 到 20 毫秒）。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/03.png" alt></p><p>异步抢占是基于一个时间条件触发的。当一个协程运行超过 10ms 时，Go 会尝试抢占它。</p><p>抢占是由线程 <code>sysmon</code> 初始化的，该线程专门用于监控包括长时间运行的协程在内的运行时。当某个协程被检测到运行超过 10ms 后，<code>sysmon</code> 向当前的线程发出一个抢占信号。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/04.png" alt></p><p>之后，当信息被信号处理器接收到时，线程中断当前的操作来处理信号，因此不会再运行当前的协程，在我们的例子中是 <code>G7</code>。取而代之的是，<code>gsignal</code> 被调度为管理发送来的信号。当它发现它是一个抢占指令后，在程序处理信号后恢复时它准备好指令来中止当前的协程。下面是这第二个阶段的示意图：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/05.png" alt></p><p><em>如果你想了解更多关于 <code>gsignal</code> 的信息，我推荐你读一下我的文章<a href="https://medium.com/a-journey-with-go/go-gsignal-master-of-signals-329f7ff39391" target="_blank" rel="noopener">”Go：gsignal，信号的掌控者“</a>。</em></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们在被选中的信号 <code>SIGURG</code> 中第一次看到了实现的细节。这个选择在提案<a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">”提案：非合作式协程抢占“</a>中有详细的解释：</p><blockquote><ul><li>它应该是调试者默认传递过来的一个信号。</li><li>它不应该是 Go/C 混合二进制中 libc 内部使用的信号。</li><li>它应该是一个可以伪造而没有其他后果的信号。</li><li>我们需要在没有实时信号时与平台打交道。<br>然后，当信号被注入和接收时，Go 需要一种在程序恢复时能终止当前协程的方式。为了实现这个过程，Go 会把一条指令推进程序计数器，这样看起来运行中的程序调用了运行时的函数。该函数暂停了协程并把它交给了调度器，调度器之后还会运行其他的协程。</li></ul></blockquote><p><em>我们应该注意到 Go 不能做到在任何地方终止程序；当前的指令必须是一个安全点。例如，如果程序现在正在调用运行时，那么抢占协程并不安全，因为运行时很多函数不应该被抢占。</em></p><p>这个新的抢占机制也让垃圾回收器受益，可以用更高效的方式终止所有的协程。诚然，STW 现在非常容易，Go 仅需要向所有运行的线程发出一个信号就可以了。下面是垃圾回收器运行时的一个例子：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/06.png" alt></p><p>然后，所有的线程都接收到这个信号，在垃圾回收器重新开启全局之前会暂停执行。</p><p><em>如果你想了解更多关于 STW 的信息，我建议你阅读我的文章<a href="https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846" target="_blank" rel="noopener">”Go：Go 怎样实现 STW？“</a>。</em></p><p>最后，这个特性被封装在一个参数中，你可以用这个参数关闭异步抢占。你可以用 <code>GODEBUG=asyncpreemptoff=1</code> 来运行你的程序，如果你因为升级到了 Go 1.14 发现了不正常的现象就可以调试你的程序，或者观察你的程序有无异步抢占时的不同表现。</p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/00.png&quot; alt=&quot;Illustration
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Inlining Optimisations in Go</title>
    <link href="https://lxb.wiki/6ce34c49/"/>
    <id>https://lxb.wiki/6ce34c49/</id>
    <published>2020-04-29T13:05:10.000Z</published>
    <updated>2020-05-05T11:39:31.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-中的内联优化"><a href="#Go-中的内联优化" class="headerlink" title="Go 中的内联优化"></a>Go 中的内联优化</h1><blockquote><p>本文讨论 Go 编译器是如何实现内联的，以及这种优化方法如何影响你的 Go 代码。</p></blockquote><p><img src="https://img.linux.net.cn/data/attachment/album/202005/02/222202e3v3pppkhnndpbpn.jpg" alt></p><p><em>请注意：</em>本文重点讨论 <em>gc</em>，这是来自 <a href="https://github.com/golang/go" target="_blank" rel="noopener">golang.org</a> 的事实标准的 Go 编译器。讨论到的概念可以广泛适用于其它 Go 编译器，如 gccgo 和 llgo，但它们在实现方式和功效上可能有所差异。</p><h3 id="内联是什么？"><a href="#内联是什么？" class="headerlink" title="内联是什么？"></a>内联是什么？</h3><p><ruby>内联<rt>inlining</rt></ruby>就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经成为编译过程中自动实现的基本优化过程的其中一步。</p><h3 id="为什么内联很重要？"><a href="#为什么内联很重要？" class="headerlink" title="为什么内联很重要？"></a>为什么内联很重要？</h3><p>有两个原因。第一个是它消除了函数调用本身的开销。第二个是它使得编译器能更高效地执行其他的优化策略。</p><h4 id="函数调用的开销"><a href="#函数调用的开销" class="headerlink" title="函数调用的开销"></a>函数调用的开销</h4><p>在任何语言中，调用一个函数 [^1] 都会有消耗。把参数编组进寄存器或放入栈中（取决于 ABI），在返回结果时的逆反过程都会有开销。引入一次函数调用会导致程序计数器从指令流的一点跳到另一点，这可能导致管道滞后。函数内部通常有<ruby>前置处理<rt>preamble</rt></ruby>，需要为函数执行准备新的栈帧，还有与前置相似的<ruby>后续处理<rt>epilogue</rt></ruby>，需要在返回给调用方之前释放栈帧空间。</p><p>在 Go 中函数调用会消耗额外的资源来支持栈的动态增长。在进入函数时，goroutine 可用的栈空间与函数需要的空间大小进行比较。如果可用空间不同，前置处理就会跳到<ruby>运行时<rt>runtime</rt></ruby>的逻辑中，通过把数据复制到一块新的、更大的空间的来增长栈空间。当这个复制完成后，运行时就会跳回到原来的函数入口，再执行栈空间检查，现在通过了检查，函数调用继续执行。这种方式下，goroutine 开始时可以申请很小的栈空间，在有需要时再申请更大的空间。[^2]</p><p>这个检查消耗很小，只有几个指令，而且由于 goroutine 的栈是成几何级数增长的，因此这个检查很少失败。这样，现代处理器的分支预测单元可以通过假定检查肯定会成功来隐藏栈空间检查的消耗。当处理器预测错了栈空间检查，不得不放弃它在推测性执行所做的操作时，与为了增加 goroutine 的栈空间运行时所需的操作消耗的资源相比，管道滞后的代价更小。</p><p>虽然现代处理器可以用预测性执行技术优化每次函数调用中的泛型和 Go 特定的元素的开销，但那些开销不能被完全消除，因此在每次函数调用执行必要的工作过程中都会有性能消耗。一次函数调用本身的开销是固定的，与更大的函数相比，调用小函数的代价更大，因为在每次调用过程中它们做的有用的工作更少。</p><p>因此，消除这些开销的方法必须是要消除函数调用本身，Go 的编译器就是这么做的，在某些条件下通过用函数的内容来替换函数调用来实现。这个过程被称为<em>内联</em>，因为它在函数调用处把函数体展开了。</p><h4 id="改进的优化机会"><a href="#改进的优化机会" class="headerlink" title="改进的优化机会"></a>改进的优化机会</h4><p>Cliff Click 博士把内联描述为现代编译器做的优化措施，像常量传播（LCTT 译注：此处作者笔误，原文为 constant proportion，修正为 constant propagation）和死代码消除一样，都是编译器的基本优化方法。实际上，内联可以让编译器看得更深，使编译器可以观察调用的特定函数的上下文内容，可以看到能继续简化或彻底消除的逻辑。由于可以递归地执行内联，因此不仅可以在每个独立的函数上下文处进行这种优化决策，也可以在整个函数调用链中进行。</p><h3 id="实践中的内联"><a href="#实践中的内联" class="headerlink" title="实践中的内联"></a>实践中的内联</h3><p>下面这个例子可以演示内联的影响：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(<span class="number">-1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个基准，会得到如下结果：[^3]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=. </span><br><span class="line">BenchmarkMax-4   530687617         2.24 ns/op</span><br></pre></td></tr></table></figure><p>在我的 2015 MacBook Air 上 <code>max(-1, i)</code> 的耗时约为 2.24 纳秒。现在去掉 <code>//go:noinline</code> 编译指令，再看下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=. </span><br><span class="line">BenchmarkMax-4   1000000000         0.514 ns/op</span><br></pre></td></tr></table></figure><p>从 2.24 纳秒降到了 0.51 纳秒，或者从 <code>benchstat</code> 的结果可以看出，有 78% 的提升。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old time/op  new time/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.49ns ± 6%  -77.96%  (p=0.000 n=18+19)</span><br></pre></td></tr></table></figure><p>这个提升是从哪儿来的呢？</p><p>首先，移除掉函数调用以及与之关联的前置处理 [^4] 是主要因素。把 <code>max</code> 函数的函数体在调用处展开，减少了处理器执行的指令数量并且消除了一些分支。</p><p>现在由于编译器优化了 <code>BenchmarkMax</code>，因此它可以看到 <code>max</code> 函数的内容，进而可以做更多的提升。当 <code>max</code> 被内联后，<code>BenchmarkMax</code> 呈现给编译器的样子，看起来是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">-1</span> &gt; i &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行一次基准，我们看一下手动内联的版本和编译器内联的版本的表现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old time/op  new time/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.48ns ± 3%  -78.14%  (p=0.000 n=18+18)</span><br></pre></td></tr></table></figure><p>现在编译器能看到在 <code>BenchmarkMax</code> 里内联 <code>max</code> 的结果，可以执行以前不能执行的优化措施。例如，编译器注意到 <code>i</code> 初始值为 <code>0</code>，仅做自增操作，因此所有与 <code>i</code> 的比较都可以假定 <code>i</code> 不是负值。这样条件表达式 <code>-1 &gt; i</code> 永远不是 <code>true</code>。[^5]</p><p>证明了 <code>-1 &gt; i</code> 永远不为 true 后，编译器可以把代码简化为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且因为分支里是个常量，编译器可以通过下面的方式移除不会走到的分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = i</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过内联和由内联解锁的优化过程，编译器把表达式 <code>r = max(-1, i))</code> 简化为 <code>r = i</code>。</p><h3 id="内联的限制"><a href="#内联的限制" class="headerlink" title="内联的限制"></a>内联的限制</h3><p>本文中我论述的内联称作<ruby>叶子内联<rt>leaf inlining</rt></ruby>：把函数调用栈中最底层的函数在调用它的函数处展开的行为。内联是个递归的过程，当把函数内联到调用它的函数 A 处后，编译器会把内联后的结果代码再内联到 A 的调用方，这样持续内联下去。例如，下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxMaxMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(max(<span class="number">-1</span>, i), max(<span class="number">0</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的例子中的代码运行速度一样快，因为编译器可以对上面的代码重复地进行内联，也把代码简化到 <code>r = i</code> 表达式。</p><p>下一篇文章中，我会论述当 Go 编译器想要内联函数调用栈中间的某个函数时选用的另一种内联策略。最后我会论述编译器为了内联代码准备好要达到的极限，这个极限 Go 现在的能力还达不到。</p><p>[^1]: 在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。<br>[^2]: 在 Go 1.14 以前，栈检查的前置处理也被垃圾回收器用于 STW，通过把所有活跃的 goroutine 栈空间设为 0，来强制它们切换为下一次函数调用时的运行时状态。这个机制<a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">最近被替换</a>为一种新机制，新机制下运行时可以不用等 goroutine 进行函数调用就可以暂停 goroutine。<br>[^3]: 我用 <code>//go:noinline</code> 编译指令来阻止编译器内联 <code>max</code>。这是因为我想把内联 <code>max</code> 的影响与其他影响隔离开，而不是用 <code>-gcflags=&#39;-l -N&#39;</code> 选项在全局范围内禁止优化。关于 <code>//go:</code> 注释在<a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas" target="_blank" rel="noopener">这篇文章</a>中详细论述。<br>[^4]: 你可以自己通过比较 <code>go test -bench=. -gcflags=-S</code> 有无 <code>//go:noinline</code> 注释时的不同结果来验证一下。<br>[^5]: 你可以用 <code>-gcflags=-d=ssa/prove/debug=on</code> 选项来自己验证一下。</p><h4 id="相关文章："><a href="#相关文章：" class="headerlink" title="相关文章："></a>相关文章：</h4><ol><li><a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast" target="_blank" rel="noopener">使 Go 变快的 5 件事</a></li><li><a href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite" target="_blank" rel="noopener">为什么 Goroutine 的栈空间会无限增长？</a></li><li><a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go" target="_blank" rel="noopener">Go 中怎么写基准测试</a></li><li><a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas" target="_blank" rel="noopener">Go 中隐藏的编译指令</a></li></ol><hr><p>via: <a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go" target="_blank" rel="noopener">https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go</a></p><p>作者：<a href="https://dave.cheney.net/author/davecheney" target="_blank" rel="noopener">Dave Cheney</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Go-中的内联优化&quot;&gt;&lt;a href=&quot;#Go-中的内联优化&quot; class=&quot;headerlink&quot; title=&quot;Go 中的内联优化&quot;&gt;&lt;/a&gt;Go 中的内联优化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文讨论 Go 编译器是如何实现内联的，以及这种优化方法如
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
      <category term="编译器" scheme="https://lxb.wiki/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>树莓派做BT下载器</title>
    <link href="https://lxb.wiki/fb1d9193/"/>
    <id>https://lxb.wiki/fb1d9193/</id>
    <published>2020-03-11T14:29:00.000Z</published>
    <updated>2020-05-10T19:40:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>可以用 <a href="https://www.transmissionbt.com/" target="_blank" rel="noopener">transmission</a>，它提供了 Web 界面</p><h4 id="1-安装-transmission："><a href="#1-安装-transmission：" class="headerlink" title="1. 安装 transmission："></a>1. 安装 transmission：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install transmission-daemon</span><br></pre></td></tr></table></figure><h4 id="2-创建下载目录，一个是下载完成的目录，一个是未完成的目录"><a href="#2-创建下载目录，一个是下载完成的目录，一个是未完成的目录" class="headerlink" title="2. 创建下载目录，一个是下载完成的目录，一个是未完成的目录"></a>2. 创建下载目录，一个是下载完成的目录，一个是未完成的目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Public/bt_complete</span><br><span class="line">mkdir Public/bt_incomplete</span><br></pre></td></tr></table></figure><h3 id="3-配置目录权限"><a href="#3-配置目录权限" class="headerlink" title="3. 配置目录权限"></a>3. 配置目录权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G debian-transmission pi</span><br><span class="line">sudo chgrp debian-transmission bt_complete</span><br><span class="line">sudo chgrp debian-transmission bt_incomplete</span><br><span class="line">sudo chmod 770 bt_complete</span><br><span class="line">sudo chmod 770 bt_incomplete</span><br></pre></td></tr></table></figure><h4 id="4-修改配置文件-etc-transmission-daemon-settings-json"><a href="#4-修改配置文件-etc-transmission-daemon-settings-json" class="headerlink" title="4. 修改配置文件 /etc/transmission-daemon/settings.json"></a>4. 修改配置文件 /etc/transmission-daemon/settings.json</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;download-dir&quot;:&quot;/home/pi/Public/bt_complete&quot;</span><br><span class="line">&quot;incomplete-dir&quot;:&quot;/home/pi/Public/bt_incomplete&quot;</span><br><span class="line">&quot;rpc-host-whitelist&quot;: &quot;192.168.1.*&quot;,</span><br></pre></td></tr></table></figure><h4 id="5-重启-transmission"><a href="#5-重启-transmission" class="headerlink" title="5. 重启 transmission"></a>5. 重启 transmission</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service transmission-daemon reload</span><br><span class="line">sudo service transmission-daemon restart</span><br></pre></td></tr></table></figure><p>两个命令按顺序执行，单独 restart 的话配置不会保存：</p><p>浏览器中输入 <code>http://192.168.1.8:9091/</code>，默认用户名密码：<code>transmission</code></p><p><strong>修改 transmission 用户名和密码的方法：</strong></p><ol><li>先停止服务： <code>sudo service transmission-daemon stop</code></li><li>修改配置文件，看到这个是加密的密码，直接把密码改为密码明文就可以：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“rpc-username”: “明文”,</span><br><span class="line">“rpc-password”: “密文”,</span><br></pre></td></tr></table></figure><ol start="3"><li>再此启动服务 ：<code>sudo service transmission-daemon start</code><br>  启动的时候 transmission 会自动把新密码加密。</li></ol><p><strong>transmission 默认监听 51413 端口，最好在路由器上做个端口转发，把这个端口转到它的 IP 地址</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以用 &lt;a href=&quot;https://www.transmissionbt.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;transmission&lt;/a&gt;，它提供了 Web 界面&lt;/p&gt;
&lt;h4 id=&quot;1-安装-transmission：&quot;
      
    
    </summary>
    
    
      <category term="RPI" scheme="https://lxb.wiki/categories/RPI/"/>
    
    
      <category term="torrent" scheme="https://lxb.wiki/tags/torrent/"/>
    
  </entry>
  
  <entry>
    <title>树莓派搭建GitHub镜像服务</title>
    <link href="https://lxb.wiki/2073ae8b/"/>
    <id>https://lxb.wiki/2073ae8b/</id>
    <published>2020-03-10T11:03:42.000Z</published>
    <updated>2020-05-20T15:37:42.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-树莓派上创建-git-账号，创建用于存放代码的目录"><a href="#1-树莓派上创建-git-账号，创建用于存放代码的目录" class="headerlink" title="1.  树莓派上创建 git 账号，创建用于存放代码的目录"></a>1.  树莓派上创建 git 账号，创建用于存放代码的目录</h3><p><code>/srv/</code></p><h3 id="2-GitHub-库-clone-到树莓派"><a href="#2-GitHub-库-clone-到树莓派" class="headerlink" title="2. GitHub 库 clone 到树莓派"></a>2. GitHub 库 clone 到树莓派</h3><p><code>git clone git@github.com:user/XXXX.git /srv/</code></p><h3 id="3-添加-remote"><a href="#3-添加-remote" class="headerlink" title="3. 添加 remote"></a>3. 添加 remote</h3><p><code>git remote add upstream https://github.com/abcd/XXXX</code></p><h3 id="4-修改-hook"><a href="#4-修改-hook" class="headerlink" title="4. 修改 hook"></a>4. 修改 hook</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.git/hooks/post-update</span></span><br><span class="line">param=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">push_branch=<span class="variable">$&#123;param##refs/heads/&#125;</span> <span class="comment">#获取到更新的分支名</span></span><br><span class="line">git push origin <span class="variable">$push_branch</span></span><br></pre></td></tr></table></figure><h3 id="5-添加定时任务"><a href="#5-添加定时任务" class="headerlink" title="5. 添加定时任务"></a>5. 添加定时任务</h3><p><code>5,35 * * * * cd /srv/XXXX &amp;&amp; git pull upstream master</code></p><h3 id="6-在本地代码添加-remote"><a href="#6-在本地代码添加-remote" class="headerlink" title="6. 在本地代码添加 remote"></a>6. 在本地代码添加 remote</h3><h4 id="6-1-有多个项目时，为避免修改每个项目的-remote，直接添加-host"><a href="#6-1-有多个项目时，为避免修改每个项目的-remote，直接添加-host" class="headerlink" title="6.1 有多个项目时，为避免修改每个项目的 remote，直接添加 host"></a>6.1 有多个项目时，为避免修改每个项目的 remote，直接添加 host</h4><p><code>192.168.1.8 gitsrv</code></p><h4 id="6-2-在每个项目在添加一次-remote"><a href="#6-2-在每个项目在添加一次-remote" class="headerlink" title="6.2 在每个项目在添加一次 remote"></a>6.2 在每个项目在添加一次 remote</h4><p><code>git remote add pi git@192.168.1.8:/srv/XXXX</code></p><p>这样即使以后地址改变，只需要改一次 host 就可以了</p><h3 id="7-推拉代码时，从-pi-推拉"><a href="#7-推拉代码时，从-pi-推拉" class="headerlink" title="7. 推拉代码时，从 pi 推拉"></a>7. 推拉代码时，从 pi 推拉</h3><p><code>git pull pi branch</code></p><p><code>git push pi branch</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-树莓派上创建-git-账号，创建用于存放代码的目录&quot;&gt;&lt;a href=&quot;#1-树莓派上创建-git-账号，创建用于存放代码的目录&quot; class=&quot;headerlink&quot; title=&quot;1.  树莓派上创建 git 账号，创建用于存放代码的目录&quot;&gt;&lt;/a&gt;1. 
      
    
    </summary>
    
    
      <category term="RPI" scheme="https://lxb.wiki/categories/RPI/"/>
    
    
      <category term="GitHub" scheme="https://lxb.wiki/tags/GitHub/"/>
    
      <category term="树莓派" scheme="https://lxb.wiki/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>非实时信号表</title>
    <link href="https://lxb.wiki/c77ce28f/"/>
    <id>https://lxb.wiki/c77ce28f/</id>
    <published>2020-02-15T11:19:45.000Z</published>
    <updated>2020-05-05T14:53:40.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h1><p>Linux系统共定义了64种信号，分为两大类：可靠信号与不可靠信号，前32种信号为不可靠信号，后32种为可靠信号。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>不可靠信号： 也称为非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为<code>1~31</code>；<br>可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为<code>32~64</code></p><h3 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h3><p>在终端，可通过kill -l查看所有的signal信号</p><table><thead><tr><th align="left">取值</th><th align="left">名称</th><th align="left">解释</th><th align="left">默认动作</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIGHUP</td><td align="left">挂起</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">SIGINT</td><td align="left">中断</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">SIGQUIT</td><td align="left">退出</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">SIGILL</td><td align="left">非法指令</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">SIGTRAP</td><td align="left">断点或陷阱指令</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">SIGABRT</td><td align="left">abort发出的信号</td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">SIGBUS</td><td align="left">非法内存访问</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">SIGFPE</td><td align="left">浮点异常</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">SIGKILL</td><td align="left">kill信号</td><td align="left">不能被忽略、处理和阻塞</td></tr><tr><td align="left">10</td><td align="left">SIGUSR1</td><td align="left">用户信号1</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">SIGSEGV</td><td align="left">无效内存访问</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">SIGUSR2</td><td align="left">用户信号2</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">SIGPIPE</td><td align="left">管道破损，没有读端的管道写数据</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">SIGALRM</td><td align="left">alarm发出的信号</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">SIGTERM</td><td align="left">终止信号</td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">SIGSTKFLT</td><td align="left">栈溢出</td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">SIGCHLD</td><td align="left">子进程退出</td><td align="left">默认忽略</td></tr><tr><td align="left">18</td><td align="left">SIGCONT</td><td align="left">进程继续</td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">SIGSTOP</td><td align="left">进程停止</td><td align="left">不能被忽略、处理和阻塞</td></tr><tr><td align="left">20</td><td align="left">SIGTSTP</td><td align="left">进程停止</td><td align="left"></td></tr><tr><td align="left">21</td><td align="left">SIGTTIN</td><td align="left">进程停止，后台进程从终端读数据时</td><td align="left"></td></tr><tr><td align="left">22</td><td align="left">SIGTTOU</td><td align="left">进程停止，后台进程想终端写数据时</td><td align="left"></td></tr><tr><td align="left">23</td><td align="left">SIGURG</td><td align="left">I/O有紧急数据到达当前进程</td><td align="left">默认忽略</td></tr><tr><td align="left">24</td><td align="left">SIGXCPU</td><td align="left">进程的CPU时间片到期</td><td align="left"></td></tr><tr><td align="left">25</td><td align="left">SIGXFSZ</td><td align="left">文件大小的超出上限</td><td align="left"></td></tr><tr><td align="left">26</td><td align="left">SIGVTALRM</td><td align="left">虚拟时钟超时</td><td align="left"></td></tr><tr><td align="left">27</td><td align="left">SIGPROF</td><td align="left">profile时钟超时</td><td align="left"></td></tr><tr><td align="left">28</td><td align="left">SIGWINCH</td><td align="left">窗口大小改变</td><td align="left">默认忽略</td></tr><tr><td align="left">29</td><td align="left">SIGIO</td><td align="left">I/O相关</td><td align="left"></td></tr><tr><td align="left">30</td><td align="left">SIGPWR</td><td align="left">关机</td><td align="left">默认忽略</td></tr><tr><td align="left">31</td><td align="left">SIGSYS</td><td align="left">系统调用异常</td><td align="left"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信号类型&quot;&gt;&lt;a href=&quot;#信号类型&quot; class=&quot;headerlink&quot; title=&quot;信号类型&quot;&gt;&lt;/a&gt;信号类型&lt;/h1&gt;&lt;p&gt;Linux系统共定义了64种信号，分为两大类：可靠信号与不可靠信号，前32种信号为不可靠信号，后32种为可靠信号。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="signal" scheme="https://lxb.wiki/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>关于 CGo 的字符串函数的解释</title>
    <link href="https://lxb.wiki/8c45788a/"/>
    <id>https://lxb.wiki/8c45788a/</id>
    <published>2020-02-09T12:55:26.000Z</published>
    <updated>2020-05-05T11:39:59.173Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="noopener">cgo</a> 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。在 CGo 的文档中有简洁的解释，但我认为解释得太简洁了，因为文档只涉及了定义中的某些特定字符串，而忽略了两个很重要的注意事项。我曾经踩过这里的坑，现在我要详细解释一下。</p><p>四个函数分别是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">CString</span><span class="params">(<span class="keyword">string</span>)</span> *<span class="title">C</span>.<span class="title">char</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoString</span><span class="params">(*C.char)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoStringN</span><span class="params">(*C.char, C.<span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoBytes</span><span class="params">(unsafe.Pointer, C.<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure><p><code>C.CString()</code> 等价于 C 的 <code>strdup()</code>，像文档中提到的那样，把 Go 的字符串复制为可以传递给 C 函数的 C 的 <code>char *</code>。很讨厌的一件事是，由于 Go 和 CGo 类型的定义方式，调用 <code>C.free</code> 时需要做一个转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cs := C.CString(<span class="string">"a string"</span>)</span><br><span class="line">C.free(unsafe.Pointer(cs))</span><br></pre></td></tr></table></figure><p>请留意，Go 字符串中可能嵌入了 <code>\0</code> 字符，而 C 字符串不会。如果你的 Go 字符串中有 <code>\0</code> 字符，当你调用 <code>C.CString()</code> 时，C 代码会从 <code>\0</code> 字符处截断你的字符串。这往往不会被注意到，但<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString" target="_blank" rel="noopener">有时文本并不保证不含 null 字符</a>。</p><p><code>C.GoString()</code> 也等价于 <code>strdup()</code>，但与 <code>C.CString()</code> 相反，是把 C 字符串转换为 Go 字符串。你可以用它定义结构体的字段，或者是声明为 C 的 <code>char *</code>（在 Go 中叫 <code>*C.cahr</code>） 的其他变量，抑或其他的一些变量（我们后面会看到）。</p><p><code>C.GoStringN()</code> 等价于 C 的 <code>memmove()</code>，与 C 中普通的字符串函数不同。<strong>它把整个 N 长度的 C buffer 复制为一个 Go 字符串，不单独处理 null 字符。</strong>再详细点，它也通过复制来实现。如果你有一个定义为 <code>char feild[64]</code> 的结构体的字段，然后调用了 <code>C.GoStringN(&amp;field, 64)</code>，那么你得到的 Go 字符串一定是 64 个字符，字符串的末尾有可能是一串 <code>\0</code> 字符。</p><p>(我认为这是 cgo 文档中的一个 bug。它宣称 GoStringN 的入参是一个 C 的字符串，但实际上很明显不是，因为 C 的字符串不能以 null 字符结束，而 GoStringN 不会在 null 字符处结束处理。)</p><p><code>C.GoBytes()</code> 是 <code>C.GoStringN()</code> 的另一个版本，不返回 <code>string</code> 而是返回 <code>[]byte</code>。它没有宣称以 C 字符串作为入参，它仅仅是对整个 buffer 做了内存拷贝。</p><p>如果你要拷贝的东西不是以 null 字符结尾的 C 字符串，而是固定长度的 memory buffer，那么 <code>C.GoString()</code> 正好能满足需求；它避开了 C 中传统的问题<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString" target="_blank" rel="noopener">处理不是 C 字符串的 ’string‘</a>。然而，如果你要处理定义为 <code>char field[N]</code> 的结构体字段这种限定长度的 C 字符串时，这些函数<em>都不能</em>满足需求。</p><p>传统语义的结构体中固定长度的字符串变量，定义为 <code>char field[N]</code> 的字段，以及“包含一个字符串”等描述，都表示当且仅当字符串有足够空间时以 null 字符结尾，换句话说，字符串最多有 N-1 个字符。如果字符串正好有 N 个字符，那么它不会以 null 字符结尾。这是 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/UnixAPIMistake" target="_blank" rel="noopener">C 代码中诸多 bug 的根源</a>，也不是一个好的 API，但我们却摆脱不了这个 API。每次我们遇到这样的字段，文档不会明确告诉你字段的内容并不一定是 null 字符结尾的，你需要自己假设你有这种 API。</p><p><code>C.GoString()</code> 或 <code>C.GoStringN()</code> 都不能正确处理这些字段。使用 <code>GoStringN()</code> 相对来说出错更少；它仅仅返回一个末尾有一串 <code>\0</code> 字符长度为 N 的 Go 字符串（如果你仅仅是把这些字段打印出来，那么你可能不会留意到；我经常干这种事）。使用有诱惑力的 <code>GoString()</code> 更是引狼入室，因为它内部会对入参做 <code>strlen()</code>；如果字符末尾没有 null 字符，<code>strlen()</code> 会访问越界的内存地址。如果你走运，你得到的 Go 字符串末尾会有大量的垃圾。如果你不走运，你的 Go 程序出现段错误，因为 <code>strlen()</code> 访问了未映射的内存地址。</p><p>（总的来说，如果字符串末尾出现了大量垃圾，通常意味着在某处有不含结束符的 C 字符串。）</p><p>你需要的是与 C 的 <code>strndup()</code> 等价的 Go 函数，以此来确保复制不超过 N 个字符且在 null 字符处终止。下面是我写的版本，不保证无错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   s := C.GoStringN(cs, C.<span class="keyword">int</span>(<span class="built_in">len</span>))</span><br><span class="line">   i := strings.IndexByte(s, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> C.GoString(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于有 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding" target="_blank" rel="noopener">Go 的字符串怎样占用内存</a>的问题，这段代码做了些额外的工作来最小化额外的内存占用。你可能想用另一种方法，返回一个 <code>GoStringN()</code> 字符串的切片。你也可以写复杂的代码，根据 i 和 len 的不同来决定选用哪种方法。</p><p>更新：<a href="https://github.com/golang/go/issues/12428#issuecomment-136581154" target="_blank" rel="noopener">Ian Lance Taylor 给我展示了份更好的代码</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> C.GoStringN(cs, C.<span class="keyword">int</span>(C.strnlen(cs, C.size_t(<span class="built_in">len</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，这里有大量的转换。这篇文章就是你看到的 Go 和 Gco 类型的结合。</p><hr><p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions" target="_blank" rel="noopener">https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions</a></p><p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann" target="_blank" rel="noopener">ChrisSiebenmann</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/cgo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cgo&lt;/a&gt; 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 字符串中的潜在问题</title>
    <link href="https://lxb.wiki/10e5e8ba/"/>
    <id>https://lxb.wiki/10e5e8ba/</id>
    <published>2020-01-16T16:12:58.000Z</published>
    <updated>2020-05-05T11:38:40.291Z</updated>
    
    <content type="html"><![CDATA[<p>在我之前的文章 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike" target="_blank" rel="noopener">Go 中我喜欢的东西</a>中提到过，我喜欢的 <a href="https://golang.org/" target="_blank" rel="noopener">Go</a> 的东西其中之一就是它的字符串（通常还有切片）。从一个 Python 开发者的角度看，它们之所以伟大，是因为创建它们时开销很少，因为它们通常不需要复制。在 Python 中，任何时候操作字符串都需要复制一部分或全部字符串，而 <a href="https://utcc.utoronto.ca/~cks/space/blog/python/StringSpeedSurprises" target="_blank" rel="noopener">这很容易对性能造成影响</a>。想要写高性能的 Python 代码需要谨慎考虑复制的问题。在 Go 中，几乎所有的字符串操作都是不复制的，仅仅是从原字符串取一个子集（例如去除字符串首尾的空白字符），因此你可以更自由地操作字符串。这个机制可以非常直接地解决你的问题，并且非常高效。</p><p>（当然，不是所有的字符串操作都不复制。例如，把一个字符串转换成大写需要复制，尽管 Go 中的实现已经足够智能，在不需要改变原字符串时 — 例如由于它已经是一个全大写的字符串 — 可以规避掉复制。）</p><p>但是这个优势也带来了潜在的坏处，那些没有开销的子字符串使原来的整个字符串一直存在于内存中。Go 中的字符串（和切片）操作之所以内存开销很少，是因为它们只是底层存储（字符串或切片底层的数组的真实数据）的一些部分的引用；创建一个字符串做的操作就是创建了一个新的引用。但是 Go（目前）不会对字符串数据或数组进行部分的垃圾回收，所以即使它一个很小的 bit 被其它元素引用，整个对象也会一直保持在内存中。换句话说，一个单字符的字符串（目前）足够让一个巨大的字符串不被 GC 回收。</p><p>当然，不会有很多人遇到这个问题。为了遇到它，你需要处理一个非常庞大的原字符串，或造成大量的内存消耗（或者两者都做），在这个基础上，你必须创建那些不持久的字符串的持久的小子字符串（好吧，你是多么希望它是非持久的）。很多使用场景不会复现这个问题；要么你的原字符串不够大，要么你的子集获取了大部分原字符串（例如你把原字符串进行了分词处理），要么子字符串生命周期不够长。简而言之，如果你是一个普通的 Go 开发者，你可以忽略这个问题。处理长字符串并且长时间维持原字符串的很小部分的人才会关注这个问题。</p><p>（我之所以关注到这个问题，是因为一次我花了大量精力用尽可能少的内存写 Python 程序，尽管它是从一个大的配置文件解析结果然后分块储存。这让我联想到了一些其他的事，如字符串的生命周期、限制字符串只复制一次，等等。然后我用 Go 语言写了一个解析器，这让我由重新考虑了一下这些问题，我意识到由于我的解析器截取出和维持的 bit 一直存在于内存中，从输入文件解析出的庞大字符串也会一直存在与内存中。）</p><p>顺便说一下，我认为这是 Go 做了权衡之后的正确结果。大部分使用字符串的开发者不会遇到这个问题，而且截取子字符串开销很小对于开发者来说用处很大。这种低开销的截取操作也减轻了 GC 的负担；当代码使用大量的子字符串截取（像 Python 中那样）时，你只需要处理固定长度的字符串引用就可以了，而不是需要处理长度变化的字符串。</p><p>当你的代码遇到这个问题时，当然有明显的解决方法：创建一个函数，通过把字符串转换成 <code>[]byte</code> 来 ”最小化“ 字符串，然后返回。这种方法生成了一个最小化的字符串，内存开销是理论上最完美实现的只复制一次，而 Go 现在很容易就可以实现。</p><h2 id="附加问题：strings-ToUpper-等怎样规避没有必要的复制"><a href="#附加问题：strings-ToUpper-等怎样规避没有必要的复制" class="headerlink" title="附加问题：strings.ToUpper() 等怎样规避没有必要的复制"></a>附加问题：<code>strings.ToUpper()</code> 等怎样规避没有必要的复制</h2><p>所有的主动转换函数像 <code>ToUpper()</code> 和 <code>ToTitle()</code> 是用 <code>strings.Map()</code> 和 <a href="http://golang.org/pkg/unicode/" target="_blank" rel="noopener">unicode 包</a> 中的函数实现的。<code>Map()</code> 足够智能，在映射的函数返回一个与已存在的 <code>rune</code> 不同的结果之前不会创建新的字符串。因此，你代码中所有类似的直接使用 <code>Map()</code> 的地方都不会有内存开销。</p><hr><p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding" target="_blank" rel="noopener">https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding</a></p><p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann" target="_blank" rel="noopener">Chris Siebenmann</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/校对者ID" target="_blank" rel="noopener">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我之前的文章 &lt;a href=&quot;https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 中我喜欢的东西&lt;/a&gt;中提到过，我喜
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go GC 怎么标记内存</title>
    <link href="https://lxb.wiki/b3baee92/"/>
    <id>https://lxb.wiki/b3baee92/</id>
    <published>2020-01-13T16:06:31.000Z</published>
    <updated>2020-05-05T11:37:17.990Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p><p>ℹ️ 本文基于 <em>Go 1.13</em>。关于内存管理的概念的讨论在我的文章 <a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44" target="_blank" rel="noopener">Go 中的内存管理和分配</a> 中有详细的解释。</p><p>Go GC 的作用是回收不再使用的内存。实现的算法是并发的三色标记和清除回收法。本中文，我们研究三色标记法，以及各个颜色的不同用处。</p><p>你可以在 Ken Fox 的 <a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/" target="_blank" rel="noopener">解读垃圾回收算法</a> 中了解更多关于不同垃圾回收机制的信息。</p><h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><p>这个阶段浏览内存来了解哪些块儿是在被我们的代码使用和哪些块儿应该被回收。</p><p>然而，因为 GC 和我们的 Go 程序并行，GC 扫描期间内存中某些对象的状态可能被改变，所以需要一个检测这种可能的变化的方法。为了解决这个潜在的问题，实现了 <a href="https://en.wikipedia.org/wiki/Write_barrier" target="_blank" rel="noopener">写屏障</a> 算法，GC 可以追踪到任何的指针修改。使写屏障生效的唯一条件是短暂终止程序，又名 “Stop the World”。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/01.png" alt></p><p>在进程启动时，Go 也在每个 processor 起了一个标记 worker 来辅助标记内存。</p><p>然后，当 root 被加入到处理队列中后，标记阶段就开始遍历和用颜色标记内存。</p><p>为了了解在标记阶段的每一步，我们来看一个简单的程序示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct1 <span class="keyword">struct</span> &#123;</span><br><span class="line">a, b <span class="keyword">int64</span></span><br><span class="line">c, d <span class="keyword">float64</span></span><br><span class="line">e *struct2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> struct2 <span class="keyword">struct</span> &#123;</span><br><span class="line">f, g <span class="keyword">int64</span></span><br><span class="line">h, i <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := allocStruct1()</span><br><span class="line">s2 := allocStruct2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">_ = allocStruct2()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"s1 = %X, s2 = %X\n"</span>, &amp;s1, &amp;s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct1</span><span class="params">()</span> *<span class="title">struct1</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;struct1&#123;</span><br><span class="line">e: allocStruct2(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct2</span><span class="params">()</span> *<span class="title">struct2</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;struct2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct2</code> 不包含指针，因此它被储存在一个专门存放不被其他对象引用的对象的 span 中。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/02.png" alt="不包含指针的结构体储存在专有的 span 中"></p><p>这减少了 GC 的工作，因为标记内存时不需要扫描这个 span。</p><p>分配工作结束后，我们的程序强迫 GC 重复前面的步骤。下面是流程图：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/03.png" alt="扫描内存"></p><p>GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。扫描到被标记为 <code>no scan</code> 的 span 时，停止扫描。然而，这个工作是在多个协程中完成的，每个指针被加入到一个 work pool 中的队列。然后，后台运行的标记 worker 从这个 work pool 中拿到前面出列的 work，扫描这个对象然后把在这个对象里找到的指针加入到队列。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/04.png" alt="garbage collector work pool"></p><h2 id="颜色标记"><a href="#颜色标记" class="headerlink" title="颜色标记"></a>颜色标记</h2><p>worker 需要一种记录哪些内存需要扫描的方法。GC 使用一种 <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking" target="_blank" rel="noopener">三色标记算法</a>，工作流程如下：</p><ul><li>开始时，所有对象都被认为是<strong>白色</strong></li><li>root 对象（栈，堆，全局变量）被标记为<strong>灰色</strong></li></ul><p>这个初始步骤完成后，GC 会：</p><ul><li>选择一个<strong>灰色</strong>的对象，标记为<strong>黑色</strong></li><li>追踪这个对象的所有指针，把所有引用的对象标记为<strong>灰色</strong></li></ul><p>然后，GC 重复以上两步，直到没有对象可被标记。在这一时刻，对象非黑即白，没有灰色。白色的对象表示没有其他对象引用，可以被回收。</p><p>下面是前面例子的图示：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/05.png" alt></p><p>初始状态下，所有的对象被认为是白色的。然后，遍历到的且被其他对象引用的对象，被标记为灰色。如果一个对象在被标记为 <code>no scan</code> 的 span 中，因为它不需要被扫描，所以可以标记为黑色。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/06.png" alt></p><p>现在灰色的对象被加入到扫描队列并被标记为黑色：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/07.png" alt></p><p>对加入到扫描队列的所有对象重复做相同的操作，直到没有对象需要被处理：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/08.png" alt></p><p>处理结束时，黑色对象表示内存中在使用的对象，白色对象是要被回收的对象。我们可以看到，由于 <code>struct2</code> 的实例是在一个匿名函数中创建的且不再存在于栈上，因此它是白色的且可以被回收。</p><p>归功于每一个 span 中的名为 <code>gcmarkBits</code> 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 scan。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/09.png" alt></p><p>我们可以看到，黑色和灰色表示的意义相同。处理的不同之处在于，标记为灰色时是把对象加入到扫描队列，而标记为黑色时，不再扫描。</p><p>GC 最终 STW，清除每一次写屏障对 work pool 做的改变，继续后续的标记。</p><p><em>你可以在我的文章 <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35" target="_blank" rel="noopener">Go GC 怎样监控你的应用</a> 中找到关于并发处理和 GC 的标记阶段更详细的描述</em>。</p><h2 id="runtime-分析器"><a href="#runtime-分析器" class="headerlink" title="runtime 分析器"></a>runtime 分析器</h2><p>Go 提供的工具使我们可以对每一步进行可视化，观察 GC 在我们的程序中的影响。开启 tracing 运行我们的代码，可以看到前面所有步骤的一个概览。下面是追踪结果：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/10.png" alt="traces of the garbage collector"></p><p>标记 worker 的生命周期也可以在追踪结果中以协程等级可视化。下面是在启动之前先在后台等待标记内存的 goroutine #33 的例子。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/11.png" alt="marking worker"></p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/校对者ID" target="_blank" rel="noopener">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
      <category term="GC" scheme="https://lxb.wiki/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>微服务中的熔断器和重试</title>
    <link href="https://lxb.wiki/c9399f4/"/>
    <id>https://lxb.wiki/c9399f4/</id>
    <published>2019-12-12T15:02:17.000Z</published>
    <updated>2020-05-05T11:41:08.979Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。</p><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/01.png" alt="01"></p><p>想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。</p><p>后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/02.png" alt="02"></p><p>熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/03.png" alt="03"></p><p>通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 <a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">wikipedia</a>）可能不会遇到这种网络模式。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/04.png" alt="04"></p><p>熔断器有三个主要的状态：</p><ul><li>Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 <strong>Max Concurrency</strong>（最大并发数）和 <strong>Timeout</strong>（超时）。</li><li>Open：所有的请求都会返回 <strong>Circuit Open</strong> 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。</li><li>Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。</li></ul><h2 id="熔断器原理"><a href="#熔断器原理" class="headerlink" title="熔断器原理"></a>熔断器原理</h2><p>控制熔断的设置共有 5 个主要参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommandConfig is used to tune circuit settings at runtime</span></span><br><span class="line"><span class="keyword">type</span> CommandConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Timeout                <span class="keyword">int</span> <span class="string">`json:"timeout"`</span></span><br><span class="line">MaxConcurrentRequests  <span class="keyword">int</span> <span class="string">`json:"max_concurrent_requests"`</span></span><br><span class="line">RequestVolumeThreshold <span class="keyword">int</span> <span class="string">`json:"request_volume_threshold"`</span></span><br><span class="line">SleepWindow            <span class="keyword">int</span> <span class="string">`json:"sleep_window"`</span></span><br><span class="line">ErrorPercentThreshold  <span class="keyword">int</span> <span class="string">`json:"error_percent_threshold"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go" target="_blank" rel="noopener">查看源码</a></p><p>可以通过根据两个服务的 SLA（‎ Service Level Agreement，<a href="https://zh.wikipedia.org/zh-hans/服务级别协议" target="_blank" rel="noopener">服务级别协议</a>）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。</p><p>一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。</p><h2 id="生产上的熔断器"><a href="#生产上的熔断器" class="headerlink" title="生产上的熔断器"></a>生产上的熔断器</h2><p>熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>这段实例代码用的是 <a href="http://github.com/afex/hystrix-go/hystrix" target="_blank" rel="noopener">hystrix-go</a> 库，hystrix Netflix 库在 Golang 的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/afex/hystrix-go/hystrix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandName = <span class="string">"producer_api"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hystrix.ConfigureCommand(commandName, hystrix.CommandConfig&#123;</span><br><span class="line">Timeout:                <span class="number">500</span>,</span><br><span class="line">MaxConcurrentRequests:  <span class="number">100</span>,</span><br><span class="line">ErrorPercentThreshold:  <span class="number">50</span>,</span><br><span class="line">RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">SleepWindow:            <span class="number">1000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, logger(handle))</span><br><span class="line">log.Println(<span class="string">"listening on :8080"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">errors := hystrix.Go(commandName, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// talk to other services</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="comment">// err := callWithRetryV1()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">output &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out := &lt;-output:</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">log.Printf(<span class="string">"success %v"</span>, out)</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errors:</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line">log.Printf(<span class="string">"failed %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger is Handler wrapper function for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(fn http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(r.URL.Path, r.Method)</span><br><span class="line">fn(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callChargeProducerAPI</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(os.Getenv(<span class="string">"SERVER_ERROR"</span>))</span><br><span class="line"><span class="keyword">if</span> os.Getenv(<span class="string">"SERVER_ERROR"</span>) == <span class="string">"1"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"503 error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 中分别测试了请求调用链 closed 和 open 两种情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Experiment 1: success path */</span><br><span class="line">// server</span><br><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">/* Experiment 2: circuit open */</span><br><span class="line">// server</span><br><span class="line">SERVER_ERROR=1 Go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试问题"><a href="#重试问题" class="headerlink" title="重试问题"></a>重试问题</h2><p>在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。</p><p>一段简单的重试代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callWithRetryV1</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">3</span>; index++ &#123;</span><br><span class="line"><span class="comment">// call producer API</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding backoff</span></span><br><span class="line"><span class="comment">// adding jitter</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h2><p>为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。</p><p>一起来看下列算法：</p><ul><li>Exponential: bash * 2<sup>attemp</sup></li><li>Full Jitter: sleep = rand(0, base * 2<sup>attempt</sup>)</li><li>Equal Jitter: temp = base * 2<sup>attemp</sup>; sleep = temp/2+rand(0, temp/2)</li><li>De-corredlated Jitter: sleep = rand(base, sleep*3)</li></ul><p>【译注】关于这几个算法，可以参考<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a> 。<strong>Full Jitter</strong>、 <strong>Equal Jitter</strong>、 <strong>De-corredlated</strong> 等都是原作者自己定义的名词。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/05.png" alt="05"></p><p>客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a>中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。</p><h2 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/06.png" alt="Example configuration of both tools"></p><p>熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://github.com/afex/hystrix-go/" target="_blank" rel="noopener">https://github.com/afex/hystrix-go/</a></li><li><a href="https://github.com/eapache/go-resiliency" target="_blank" rel="noopener">https://github.com/eapache/go-resiliency</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></li><li><a href="https://www.awsarchitectureblog.com/2015/03/backoff.html" target="_blank" rel="noopener">https://www.awsarchitectureblog.com/2015/03/backoff.html</a></li><li><a href="https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience" target="_blank" rel="noopener">https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience</a></li></ol><hr><p>via: <a href="https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/" target="_blank" rel="noopener">https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/</a></p><p>作者：<a href="http://github.com/titpetric" target="_blank" rel="noopener">Tit Petric</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25295" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。&lt;/p&gt;
&lt;h2 id=&quot;熔断器&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>协程，操作系统线程和 CPU 管理</title>
    <link href="https://lxb.wiki/4e717bb5/"/>
    <id>https://lxb.wiki/4e717bb5/</id>
    <published>2019-12-12T15:01:35.000Z</published>
    <updated>2020-05-05T11:40:54.072Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French."></p><p>ℹ️ <em>本文运行环境为 Go 1.13</em></p><p>对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。</p><h2 id="M-P-G-编排"><a href="#M-P-G-编排" class="headerlink" title="M, P, G 编排"></a>M, P, G 编排</h2><p>为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The main concepts are:</span><br><span class="line">G - goroutine.</span><br><span class="line">M - worker thread, or machine.</span><br><span class="line">P - processor, a resource that is required to execute Go code.</span><br><span class="line">    M must have an associated P to execute Go code[...].</span><br></pre></td></tr></table></figure><p><code>P</code>, <code>M</code>, <code>G</code> 模型图解：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/01.png" alt="P, M, G diagram"></p><p>每个协程（<code>G</code>）运行在与一个逻辑 CPU（<code>P</code>）相关联的 OS 线程（<code>M</code>）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`hello`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`world`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Go 根据机器逻辑 CPU 的个数来创建不同的 <code>P</code>，并且把它们保存在一个空闲 <code>P</code> 的 list 里。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/02.png" alt="P initialization"></p><p>然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 <code>P</code>。这个 <code>P</code> 通过与之相关联的 OS 线程来创建一个 <code>M</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/03.png" alt="OS thread creation"></p><p>然而，像 <code>P</code> 那样，系统调用返回的甚至被 gc 强行停止的空闲的 <code>M</code> — 比如没有协程在等待运行 — 也会被加到一个空闲 list：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/04.png" alt="M and P idle list"></p><p>在程序启动阶段，Go 就已经创建了一些 OS 线程并与 <code>M</code> 想关联了。在我们的例子中，打印 <code>hello</code> 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 <code>M</code> 和 <code>P</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/05.png" alt="M and P pulled from the idle list"></p><p>现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 <code>P</code> 多的 <code>M</code>，在系统调用时怎么管理协程。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 <code>P</code> 和线程 <code>M</code> 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   fd, _ := os.Open(<span class="string">"number.txt"</span>)</span><br><span class="line">   fd.Read(buf)</span><br><span class="line">   fd.Close()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="keyword">string</span>(buf)) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读取的流程如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/06.png" alt="Syscall handoffs P"></p><p><code>P0</code> 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。</p><ul><li>尝试去捕获相同的 <code>P</code>，在我们的例子中就是 <code>P0</code>，然后 resume 执行过程</li><li>尝试从空闲 list 中捕获一个 <code>P</code>，然后 resume 执行过程</li><li>把协程放到全局队列里，把与之相关联的 <code>M</code> 放回空闲 list 去</li></ul><p>然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 <code>M</code> 不会阻塞：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/07.png" alt="Network poller waiting for the resource"></p><p>在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/08.png" alt></p><p>如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。</p><h2 id="OS-线程方面的限制"><a href="#OS-线程方面的限制" class="headerlink" title="OS 线程方面的限制"></a>OS 线程方面的限制</h2><p>在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：</p><blockquote><p><em>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</em></p></blockquote><p>译注：<strong>GOMAXPROCS</strong> 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 <strong>GOMAXPROCS</strong> 没有影响。这个包的 <strong><em>GOMAXPROCS</em></strong> 函数查询和修改这个最大数限制。</p><p>对这种情形举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++  &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         http.Get(<span class="string">`https://httpstat.us/200?sleep=10000`</span>)</span><br><span class="line"></span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用追踪工具得到的线程数如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/09.png" alt></p><p>由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。</p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25292" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png&quot; alt=&quot;Illus
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
  </entry>
  
</feed>
