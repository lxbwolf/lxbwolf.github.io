<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaobin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxb.wiki/"/>
  <updated>2021-05-01T10:54:12.616Z</updated>
  <id>https://lxb.wiki/</id>
  
  <author>
    <name>Xiaobin.Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>误删了Mac中Chrome书签后如何恢复</title>
    <link href="https://lxb.wiki/ef3fb32/"/>
    <id>https://lxb.wiki/ef3fb32/</id>
    <published>2021-05-01T10:44:48.000Z</published>
    <updated>2021-05-01T10:54:12.616Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><p>书签误删该如何恢复</p><p>1 打开访达，在菜单栏上点击【前往】—【前往文件夹】，或者使用快捷键【Command+Shift+G】即可打开【前往文件夹】</p><p>输入以下路径【/Users/用户名/Library/Application Support/Google/Chrome】（注：路径中的用户名就是你电脑用户名称），如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210501185028.png" alt></p><p>2 在chrome文件目录下找到 【Default】文件夹，将里面的 【Bookmarks.bak】 的文件复制到桌面，将.bak名的后缀去掉，如下图所示：</p><p>注：如果你有多个用户的话，则需要找到对应的用户，一般在文件名为“Profile1、2、3”底下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210501185251.png" alt></p><p>3 在同样的文件夹底下，将修改好的 Bookmarks 复制进 去替换，重启chrome即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;



&lt;!-- tocstop --&gt;

&lt;p&gt;书签误删该如何恢复&lt;/p&gt;
&lt;p&gt;1 打开访达，在菜单栏上点击【前往】—【前往文件夹】，或者使用快捷键【Command+Shift+G】即可打开【前往文件夹】&lt;/p&gt;
&lt;p&gt;输入以下路径【/Users/用户
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="Chrome" scheme="https://lxb.wiki/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下 su 和 su - 的区别</title>
    <link href="https://lxb.wiki/686a477f/"/>
    <id>https://lxb.wiki/686a477f/</id>
    <published>2021-02-13T13:24:47.000Z</published>
    <updated>2021-05-03T03:25:41.115Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><p>大部分Linux发行版的默认账户是普通用户，而更改系统文件或者执行某些命令，需要root身份才能进行，这就需要从当前用户切换到root用户。Linux中切换用户的命令是su或su -。前天我在使用useradd这个命令时，才体会到这两者的本质区别。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503112328.png" alt></p><p>我首先是用su命令切换到root身份的，但是运行useradd时，出现错误：bash: useradd: command not found。google了一下，原因是在这个用su命令切换过来的root用户上。</p><p><strong>su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。用echo $PATH命令看一下su和su -以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用su -命令。</strong> 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503112427.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;



&lt;!-- tocstop --&gt;

&lt;p&gt;大部分Linux发行版的默认账户是普通用户，而更改系统文件或者执行某些命令，需要root身份才能进行，这就需要从当前用户切换到root用户。Linux中切换用户的命令是su或su -。前天我在使用usera
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="root" scheme="https://lxb.wiki/tags/root/"/>
    
  </entry>
  
  <entry>
    <title>raft 算法</title>
    <link href="https://lxb.wiki/3d118e3a/"/>
    <id>https://lxb.wiki/3d118e3a/</id>
    <published>2021-02-06T12:36:12.000Z</published>
    <updated>2021-02-26T13:05:52.078Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#拜占庭将军问题">拜占庭将军问题</a></li><li><a href="#针对简化版拜占庭将军问题raft-解决方案类比">针对简化版拜占庭将军问题，Raft 解决方案类比</a><ul><li><a href="#1-raft-节点状态">1. Raft 节点状态</a></li><li><a href="#2-选主-leader-election">2. 选主 Leader Election</a><ul><li><a href="#21-正常情况下选主">2.1 正常情况下选主</a></li><li><a href="#22-leader-出故障情况下的选主">2.2 Leader 出故障情况下的选主</a></li><li><a href="#23-多个-candidate-情况下的选主">2.3 多个 Candidate 情况下的选主</a></li></ul></li><li><a href="#3-复制日志-log-replication">3. 复制日志 Log Replication</a><ul><li><a href="#31-正常情况下复制日志">3.1 正常情况下复制日志</a></li><li><a href="#32-network-partition-情况下进行复制日志">3.2 Network Partition 情况下进行复制日志</a></li></ul></li><li><a href="#小总结">小总结</a></li></ul></li></ul><!-- tocstop --><h1 id="拜占庭将军问题"><span id="拜占庭将军问题">拜占庭将军问题</span></h1><p>拜占庭将军问题是 Leslie Lamport 在 <a href="https://web.archive.org/web/20170205142845/http://lamport.azurewebsites.net/pubs/byz.pdf" target="_blank" rel="noopener">The Byzantine Generals Problem</a> 论文中提出的分布式领域的容错问题，它是分布式领域中最复杂、最严格的容错模型。</p><p>在该模型下，系统不会对集群中的节点做任何的限制，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。</p><p>拜占庭将军问题描述了一个如下的场景，有一组将军分别指挥一部分军队，每一个将军都不知道其它将军是否是可靠的，也不知道其他将军传递的信息是否可靠，但是它们需要通过投票选择是否要进攻或者撤退：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204025.png" alt></p><p>在这一节中，黄色代表状态未知，绿色代表进攻，蓝色代表撤退，最后红色代表当前将军的信息不可靠。</p><p>在这时，无论将军是否可靠，只要所有的将军达成了统一的方案，选择进攻或者撤退其实就是没有任何问题的：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204121.png" alt></p><p>上述的情况不会对当前的战局有太多的影响，也不会造成损失，但是如果其中的一个将军告诉其中一部分将军选择进攻、另一部分选择撤退，就会出现非常严重的问题了。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204149.png" alt></p><p>由于将军的队伍中出了一个叛徒或者信息在传递的过程中被拦截，会导致一部分将军会选择进攻，剩下的一部分会选择撤退，它们都认为自己的选择是大多数人的选择，这时就出现了严重的不一致问题。</p><p>拜占庭将军问题是对分布式系统容错的最高要求，然而这不是日常工作中使用的大多数分布式系统中会面对的问题，我们遇到更多的还是节点故障宕机或者不响应等情况，这就大大简化了系统对容错的要求；不过类似 Bitcoin、Ethereum 等分布式系统确实需要考虑拜占庭容错的问题。</p><blockquote><p>​    拜占庭将军问题是分布式领域最复杂、最严格的容错模型。但在日常工作中使用的分布式系统面对的问题不会那么复杂，更多的是计算机故障挂掉了，或者网络通信问题而没法传递信息，这种情况不考虑计算机之间互相发送恶意信息，极大简化了系统对容错的要求，最主要的是达到一致性。</p></blockquote><p>所以将拜占庭将军问题根据常见的工作上的问题进行简化：<strong>假设将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成一致性决定？</strong></p><p>对于这个简化后的问题，有许多解决方案，第一个被证明的共识算法是 Paxos，由拜占庭将军问题的作者 Leslie Lamport 在1990年提出，最初以论文难懂而出名，后来这哥们在2001重新发了一篇简单版的论文 <a href="https://link.jianshu.com?t=%5Bhttps%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf%5D(https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf)" target="_blank" rel="noopener">Paxos Made Simple</a>，然而还是挺难懂的。</p><p>因为 Paxos 难懂，难实现，所以斯坦福大学的教授在2014年发表了新的分布式协议 Raft。与 Paxos 相比，Raft 有着基本相同运行效率，但是更容易理解，也更容易被用在系统开发上。</p><h1 id="针对简化版拜占庭将军问题raft-解决方案类比"><span id="针对简化版拜占庭将军问题raft-解决方案类比">针对简化版拜占庭将军问题，Raft 解决方案类比</span></h1><p>我们还是用拜占庭将军的例子来帮助理解 Raft。</p><blockquote><p>​    假设将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成一致性决定？</p></blockquote><p>Raft 的解决方案大概可以理解成 先在所有将军中选出一个大将军，所有的决定由大将军来做。<strong>选举环节</strong>：比如说现在一共有3个将军 A, B, C，每个将军都有一个<strong>随机时间</strong>的倒计时器，倒计时一结束，这个将军就会把自己当成大将军候选人，然后派信使去问其他几个将军，能不能选我为总将军？假设现在将军A倒计时结束了，他派信使传递选举投票的信息给将军B和C，如果将军B和C还没把自己当成候选人（倒计时还没有结束），并且没有把选举票投给其他，他们把票投给将军A，信使在回到将军A时，将军A知道自己收到了足够的票数，成为了大将军。在这之后，是否要进攻就由大将军决定，然后派信使去通知另外两个将军，如果在一段时间后还没有收到回复（可能信使被暗杀），那就再重派一个信使，直到收到回复。</p><p>故事先讲到这里，希望不做技术方面的朋友可以大概能理解 Raft 的原理，下面从比较技术的角度讲讲 Raft 的原理。 </p><h2 id="1-raft-节点状态"><span id="1-raft-节点状态">1. Raft 节点状态</span></h2><p>从拜占庭将军的故事映射到分布式系统上，每个将军相当于一个分布式网络节点，每个节点有<strong>三种状态：Follower，Candidate，Leader</strong>，状态之间是互相转换的，可以参考下图，具体的后面说。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204532.png" alt></p><p>每个节点上都有一个倒计时器 (Election Timeout)，时间随机在 150ms 到 300ms 之间。有几种情况会重设 Timeout：</p><ol><li>收到选举的请求</li><li>收到 Leader 的 Heartbeat (后面会讲到)</li></ol><p>在 Raft 运行过程中，最主要进行两个活动：</p><ol><li>选主 Leader Election</li><li>复制日志 Log Replication</li></ol><h2 id="2-选主-leader-election"><span id="2-选主-leader-election">2. 选主 Leader Election</span></h2><h3 id="21-正常情况下选主"><span id="21-正常情况下选主">2.1 正常情况下选主</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204600.png" alt></p><p>假设现在有如图5个节点，5个节点一开始的状态都是 Follower。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204614.png" alt></p><p>在一个节点倒计时结束 (Timeout) 后，这个节点的状态变成 Candidate 开始选举，它给其他几个节点发送选举请求 (RequestVote)</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204652.png" alt></p><p>其他四个节点都返回成功，这个节点的状态由 Candidate 变成了 Leader，并在每个一小段时间后，就给所有的 Follower 发送一个 Heartbeat 以保持所有节点的状态，Follower 收到 Leader 的 Heartbeat 后重设 Timeout。</p><p>这是最简单的选主情况，<strong>只要有超过一半的节点投支持票了，Candidate 才会被选举为 Leader</strong>，5个节点的情况下，3个节点 (包括 Candidate 本身) 投了支持就行。</p><h3 id="22-leader-出故障情况下的选主"><span id="22-leader-出故障情况下的选主">2.2 Leader 出故障情况下的选主</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204743.png" alt></p><p>一开始已经有一个 Leader，所有节点正常运行。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204807.png" alt></p><p>Leader 出故障挂掉了，其他四个 Follower 将进行重新选主。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204831.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204909.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204929.png" alt></p><p>4个节点的选主过程和5个节点的类似，在选出一个新的 Leader 后，原来的 Leader 恢复了又重新加入了，这个时候怎么处理？在 Raft 里，第几轮选举是有记录的，重新加入的 Leader 是第一轮选举 (Term 1) 选出来的，而现在的 Leader 则是 Term 2，所有原来的 Leader 会自觉降级为 Follower</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205008.png" alt></p><h3 id="23-多个-candidate-情况下的选主"><span id="23-多个-candidate-情况下的选主">2.3 多个 Candidate 情况下的选主</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205055.png" alt></p><p>假设一开始有4个节点，都还是 Follower。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205115.png" alt></p><p>有两个 Follower 同时 Timeout，都变成了 Candidate 开始选举，分别给一个 Follower 发送了投票请求。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205141.png" alt></p><p>两个 Follower 分别返回了ok，这时两个 Candidate 都只有2票，要3票才能被选成 Leader。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205210.png" alt></p><p>两个 Candidate 会分别给另外一个还没有给自己投票的 Follower 发送投票请求。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205227.png" alt></p><p>但是因为 Follower 在这一轮选举中，都已经投完票了，所以都拒绝了他们的请求。所以在 Term 2 没有 Leader 被选出来。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205242.png" alt></p><p>这时，两个节点的状态是 Candidate，两个是 Follower，但是他们的倒计时器仍然在运行，最先 Timeout 的那个节点会进行发起新一轮 Term 3 的投票。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205257.png" alt></p><p>两个 Follower 在 Term 3 还没投过票，所以返回 OK，这时 Candidate 一共有三票，被选为了 Leader。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205319.png" alt></p><p>如果 Leader Heartbeat 的时间晚于另外一个 Candidate timeout 的时间，另外一个 Candidate 仍然会发送选举请求。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205340.png" alt></p><p>两个 Follower 已经投完票了，拒绝了这个 Candidate 的投票请求。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205354.png" alt></p><p>Leader 进行 Heartbeat， Candidate 收到后状态自动转为 Follower，完成选主。</p><p>以上是 Raft 最重要活动之一选主的介绍，以及在不同情况下如何进行选主。</p><h2 id="3-复制日志-log-replication"><span id="3-复制日志-log-replication">3. 复制日志 Log Replication</span></h2><h3 id="31-正常情况下复制日志"><span id="31-正常情况下复制日志">3.1 正常情况下复制日志</span></h3><p>Raft 在实际应用场景中的一致性更多的是体现在不同节点之间的数据一致性，客户端发送请求到任何一个节点都能收到一致的返回，当一个节点出故障后，其他节点仍然能以已有的数据正常进行。在选主之后的复制日志就是为了达到这个目的。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205420.png" alt></p><p>一开始，Leader 和 两个 Follower 都没有任何数据。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205438.png" alt></p><p>客户端发送请求给 Leader，储存数据 “sally”，Leader 先将数据写在本地日志，这时候数据还是 <strong>Uncommitted</strong> (还没最终确认，红色表示)</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205539.png" alt></p><p>Leader 给两个 Follower 发送 AppendEntries 请求，数据在 Follower 上没有冲突，则将数据暂时写在本地日志，Follower 的数据也还是 Uncommitted。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205616.png" alt></p><p>Follower 将数据写到本地后，返回 OK。Leader 收到后成功返回，<strong>只要收到的成功的返回数量超过半数 (包含Leader)</strong>，Leader 将数据 “sally” 的状态改成 Committed。( 这个时候 Leader 就可以返回给客户端了)</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205634.png" alt></p><p>Leader 再次给 Follower 发送 AppendEntries 请求，收到请求后，Follower 将本地日志里 Uncommitted 数据改成 Committed。这样就完成了一整个复制日志的过程，三个节点的数据是一致的，</p><h3 id="32-network-partition-情况下进行复制日志"><span id="32-network-partition-情况下进行复制日志">3.2 Network Partition 情况下进行复制日志</span></h3><p>在 Network Partition 的情况下，部分节点之间没办法互相通信，Raft 也能保证在这种情况下数据的一致性。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205655.png" alt></p><p>一开始有 5 个节点处于同一网络状态下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205712.png" alt></p><p>Network Partition 将节点分成两边，一边有两个节点，一边三个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205803.png" alt></p><p>两个节点这边已经有 Leader 了，来自客户端的数据 “bob” 通过 Leader 同步到 Follower。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205819.png" alt></p><p>因为只有两个节点，少于3个节点，所以 “bob” 的状态仍是 Uncommitted。所以在这里，<strong>服务器会返回错误给客户端</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205832.png" alt></p><p>另外一个 Partition 有三个节点，进行重新选主。客户端数据 “tom” 发到新的 Leader，通过和上节网络状态下相似的过程，同步到另外两个 Follower。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205851.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205919.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210105.png" alt></p><p>因为这个 Partition 有3个节点，超过半数，所以数据 “tom” 都 Commit 了。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210129.png" alt></p><p>网络状态恢复，5个节点再次处于同一个网络状态下。但是这里出现了数据冲突 “bob” 和 “tom”</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210159.png" alt></p><p>三个节点的 Leader 广播 AppendEntries</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210245.png" alt></p><p>两个节点 Partition 的 Leader 自动降级为 Follower，因为这个 Partition 的数据 “bob” 没有 Commit，返回给客户端的是错误，客户端知道请求没有成功，所以 Follower 在收到 AppendEntries 请求时，可以把 “bob“ 删除，然后同步 ”tom”，通过这么一个过程，就完成了在 Network Partition 情况下的复制日志，保证了数据的一致性。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210329.png" alt></p><h2 id="小总结"><span id="小总结">小总结</span></h2><p>Raft 是能够实现分布式系统强一致性的算法，每个系统节点有三种状态 Follower，Candidate，Leader。实现 Raft 算法两个最重要的事是：选主和复制日志</p><p><strong>参考链接：</strong><br>Raft 官网：<a href="https://link.jianshu.com?t=https%3A%2F%2Fraft.github.io%2F" target="_blank" rel="noopener">https://raft.github.io/</a></p><p>Raft 原理动画 (推荐看看)：<a href="https://link.jianshu.com?t=http%3A%2F%2Fthesecretlivesofdata.com%2Fraft%2F" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>Raft 算法解析图片来源：<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fcoreos-analyse-etcd" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/coreos-analyse-etcd</a></p><p>分布式一致性与共识算法 <a href="https://draveness.me/consensus/" target="_blank" rel="noopener">https://draveness.me/consensus/</a></p><p>共识算法：Raft <a href="https://www.jianshu.com/p/8e4bbe7e276c" target="_blank" rel="noopener">https://www.jianshu.com/p/8e4bbe7e276c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#拜占庭将军问题&quot;&gt;拜占庭将军问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#针对简化版拜占庭将军问题raft-解决方案类比&quot;&gt;针对简化版拜占庭将军问题，Raft 解决方案类比&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://lxb.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="raft" scheme="https://lxb.wiki/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>使用子模块和子树来管理 Git 项目</title>
    <link href="https://lxb.wiki/331c3227/"/>
    <id>https://lxb.wiki/331c3227/</id>
    <published>2020-12-23T14:11:17.000Z</published>
    <updated>2021-01-03T14:26:15.784Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#必要性">必要性</a></li><li><a href="#git-子模块和子树">Git 子模块和子树</a></li><li><a href="#git-子模块是什么">Git 子模块是什么？</a><ul><li><a href="#克隆一个存储库并加载子模块">克隆一个存储库并加载子模块</a></li><li><a href="#下载子模块">下载子模块</a></li><li><a href="#拉取子模块">拉取子模块</a></li><li><a href="#使用子模块创建存储库">使用子模块创建存储库：</a></li><li><a href="#更新子模块的提交">更新子模块的提交</a></li><li><a href="#从一个父存储库中删除一个子模块">从一个父存储库中删除一个子模块</a></li></ul></li><li><a href="#git-子树是什么">Git 子树是什么？</a><ul><li><a href="#向父存储库中添加一个子树">向父存储库中添加一个子树</a></li><li><a href="#向子树推送修改以及从子树拉取修改">向子树推送修改以及从子树拉取修改</a></li></ul></li><li><a href="#你应该使用哪个">你应该使用哪个？</a></li></ul><!-- tocstop --><blockquote><p>使用子模块和子树来帮助你管理多个存储库中共有的子项目。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222058.png" alt></p><p>如果你参与了开源项目的开发，那么你很可能已经用了 Git 来管理你的源码。你可能遇到过有很多依赖和/或子项目的项目。你是如何管理它们的？</p><p>对于一个开源组织，要实现社区<strong>和</strong>产品的单一来源文档和依赖管理比较棘手。文档和项目往往会碎片化和变得冗余，这致使它们很难维护。</p><h3 id="必要性"><span id="必要性">必要性</span></h3><p>假设你想把单个项目作为一个存储库内的子项目，传统的方法是把该项目复制到父存储库中，但是，如果你想要在多个父项目中使用同一个子项目呢？如果把子项目复制到所有父项目中，当有更新时，你都要在每个父项目中做修改，这是不太可行的。这会导致父项目中的冗余和数据不一致，使更新和维护子项目变得很困难。</p><h3 id="git-子模块和子树"><span id="git-子模块和子树">Git 子模块和子树</span></h3><p>如果你可以用一条命令把一个项目放进另一个项目中，会怎样呢？如果你随时可以把一个项目作为子项目添加到任意数目的项目中，并可以同步更新修改呢？Git 提供了这类问题的解决方案：Git 子模块submodule<ruby>子模块<rt>submodule</rt></ruby>和 Git 子树subtree<ruby>子树<rt>subtree</rt></ruby>。创建这些工具的目的是以更加模块化的水平来支持共用代码的开发工作流，旨在 Git 存储库源码管理source-code management<ruby>源码管理<rt>source-code management</rt></ruby>（SCM）与它下面的子树之间架起一座桥梁。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222135.png" alt="Cherry tree growing on a mulberry tree" title="Cherry tree growing on a mulberry tree"></p><p><em>生长在桑树上的樱桃树</em></p><p>下面是本文要详细介绍的概念的一个真实应用场景。如果你已经很熟悉树形结构，这个模型看起来是下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222254.png" alt="Tree with subtrees" title="Tree with subtrees"></p><h3 id="git-子模块是什么"><span id="git-子模块是什么">Git 子模块是什么？</span></h3><p>Git 在它默认的包中提供了子模块，子模块可以把 Git 存储库嵌入到其他存储库中。确切地说，Git 子模块指向子树中的某次提交。下面是我 <a href="https://github.com/manaswinidas/Docs-test/" target="_blank" rel="noopener">Docs-test</a> GitHub 存储库中的 Git 子模块的样子：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222434.png" alt="Git submodules screenshot" title="Git submodules screenshot"></p><p><a href="mailto:folder@commitId" target="_blank" rel="noopener">文件夹@提交 Id</a> 格式表明这个存储库是一个子模块，你可以直接点击文件夹进入该子树。名为 <code>.gitmodules</code> 的配置文件包含所有子模块存储库的详细信息。我的存储库的 <code>.gitmodules</code> 文件如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222553.png" alt="Screenshot of .gitmodules file" title="Screenshot of .gitmodules file"></p><p>你可以用下面的命令在你的存储库中使用 Git 子模块：</p><h4 id="克隆一个存储库并加载子模块"><span id="克隆一个存储库并加载子模块">克隆一个存储库并加载子模块</span></h4><p>克隆一个含有子模块的存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --recursive &lt;URL to Git repo&gt;</span><br></pre></td></tr></table></figure><p>如果你之前已经克隆了存储库，现在想加载它的子模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init</span><br></pre></td></tr></table></figure><p>如果有嵌套的子模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h4 id="下载子模块"><span id="下载子模块">下载子模块</span></h4><p>串行地连续下载多个子模块是很枯燥的工作，所以 <code>clone</code> 和 <code>submodule update</code> 会支持 <code>--jobs</code> （或 <code>-j</code>）参数：</p><p>例如，想一次下载 8 个子模块，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive -j 8</span><br><span class="line">$ git clone --recursive --jobs 8 &lt;URL to Git repo&gt;</span><br></pre></td></tr></table></figure><h4 id="拉取子模块"><span id="拉取子模块">拉取子模块</span></h4><p>在运行或构建父项目之前，你需要确保依赖的子项目都是最新的。</p><p>拉取子模块的所有修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br></pre></td></tr></table></figure><h4 id="使用子模块创建存储库"><span id="使用子模块创建存储库">使用子模块创建存储库：</span></h4><p>向一个父存储库添加子树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add &lt;URL to Git repo&gt;</span><br></pre></td></tr></table></figure><p>初始化一个已存在的 Git 子模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br></pre></td></tr></table></figure><p>你也可以通过为 <code>submodule update</code> 命令添加 <code>--update</code> 参数在子模块中创建分支和追踪提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br></pre></td></tr></table></figure><h4 id="更新子模块的提交"><span id="更新子模块的提交">更新子模块的提交</span></h4><p>上面提到过，一个子模块就是一个指向子树中某次提交的链接。如果你想更新子模块的提交，不要担心。你不需要显式地指定最新的提交。你只需要使用通用的 <code>submodule update</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update</span><br></pre></td></tr></table></figure><p>就像你平时创建父存储库和把父存储库推送到 GitHub 那样添加和提交就可以了。</p><h4 id="从一个父存储库中删除一个子模块"><span id="从一个父存储库中删除一个子模块">从一个父存储库中删除一个子模块</span></h4><p>仅仅手动删除一个子项目文件夹不会从父项目中移除这个子项目。想要删除名为 <code>childmodule</code> 的子模块，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -f childmodule</span><br></pre></td></tr></table></figure><p>虽然 Git 子模块看起来很容易上手，但是对于初学者来说，有一定的使用门槛。</p><h3 id="git-子树是什么"><span id="git-子树是什么">Git 子树是什么？</span></h3><p>Git 子树 subtree<ruby>子树<rt> subtree</rt></ruby>，是在 Git 1.7.11 引入的，让你可以把任何存储库的副本作为子目录嵌入另一个存储库中。它是 Git 项目可以注入和管理项目依赖的几种方法之一。它在常规的提交中保存了外部依赖信息。Git 子树提供了整洁的集成点，因此很容易复原它们。</p><p>如果你参考 <a href="https://help.github.com/en/github/using-git/about-git-subtree-merges" target="_blank" rel="noopener">GitHub 提供的子树教程</a>来使用子树，那么无论你什么时候添加子树，在本地都不会看到 <code>.gittrees</code> 配置文件。这让我们很难分辨哪个是子树，因为它们看起来很像普通的文件夹，但是它们却是子树的副本。默认的 Git 包中不提供带 <code>.gittrees</code> 配置文件的 Git 子树版本，因此如果你想要带 <code>.gittrees</code> 配置文件的 git-subtree 命令，必须从 Git 源码存储库的 <a href="https://github.com/git/git/tree/master/contrib/subtree" target="_blank" rel="noopener">/contrib/subtree 文件夹</a> 下载 git-subtree。</p><p>你可以像克隆其他常规的存储库那样克隆任何含有子树的存储库，但由于在父存储库中有整个子树的副本，因此克隆过程可能会持续很长时间。</p><p>你可以用下面的命令在你的存储库中使用 Git 子树。</p><h4 id="向父存储库中添加一个子树"><span id="向父存储库中添加一个子树">向父存储库中添加一个子树</span></h4><p>想要向父存储库中添加一个子树，首先你需要执行 <code>remote add</code>，之后执行 <code>subtree add</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add remote-name &lt;URL to Git repo&gt;</span><br><span class="line">$ git subtree add --prefix=folder/ remote-name &lt;URL to Git repo&gt; subtree-branchname</span><br></pre></td></tr></table></figure><p>上面的命令会把整个子项目的提交历史合并到父存储库。</p><h4 id="向子树推送修改以及从子树拉取修改"><span id="向子树推送修改以及从子树拉取修改">向子树推送修改以及从子树拉取修改</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git subtree push-all</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git subtree pull-all</span><br></pre></td></tr></table></figure><h3 id="你应该使用哪个"><span id="你应该使用哪个">你应该使用哪个？</span></h3><p>任何工具都有优缺点。下面是一些可能会帮助你决定哪种最适合你的特性：</p><ul><li>Git 子模块的存储库占用空间更小，因为它们只是指向子项目的某次提交的链接，而 Git 子树保存了整个子项目及其提交历史。</li><li>Git 子模块需要在服务器中可访问，但子树是去中心化的。</li><li>Git 子模块大量用于基于组件的开发，而 Git 子树多用于基于系统的开发。</li></ul><p>Git 子树并不是 Git 子模块的直接可替代项。有明确的说明来指导我们该使用哪种。如果有一个归属于你的外部存储库，使用场景是向它回推代码，那么就使用 Git 子模块，因为推送代码更容易。如果你有第三方代码，且不会向它推送代码，那么使用 Git 子树，因为拉取代码更容易。</p><p>自己尝试使用 Git 子树和子模块，然后在评论中留下你的使用感想。</p><hr><p>via: <a href="https://opensource.com/article/20/5/git-submodules-subtrees" target="_blank" rel="noopener">https://opensource.com/article/20/5/git-submodules-subtrees</a></p><p>作者：<a href="https://opensource.com/users/manaswinidas" target="_blank" rel="noopener">Manaswini Das</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#必要性&quot;&gt;必要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git-子模块和子树&quot;&gt;Git 子模块和子树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git-子模块是什么&quot;&gt;Git 子模块是什么？&lt;/a&gt;&lt;u
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="git" scheme="https://lxb.wiki/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>备忘单：提升你的 MariaDB 和 MySQL 数据库技能</title>
    <link href="https://lxb.wiki/3641869e/"/>
    <id>https://lxb.wiki/3641869e/</id>
    <published>2020-12-13T14:07:00.000Z</published>
    <updated>2021-01-03T14:16:26.861Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#与-mariadb-交互">与 MariaDB 交互</a></li><li><a href="#学习-sql-基本知识">学习 SQL 基本知识</a><ul><li><a href="#显示数据库的表">显示数据库的表</a></li><li><a href="#检查一个表">检查一个表</a></li><li><a href="#创建一个新的用户">创建一个新的用户</a></li><li><a href="#查看表的字段">查看表的字段</a></li><li><a href="#为一个用户赋予权限">为一个用户赋予权限</a></li></ul></li><li><a href="#创建自定义的数据库">创建自定义的数据库</a><ul><li><a href="#创建一个-mariadb-数据库">创建一个 MariaDB 数据库</a></li><li><a href="#创建一个表">创建一个表</a></li><li><a href="#同时增加多行数据">同时增加多行数据</a></li></ul></li><li><a href="#关联多个表">关联多个表</a><ul><li><a href="#连接表">连接表</a></li></ul></li><li><a href="#下载-mariadb-和-mysql-备忘单">下载 MariaDB 和 MySQL 备忘单</a></li></ul><!-- tocstop --><blockquote><p>阅读本文并下载我们的免费备忘单，去使用开源的数据库吧。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103221458.png" alt></p><p>当你写一个程序或配置一个服务时，你最终都要持久化存储信息。有时候，你只需要一个 INI 或者 <a href="https://www.redhat.com/sysadmin/yaml-tips" target="_blank" rel="noopener">YAML</a> 配置文件就够了。而有时候，一个自定义格式的 XML 或者 JSON 或其他类似的文件会更好。</p><p>但也有时候你需要校验输入、快速查询信息、关联数据、通常还要熟练地处理你的用户的请求。这就是设计数据库的目的，而 <a href="https://mariadb.org/" target="_blank" rel="noopener">MariaDB</a>（由 <a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a> 的原始开发人员开发的一个分支） 是一个极佳的选项。在本文中我使用的是 MariaDB，但这些信息同样适用于 MySQL。</p><p>通过编程语言与数据库进行交互是很普遍的。正因如此，出现了大量 Java、Python、Lua、PHP、Ruby、C++ 和其他语言的 <a href="https://en.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL</a> 库。然而，在使用这些库之前，理解数据库引擎做了什么以及为什么选择数据库是重要的对我们会很有帮助。本文介绍 MariaDB 和 <code>mysql</code> 命令来帮助你熟悉数据库处理数据的基本原理。</p><p>如果你还没有安装 MariaDB，请查阅我的文章 <a href="https://opensource.com/article/20/10/install-mariadb-and-mysql-linux" target="_blank" rel="noopener">在 Linux 上安装 MariaDB</a>。如果你没有使用 Linux，请参照 MariaDB <a href="https://mariadb.org/download" target="_blank" rel="noopener">下载页面</a>提供的指导方法。</p><h3 id="与-mariadb-交互"><span id="与-mariadb-交互">与 MariaDB 交互</span></h3><p>你可以使用 <code>mysql</code> 命令与 MariaDB 进行交互。首先使用子命令 <code>ping</code> 确认你的服务是运行着的，在提示后输入密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysqladmin -u root -p ping</span><br><span class="line">Enter password:</span><br><span class="line">mysqld is alive</span><br></pre></td></tr></table></figure><p>为了易于读者理解，打开一个交互式的 MariaDB 会话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MariaDB monitor.</span><br><span class="line">Commands end with ; or \g.</span><br><span class="line">[...]</span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help.</span><br><span class="line">Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure><p>你现在是在一个 MariaDB 子 shell 中，提示符是 MariaDB 提示符。普通的 Bash 命令在这里不能使用，只能用 MariaDB 命令。输入 <code>help</code> （或 <code>?</code>）查看命令列表。这些是你的 MariaDB shell 的管理命令，使用它们可以定制你的 shell，但它们不属于 SQL 语言。</p><h3 id="学习-sql-基本知识"><span id="学习-sql-基本知识">学习 SQL 基本知识</span></h3><p><a href="https://publications.opengroup.org/c449" target="_blank" rel="noopener">结构化查询语言</a>是基于它们的能力定义的：一种通过有规则且一致的语法来查询数据库中的内容以得到有用的结果的方法。SQL 看起来像是普通的英文语句，有一点点生硬。例如，如果你登入数据库服务器，想查看有哪些库，输入 <code>SHOW DATABASES;</code> 并回车就能看到结果。</p><p>SQL 命令以分号作为结尾。如果你忘记输入分号，MariaDB 会认为你是想在下一行继续输入你的查询命令，在下一行你可以继续输入命令也可以输入分号结束命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(NONE)]&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| DATABASE           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">4 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure><p>上面的例子显示当前有四个数据库：<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code> 和 <code>test</code>。你必须指定 MariaDB 使用哪个库，才能对该库使用查询语句。指定数据库的命令是 <code>use</code>。当你选择了一个库后，MariaDB 提示框会切换为选择的库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(NONE)]&gt; USE test;</span><br><span class="line">MariaDB [(test)]&gt;</span><br></pre></td></tr></table></figure><h4 id="显示数据库的表"><span id="显示数据库的表">显示数据库的表</span></h4><p>数据库里有<em>表</em>，与电子表格类似：有一系列的行（在数据库中称为<em>记录</em>）和列。一个行和一个列唯一确定一个<em>字段</em>。</p><p>查看一个数据库中可用的表（可以理解为多表单电子表格中的一页），使用 SQL 关键字 <code>SHOW</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(test)]&gt; SHOW TABLES;</span><br><span class="line">empty SET</span><br></pre></td></tr></table></figure><p><code>test</code> 数据库是空的，所以使用 <code>use</code> 命令切换到 <code>mysql</code> 数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(test)]&gt; USE mysql;</span><br><span class="line">MariaDB [(mysql)]&gt; SHOW TABLES;</span><br><span class="line"></span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql           |</span><br><span class="line">+---------------------------+</span><br><span class="line">| column_stats              |</span><br><span class="line">| columns_priv              |</span><br><span class="line">| db                        |</span><br><span class="line">[...]</span><br><span class="line">| time_zone_transition_type |</span><br><span class="line">| transaction_registry      |</span><br><span class="line">| USER                      |</span><br><span class="line">+---------------------------+</span><br><span class="line">31 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure><p>这个数据库中有很多表！<code>mysql</code> 数据库是这个 MariaDB 实例的系统管理数据库。它里面包含重要数据，比如用来管理数据库权限的用户结构。这个数据库很重要，你不需要经常直接与它交互，但是使用 SQL 脚本来操作它却很常见。当你学习 MariaDB 时理解 <code>mysql</code> 数据库很有用，因为它有助于说明一些基本的 SQL 命令。</p><h4 id="检查一个表"><span id="检查一个表">检查一个表</span></h4><p>这个实例的 <code>mysql</code> 数据库的最后一个表名为 <code>USER</code>。这个表包含了可以访问这个数据库的用户。当前里面只有一个 root 用户，但是你可以添加不同权限的用户，赋予它们查看、更新或创建数据的权限。你可以查看一个表的列首来了解一个  MariaDB 用户的所有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; SHOW COLUMNS IN USER;</span><br><span class="line">MariaDB [mysql]&gt; SHOW COLUMNS IN USER;</span><br><span class="line">+-------------+---------------+------+-----+----------+</span><br><span class="line">| FIELD       | TYPE          | NULL | KEY | DEFAULT  |</span><br><span class="line">+-------------+---------------+------+-----+----------+</span><br><span class="line">| Host        | CHAR(60)      | NO   | PRI |          |</span><br><span class="line">| USER        | CHAR(80)      | NO   | PRI |          |</span><br><span class="line">| Password    | CHAR(41)      | NO   |     |          |</span><br><span class="line">| Select_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO   |     | N        |</span><br><span class="line">| Insert_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO   |     | N        |</span><br><span class="line">| Update_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO   |     | N        |</span><br><span class="line">| Delete_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO   |     | N        |</span><br><span class="line">| Create_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO   |     | N        |</span><br><span class="line">| Drop_priv   | enum(&apos;N&apos;,&apos;Y&apos;) | NO   |     | N        |</span><br><span class="line">[...]</span><br><span class="line">47 ROWS IN SET (0.001 sec)</span><br></pre></td></tr></table></figure><h4 id="创建一个新的用户"><span id="创建一个新的用户">创建一个新的用户</span></h4><p>不论你是否需要一个普通的账号来管理数据库或者为计算机配置数据库（例如安装 WordPress、Drupal 或 Joomla时），在 MariaDB 中多建一个用户账号是很普遍的。你可以通过向 <code>mysql</code> 数据库的 <code>USER</code> 表中添加一个用户或使用 SQL 关键字 <code>CREATE</code> 来提示 MariaDB 创建一个 MariaDB 用户。使用 <code>CREATE</code> 来创建新用户会默认执行一些有用的方法，因此你不需要手动生成所有的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE USER &apos;tux&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;really_secure_password&apos;;</span><br></pre></td></tr></table></figure><h4 id="查看表的字段"><span id="查看表的字段">查看表的字段</span></h4><p>你可以使用 <code>SELECT</code> 关键字来查看数据库表的字段和值。这本例中，你创建了一个名为 <code>tux</code> 的用户，因此查询 <code>USER</code> 表中的列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT USER,host FROM USER;</span><br><span class="line">+------+------------+</span><br><span class="line">| USER | host       |</span><br><span class="line">+------+------------+</span><br><span class="line">| root | localhost  |</span><br><span class="line">[...]</span><br><span class="line">| tux  | localhost  |</span><br><span class="line">+------+------------+</span><br><span class="line">7 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure><h4 id="为一个用户赋予权限"><span id="为一个用户赋予权限">为一个用户赋予权限</span></h4><p>通过查看 <code>USER</code> 表列出的信息，你可以看到用户的状态。例如，新用户 <code>tux</code> 对这个数据库没有任何权限。使用 <code>WHERE</code> 语句你可以只查 <code>tux</code> 那一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT USER,select_priv,insert_priv,update_priv FROM USER WHERE USER=&apos;tux&apos;;</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| USER | select_priv | insert_priv | update_priv |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| tux  | N           | N           | N           |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure><p>使用 <code>GRANT</code> 命令修改用户的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; GRANT SELECT ON *.* TO &apos;tux&apos;@&apos;localhost&apos;;</span><br><span class="line">&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>验证你的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT USER,select_priv,insert_priv,update_priv FROM USER WHERE USER=&apos;tux&apos;;</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| USER | select_priv | insert_priv | update_priv |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| tux  | Y           | N           | N           |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure><p><code>tux</code> 用户现在有了从所有表中查询记录的权限。</p><h3 id="创建自定义的数据库"><span id="创建自定义的数据库">创建自定义的数据库</span></h3><p>到目前为止，你一直在与默认的数据库进行交互。除了用户管理，大部分人很少会与默认的数据库进行交互。通常，你会用自定义的数据来填充创建的数据库。</p><h4 id="创建一个-mariadb-数据库"><span id="创建一个-mariadb-数据库">创建一个 MariaDB 数据库</span></h4><p>你可能已经可以自己在 MariaDB 中创建新数据库了。创建数据库跟新建用户差不多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE DATABASE example;</span><br><span class="line">Query OK, 1 ROW affected (0.000 sec)</span><br><span class="line">&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| DATABASE           |</span><br><span class="line">+--------------------+</span><br><span class="line">| example            |</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>使用 <code>use</code> 命令来把这个新建的数据库作为当前使用的库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; USE example;</span><br></pre></td></tr></table></figure><h4 id="创建一个表"><span id="创建一个表">创建一个表</span></h4><p>创建表比创建数据库要复杂，因为你必须定义列首。MariaDB 提供了很多方便的函数，可以用于创建列，引入数据类型定义，自增选项，对空值的约束，自动时间戳等等。</p><p>下面是用来描述一系列用户的一个简单的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS member (</span><br><span class="line">    -&gt; id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    -&gt; name VARCHAR(128) NOT NULL,</span><br><span class="line">    -&gt; startdate TIMESTAMP DEFAULT CURRENT_TIMESTAMP);</span><br><span class="line">Query OK, 0 ROWS affected (0.030 sec)</span><br></pre></td></tr></table></figure><p>这个表通过使用一个自动递增的方法来唯一标识每一行。表示用户名字的字段不能为空（或 <code>null</code>），每一行被创建时会自动生成时间戳。</p><p>使用 SQL 关键字 <code>INSERT</code> 向这个表填充一些示例数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT INTO member (name) VALUES (&apos;Alice&apos;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br><span class="line">&gt; INSERT INTO member (name) VALUES (&apos;Bob&apos;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br><span class="line">&gt; INSERT INTO member (name) VALUES (&apos;Carol&apos;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br><span class="line">&gt; INSERT INTO member (name) VALUES (&apos;David&apos;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br></pre></td></tr></table></figure><p>验证一下表里的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM member;</span><br><span class="line">+----+-------+---------------------+</span><br><span class="line">| id | name  | startdate           |</span><br><span class="line">+----+-------+---------------------+</span><br><span class="line">|  1 | Alice | 2020-10-03 15:25:06 |</span><br><span class="line">|  2 | Bob   | 2020-10-03 15:26:43 |</span><br><span class="line">|  3 | Carol | 2020-10-03 15:26:46 |</span><br><span class="line">|  4 | David | 2020-10-03 15:26:51 |</span><br><span class="line">+----+-------+---------------------+</span><br><span class="line">4 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure><h4 id="同时增加多行数据"><span id="同时增加多行数据">同时增加多行数据</span></h4><p>再创建一个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS linux (</span><br><span class="line">    -&gt; id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    -&gt; distro VARCHAR(128) NOT NULL);</span><br><span class="line">Query OK, 0 ROWS affected (0.030 sec)</span><br></pre></td></tr></table></figure><p>填充一些示例数据，这次使用 <code>VALUES</code> 快捷方式，这样你可以一次添加多行数据。<code>VALUES</code> 关键字需要一个用括号包围的列表作为参数，也可以用逗号分隔的多个列表作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT INTO linux (distro)</span><br><span class="line"> -&gt; VALUES (&apos;Slackware&apos;), (&apos;RHEL&apos;),(&apos;Fedora&apos;),(&apos;Debian&apos;);</span><br><span class="line">Query OK, 4 ROWS affected (0.011 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line">&gt; SELECT * FROM linux;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | distro    |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | Slackware |</span><br><span class="line">|  2 | RHEL      |</span><br><span class="line">|  3 | Fedora    |</span><br><span class="line">|  4 | Debian    |</span><br><span class="line">+----+-----------+</span><br></pre></td></tr></table></figure><h3 id="关联多个表"><span id="关联多个表">关联多个表</span></h3><p>现在你有两个表，之间没有关联。两个表的数据是独立的，但是你可能需要表一中的一个值来识别表二的记录。</p><p>你可以在表一中新增一列对应表二中的值。因为两个表都有唯一的标识符（自动递增的 <code>id</code> 字段），关联的它们的最简单的方式是，使用表一中的 <code>id</code> 字段作为表二的查询条件。</p><p>在表一中创建一列用来表示表二中的一个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; ALTER TABLE member ADD COLUMN (os INT);</span><br><span class="line">Query OK, 0 ROWS affected (0.012 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">&gt; DESCRIBE member;</span><br><span class="line">DESCRIBE member;</span><br><span class="line">+-----------+--------------+------+-----+---------+------+</span><br><span class="line">| FIELD     | TYPE         | NULL | KEY | DEFAULT | Extra|</span><br><span class="line">+-----------+--------------+------+-----+---------+------+</span><br><span class="line">| id        | INT(11)      | NO   | PRI | NULL    | auto_|</span><br><span class="line">| name      | VARCHAR(128) | NO   |     | NULL    |      |</span><br><span class="line">| startdate | TIMESTAMP    | NO   |     | cur[...]|      |</span><br><span class="line">| os        | INT(11)      | YES  |     | NULL    |      |</span><br><span class="line">+-----------+--------------+------+-----+---------+------+</span><br></pre></td></tr></table></figure><p>把 <code>linux</code> 表中的唯一 ID 分配给每个成员。因为记录已经存在，使用 <code>UPDATE</code> 关键字而不是 <code>INSERT</code>。尤其是当你想查询某行然后再更新某列值时。语法上，表达方式有点倒装，先更新后查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; UPDATE member SET os=1 WHERE name=&apos;Alice&apos;;</span><br><span class="line">Query OK, 1 ROW affected (0.007 sec)</span><br><span class="line">ROWS matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p>要填充数据，请对其他名字重复执行这个过程。为了数据的多样性，在四行记录中分配三个不同的值。</p><h4 id="连接表"><span id="连接表">连接表</span></h4><p>现在这两个表彼此有了关联，你可以使用 SQL 来展示关联的数据。数据库中有很多种连接方式，你可以尽请尝试。下面的例子是关联 <code>member</code> 表中 <code>os</code> 字段和 <code>linux</code> 表中 <code>id</code> 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM member JOIN linux ON member.os=linux.id;</span><br><span class="line">+----+-------+---------------------+------+----+-----------+</span><br><span class="line">| id | name  | startdate           | os   | id | distro    |</span><br><span class="line">+----+-------+---------------------+------+----+-----------+</span><br><span class="line">|  1 | Alice | 2020-10-03 15:25:06 |    1 |  1 | Slackware |</span><br><span class="line">|  2 | Bob   | 2020-10-03 15:26:43 |    3 |  3 | Fedora    |</span><br><span class="line">|  4 | David | 2020-10-03 15:26:51 |    3 |  3 | Fedora    |</span><br><span class="line">|  3 | Carol | 2020-10-03 15:26:46 |    4 |  4 | Debian    |</span><br><span class="line">+----+-------+---------------------+------+----+-----------+</span><br><span class="line">4 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure><p>连接 <code>os</code> 和 <code>id</code> 字段。</p><p>在图形化的应用中，你可以想象 <code>os</code> 字段可以在下拉菜单中设置，值的来源是 <code>linux</code> 表中的 <code>distro</code> 字段。通过使用多个表中独立却有关联的数据，你可以保证数据的一致性和有效性，使用 SQL 你可以动态地关联它们。</p><h3 id="下载-mariadb-和-mysql-备忘单"><span id="下载-mariadb-和-mysql-备忘单">下载 MariaDB 和 MySQL 备忘单</span></h3><p>MariaDB 是企业级的数据库。它是健壮、强大、高效的数据库引擎。学习它是你向管理 web 应用和编写语言库迈出的伟大的一步。你可以<a href="https://opensource.com/downloads/mariadb-mysql-cheat-sheet" target="_blank" rel="noopener">下载 MariaDB 和 MySQL 备忘单</a>，在你使用 MariaDB 时可以快速参考。</p><hr><p>via: <a href="https://opensource.com/article/20/10/mariadb-mysql-cheat-sheet" target="_blank" rel="noopener">https://opensource.com/article/20/10/mariadb-mysql-cheat-sheet</a></p><p>作者：<a href="https://opensource.com/users/seth" target="_blank" rel="noopener">Seth Kenlon</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#与-mariadb-交互&quot;&gt;与 MariaDB 交互&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#学习-sql-基本知识&quot;&gt;学习 SQL 基本知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#显示数据库的表&quot;&gt;显
      
    
    </summary>
    
    
      <category term="DB" scheme="https://lxb.wiki/categories/DB/"/>
    
    
      <category term="mysql" scheme="https://lxb.wiki/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解一下 Fossil，一个 Git 的替代品</title>
    <link href="https://lxb.wiki/ff3c9770/"/>
    <id>https://lxb.wiki/ff3c9770/</id>
    <published>2020-12-10T13:54:47.000Z</published>
    <updated>2021-01-03T14:05:27.526Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#安装-fossil">安装 Fossil</a></li><li><a href="#创建一个-fossil-仓库">创建一个 Fossil 仓库</a></li><li><a href="#fossil-仓库工作流">Fossil 仓库工作流</a><ul><li><a href="#添加文件">添加文件</a></li><li><a href="#使用分支">使用分支</a></li><li><a href="#合并修改">合并修改</a></li></ul></li><li><a href="#查看-fossil-时间线">查看 Fossil 时间线</a></li><li><a href="#公开你的-fossil-仓库">公开你的 Fossil 仓库</a></li><li><a href="#使用-fossil-作为独立的托管">使用 Fossil 作为独立的托管</a></li></ul><!-- tocstop --><blockquote><p>Fossil 是一个集版本控制系统、bug 追踪、维基、论坛以及文档解决方案于一体的系统。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103215724.png" alt></p><p>每个开发者都知道，追踪代码的修改是至关重要的。有时候你会处于好奇或者教育的目的需要展示你的项目开始和进化的历史。有时候你想让其他的开发者参与到你的项目中，因此你需要一种值得信赖的能合并不同代码分支的方法。更极端一点，有时候你为了解决一个问题而修改的代码导致已有的功能不能正常使用。</p><p><a href="https://fossil-scm.org/home/doc/trunk/www/index.wiki" target="_blank" rel="noopener">Fossil</a> 源码管理系统是由著名的 <a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener">SQLite</a> 数据库的作者开发的一个集版本控制系统、bug 追踪、维基、论坛以及文档解决方案于一体的系统。</p><h3 id="安装-fossil"><span id="安装-fossil">安装 Fossil</span></h3><p>Fossil 是一个独立的 C 程序，因此你可以从它的网站上<a href="https://fossil-scm.org/home/uv/download.html" target="_blank" rel="noopener">下载</a>后放在环境变量 <a href="https://opensource.com/article/17/6/set-path-linux" target="_blank" rel="noopener">PATH</a> 中的任意位置。例如，假定 <code>/usr/local/bin</code> 已经在你的环境变量中（默认情况下是在的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://fossil-scm.org/home/uv/fossil-linux-x64-X.Y.tar.gz</span><br><span class="line">$ sudo tar xvf fossil-linux-x64-X.Y.tar.gz --directory /usr/local/bin</span><br></pre></td></tr></table></figure><p>你也可以通过包管理器从软件仓库中找到 Fossil，或者直接从源码编译。</p><h3 id="创建一个-fossil-仓库"><span id="创建一个-fossil-仓库">创建一个 Fossil 仓库</span></h3><p>如果你已经有一个代码项目，想用 Fossil 来追踪，那么第一步就是创建一个 Fossil 仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ fossil init myproject.fossil</span><br><span class="line">project-id: 010836ac6112fefb0b015702152d447c8c1d8604</span><br><span class="line">server-id:  54d837e9dc938ba1caa56d31b99c35a4c9627f44</span><br><span class="line">admin-user: klaatu (initial password is &quot;14b605&quot;)</span><br></pre></td></tr></table></figure><p>创建 Fossil 仓库的过程中会返回三行信息：一个唯一的项目 ID、一个唯一的服务器 ID 以及管理员 ID 和密码。项目 ID 和服务器 ID 是版本数字。管理员凭证表明你对这个仓库的所有权，当你把 Fossil 作为服务器让其他用户来访问时可以使用管理员权限。</p><h3 id="fossil-仓库工作流"><span id="fossil-仓库工作流">Fossil 仓库工作流</span></h3><p>在你使用 Fossil 仓库之前，你需要先为它的数据创建一个工作路径。你可以把这个过程类比为使用 Python 时创建一个虚拟环境或者解压一个只用来备份的 ZIP 文件。</p><p>创建一个工作目录并进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myprojectdir</span><br><span class="line">$ cd myprojectdir</span><br></pre></td></tr></table></figure><p>把你的 Fossil 打开到刚刚创建的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ fossil open ../myproject</span><br><span class="line">project-name: &lt;unnamed&gt;</span><br><span class="line">repository:   /home/klaatu/myprojectdir/../myproject</span><br><span class="line">local-root:   /home/klaatu/myprojectdir/</span><br><span class="line">config-db:    /home/klaatu/.fossil</span><br><span class="line">project-code: 010836ac6112fefb0b015702152d447c8c1d8604</span><br><span class="line">checkout:     9e6cd96dd675544c58a246520ad58cdd460d1559 2020-11-09 04:09:35 UTC</span><br><span class="line">tags:         trunk</span><br><span class="line">comment:      initial empty check-in (user: klaatu)</span><br><span class="line">check-ins:    1</span><br></pre></td></tr></table></figure><p>你可能注意到了，Fossil 在你的家目录下创建了一个名为 <code>.fossil</code> 的隐藏文件，用来追踪你的全局 Fossil 配置。这个配置不是只适用于你的一个项目的；这个文件只会在你第一次使用 Fossil 时生成。</p><h4 id="添加文件"><span id="添加文件">添加文件</span></h4><p>使用 <code>add</code> 和 <code>commit</code> 子命令来向你的仓库添加文件。例如，创建一个简单的 <code>README</code> 文件，把它添加到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;My first Fossil project&quot; &gt; README</span><br><span class="line">$ fossil add README</span><br><span class="line">ADDED  README</span><br><span class="line">$ fossil commit -m &apos;My first commit&apos;</span><br><span class="line">New_Version: 2472a43acd11c93d08314e852dedfc6a476403695e44f47061607e4e90ad01aa</span><br></pre></td></tr></table></figure><h4 id="使用分支"><span id="使用分支">使用分支</span></h4><p>Fossil 仓库开始时默认使用的主分支名为 <code>trunk</code>。当你想修改代码而又不影响主干代码时，你可以从 trunk 分支切走。创建新分支需要使用 <code>branch</code> 子命令，这个命令需要两个参数：一个新分支的名字，一个新分支的基分支名字。在本例中，只有一个分支 <code>trunk</code>，因此尝试创建一个名为 <code>dev</code> 的新分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ fossil branch --help</span><br><span class="line">Usage: fossil branch new BRANCH-NAME BASIS ?OPTIONS?</span><br><span class="line">$ fossil branch new dev trunk</span><br><span class="line">New branch: cb90e9c6f23a9c98e0c3656d7e18d320fa52e666700b12b5ebbc4674a0703695</span><br></pre></td></tr></table></figure><p>你已经创建了一个新分支，但是你当前所在的分支仍然是 <code>trunk</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fossil branch current</span><br><span class="line">trunk</span><br></pre></td></tr></table></figure><p>使用 <code>checkout</code> 命令切换到你的新分支 <code>dev</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fossil checkout dev</span><br><span class="line">dev</span><br></pre></td></tr></table></figure><h4 id="合并修改"><span id="合并修改">合并修改</span></h4><p>假设你在 <code>dev</code> 分支中添加了一个新文件，完成了测试，现在想把它合并到 <code>trunk</code>。这个过程叫做<em>合并</em>。</p><p>首先，切回目标分支（本例中目标分支为 <code>trunk</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ fossil checkout trunk</span><br><span class="line">trunk</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure><p>这个分支中没有你的新文件（或者你对其他文件的修改），而那些内容是合并的过程需要的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ fossil merge dev</span><br><span class="line"> &quot;fossil undo&quot; is available to undo changes to the working checkout.</span><br><span class="line">$ ls</span><br><span class="line">myfile.lua  README</span><br></pre></td></tr></table></figure><h3 id="查看-fossil-时间线"><span id="查看-fossil-时间线">查看 Fossil 时间线</span></h3><p>使用 <code>timeline</code> 选项来查看仓库的历史。这个命令列出了你的仓库的所有活动的详细信息，包括用来表示每次修改的哈希值、每次提交时填写的信息以及提交者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ fossil timeline</span><br><span class="line">=== 2020-11-09 ===</span><br><span class="line">06:24:16 [5ef06e668b] added exciting new file (user: klaatu tags: dev)</span><br><span class="line">06:11:19 [cb90e9c6f2] Create new branch named &quot;dev&quot; (user: klaatu tags: dev)</span><br><span class="line">06:08:09 [a2bb73e4a3] *CURRENT* some additions were made (user: klaatu tags: trunk)</span><br><span class="line">06:00:47 [2472a43acd] This is my first commit. (user: klaatu tags: trunk)</span><br><span class="line">04:09:35 [9e6cd96dd6] initial empty check-in (user: klaatu tags: trunk)</span><br><span class="line">+++ no more data (5) +++</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103215802.png" alt="Fossil UI" title="Fossil UI"></p><h3 id="公开你的-fossil-仓库"><span id="公开你的-fossil-仓库">公开你的 Fossil 仓库</span></h3><p>因为 Fossil 有个内置的 web 界面，所以 Fossil 不像 GitLab 和 Gitea 那样需要主机服务。Fossil 就是它自己的主机服务，只要你把它放在一台机器上就行了。在你公开你的 Fossil 仓库之前，你还需要通过 web 用户界面（UI）来配置一些信息：</p><p>使用 <code>ui</code> 子命令启动一个本地的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/home/klaatu/myprojectdir/</span><br><span class="line">$ fossil ui</span><br></pre></td></tr></table></figure><p>“Users” 和 “Settings” 是安全相关的，“Configuration” 是项目属性相关的（包括一个合适的标题）。web 界面不仅仅是一个方便的功能。 它是能在生产环境中使用并作为 Fossil 项目的宿主机来使用的。它还有一些其他的高级选项，比如用户管理（或者叫自我管理）、在同一个服务器上与其他的 Fossil 仓库进行单点登录（SSO）。</p><p>当配置完成后，关掉 web 界面并按下 <code>Ctrl+C</code> 来停止 UI 引擎。像提交代码一样提交你的 web 修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fossil commit -m &apos;web ui updates&apos;</span><br><span class="line">New_Version: 11fe7f2855a3246c303df00ec725d0fca526fa0b83fa67c95db92283e8273c60</span><br></pre></td></tr></table></figure><p>现在你可以配置你的 Fossil 服务器了。</p><ol><li>把你的 Fossil 仓库（本例中是 <code>myproject.fossil</code>）复制到服务器，你只需要这一个文件。</li><li>如果你的服务器没有安装 Fossil，就在你的服务器上安装 Fossil。在服务器上安装的过程跟在本地一样。</li><li>在你的 <code>cgi-bin</code> 目录下（或它对应的目录，这取决于你的 HTTP 守护进程）创建一个名为 <code>repo_myproject.cgi</code> 的文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/local/bin/fossil</span><br><span class="line">repository: /home/klaatu/public_html/myproject.fossil</span><br></pre></td></tr></table></figure><p>添加可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x repo_myproject.cgi</span><br></pre></td></tr></table></figure><p>你需要做的都已经做完了。现在可以通过互联网访问你的项目了。</p><p>你可以通过 CGI 脚本来访问 web UI，例如 <code>https://example.com/cgi-bin/repo_myproject.cgi</code>。</p><p>你也可以通过命令行来进行交互：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fossil clone https://klaatu@example.com/cgi-bin/repo_myproject.cgi</span><br></pre></td></tr></table></figure><p>在本地的克隆仓库中工作时，你需要使用 <code>push</code> 子命令把本地的修改推送到远程的仓库，使用 <code>pull</code> 子命令把远程的修改拉取到本地仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fossil push https://klaatu@example.com/cgi-bin/repo_myproject.cgi</span><br></pre></td></tr></table></figure><h3 id="使用-fossil-作为独立的托管"><span id="使用-fossil-作为独立的托管">使用 Fossil 作为独立的托管</span></h3><p>Fossil 将大量的权力交到了你的手中（以及你的合作者的手中），让你不再依赖托管服务。本文只是简单的介绍了基本概念。你的代码项目还会用到很多有用的 Fossil 功能。尝试一下 Fossil。它不仅会改变你对版本控制的理解；它会让你不再考虑其他的版本控制系统。</p><hr><p>via: <a href="https://opensource.com/article/20/11/fossil" target="_blank" rel="noopener">https://opensource.com/article/20/11/fossil</a></p><p>作者：<a href="https://opensource.com/users/klaatu" target="_blank" rel="noopener">Klaatu</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装-fossil&quot;&gt;安装 Fossil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#创建一个-fossil-仓库&quot;&gt;创建一个 Fossil 仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#fossil-仓库
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term=" fossil" scheme="https://lxb.wiki/tags/fossil/"/>
    
  </entry>
  
  <entry>
    <title>跳表的增删改查</title>
    <link href="https://lxb.wiki/942c23ec/"/>
    <id>https://lxb.wiki/942c23ec/</id>
    <published>2020-12-02T13:06:56.000Z</published>
    <updated>2020-12-27T17:27:41.487Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#快速了解跳表">快速了解跳表</a></li><li><a href="#跳表的增删改查">跳表的增删改查</a><ul><li><a href="#查询操作">查询操作</a></li><li><a href="#删除操作">删除操作</a></li><li><a href="#插入操作">插入操作</a></li></ul></li><li><a href="#总结">总结</a></li></ul><!-- tocstop --><h3 id="快速了解跳表"><span id="快速了解跳表">快速了解跳表</span></h3><p>跳跃表(简称跳表)由美国计算机科学家<strong><em>William Pugh发明于1989年</em></strong>。他在论文《Skip lists: a probabilistic alternative to balanced trees》中详细介绍了跳表的数据结构和插入删除等操作。</p><blockquote><p>​    跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。</p></blockquote><p>链表的优势就是更高效的插入、删除。<strong>痛点就是查询很慢很慢</strong>！每次查询都是一种O(n)复杂度的操作</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011145.png" alt></p><p>这是一个带头结点的链表(头结点相当于一个固定的入口，不存储有意义的值)，每次查找都需要一个个枚举，相当的慢，我们能不能稍微优化一下，让它稍微跳一跳呢？答案是可以的，我们知道很多算法和数据结构<strong>以空间换时间</strong>，我们在上面加一层索引，让部分节点在上层能够直接定位到，这样链表的查询时间近乎减少一半</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011307.png" alt></p><p>这样，在查询某个节点的时候，首先会从上一层快速定位节点所在的一个范围，如果找到具体范围向下然后查找代价很小，当然在表的结构设计上会增加一个向下的索引(指针)用来查找确定底层节点。平均查找速度平均为O(n/2)。但是当节点数量很大的时候，它依旧很慢很慢。我们都知道二分查找是每次都能折半的去压缩查找范围，要是有序链表也能这么跳起来那就太完美了。没错<strong>跳表就能让链表拥有近乎的接近二分查找的效率的一种数据结构</strong>，其原理依然是给上面加若干层索引，优化查找速度。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011343.png" alt></p><p>通过上图可以看到，通过这样的一个数据结构对有序链表进行查找都能近乎二分的性能。就是在上面维护那么多层的索引，首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。</p><p>对于理想的跳表，每向上一层索引节点数量都是下一层的1/2.那么如果n个节点增加的节点数量(1/2+1/4+…)&lt;n。并且层数较低，对查找效果影响不大。但是对于这么一个结构，你可能会疑惑，这样完美的结构真的存在吗？大概率不存在的，因为作为一个链表，少不了增删该查的一些操作。而删除和插入可能会改变整个结构，所以上面的这些都是理想的结构，在插入的时候是否添加上层索引是个概率问题(1/2的概率)，</p><h3 id="跳表的增删改查"><span id="跳表的增删改查">跳表的增删改查</span></h3><p>在实现本跳表的过程为了便于操作，我们将跳表的头结点(head)的key设为int的最小值(一定满足左小右大方便比较)。</p><p>对于每个节点的设置，设置成SkipNode类，为了防止初学者将next向下还是向右搞混，直接设置right，down两个指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipNode</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    T value;</span><br><span class="line">    SkipNode right,down;<span class="comment">//右下个方向的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipNode</span> <span class="params">(<span class="keyword">int</span> key,T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳表的结构和初始化也很重要，其主要参数和初始化方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    SkipNode headNode;<span class="comment">//头节点，入口</span></span><br><span class="line">    <span class="keyword">int</span> highLevel;<span class="comment">//当前跳表索引层数</span></span><br><span class="line">    Random random;<span class="comment">// 用于投掷硬币</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;<span class="comment">//最大的层</span></span><br><span class="line"></span><br><span class="line">    SkipList()&#123;</span><br><span class="line">        random=<span class="keyword">new</span> Random();</span><br><span class="line">        headNode=<span class="keyword">new</span> SkipNode(Integer.MIN_VALUE,<span class="keyword">null</span>);</span><br><span class="line">        highLevel=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询操作"><span id="查询操作">查询操作</span></h4><p>很多时候链表也可能这样相连仅仅是某个元素或者key作为有序的标准。所以有可能链表内部存在一些value。不过修改和查询其实都是一个操作，找到关键数字(key)。并且查找的流程也很简单，设置一个临时节点team=head。当<strong>team不为null</strong>其流程大致如下：</p><p>(1) 从team节点出发，<strong>如果当前节点的key与查询的key相等</strong>，那么返回当前节点(如果是修改操作那么一直向下进行修改值即可)。</p><p>(2) 如果key不相等，且<strong>右侧为null</strong>，那么证明只能向下(结果可能出现在下右方向)，此时team=team.down</p><p>(3) 如果key不相等，且右侧不为null，且<strong>右侧节点key小于待查询的key</strong>。那么说明同级还可向右，此时team=team.right</p><p>(4)（否则的情况）如果key不相等，且右侧不为null，且<strong>右侧节点key大于待查询的key</strong> 。那么说明如果有结果的话就在这个索引和下个索引之间，此时team=team.down。</p><p>最终将按照这个步骤返回正确的节点或者null(说明没查到)。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011553.png" alt></p><p>例如上图查询12节点，首先第一步从head出发发现右侧不为空，且7&lt;12,向右；第二步右侧为null向下；第三步节点7的右侧10&lt;12继续向右；第四步10右侧为null向下；第五步右侧12小于等于向右。第六步起始发现相等返回节点结束。</p><p>而这块的代码也非常容易：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SkipNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    SkipNode team=headNode;</span><br><span class="line">    <span class="keyword">while</span> (team!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(team.key==key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  team;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right==<span class="keyword">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//右侧比较小向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><span id="删除操作">删除操作</span></h4><p>删除操作比起查询稍微复杂一丢丢，但是比插入简单。删除需要改变链表结构所以需要处理好节点之间的联系。对于删除操作你需要谨记以下几点：</p><p>(1)删除当前节点和这个节点的前后节点都有关系</p><p>(2)删除当前层节点之后，下一层该key的节点也要删除，一直删除到最底层</p><p>根据这两点分析一下：如果找到当前节点了，<strong>它的前面一个节点怎么查找呢</strong>？这个总不能在遍历一遍吧！有的使用四个方向的指针(上下左右)用来找到左侧节点。是可以的，但是这里可以<strong>特殊处理一下</strong> ，不直接判断和操作节点，先找到<strong>待删除节点的左侧节点</strong>。通过这个节点即可完成删除，然后这个节点直接向下去找下一层待删除的左侧节点。设置一个临时节点team=head，<strong>当team不为null</strong>具体循环流程为：</p><p>(1)如果<strong>team右侧为null</strong>，那么team=team.down(之所以敢直接这么判断是因为左侧有头结点在左侧，不用担心特殊情况)</p><p>(2)如果team右侧不 为null，并且<strong>右侧的key等于待删除的key</strong>，那么先删除节点，再team向下team=team.down为了删除下层节点。</p><p>(3)如果team右侧不 为null，并且<strong>右侧key小于待删除的key</strong>，那么team向右team=team.right。</p><p>(4)如果team右侧不 为null，并且<strong>右侧key大于待删除的key</strong>，那么team向下team=team.down，在下层继续查找删除节点。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011642.png" alt></p><p>例如上图删除10节点，首先team=head从team出发，7&lt;10向右(team=team.right后面省略)；第二步右侧为null只能向下；第三部右侧为10在当前层删除10节点然后向下继续查找下一层10节点；第四步8&lt;10向右；第五步右侧为10删除该节点并且team向下。team为null说明删除完毕退出循环。</p><p>删除操作实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span><span class="comment">//删除不需要考虑层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SkipNode team=headNode;</span><br><span class="line">    <span class="keyword">while</span> (team!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (team.right == <span class="keyword">null</span>) &#123;<span class="comment">//右侧没有了，说明这一层找到，没有只能下降</span></span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key==key)<span class="comment">//找到节点，右侧即为待删除节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            team.right=team.right.right;<span class="comment">//删除右侧节点</span></span><br><span class="line">            team=team.down;<span class="comment">//向下继续查找删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//右侧已经不可能了，向下</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//节点还在右侧</span></span><br><span class="line">            team=team.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入操作"><span id="插入操作">插入操作</span></h4><p>插入操作在实现起来是最麻烦的，需要的考虑的东西最多。回顾查询，不需要动索引；回顾删除，每层索引如果有删除就是了。但是插入不一样了，<strong>插入需要考虑是否插入索引，插入几层</strong>等问题。由于需要插入删除所以我们肯定无法维护一个完全理想的索引结构，因为它耗费的代价太高。但我们使用<strong>随机化</strong>的方法去判断是否向上层插入索引。即产生一个[0-1]的随机数如果小于0.5就向上插入索引，插入完毕后再次使用随机数判断是否向上插入索引。运气好这个值可能是多层索引，运气不好只插入最底层(这是100%插入的)。但是索引也不能不限制高度，我们一般会设置索引最高值如果大于这个值就不往上继续添加索引了。</p><p>我们一步步剖析该怎么做，其流程为</p><p>(1)首先通过上面查找的方式，找到<strong>待插入的左节点</strong>。插入的话最底层肯定是需要插入的，所以通过链表插入节点(需要考虑是否为末尾节点)</p><p>(2)插入完这一层，需要考虑上一层是否插入，首先判断当前索引层级，如果大于最大值那么就停止(比如已经到最高索引层了)。否则设置一个随机数1/2的概率向上插入一层索引(因为理想状态下的就是每2个向上建一个索引节点)。</p><p>(3)继续(2)的操作，直到概率退出或者索引层数大于最大索引层。</p><p>在<strong>具体向上插入</strong>的时候，实质上还有非常重要的细节需要考虑。首先<strong>如何找到上层的待插入节点</strong> ？</p><p>这个各个实现方法可能不同，如果有左、上指向的指针那么可以向左向上找到上层需要插入的节点，但是如果只有右指向和下指向的我们也可以<strong>巧妙的借助查询过程中记录下降的节点</strong>。因为曾经下降的节点倒序就是需要插入的节点，最底层也不例外(因为没有匹配值会下降为null结束循环)。在这里我使用<strong>栈</strong>这个数据结构进行存储，当然使用List也可以。下图就是给了一个插入示意图。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011750.png" alt></p><p>其次如果该层是目前的<strong>最高层索引</strong>，需要<strong>继续向上建立索引</strong>应该怎么办？</p><p>首先跳表最初肯定是没索引的，然后慢慢添加节点才有一层、二层索引，但是如果这个节点添加的索引突破当前最高层，该怎么办呢？</p><p>这时候<strong>需要注意</strong>了，跳表的head需要改变了，新建一个ListNode节点作为新的head，将它的down指向老head，将这个head节点加入栈中(也就是这个节点作为下次后面要插入的节点)，就比如上面的9节点如果运气够好在往上建立一层节点，会是这样的。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011835.png" alt></p><p>插入上层的时候注意所有节点要新建(拷贝)，除了right的指向down的指向也不能忘记，down指向上一个节点可以用一个临时节点作为前驱节点。如果层数突破当前最高层，头head节点(入口)需要改变。</p><p>这部分更多的细节在代码中注释解释了，详细代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(SkipNode node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> key=node.key;</span><br><span class="line">    SkipNode findNode=search(key);</span><br><span class="line">    <span class="keyword">if</span>(findNode!=<span class="keyword">null</span>)<span class="comment">//如果存在这个key的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        findNode.value=node.value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;SkipNode&gt;stack=<span class="keyword">new</span> Stack&lt;SkipNode&gt;();<span class="comment">//存储向下的节点，这些节点可能在右侧插入节点</span></span><br><span class="line">    SkipNode team=headNode;<span class="comment">//查找待插入的节点   找到最底层的哪个节点。</span></span><br><span class="line">    <span class="keyword">while</span> (team!=<span class="keyword">null</span>) &#123;<span class="comment">//进行查找操作 </span></span><br><span class="line">        <span class="keyword">if</span>(team.right==<span class="keyword">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">        &#123;</span><br><span class="line">            stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">        &#123;</span><br><span class="line">            stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">1</span>;<span class="comment">//当前层数，从第一层添加(第一层必须添加，先添加再判断)</span></span><br><span class="line">    SkipNode downNode=<span class="keyword">null</span>;<span class="comment">//保持前驱节点(即down的指向，初始为null)</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//在该层插入node</span></span><br><span class="line">        team=stack.pop();<span class="comment">//抛出待插入的左侧节点</span></span><br><span class="line">        SkipNode nodeTeam=<span class="keyword">new</span> SkipNode(node.key, node.value);<span class="comment">//节点需要重新创建</span></span><br><span class="line">        nodeTeam.down=downNode;<span class="comment">//处理竖方向</span></span><br><span class="line">        downNode=nodeTeam;<span class="comment">//标记新的节点下次使用</span></span><br><span class="line">        <span class="keyword">if</span>(team.right==<span class="keyword">null</span>) &#123;<span class="comment">//右侧为null 说明插入在末尾</span></span><br><span class="line">            team.right=nodeTeam;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//水平方向处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右侧还有节点，插入在两者之间</span></span><br><span class="line">            nodeTeam.right=team.right;</span><br><span class="line">            team.right=nodeTeam;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑是否需要向上</span></span><br><span class="line">        <span class="keyword">if</span>(level&gt;MAX_LEVEL)<span class="comment">//已经到达最高级的节点啦</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">double</span> num=random.nextDouble();<span class="comment">//[0-1]随机数</span></span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0.5</span>)<span class="comment">//运气不好结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;highLevel)<span class="comment">//比当前最大高度要高但是依然在允许范围内 需要改变head节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            highLevel=level;</span><br><span class="line">            <span class="comment">//需要创建一个新的节点</span></span><br><span class="line">            SkipNode highHeadNode=<span class="keyword">new</span> SkipNode(Integer.MIN_VALUE, <span class="keyword">null</span>);</span><br><span class="line">            highHeadNode.down=headNode;</span><br><span class="line">            headNode=highHeadNode;<span class="comment">//改变head</span></span><br><span class="line">            stack.add(headNode);<span class="comment">//下次抛出head</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><span id="总结">总结</span></h3><p>对于上面，跳表完整分析就结束啦，当然，你可能看到不同品种跳表的实现，还有的用数组方式表示上下层的关系这样也可以，但本文只定义right和down两个方向的链表更纯正化的讲解跳表。</p><p>对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？因为跳表除了查找插入维护和红黑树有着差不多的效率，它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。而JDK中<strong>跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。</strong> 有兴趣的也可以查阅一下源码。</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipNode</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    T value;</span><br><span class="line">    SkipNode right,down;<span class="comment">//左右上下四个方向的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipNode</span> <span class="params">(<span class="keyword">int</span> key,T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    SkipNode headNode;<span class="comment">//头节点，入口</span></span><br><span class="line">    <span class="keyword">int</span> highLevel;<span class="comment">//层数</span></span><br><span class="line">    Random random;<span class="comment">// 用于投掷硬币</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;<span class="comment">//最大的层</span></span><br><span class="line">    SkipList()&#123;</span><br><span class="line">        random=<span class="keyword">new</span> Random();</span><br><span class="line">        headNode=<span class="keyword">new</span> SkipNode(Integer.MIN_VALUE,<span class="keyword">null</span>);</span><br><span class="line">        highLevel=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SkipNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        SkipNode team=headNode;</span><br><span class="line">        <span class="keyword">while</span> (team!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(team.key==key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>  team;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right==<span class="keyword">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//右侧比较小向右</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span><span class="comment">//删除不需要考虑层数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SkipNode team=headNode;</span><br><span class="line">        <span class="keyword">while</span> (team!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (team.right == <span class="keyword">null</span>) &#123;<span class="comment">//右侧没有了，说明这一层找到，没有只能下降</span></span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key==key)<span class="comment">//找到节点，右侧即为待删除节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                team.right=team.right.right;<span class="comment">//删除右侧节点</span></span><br><span class="line">                team=team.down;<span class="comment">//向下继续查找删除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//右侧已经不可能了，向下</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//节点还在右侧</span></span><br><span class="line">                team=team.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(SkipNode node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> key=node.key;</span><br><span class="line">        SkipNode findNode=search(key);</span><br><span class="line">        <span class="keyword">if</span>(findNode!=<span class="keyword">null</span>)<span class="comment">//如果存在这个key的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            findNode.value=node.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;SkipNode&gt;stack=<span class="keyword">new</span> Stack&lt;SkipNode&gt;();<span class="comment">//存储向下的节点，这些节点可能在右侧插入节点</span></span><br><span class="line">        SkipNode team=headNode;<span class="comment">//查找待插入的节点   找到最底层的哪个节点。</span></span><br><span class="line">        <span class="keyword">while</span> (team!=<span class="keyword">null</span>) &#123;<span class="comment">//进行查找操作</span></span><br><span class="line">            <span class="keyword">if</span>(team.right==<span class="keyword">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//向右</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">1</span>;<span class="comment">//当前层数，从第一层添加(第一层必须添加，先添加再判断)</span></span><br><span class="line">        SkipNode downNode=<span class="keyword">null</span>;<span class="comment">//保持前驱节点(即down的指向，初始为null)</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//在该层插入node</span></span><br><span class="line">            team=stack.pop();<span class="comment">//抛出待插入的左侧节点</span></span><br><span class="line">            SkipNode nodeTeam=<span class="keyword">new</span> SkipNode(node.key, node.value);<span class="comment">//节点需要重新创建</span></span><br><span class="line">            nodeTeam.down=downNode;<span class="comment">//处理竖方向</span></span><br><span class="line">            downNode=nodeTeam;<span class="comment">//标记新的节点下次使用</span></span><br><span class="line">            <span class="keyword">if</span>(team.right==<span class="keyword">null</span>) &#123;<span class="comment">//右侧为null 说明插入在末尾</span></span><br><span class="line">                team.right=nodeTeam;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//水平方向处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//右侧还有节点，插入在两者之间</span></span><br><span class="line">                nodeTeam.right=team.right;</span><br><span class="line">                team.right=nodeTeam;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//考虑是否需要向上</span></span><br><span class="line">            <span class="keyword">if</span>(level&gt;MAX_LEVEL)<span class="comment">//已经到达最高级的节点啦</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">double</span> num=random.nextDouble();<span class="comment">//[0-1]随机数</span></span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0.5</span>)<span class="comment">//运气不好结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">if</span>(level&gt;highLevel)<span class="comment">//比当前最大高度要高但是依然在允许范围内 需要改变head节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                highLevel=level;</span><br><span class="line">                <span class="comment">//需要创建一个新的节点</span></span><br><span class="line">                SkipNode highHeadNode=<span class="keyword">new</span> SkipNode(Integer.MIN_VALUE, <span class="keyword">null</span>);</span><br><span class="line">                highHeadNode.down=headNode;</span><br><span class="line">                headNode=highHeadNode;<span class="comment">//改变head</span></span><br><span class="line">                stack.add(headNode);<span class="comment">//下次抛出head</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SkipNode teamNode=headNode;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">        SkipNode last=teamNode;</span><br><span class="line">        <span class="keyword">while</span> (last.down!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            last=last.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (teamNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            SkipNode enumNode=teamNode.right;</span><br><span class="line">            SkipNode enumLast=last.right;</span><br><span class="line">            System.out.printf(<span class="string">"%-8s"</span>,<span class="string">"head-&gt;"</span>);</span><br><span class="line">            <span class="keyword">while</span> (enumLast!=<span class="keyword">null</span>&amp;&amp;enumNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(enumLast.key==enumNode.key)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"%-5s"</span>,enumLast.key+<span class="string">"-&gt;"</span>);</span><br><span class="line">                    enumLast=enumLast.right;</span><br><span class="line">                    enumNode=enumNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    enumLast=enumLast.right;</span><br><span class="line">                    System.out.printf(<span class="string">"%-5s"</span>,<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            teamNode=teamNode.down;</span><br><span class="line">            index++;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SkipList&lt;Integer&gt;list=<span class="keyword">new</span> SkipList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> SkipNode(i,<span class="number">666</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        list.printList();</span><br><span class="line">        list.delete(<span class="number">4</span>);</span><br><span class="line">        list.delete(<span class="number">8</span>);</span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#快速了解跳表&quot;&gt;快速了解跳表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#跳表的增删改查&quot;&gt;跳表的增删改查&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#查询操作&quot;&gt;查询操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="跳表" scheme="https://lxb.wiki/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tmux 使用教程</title>
    <link href="https://lxb.wiki/176a23be/"/>
    <id>https://lxb.wiki/176a23be/</id>
    <published>2020-11-30T15:46:08.000Z</published>
    <updated>2020-12-01T16:31:15.901Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-tmux-是什么">1 Tmux 是什么？</a><ul><li><a href="#11-会话与进程">1.1 会话与进程</a></li><li><a href="#12-tmux-的作用">1.2 Tmux 的作用</a></li></ul></li><li><a href="#2-基本用法">2 基本用法</a><ul><li><a href="#21-安装">2.1 安装</a></li><li><a href="#22-启动与退出">2.2 启动与退出</a></li><li><a href="#23-前缀键">2.3 前缀键</a></li></ul></li><li><a href="#3-会话管理">3 会话管理</a><ul><li><a href="#31-新建会话">3.1 新建会话</a></li><li><a href="#32-分离会话">3.2 分离会话</a></li><li><a href="#33-接入会话">3.3 接入会话</a></li><li><a href="#34-杀死会话">3.4 杀死会话</a></li><li><a href="#35-切换会话">3.5 切换会话</a></li><li><a href="#36-重命名会话">3.6 重命名会话</a></li><li><a href="#37-会话快捷键">3.7 会话快捷键</a></li></ul></li><li><a href="#4-最简操作流程">4 最简操作流程</a></li><li><a href="#5-窗格操作">5 窗格操作</a><ul><li><a href="#51-划分窗格">5.1 划分窗格</a></li><li><a href="#52-移动光标">5.2 移动光标</a></li><li><a href="#53-交换窗格位置">5.3 交换窗格位置</a></li><li><a href="#54-窗格快捷键">5.4 窗格快捷键</a></li></ul></li><li><a href="#6-窗口管理">6 窗口管理</a><ul><li><a href="#61-新建窗口">6.1 新建窗口</a></li><li><a href="#62-切换窗口">6.2 切换窗口</a></li><li><a href="#63-重命名窗口">6.3 重命名窗口</a></li><li><a href="#64-窗口快捷键">6.4 窗口快捷键</a></li></ul></li><li><a href="#7-其他命令">7 其他命令</a></li><li><a href="#8-参考链接">8 参考链接</a></li></ul><!-- tocstop --><h2 id="1-tmux-是什么"><span id="1-tmux-是什么">1 Tmux 是什么？</span></h2><h3 id="11-会话与进程"><span id="11-会话与进程">1.1 会话与进程</span></h3><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://lxb.wiki/2e3ff18f/">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p><p>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><h3 id="12-tmux-的作用"><span id="12-tmux-的作用">1.2 Tmux 的作用</span></h3><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p><blockquote><p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p><p>（2） 它可以让新窗口”接入”已经存在的会话。</p><p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p><p>（4）它还支持窗口任意的垂直和水平拆分。</p></blockquote><p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p><h2 id="2-基本用法"><span id="2-基本用法">2 基本用法</span></h2><h3 id="21-安装"><span id="21-安装">2.1 安装</span></h3><p>Tmux 一般需要自己安装。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># Ubuntu 或 Debian</span></span><br><span class="line">&gt; $ sudo apt-get install tmux</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># CentOS 或 Fedora</span></span><br><span class="line">&gt; $ sudo yum install tmux</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># Mac</span></span><br><span class="line">&gt; $ brew install tmux</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="22-启动与退出"><span id="22-启动与退出">2.2 启动与退出</span></h3><p>安装完成后，键入<code>tmux</code>命令，就进入了 Tmux 窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201001437.png" alt></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ <span class="built_in">exit</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="23-前缀键"><span id="23-前缀键">2.3 前缀键</span></h3><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h2 id="3-会话管理"><span id="3-会话管理">3 会话管理</span></h2><h3 id="31-新建会话"><span id="31-新建会话">3.1 新建会话</span></h3><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux new -s &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令新建一个指定名称的会话。</p><h3 id="32-分离会话"><span id="32-分离会话">3.2 分离会话</span></h3><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux detach</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux ls</span><br><span class="line">&gt; <span class="comment"># or</span></span><br><span class="line">&gt; $ tmux list-session</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="33-接入会话"><span id="33-接入会话">3.3 接入会话</span></h3><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用会话编号</span></span><br><span class="line">&gt; $ tmux attach -t 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 使用会话名称</span></span><br><span class="line">&gt; $ tmux attach -t &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="34-杀死会话"><span id="34-杀死会话">3.4 杀死会话</span></h3><p><code>tmux kill-session</code>命令用于杀死某个会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用会话编号</span></span><br><span class="line">&gt; $ tmux <span class="built_in">kill</span>-session -t 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 使用会话名称</span></span><br><span class="line">&gt; $ tmux <span class="built_in">kill</span>-session -t &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="35-切换会话"><span id="35-切换会话">3.5 切换会话</span></h3><p><code>tmux switch</code>命令用于切换会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用会话编号</span></span><br><span class="line">&gt; $ tmux switch -t 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 使用会话名称</span></span><br><span class="line">&gt; $ tmux switch -t &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="36-重命名会话"><span id="36-重命名会话">3.6 重命名会话</span></h3><p><code>tmux rename-session</code>命令用于重命名会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux rename-session -t 0 &lt;new-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令将0号会话重命名。</p><h3 id="37-会话快捷键"><span id="37-会话快捷键">3.7 会话快捷键</span></h3><p>下面是一些会话相关的快捷键。</p><blockquote><ul><li><code>Ctrl+b d</code>：分离当前会话。</li><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>Ctrl+b $</code>：重命名当前会话。</li></ul></blockquote><h2 id="4-最简操作流程"><span id="4-最简操作流程">4 最简操作流程</span></h2><p>综上所述，以下是 Tmux 的最简操作流程。</p><blockquote><ol><li>新建会话<code>tmux new -s my_session</code>。</li><li>在 Tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux attach-session -t my_session</code>。</li></ol></blockquote><h2 id="5-窗格操作"><span id="5-窗格操作">5 窗格操作</span></h2><p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。</p><h3 id="51-划分窗格"><span id="51-划分窗格">5.1 划分窗格</span></h3><p><code>tmux split-window</code>命令用来划分窗格。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 划分上下两个窗格</span></span><br><span class="line">&gt; $ tmux split-window</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 划分左右两个窗格</span></span><br><span class="line">&gt; $ tmux split-window -h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201002216.png" alt></p><h3 id="52-移动光标"><span id="52-移动光标">5.2 移动光标</span></h3><p><code>tmux select-pane</code>命令用来移动光标位置。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 光标切换到上方窗格</span></span><br><span class="line">&gt; $ tmux select-pane -U</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 光标切换到下方窗格</span></span><br><span class="line">&gt; $ tmux select-pane -D</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 光标切换到左边窗格</span></span><br><span class="line">&gt; $ tmux select-pane -L</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 光标切换到右边窗格</span></span><br><span class="line">&gt; $ tmux select-pane -R</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="53-交换窗格位置"><span id="53-交换窗格位置">5.3 交换窗格位置</span></h3><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 当前窗格上移</span></span><br><span class="line">&gt; $ tmux swap-pane -U</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 当前窗格下移</span></span><br><span class="line">&gt; $ tmux swap-pane -D</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="54-窗格快捷键"><span id="54-窗格快捷键">5.4 窗格快捷键</span></h3><p>下面是一些窗格操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b %</code>：划分左右两个窗格。</li><li><code>Ctrl+b &quot;</code>：划分上下两个窗格。</li><li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li><li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li><li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li><li><code>Ctrl+b {</code>：当前窗格与上一个窗格交换位置。</li><li><code>Ctrl+b }</code>：当前窗格与下一个窗格交换位置。</li><li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li><li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li><li><code>Ctrl+b x</code>：关闭当前窗格。</li><li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li><li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li><li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li><li><code>Ctrl+b q</code>：显示窗格编号。</li></ul></blockquote><h2 id="6-窗口管理"><span id="6-窗口管理">6 窗口管理</span></h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p><h3 id="61-新建窗口"><span id="61-新建窗口">6.1 新建窗口</span></h3><p><code>tmux new-window</code>命令用来创建新窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux new-window</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 新建一个指定名称的窗口</span></span><br><span class="line">&gt; $ tmux new-window -n &lt;window-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="62-切换窗口"><span id="62-切换窗口">6.2 切换窗口</span></h3><p><code>tmux select-window</code>命令用来切换窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 切换到指定编号的窗口</span></span><br><span class="line">&gt; $ tmux select-window -t &lt;window-number&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 切换到指定名称的窗口</span></span><br><span class="line">&gt; $ tmux select-window -t &lt;window-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="63-重命名窗口"><span id="63-重命名窗口">6.3 重命名窗口</span></h3><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux rename-window &lt;new-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="64-窗口快捷键"><span id="64-窗口快捷键">6.4 窗口快捷键</span></h3><p>下面是一些窗口操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li><li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li><li><code>Ctrl+b n</code>：切换到下一个窗口。</li><li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li><li><code>Ctrl+b w</code>：从列表中选择窗口。</li><li><code>Ctrl+b ,</code>：窗口重命名。</li></ul></blockquote><h2 id="7-其他命令"><span id="7-其他命令">7 其他命令</span></h2><p>下面是一些其他命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 列出所有快捷键，及其对应的 Tmux 命令</span></span><br><span class="line">&gt; $ tmux list-keys</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有 Tmux 命令及其参数</span></span><br><span class="line">&gt; $ tmux list-commands</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出当前所有 Tmux 会话的信息</span></span><br><span class="line">&gt; $ tmux info</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 重新加载当前的 Tmux 配置</span></span><br><span class="line">&gt; $ tmux <span class="built_in">source</span>-file ~/.tmux.conf</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="8-参考链接"><span id="8-参考链接">8 参考链接</span></h2><ul><li><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/" target="_blank" rel="noopener">A Quick and Easy Guide to tmux</a></li><li><a href="https://danielmiessler.com/study/tmux/" target="_blank" rel="noopener">Tactical tmux: The 10 Most Important Commands</a></li><li><a href="https://linuxize.com/post/getting-started-with-tmux/" target="_blank" rel="noopener">Getting started with Tmux</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-tmux-是什么&quot;&gt;1 Tmux 是什么？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-会话与进程&quot;&gt;1.1 会话与进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-tmux-的作用&quot;&gt;1.2 T
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="tmux" scheme="https://lxb.wiki/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 守护进程的启动方法</title>
    <link href="https://lxb.wiki/2e3ff18f/"/>
    <id>https://lxb.wiki/2e3ff18f/</id>
    <published>2020-11-03T12:49:04.000Z</published>
    <updated>2020-11-30T16:07:09.880Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-问题的由来">1 问题的由来</a></li><li><a href="#2-前台任务与后台任务">2 前台任务与后台任务</a></li><li><a href="#3-sighup信号">3 SIGHUP信号</a></li><li><a href="#4-disown-命令">4 disown 命令</a></li><li><a href="#5-标准-io">5 标准 I/O</a></li><li><a href="#6-nohup-命令">6 nohup 命令</a></li><li><a href="#7-screen-命令与-tmux-命令">7 Screen 命令与 Tmux 命令</a></li><li><a href="#8-node-工具">8 Node 工具</a></li><li><a href="#9-systemd">9 Systemd</a></li></ul><!-- tocstop --><p><a href="http://baike.baidu.com/view/53123.htm" target="_blank" rel="noopener">“守护进程”</a>（daemon）就是一直在后台运行的进程（daemon）。</p><p>如何将一个 Web 应用，启动为守护进程。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/201130/00.png" alt></p><h2 id="1-问题的由来"><span id="1-问题的由来">1 问题的由来</span></h2><p>Web应用写好后，下一件事就是启动，让它一直在后台运行。</p><p>这并不容易。举例来说，下面是一个最简单的Node应用<code>server.js</code>，只有6行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>你在命令行下启动它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br></pre></td></tr></table></figure><p>看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。</p><p>怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？</p><h2 id="2-前台任务与后台任务"><span id="2-前台任务与后台任务">2 前台任务与后台任务</span></h2><p>上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。</p><p>变成守护进程的第一步，就是把它改成”后台任务”（background job）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js &amp;</span><br></pre></td></tr></table></figure><p>只要在命令的尾部加上符号<code>&amp;</code>，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按<code>ctrl + z</code>，然后执行<code>bg</code>命令（让最近一个暂停的”后台任务”继续执行）。</p><p>“后台任务”有两个特点。</p><ol><li>继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。</li><li>不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。</li></ol><p>可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。</p><h2 id="3-sighup信号"><span id="3-sighup信号">3 SIGHUP信号</span></h2><p>变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？</p><p>Linux系统是这样设计的。</p><ol><li>用户准备退出 session</li><li>系统向该 session 发出<code>SIGHUP</code>信号</li><li>session 将<code>SIGHUP</code>信号发给所有子进程</li><li>子进程收到<code>SIGHUP</code>信号后，自动退出</li></ol><p>上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了<code>SIGHUP</code>信号。</p><p>那么，”后台任务”是否也会收到<code>SIGHUP</code>信号？</p><p>这由 Shell 的<code>huponexit</code>参数决定的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> | grep huponexit</span><br></pre></td></tr></table></figure><p>执行上面的命令，就会看到<code>huponexit</code>参数的值。</p><p>大多数Linux系统，这个参数默认关闭（<code>off</code>）。因此，session 退出的时候，不会把<code>SIGHUP</code>信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出。</p><h2 id="4-disown-命令"><span id="4-disown-命令">4 disown 命令</span></h2><p>通过”后台任务”启动”守护进程”并不保险，因为有的系统的<code>huponexit</code>参数可能是打开的（<code>on</code>）。</p><p>更保险的方法是使用<code>disown</code>命令。它可以将指定任务从”后台任务”列表（<code>jobs</code>命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session 就肯定不会向它发出<code>SIGHUP</code>信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure><p>执行上面的命令以后，<code>server.js</code>进程就被移出了”后台任务”列表。你可以执行<code>jobs</code>命令验证，输出结果里面，不会有这个进程。</p><p><code>disown</code>的用法如下。</p><p>​    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移出最近一个正在执行的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出所有正在执行的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出所有后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不移出后台任务，但是让它们不会收到SIGHUP信号</span></span><br><span class="line">$ <span class="built_in">disown</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据jobId，移出指定的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> %2</span><br><span class="line">$ <span class="built_in">disown</span> -h %2</span><br></pre></td></tr></table></figure><h2 id="5-标准-io"><span id="5-标准-io">5 标准 I/O</span></h2><p>使用<code>disown</code>命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准I/O有交互，它还是会挂掉。</p><p>还是以上面的脚本为例，现在加入一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server starts...'</span>); <span class="comment">// 加入此行</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>启动上面的脚本，然后再执行<code>disown</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure><p>接着，你退出 session，访问5000端口，就会发现连不上。</p><p>这是因为”后台任务”的标准 I/O 继承自当前 session，<code>disown</code>命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。</p><p>为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ node server.js &gt; stdout.txt 2&gt; stderr.txt &lt; /dev/null &amp;</span><br><span class="line">&gt; $ <span class="built_in">disown</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面这样执行，基本上就没有问题了。</p><h2 id="6-nohup-命令"><span id="6-nohup-命令">6 nohup 命令</span></h2><p>还有比<code>disown</code>更方便的命令，就是<code>nohup</code>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ nohup node server.js &amp;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>nohup</code>命令对<code>server.js</code>进程做了三件事。</p><blockquote><ul><li>阻止<code>SIGHUP</code>信号发到这个进程。</li><li>关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。</li><li>重定向标准输出和标准错误到文件<code>nohup.out</code>。</li></ul></blockquote><p>也就是说，<code>nohup</code>命令实际上将子进程与它所在的 session 分离了。</p><p>注意，<code>nohup</code>命令不会自动把进程变为”后台任务”，所以必须加上<code>&amp;</code>符号。</p><h2 id="7-screen-命令与-tmux-命令"><span id="7-screen-命令与-tmux-命令">7 Screen 命令与 Tmux 命令</span></h2><p>另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 <a href="https://www.gnu.org/software/screen/" target="_blank" rel="noopener">Screen</a> 命令和 <a href="https://tmux.github.io/" target="_blank" rel="noopener">Tmux</a> 命令。</p><p>它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。</p><p>Screen 的用法如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 新建一个 session</span></span><br><span class="line">&gt; $ screen</span><br><span class="line">&gt; $ node server.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后，按下<code>ctrl + A</code>和<code>ctrl + D</code>，回到原来的 session，从那里退出登录。下次登录时，再切回去。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ screen -r</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果新建多个后台 session，就需要为它们指定名字。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ screen -S name</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 切回指定 session</span></span><br><span class="line">&gt; $ screen -r name</span><br><span class="line">&gt; $ screen -r pid_number</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有 session</span></span><br><span class="line">&gt; $ screen -ls</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果要停掉某个 session，可以先切回它，然后按下<code>ctrl + c</code>和<code>ctrl + d</code>。</p><p>Tmux 比 Screen 功能更多、更强大，它的基本用法如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux</span><br><span class="line">&gt; $ node server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 返回原来的session</span></span><br><span class="line">&gt; $ tmux detach</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>除了<code>tmux detach</code>，另一种方法是按下<code>Ctrl + B</code>和<code>d</code> ，也可以回到原来的 session。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 下次登录时，返回后台正在运行服务session</span></span><br><span class="line">&gt; $ tmux attach</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果新建多个 session，就需要为每个 session 指定名字。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 新建 session</span></span><br><span class="line">&gt; $ tmux new -s session_name</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 切换到指定 session</span></span><br><span class="line">&gt; $ tmux attach -t session_name</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有 session</span></span><br><span class="line">&gt; $ tmux list-sessions</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 退出当前 session，返回前一个 session </span></span><br><span class="line">&gt; $ tmux detach</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 杀死指定 session</span></span><br><span class="line">&gt; $ tmux <span class="built_in">kill</span>-session -t session-name</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="8-node-工具"><span id="8-node-工具">8 Node 工具</span></h2><p>对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：<a href="https://github.com/foreverjs/forever" target="_blank" rel="noopener">forever</a>，<a href="http://nodemon.io/" target="_blank" rel="noopener">nodemon</a> 和 <a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">pm2</a>。</p><p>forever 的功能很简单，就是保证进程退出时，应用会自动重启。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 作为前台任务启动</span></span><br><span class="line">&gt; $ forever server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 作为服务进程启动 </span></span><br><span class="line">&gt; $ forever start app.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 停止服务进程</span></span><br><span class="line">&gt; $ forever stop Id</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 重启服务进程</span></span><br><span class="line">&gt; $ forever restart Id</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 监视当前目录的文件变动，一有变动就重启</span></span><br><span class="line">&gt; $ forever -w server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># -m 参数指定最多重启次数</span></span><br><span class="line">&gt; $ forever -m 5 server.js </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有进程</span></span><br><span class="line">&gt; $ forever list</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>nodemon</code>一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 默认监视当前目录的文件变化</span></span><br><span class="line">&gt; $ nodemon server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; ＃ 监视指定文件的变化   </span><br><span class="line">&gt; $ nodemon --watch app --watch libs server.js  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 启动应用</span></span><br><span class="line">&gt; $ pm2 start app.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 指定同时起多少个进程（由CPU核心数决定），组成一个集群</span></span><br><span class="line">&gt; $ pm2 start app.js -i max</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有任务</span></span><br><span class="line">&gt; $ pm2 list</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 停止指定任务</span></span><br><span class="line">&gt; $ pm2 stop 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; ＃ 重启指定任务</span><br><span class="line">&gt; $ pm2 restart 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 删除指定任务</span></span><br><span class="line">&gt; $ pm2 delete 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 保存当前的所有任务，以后可以恢复</span></span><br><span class="line">&gt; $ pm2 save</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出每个进程的统计数据</span></span><br><span class="line">&gt; $ pm2 monit</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 查看所有日志</span></span><br><span class="line">&gt; $ pm2 logs</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 导出数据</span></span><br><span class="line">&gt; $ pm2 dump</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 重启所有进程</span></span><br><span class="line">&gt; $ pm2 <span class="built_in">kill</span></span><br><span class="line">&gt; $ pm2 resurect</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 启动web界面 http://localhost:9615</span></span><br><span class="line">&gt; $ pm2 web</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="9-systemd"><span id="9-systemd">9 Systemd</span></h2><p>除了专用工具以外，Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-问题的由来&quot;&gt;1 问题的由来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-前台任务与后台任务&quot;&gt;2 前台任务与后台任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-sighup信号&quot;&gt;3 SIGHU
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://lxb.wiki/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="daemon" scheme="https://lxb.wiki/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>目录切换：dirs、pushd、popd命令</title>
    <link href="https://lxb.wiki/1ca354f7/"/>
    <id>https://lxb.wiki/1ca354f7/</id>
    <published>2020-11-01T13:05:57.000Z</published>
    <updated>2020-11-16T13:24:50.114Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#目录栈指令">目录栈指令</a><ul><li><a href="#1-dirs">1 dirs</a><ul><li><a href="#11-功能">1.1 功能</a></li><li><a href="#12-语法">1.2 语法</a></li></ul></li><li><a href="#2-pushd">2 pushd</a><ul><li><a href="#21-功能">2.1 功能</a></li><li><a href="#22-语法">2.2 语法</a></li></ul></li><li><a href="#3-popd">3 popd</a><ul><li><a href="#31-功能">3.1 功能</a></li><li><a href="#32-语法">3.2 语法</a></li></ul></li><li><a href="#4-示例">4 示例</a></li></ul></li></ul><!-- tocstop --><h2 id="目录栈指令"><span id="目录栈指令">目录栈指令</span></h2><p>目录栈是用户最近访问过的系统目录列表，并以堆栈的形式管理。栈中的内容与Shell环境变量 <code>DIRSTACK</code> 的值对应</p><h3 id="1-dirs"><span id="1-dirs">1 dirs</span></h3><h4 id="11-功能"><span id="11-功能">1.1 功能</span></h4><p>显示当前目录栈中的所有记录（不带参数的dirs命令显示当前目录栈中的记录）</p><h4 id="12-语法"><span id="12-语法">1.2 语法</span></h4><p><strong>格式：</strong></p><p><code>dirs [-clpv] [+n] [-n]</code></p><p><strong>选项</strong></p><ul><li>-c  删除目录栈中的所有记录</li><li>-l   以完整格式显示(绝对路径)</li><li>-p  一个目录一行的方式显示</li><li>-v  每行一个目录来显示目录栈的内容，每个目录前加上的编号</li><li>+N 显示从左到右的第n个目录，数字从0开始</li><li>-N  显示从右到左的第n个日录，数字从0开始</li></ul><p>注意：dirs始终显示当人们目录, 再是堆栈中的内容；即使目录堆栈为空, dirs命令仍然只显示当前目录</p><h3 id="2-pushd"><span id="2-pushd">2 pushd</span></h3><h4 id="21-功能"><span id="21-功能">2.1 功能</span></h4><p>将目录加入到栈顶部，并切换到该目录；若 <code>pushd</code> 命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置</p><h4 id="22-语法"><span id="22-语法">2.2 语法</span></h4><p><strong>格式：</strong></p><p><code>pushd [目录 | -N | +N]  [-n]</code></p><p><strong>选项</strong></p><ul><li>目录  将该目录加入到栈顶，并执行”cd 目录”，切换到该目录</li><li>+N  将第N个目录移至栈顶（从左边数起，数字从0开始）</li><li>-N  将第N个目录移至栈顶（从右边数起，数字从0开始）</li><li>-n  将目录入栈时，不切换目录</li></ul><h3 id="3-popd"><span id="3-popd">3 popd</span></h3><h4 id="31-功能"><span id="31-功能">3.1 功能</span></h4><p>删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录</p><h4 id="32-语法"><span id="32-语法">3.2 语法</span></h4><p><strong>格式：</strong></p><p><code>pushd [-N | +N]  [-n]</code></p><p><strong>选项</strong></p><ul><li>+N  将第N个目录删除（从左边数起，数字从0开始）</li><li>-N  将第N个目录删除（从右边数起，数字从0开始）</li><li>-n  将目录出栈时，不切换目录</li></ul><h3 id="4-示例"><span id="4-示例">4 示例</span></h3><p><strong>入栈与出栈</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@root]:~<span class="comment"># mkdir /root/dir&#123;1,2,3,4&#125;</span></span><br><span class="line">[root@root]:~<span class="comment"># for ((i=1;i&lt;=4;i++)); do pushd /root/dir$&#123;i&#125;; done</span></span><br><span class="line">/root/dir1 ~</span><br><span class="line">/root/dir2 /root/dir1 ~</span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># dirs </span></span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line"><span class="built_in">dirs</span>显出了栈中的所有目录</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># popd（相当于popd +0）</span></span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">[root@root:/root/dir3]<span class="comment"># dirs</span></span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">可以看出/root/dir4目录已被清除，此时栈里已经没有了dir4目录，切当前目录切换为dir3</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir3]<span class="comment"># pushd /root/dir4 </span></span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">[root@root:/root/dir4]</span><br><span class="line">不推荐以上面的方法进行切换，因为这种方式和<span class="built_in">cd</span>没有区别。</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># popd +1</span></span><br><span class="line">/root/dir4 /root/dir2 /root/dir1 ~</span><br><span class="line">推荐以这种方式进行切换，尤其是目录层次比较多时</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># popd -2</span></span><br><span class="line">/root/dir4 /root/dir1 ~</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir2]<span class="comment"># pushd -1</span></span><br><span class="line">/root/dir1 ~ /root/dir2 /root/dir3 /root/dir4</span><br><span class="line">[root@root:/root/dir3]</span><br><span class="line">注意：最左边表示栈顶，最右边表示栈底</span><br></pre></td></tr></table></figure><p><strong>清空栈</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@root]:~<span class="comment"># dirs</span></span><br><span class="line">~ /root/dir2 /root/dir3 /root/dir4 /root/dir1</span><br><span class="line">[root@root]:~<span class="comment"># dirs -c</span></span><br><span class="line">[root@root](mailto:root@root):~<span class="comment"># dirs</span></span><br><span class="line">~</span><br></pre></td></tr></table></figure><p><strong>列表形式显示的栈的内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@root:/root/dir4]<span class="comment"># dirs -l -v</span></span><br><span class="line">0 /root/dir4</span><br><span class="line">1 /root/dir3</span><br><span class="line">2 /root/dir2</span><br><span class="line">3 /root/dir1</span><br><span class="line">4 /root</span><br></pre></td></tr></table></figure><p>注：如果只是两个目录之间的切换 <code>cd -</code>足矣，而且方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#目录栈指令&quot;&gt;目录栈指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-dirs&quot;&gt;1 dirs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-功能&quot;&gt;1.1 功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Shell" scheme="https://lxb.wiki/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://lxb.wiki/tags/Shell/"/>
    
      <category term="dirs" scheme="https://lxb.wiki/tags/dirs/"/>
    
      <category term="pushd" scheme="https://lxb.wiki/tags/pushd/"/>
    
      <category term="popd" scheme="https://lxb.wiki/tags/popd/"/>
    
  </entry>
  
  <entry>
    <title>使用 gosec 检查 Go 代码中的安全问题</title>
    <link href="https://lxb.wiki/a59515fd/"/>
    <id>https://lxb.wiki/a59515fd/</id>
    <published>2020-10-19T15:36:00.000Z</published>
    <updated>2020-11-29T15:49:11.331Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#开始使用-gosec">开始使用 gosec</a><ul><li><a href="#安装-go-和-gosec">安装 Go 和 gosec</a></li></ul></li><li><a href="#使用默认选项运行-gosec">使用默认选项运行 gosec</a><ul><li><a href="#关于误判">关于误判</a></li><li><a href="#高优先级问题">高优先级问题</a></li><li><a href="#中优先级问题">中优先级问题</a></li><li><a href="#低优先级问题">低优先级问题</a></li></ul></li><li><a href="#自定义-gosec-扫描">自定义 gosec 扫描</a><ul><li><a href="#排除指定的测试">排除指定的测试</a></li><li><a href="#运行指定的检查">运行指定的检查</a></li><li><a href="#扫描测试文件">扫描测试文件</a></li><li><a href="#修改输出的格式">修改输出的格式</a></li></ul></li><li><a href="#用-gosec-检查容易被发现的问题">用 gosec 检查容易被发现的问题</a></li></ul><!-- tocstop --><blockquote><p>来学习下 Go 语言的安全检查工具 gosec。</p></blockquote><p><img src="https://img.linux.net.cn/data/attachment/album/202010/04/125129bh4qxxsyqpvqjtx4.jpg" alt></p><p><a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>写的代码越来越常见，尤其是在容器、Kubernetes 或云生态相关的开发中。Docker 是最早采用 Golang 的项目之一，随后是 Kubernetes，之后大量的新项目在众多编程语言中选择了 Go。</p><p>像其他语言一样，Go 也有它的长处和短处（如安全缺陷）。这些缺陷可能会因为语言本身的缺陷加上程序员编码不当而产生，例如，C 代码中的内存安全问题。</p><p>无论它们出现的原因是什么，安全问题都应该在开发过程的早期修复，以免在封装好的软件中出现。幸运的是，静态分析工具可以帮你以更可重复的方式处理这些问题。静态分析工具通过解析用某种编程语言写的代码来找到问题。</p><p>这类工具中很多被称为 linter。传统意义上，linter 更注重的是检查代码中编码问题、bug、代码风格之类的问题，它们可能不会发现代码中的安全问题。例如，<a href="https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html" target="_blank" rel="noopener">Coverity</a> 是一个很流行的工具，它可以帮助寻找 C/C++ 代码中的问题。然而，也有一些工具专门用来检查源码中的安全问题。例如，<a href="https://pypi.org/project/bandit/" target="_blank" rel="noopener">Bandit</a> 可以检查 Python 代码中的安全缺陷。而 <a href="https://github.com/securego/gosec" target="_blank" rel="noopener">gosec</a> 则用来搜寻 Go 源码中的安全缺陷。<code>gosec</code> 通过扫描 Go 的 AST（抽象语法树abstract syntax tree<ruby>抽象语法树<rt>abstract syntax tree</rt></ruby>）来检查源码中的安全问题。</p><h3 id="开始使用-gosec"><span id="开始使用-gosec">开始使用 gosec</span></h3><p>在开始学习和使用 <code>gosec</code> 之前，你需要准备一个 Go 语言写的项目。有这么多开源软件，我相信这不是问题。你可以在 GitHub 的 <a href="https://github.com/trending/go" target="_blank" rel="noopener">热门 Golang 仓库</a>中找一个。</p><p>本文中，我随机选了 <a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">Docker CE</a> 项目，但你可以选择任意的 Go 项目。</p><h4 id="安装-go-和-gosec"><span id="安装-go-和-gosec">安装 Go 和 gosec</span></h4><p>如果你还没安装 Go，你可以先从仓库中拉取下来。如果你用的是 Fedora 或其他基于 RPM 的 Linux 发行版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dnf install golang.x86_64</span><br></pre></td></tr></table></figure><p>如果你用的是其他操作系统，请参照 <a href="https://golang.org/doc/install" target="_blank" rel="noopener">Golang 安装</a>页面。</p><p>使用 <code>version</code> 参数来验证 Go 是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.14.6 linux/amd64</span><br></pre></td></tr></table></figure><p>运行 <code>go get</code> 命令就可以轻松地安装 <code>gosec</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/securego/gosec/cmd/gosec</span><br></pre></td></tr></table></figure><p>上面这行命令会从 GitHub 下载 <code>gosec</code> 的源码，编译并安装到指定位置。在仓库的 <code>README</code> 中你还可以看到<a href="https://github.com/securego/gosec#install" target="_blank" rel="noopener">安装该工具的其他方法</a>。</p><p><code>gosec</code> 的源码会被下载到 <code>$GOPATH</code> 的位置，编译出的二进制文件会被安装到你系统上设置的 <code>bin</code> 目录下。你可以运行下面的命令来查看 <code>$GOPATH</code> 和 <code>$GOBIN</code> 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go env | grep GOBIN</span><br><span class="line">GOBIN=&quot;/root/go/gobin&quot;</span><br><span class="line">$ go env | grep GOPATH</span><br><span class="line">GOPATH=&quot;/root/go&quot;</span><br></pre></td></tr></table></figure><p>如果 <code>go get</code> 命令执行成功，那么 <code>gosec</code> 二进制应该就可以使用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l ~/go/bin/</span><br><span class="line">total 9260</span><br><span class="line">-rwxr-xr-x. 1 root root 9482175 Aug 20 04:17 gosec</span><br></pre></td></tr></table></figure><p>你可以把 <code>$GOPATH</code> 下的 <code>bin</code> 目录添加到 <code>$PATH</code> 中。这样你就可以像使用系统上的其他命令一样来使用 <code>gosec</code> 命令行工具（CLI）了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ which gosec</span><br><span class="line">/root/go/bin/gosec</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>使用 <code>gosec</code> 命令行工具的 <code>-help</code> 选项来看看运行是否符合预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -help</span><br><span class="line"></span><br><span class="line">gosec - Golang security checker</span><br><span class="line"></span><br><span class="line">gosec analyzes Go source code to look for common programming mistakes that</span><br><span class="line">can lead to security problems.</span><br><span class="line"></span><br><span class="line">VERSION: dev</span><br><span class="line">GIT TAG:</span><br><span class="line">BUILD DATE:</span><br><span class="line"></span><br><span class="line">USAGE:</span><br></pre></td></tr></table></figure><p>之后，创建一个目录，把源码下载到这个目录作为实例项目（本例中，我用的是 Docker CE）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir gosec-demo</span><br><span class="line">$ cd gosec-demo/</span><br><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo</span><br><span class="line">$ git clone https://github.com/docker/docker-ce.git</span><br><span class="line">Cloning into &apos;docker-ce&apos;...</span><br><span class="line">remote: Enumerating objects: 1271, done.</span><br><span class="line">remote: Counting objects: 100% (1271/1271), done.</span><br><span class="line">remote: Compressing objects: 100% (722/722), done.</span><br><span class="line">remote: Total 431003 (delta 384), reused 981 (delta 318), pack-reused 429732</span><br><span class="line">Receiving objects: 100% (431003/431003), 166.84 MiB | 28.94 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (221338/221338), done.</span><br><span class="line">Updating files: 100% (10861/10861), done.</span><br></pre></td></tr></table></figure><p>代码统计工具（本例中用的是 <code>cloc</code>）显示这个项目大部分是用 Go 写的，恰好迎合了 <code>gosec</code> 的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./cloc /root/gosec-demo/docker-ce/</span><br><span class="line">   10771 text files.</span><br><span class="line">    8724 unique files.                                          </span><br><span class="line">    2560 files ignored.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Go                                7222         190785         230478        1574580</span><br><span class="line">YAML                                37           4831            817         156762</span><br><span class="line">Markdown                           529          21422              0          67893</span><br><span class="line">Protocol Buffers                   149           5014          16562          10071</span><br></pre></td></tr></table></figure><h3 id="使用默认选项运行-gosec"><span id="使用默认选项运行-gosec">使用默认选项运行 gosec</span></h3><p>在 Docker CE 项目中使用默认选项运行 <code>gosec</code>，执行 <code>gosec ./...</code> 命令。屏幕上会有很多输出内容。在末尾你会看到一个简短的 “Summary”，列出了浏览的文件数、所有文件的总行数，以及源码中发现的问题数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo/docker-ce</span><br><span class="line">$ time gosec ./...</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Including rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Excluding rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Import directory: /root/gosec-demo/docker-ce/components/engine/opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking package: opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/address_pools.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/env.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/hosts.go</span><br><span class="line"></span><br><span class="line"># End of gosec run</span><br><span class="line"></span><br><span class="line">Summary:</span><br><span class="line">   Files: 1278</span><br><span class="line">   Lines: 173979</span><br><span class="line">   Nosec: 4</span><br><span class="line">  Issues: 644</span><br><span class="line"></span><br><span class="line">real    0m52.019s</span><br><span class="line">user    0m37.284s</span><br><span class="line">sys     0m12.734s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>滚动屏幕你会看到不同颜色高亮的行：红色表示需要尽快查看的高优先级问题，黄色表示中优先级的问题。</p><h4 id="关于误判"><span id="关于误判">关于误判</span></h4><p>在开始检查代码之前，我想先分享几条基本原则。默认情况下，静态检查工具会基于一系列的规则对测试代码进行分析，并报告出它们发现的<em>所有</em>问题。这是否意味着工具报出来的每一个问题都需要修复？非也。这个问题最好的解答者是设计和开发这个软件的人。他们最熟悉代码，更重要的是，他们了解软件会在什么环境下部署以及会被怎样使用。</p><p>这个知识点对于判定工具标记出来的某段代码到底是不是安全缺陷至关重要。随着工作时间和经验的积累，你会慢慢学会怎样让静态分析工具忽略非安全缺陷，使报告内容的可执行性更高。因此，要判定 <code>gosec</code> 报出来的某个问题是否需要修复，让一名有经验的开发者对源码做人工审计会是比较好的办法。</p><h4 id="高优先级问题"><span id="高优先级问题">高优先级问题</span></h4><p>从输出内容看，<code>gosec</code> 发现了 Docker CE 的一个高优先级问题，它使用的是低版本的 TLS（传输层安全Transport Layer Security<ruby>传输层安全<rt>Transport Layer Security<rt></rt></rt></ruby>）。无论什么时候，使用软件和库的最新版本都是确保它更新及时、没有安全问题的最好的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/daemon/logger/splunk/splunk.go:173] - G402 (CWE-295): TLS MinVersion too low. (Confidence: HIGH, Severity: HIGH)</span><br><span class="line">    172:</span><br><span class="line">  &gt; 173:        tlsConfig := &amp;tls.Config&#123;&#125;</span><br><span class="line">    174:</span><br></pre></td></tr></table></figure><p>它还发现了一个弱随机数生成器。它是不是一个安全缺陷，取决于生成的随机数的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/namesgenerator/names-generator.go:843] - G404 (CWE-338): Use of weak random number generator (math/rand instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)</span><br><span class="line">    842: begin:</span><br><span class="line">  &gt; 843:        name := fmt.Sprintf(&quot;%s_%s&quot;, left[rand.Intn(len(left))], right[rand.Intn(len(right))])</span><br><span class="line">    844:        if name == &quot;boring_wozniak&quot; /* Steve Wozniak is not boring */ &#123;</span><br></pre></td></tr></table></figure><h4 id="中优先级问题"><span id="中优先级问题">中优先级问题</span></h4><p>这个工具还发现了一些中优先级问题。它标记了一个通过与 <code>tar</code> 相关的解压炸弹这种方式实现的潜在的 DoS 威胁，这种方式可能会被恶意的攻击者利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/copy.go:357] - G110 (CWE-409): Potential DoS vulnerability via decompression bomb (Confidence: MEDIUM, Severity: MEDIUM)</span><br><span class="line">    356:</span><br><span class="line">  &gt; 357:                        if _, err = io.Copy(rebasedTar, srcTar); err != nil &#123;</span><br><span class="line">    358:                                w.CloseWithError(err)</span><br></pre></td></tr></table></figure><p>它还发现了一个通过变量访问文件的问题。如果恶意使用者能访问这个变量，那么他们就可以改变变量的值去读其他文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/context/tlsdata.go:80] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    79:         if caPath != &quot;&quot; &#123;</span><br><span class="line">  &gt; 80:                 if ca, err = ioutil.ReadFile(caPath); err != nil &#123;</span><br><span class="line">    81:                         return nil, err</span><br></pre></td></tr></table></figure><p>文件和目录通常是操作系统安全的最基础的元素。这里，<code>gosec</code> 报出了一个可能需要你检查目录的权限是否安全的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/contrib/apparmor/main.go:41] - G301 (CWE-276): Expect directory permissions to be 0750 or less (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    40:         // make sure /etc/apparmor.d exists</span><br><span class="line">  &gt; 41:         if err := os.MkdirAll(path.Dir(apparmorProfilePath), 0755); err != nil &#123;</span><br><span class="line">    42:                 log.Fatal(err)</span><br></pre></td></tr></table></figure><p>你经常需要在源码中启动命令行工具。Go 使用内建的 exec 库来实现。仔细地分析用来调用这些工具的变量，就能发现安全缺陷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/testutil/fakestorage/fixtures.go:59] - G204 (CWE-78): Subprocess launched with variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    58:</span><br><span class="line">  &gt; 59:              cmd := exec.Command(goCmd, &quot;build&quot;, &quot;-o&quot;, filepath.Join(tmp, &quot;httpserver&quot;), &quot;github.com/docker/docker/contrib/httpserver&quot;)</span><br><span class="line">    60:                 cmd.Env = append(os.Environ(), []string&#123;</span><br></pre></td></tr></table></figure><h4 id="低优先级问题"><span id="低优先级问题">低优先级问题</span></h4><p>在这个输出中，gosec 报出了一个 <code>unsafe</code> 调用相关的低优先级问题，这个调用会绕开 Go 提供的内存保护。再仔细分析下你调用 <code>unsafe</code> 的方式，看看是否有被别人利用的可能性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/changes_linux.go:264] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    263:        for len(buf) &gt; 0 &#123;</span><br><span class="line">  &gt; 264:                dirent := (*unix.Dirent)(unsafe.Pointer(&amp;buf[0]))</span><br><span class="line">    265:                buf = buf[dirent.Reclen:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/devicemapper/devmapper_wrapper.go:88] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    87: func free(p *C.char) &#123;</span><br><span class="line">  &gt; 88:         C.free(unsafe.Pointer(p))</span><br><span class="line">    89: &#125;</span><br></pre></td></tr></table></figure><p>它还标记了源码中未处理的错误。源码中出现的错误你都应该处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/command/image/build/context.go:172] - G104 (CWE-703): Errors unhandled. (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    171:                err := tar.Close()</span><br><span class="line">  &gt; 172:                os.RemoveAll(dockerfileDir)</span><br><span class="line">    173:                return err</span><br></pre></td></tr></table></figure><h3 id="自定义-gosec-扫描"><span id="自定义-gosec-扫描">自定义 gosec 扫描</span></h3><p>使用 <code>gosec</code> 的默认选项会带来很多的问题。然而，经过人工审计，随着时间推移你会掌握哪些问题是不需要标记的。你可以自己指定排除和包含哪些测试。</p><p>我上面提到过，<code>gosec</code> 是基于一系列的规则从 Go 源码中查找问题的。下面是它使用的完整的<a href="https://github.com/securego/gosec#available-rules" target="_blank" rel="noopener">规则</a>列表：</p><ul><li>G101：查找硬编码凭证</li><li>G102：绑定到所有接口</li><li>G103：审计 <code>unsafe</code> 块的使用</li><li>G104：审计未检查的错误</li><li>G106：审计 <code>ssh.InsecureIgnoreHostKey</code> 的使用</li><li>G107: 提供给 HTTP 请求的 url 作为污点输入</li><li>G108: <code>/debug/pprof</code> 上自动暴露的剖析端点</li><li>G109: <code>strconv.Atoi</code> 转换到 int16 或 int32 时潜在的整数溢出</li><li>G110: 潜在的通过解压炸弹实现的 DoS</li><li>G201：SQL 查询构造使用格式字符串</li><li>G202：SQL 查询构造使用字符串连接</li><li>G203：在 HTML 模板中使用未转义的数据</li><li>G204：审计命令执行情况</li><li>G301：创建目录时文件权限分配不合理</li><li>G302：使用 <code>chmod</code> 时文件权限分配不合理</li><li>G303：使用可预测的路径创建临时文件</li><li>G304：通过污点输入提供的文件路径</li><li>G305：提取 zip/tar 文档时遍历文件</li><li>G306: 写到新文件时文件权限分配不合理</li><li>G307: 把返回错误的函数放到 <code>defer</code> 内</li><li>G401：检测 DES、RC4、MD5 或 SHA1 的使用</li><li>G402：查找错误的 TLS 连接设置</li><li>G403：确保最小 RSA 密钥长度为 2048 位</li><li>G404：不安全的随机数源（<code>rand</code>）</li><li>G501：导入黑名单列表：crypto/md5</li><li>G502：导入黑名单列表：crypto/des</li><li>G503：导入黑名单列表：crypto/rc4</li><li>G504：导入黑名单列表：net/http/cgi</li><li>G505：导入黑名单列表：crypto/sha1</li><li>G601: 在 <code>range</code> 语句中使用隐式的元素别名</li></ul><h4 id="排除指定的测试"><span id="排除指定的测试">排除指定的测试</span></h4><p>你可以自定义 <code>gosec</code> 来避免对已知为安全的问题进行扫描和报告。你可以使用 <code>-exclude</code> 选项和上面的规则编号来忽略指定的问题。</p><p>例如，如果你不想让 <code>gosec</code> 检查源码中硬编码凭证相关的未处理的错误，那么你可以运行下面的命令来忽略这些错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -exclude=G104 ./...</span><br><span class="line">$ gosec -exclude=G104,G101 ./...</span><br></pre></td></tr></table></figure><p>有时候你知道某段代码是安全的，但是 <code>gosec</code> 还是会报出问题。然而，你又不想完全排除掉整个检查，因为你想让 <code>gosec</code> 检查新增的代码。通过在你已知为安全的代码块添加 <code>#nosec</code> 标记可以避免 <code>gosec</code> 扫描。这样 <code>gosec</code> 会继续扫描新增代码，而忽略掉 <code>#nosec</code> 标记的代码块。</p><h4 id="运行指定的检查"><span id="运行指定的检查">运行指定的检查</span></h4><p>另一方面，如果你只想检查指定的问题，你可以通过 <code>-include</code> 选项和规则编号来告诉 <code>gosec</code> 运行哪些检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -include=G201,G202 ./...</span><br></pre></td></tr></table></figure><h4 id="扫描测试文件"><span id="扫描测试文件">扫描测试文件</span></h4><p>Go 语言自带对测试的支持，通过单元测试来检验一个元素是否符合预期。在默认模式下，<code>gosec</code> 会忽略测试文件，你可以使用 <code>-tests</code> 选项把它们包含进来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gosec -tests ./...</span><br></pre></td></tr></table></figure><h4 id="修改输出的格式"><span id="修改输出的格式">修改输出的格式</span></h4><p>找出问题只是它的一半功能；另一半功能是把它检查到的问题以用户友好同时又方便工具处理的方式报告出来。幸运的是，<code>gosec</code> 可以用不同的方式输出。例如，如果你想看 JSON 格式的报告，那么就使用 <code>-fmt</code> 选项指定 JSON 格式并把结果保存到 <code>results.json</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -fmt=json -out=results.json ./...</span><br><span class="line"></span><br><span class="line">$ ls -l results.json</span><br><span class="line">-rw-r--r--. 1 root root 748098 Aug 20 05:06 results.json</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line">             &quot;severity&quot;: &quot;LOW&quot;,</span><br><span class="line">             &quot;confidence&quot;: &quot;HIGH&quot;,</span><br><span class="line">             &quot;cwe&quot;: &#123;</span><br><span class="line">                 &quot;ID&quot;: &quot;242&quot;,</span><br><span class="line">                 &quot;URL&quot;: &quot;https://cwe.mitre.org/data/definitions/242.html&quot;</span><br><span class="line">             &#125;,</span><br><span class="line">             &quot;rule_id&quot;: &quot;G103&quot;,</span><br><span class="line">             &quot;details&quot;: &quot;Use of unsafe calls should be audited&quot;,</span><br><span class="line">             &quot;file&quot;: &quot;/root/gosec-demo/docker-ce/components/engine/daemon/graphdriver/graphtest/graphtest_unix.go&quot;,</span><br><span class="line">             &quot;code&quot;: &quot;304: \t// Cast to []byte\n305: \theader := *(*reflect.SliceHeader)(unsafe.Pointer(\u0026buf))\n306: \theader.      Len *= 8\n&quot;,</span><br><span class="line">             &quot;line&quot;: &quot;305&quot;,</span><br><span class="line">             &quot;column&quot;: &quot;36&quot;</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure><h3 id="用-gosec-检查容易被发现的问题"><span id="用-gosec-检查容易被发现的问题">用 gosec 检查容易被发现的问题</span></h3><p>静态检查工具不能完全代替人工代码审计。然而，当代码量变大、有众多开发者时，这样的工具往往有助于以可重复的方式找出容易被发现的问题。它对于帮助新开发者识别和在编码时避免引入这些安全缺陷很有用。</p><hr><p>via: <a href="https://opensource.com/article/20/9/gosec" target="_blank" rel="noopener">https://opensource.com/article/20/9/gosec</a></p><p>作者：<a href="https://opensource.com/users/gkamathe" target="_blank" rel="noopener">Gaurav Kamathe</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbowlf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#开始使用-gosec&quot;&gt;开始使用 gosec&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装-go-和-gosec&quot;&gt;安装 Go 和 gosec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="Go" scheme="https://lxb.wiki/tags/Go/"/>
    
      <category term="gosec" scheme="https://lxb.wiki/tags/gosec/"/>
    
  </entry>
  
  <entry>
    <title>PHP检测图片是否有木马</title>
    <link href="https://lxb.wiki/9a49b652/"/>
    <id>https://lxb.wiki/9a49b652/</id>
    <published>2020-10-15T11:59:17.000Z</published>
    <updated>2020-11-12T15:21:04.304Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Content-type: text/html; charset=utf-8"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHex</span><span class="params">($img)</span> </span>&#123;</span><br><span class="line">  $status = <span class="number">0</span>;</span><br><span class="line">  $tips = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"0"</span> =&gt; <span class="string">"文件没问题"</span>,</span><br><span class="line">    <span class="string">"5"</span> =&gt; <span class="string">"文件有毒"</span>,</span><br><span class="line">    <span class="string">"-1"</span> =&gt; <span class="string">"文件没有上传"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (file_exists($img)) &#123;</span><br><span class="line">    $resource = fopen($img, <span class="string">'rb'</span>);</span><br><span class="line">    $fileSize = filesize($img);</span><br><span class="line">    fseek($resource, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ($fileSize &gt; <span class="number">512</span>) &#123; <span class="comment">// 取头和尾</span></span><br><span class="line">      $hexCode = bin2hex(fread($resource, <span class="number">512</span>));</span><br><span class="line">      fseek($resource, $fileSize - <span class="number">512</span>);</span><br><span class="line">      $hexCode .= bin2hex(fread($resource, <span class="number">512</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 取全部</span></span><br><span class="line">      $hexCode = bin2hex(fread($resource, $fileSize));</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($resource);</span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;% ( ) %&gt; */</span></span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;? ( ) ?&gt; */</span></span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;script | /script&gt; 大小写亦可 */</span></span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">"/(3c25.*?28.*?29.*?253e)|(3c3f.*?28.*?29.*?3f3e)|(3C534352495054)|(2F5343524950543E)|(3C736372697074)|(2F7363726970743E)/is"</span>, $hexCode)) &#123;</span><br><span class="line">      $status = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $status = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $tips[$status];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$rs = checkHex(<span class="string">"du.png"</span>);</span><br><span class="line"></span><br><span class="line">print_r($rs);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;



&lt;!-- tocstop --&gt;

&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="Pic" scheme="https://lxb.wiki/categories/Pic/"/>
    
    
      <category term="Pic" scheme="https://lxb.wiki/tags/Pic/"/>
    
  </entry>
  
  <entry>
    <title>流量复制重放工具goreplay</title>
    <link href="https://lxb.wiki/8c9efcce/"/>
    <id>https://lxb.wiki/8c9efcce/</id>
    <published>2020-10-04T15:17:17.000Z</published>
    <updated>2020-12-06T12:56:55.316Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#goreplay简介">goreplay简介</a></li><li><a href="#goreplay工作原理">goreplay工作原理</a><ul><li><a href="#goreplay常见用法">goreplay常见用法</a></li><li><a href="#gor参数">gor参数</a></li></ul></li></ul><!-- tocstop --><h1 id="goreplay简介"><span id="goreplay简介">goreplay简介</span></h1><p><a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">https://github.com/buger/goreplay</a></p><p><a href="https://goreplay.org/" target="_blank" rel="noopener">https://goreplay.org</a></p><p>GoReplay是一个开源工具，用于捕获实时HTTP流量并将其重放到测试环境中，以便使用真实数据持续测试系统。<br>GoReplay不是代理，而是监听网络接口上的流量，不需要更改生产基础架构，而是在与服务相同的计算机上运行GoReplay守护程序。</p><h1 id="goreplay工作原理"><span id="goreplay工作原理">goreplay工作原理</span></h1><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206205553.png" alt></p><h2 id="goreplay常见用法"><span id="goreplay常见用法">goreplay常见用法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 简单的 HTTP 流量复制：</span><br><span class="line">gor –input-raw :80 –output-http “http://staging.com”</span><br><span class="line"></span><br><span class="line">2.HTTP 流量复制频率控制：</span><br><span class="line">gor –input-tcp :28020 –output-http “http://staging.com|10″</span><br><span class="line"></span><br><span class="line">3.HTTP 流量复制缩小：</span><br><span class="line">gor –input-raw :80 –output-tcp “replay.local:28020|10%”</span><br><span class="line"></span><br><span class="line">4.HTTP 流量记录到本地文件：</span><br><span class="line">gor –input-raw :80 –output-file requests.gor</span><br><span class="line"></span><br><span class="line">5.HTTP 流量回放和压测：</span><br><span class="line">gor –input-file “requests.gor|200%” –output-http “staging.com”</span><br><span class="line"></span><br><span class="line">6.HTTP 流量过滤复制：</span><br><span class="line">gor –input-raw :8080 –output-http staging.com –output-http-url-regexp ^www.</span><br><span class="line"></span><br><span class="line">7.HTTP指定接口流量复制：</span><br><span class="line">gor --input-raw :80 --http-allow-url <span class="string">'/api/v1'</span> --output-stdout      //--output-stdout表示直接在控制台输出</span><br></pre></td></tr></table></figure><h2 id="gor参数"><span id="gor参数">gor参数</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">[root@~]<span class="comment"># gor --help</span></span><br><span class="line">Gor is a simple http traffic replication tool written <span class="keyword">in</span> Go. Its main goal is to replay traffic from production servers to staging and dev environments.</span><br><span class="line">Project page: https://github.com/buger/gor</span><br><span class="line">Author: &lt;Leonid Bugaev&gt; leonsbox@gmail.com</span><br><span class="line">Current Version: 1.0.0</span><br><span class="line"></span><br><span class="line">  -copy-buffer-size int</span><br><span class="line">    Set the buffer size <span class="keyword">for</span> an individual request (default 5M) (default 5242880)</span><br><span class="line">  -cpuprofile string</span><br><span class="line">    write cpu profile to file</span><br><span class="line">  -debug verbose//打开debug模式，显示所有接口的流量 </span><br><span class="line">    Turn on debug output, shows all intercepted traffic. Works only when with verbose flag</span><br><span class="line">  -<span class="built_in">exit</span>-after duration</span><br><span class="line">    <span class="built_in">exit</span> after specified duration</span><br><span class="line">  -http-allow-header value      //用一个正则表达式来匹配http头部，如果请求的头部没有匹配上，则被拒绝</span><br><span class="line">    A regexp to match a specific header against. Requests with non-matching headers will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-allow-header api-version:^v1</span><br><span class="line">  -http-allow-method value      // 类似于一个白名单机制来允许通过的http请求方法，除此之外的方法都被拒绝.</span><br><span class="line">    Whitelist of HTTP methods to replay. Anything <span class="keyword">else</span> will be dropped:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-allow-method GET --http-allow-method OPTIONS</span><br><span class="line">  -http-allow-url value             //一个正则表达式用来匹配url， 用来过滤完全匹配的的url，在此之外的都被过滤掉</span><br><span class="line">    A regexp to match requests against. Filter get matched against full url with domain. Anything <span class="keyword">else</span> will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-allow-url ^www.</span><br><span class="line">  -http-basic-auth-filter value         //匹配认证头重放</span><br><span class="line">    A regexp to match the decoded basic auth string against. Requests with non-matching headers will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-basic-auth-filter <span class="string">"^customer[0-9].*"</span></span><br><span class="line">  -http-disallow-header value       //用一个正则表达式来匹配http头部，匹配到的请求会被拒绝掉</span><br><span class="line">    A regexp to match a specific header against. Requests with matching headers will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-disallow-header <span class="string">"User-Agent: Replayed by Gor"</span></span><br><span class="line">  -http-disallow-url value      //用一个正则表达式来匹配url，如果请求匹配上了，则会被拒绝</span><br><span class="line">    A regexp to match requests against. Filter get matched against full url with domain. Anything <span class="keyword">else</span> will be forwarded:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-disallow-url ^www.</span><br><span class="line">  -http-header-limiter value//读取请求，基于FNV32-1A散列来拒绝一定比例的特殊请求 </span><br><span class="line">    Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A <span class="built_in">hash</span> of a specific header:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-header-limiter user-id:25%</span><br><span class="line">  -http-original-host       //在--output-http的输出中，通常gor会使用取代请求的http头，所以应该禁用该选项，保留原始的主机头</span><br><span class="line">    Normally gor replaces the Host http header with the host supplied with --output-http.  This option disables that behavior, preserving the original Host header.</span><br><span class="line">  -http-param-limiter value</span><br><span class="line">    Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A <span class="built_in">hash</span> of a specific GET param:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-param-limiter user_id:25%</span><br><span class="line">  -http-pprof :8181</span><br><span class="line">    Enable profiling. Starts  http server on specified port, exposing special /debug/pprof endpoint. Example: :8181</span><br><span class="line">  -http-rewrite-header value</span><br><span class="line">    Rewrite the request header based on a mapping:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-rewrite-header Host: (.*).example.com,<span class="variable">$1</span>.beta.example.com</span><br><span class="line">  -http-rewrite-url value</span><br><span class="line">    Rewrite the request url based on a mapping:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-rewrite-url /v1/user/([^\/]+)/ping:/v2/user/<span class="variable">$1</span>/ping</span><br><span class="line">  -http-set-header value</span><br><span class="line">    Inject additional headers to http reqest:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-set-header <span class="string">'User-Agent: Gor'</span></span><br><span class="line">  -http-set-param value</span><br><span class="line">    Set request url param, <span class="keyword">if</span> param already exists it will be overwritten:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-set-param api_key=1</span><br><span class="line">  -input-dummy value</span><br><span class="line">    Used <span class="keyword">for</span> testing outputs. Emits <span class="string">'Get /'</span> request every 1s</span><br><span class="line">  -input-file value//从一个文件中读取请求</span><br><span class="line">    Read requests from file: </span><br><span class="line">    gor --input-file ./requests.gor --output-http staging.com</span><br><span class="line">  -input-file-loop</span><br><span class="line">    Loop input files, useful <span class="keyword">for</span> performance testing.</span><br><span class="line">  -input-kafka-host string</span><br><span class="line">    Send request and response stats to Kafka:</span><br><span class="line">    gor --output-stdout --input-kafka-host <span class="string">'192.168.0.1:9092,192.168.0.2:9092'</span></span><br><span class="line">  -input-kafka-json-format</span><br><span class="line">    If turned on, it will assume that messages coming <span class="keyword">in</span> JSON format rather than  GoReplay text format.</span><br><span class="line">  -input-kafka-topic string</span><br><span class="line">    Send request and response stats to Kafka:</span><br><span class="line">    gor --output-stdout --input-kafka-topic <span class="string">'kafka-log'</span></span><br><span class="line">  -input-raw value</span><br><span class="line">    Capture traffic from given port (use RAW sockets and require *sudo* access):</span><br><span class="line">    <span class="comment"># Capture traffic from 8080 port</span></span><br><span class="line">    gor --input-raw :8080 --output-http staging.com</span><br><span class="line">  -input-raw-bpf-filter string</span><br><span class="line">    BPF filter to write custom expressions. Can be useful <span class="keyword">in</span> <span class="keyword">case</span> of non standard network interfaces like tunneling or SPAN port. Example: --input-raw-bpf-filter <span class="string">'dst port 80'</span></span><br><span class="line">  -input-raw-buffer-size int</span><br><span class="line">    Controls size of the OS buffer (<span class="keyword">in</span> bytes) <span class="built_in">which</span> holds packets until they dispatched. Default value depends by system: <span class="keyword">in</span> Linux around 2MB. If you see big package drop, increase this value.</span><br><span class="line">  -input-raw-engine libpcap</span><br><span class="line">    Intercept traffic using libpcap (default), and `raw_socket` (default <span class="string">"libpcap"</span>)</span><br><span class="line">  -input-raw-expire duration</span><br><span class="line">    How much it should <span class="built_in">wait</span> <span class="keyword">for</span> the last TCP packet, till consider that TCP message complete. (default 2s)</span><br><span class="line">  -input-raw-immediate-mode</span><br><span class="line">    Set pcap interface to immediate mode.</span><br><span class="line">  -input-raw-override-snaplen</span><br><span class="line">    Override the capture snaplen to be 64k. Required <span class="keyword">for</span> some Virtualized environments</span><br><span class="line">  -input-raw-realip-header string</span><br><span class="line">    If not blank, injects header with given name and real IP value to the request payload. Usually this header should be named: X-Real-IP</span><br><span class="line">  -input-raw-timestamp-type string</span><br><span class="line">    Possible values: PCAP_TSTAMP_HOST, PCAP_TSTAMP_HOST_LOWPREC, PCAP_TSTAMP_HOST_HIPREC, PCAP_TSTAMP_ADAPTER, PCAP_TSTAMP_ADAPTER_UNSYNCED. This values not supported on all systems, GoReplay will tell you available values of you put wrong one.</span><br><span class="line">  -input-raw-track-response</span><br><span class="line">    If turned on Gor will track responses <span class="keyword">in</span> addition to requests, and they will be available to middleware and file output.</span><br><span class="line">  -input-tcp value// 用来在多个gor之间流转流量</span><br><span class="line">    Used <span class="keyword">for</span> internal communication between Gor instances. Example: </span><br><span class="line">    <span class="comment"># Receive requests from other Gor instances on 28020 port, and redirect output to staging</span></span><br><span class="line">    gor --input-tcp :28020 --output-http staging.com</span><br><span class="line">  -input-tcp-certificate string</span><br><span class="line">    Path to PEM encoded certificate file. Used when TLS turned on.</span><br><span class="line">  -input-tcp-certificate-key string</span><br><span class="line">    Path to PEM encoded certificate key file. Used when TLS turned on.</span><br><span class="line">  -input-tcp-secure</span><br><span class="line">    Turn on TLS security. Do not forget to specify certificate and key files.</span><br><span class="line">  -memprofile string</span><br><span class="line">    write memory profile to this file</span><br><span class="line">  -middleware string</span><br><span class="line">    Used <span class="keyword">for</span> modifying traffic using external <span class="built_in">command</span></span><br><span class="line">  -output-dummy value//用来测试输入，打印出接收的数据.</span><br><span class="line">    DEPRECATED: use --output-stdout instead</span><br><span class="line">  -output-file value//把进入的请求写入一个文件中 </span><br><span class="line">    Write incoming requests to file: </span><br><span class="line">    gor --input-raw :80 --output-file ./requests.gor</span><br><span class="line">  -output-file-append</span><br><span class="line">    The flushed chunk is appended to existence file or not. </span><br><span class="line">  -output-file-flush-interval duration</span><br><span class="line">    Interval <span class="keyword">for</span> forcing buffer flush to the file, default: 1s. (default 1s)</span><br><span class="line">  -output-file-max-size-limit value</span><br><span class="line">    Max size of output file, Default: 1TB (default -1)</span><br><span class="line">  -output-file-queue-limit int</span><br><span class="line">    The length of the chunk queue. Default: 256 (default 256)</span><br><span class="line">  -output-file-size-limit value</span><br><span class="line">    Size of each chunk. Default: 32mb (default 33554432)</span><br><span class="line">  -output-http value//转发进入的请求到一个http地址上</span><br><span class="line">    Forwards incoming requests to given http address.</span><br><span class="line">    <span class="comment"># Redirect all incoming requests to staging.com address </span></span><br><span class="line">    gor --input-raw :80 --output-http http://staging.com</span><br><span class="line">  -output-http-compatibility-mode</span><br><span class="line">    Use standard Go client, instead of built-in implementation. Can be slower, but more compatible.</span><br><span class="line">  -output-http-debug</span><br><span class="line">    Enables http debug output.</span><br><span class="line">  -output-http-elasticsearch string//把请求和响应状态发送到ElasticSearch</span><br><span class="line">    Send request and response stats to ElasticSearch:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --output-http-elasticsearch <span class="string">'es_host:api_port/index_name'</span></span><br><span class="line">  -output-http-header --output-http-header</span><br><span class="line">    WARNING: --output-http-header DEPRECATED, use `--http-set-header` instead</span><br><span class="line">  -output-http-header-filter --output-http-header-filter</span><br><span class="line">    WARNING: --output-http-header-filter DEPRECATED, use `--http-allow-header` instead</span><br><span class="line">  -output-http-header-hash-filter output-http-header-hash-filter</span><br><span class="line">    WARNING: output-http-header-hash-filter DEPRECATED, use `--http-header-hash-limiter` instead</span><br><span class="line">  -output-http-method --output-http-method</span><br><span class="line">    WARNING: --output-http-method DEPRECATED, use `--http-allow-method` instead</span><br><span class="line">  -output-http-queue-len int</span><br><span class="line">    Number of requests that can be queued <span class="keyword">for</span> output, <span class="keyword">if</span> all workers are busy. default = 1000 (default 1000)</span><br><span class="line">  -output-http-redirects int//设置多少次重定向被允许</span><br><span class="line">    Enable how often redirects should be followed.</span><br><span class="line">  -output-http-response-buffer int</span><br><span class="line">    HTTP response buffer size, all data after this size will be discarded.</span><br><span class="line">  -output-http-rewrite-url --output-http-rewrite-url</span><br><span class="line">    WARNING: --output-http-rewrite-url DEPRECATED, use `--http-rewrite-url` instead</span><br><span class="line">  -output-http-stats//每5秒钟输出一次输出队列的状态</span><br><span class="line">    Report http output queue stats to console every N milliseconds. See output-http-stats-ms</span><br><span class="line">  -output-http-stats-ms int</span><br><span class="line">    Report http output queue stats to console every N milliseconds. default: 5000 (default 5000)</span><br><span class="line">  -output-http-timeout duration//指定http的request/response超时时间，默认是5秒 </span><br><span class="line">    Specify HTTP request/response timeout. By default 5s. Example: --output-http-timeout 30s (default 5s)</span><br><span class="line">  -output-http-track-response</span><br><span class="line">    If turned on, HTTP output responses will be <span class="built_in">set</span> to all outputs like stdout, file and etc.</span><br><span class="line">  -output-http-url-regexp --output-http-url-regexp</span><br><span class="line">    WARNING: --output-http-url-regexp DEPRECATED, use `--http-allow-url` instead</span><br><span class="line">  -output-http-workers int// gor默认是动态的扩展工作者数量，你也可以指定固定数量的工作者</span><br><span class="line">    Gor uses dynamic worker scaling. Enter a number to <span class="built_in">set</span> a maximum number of workers. default = 0 = unlimited.</span><br><span class="line">  -output-http-workers-min int</span><br><span class="line">    Gor uses dynamic worker scaling. Enter a number to <span class="built_in">set</span> a minimum number of workers. default = 1.</span><br><span class="line">  -output-kafka-host string</span><br><span class="line">    Read request and response stats from Kafka:</span><br><span class="line">    gor --input-raw :8080 --output-kafka-host <span class="string">'192.168.0.1:9092,192.168.0.2:9092'</span></span><br><span class="line">  -output-kafka-json-format</span><br><span class="line">    If turned on, it will serialize messages from GoReplay text format to JSON.</span><br><span class="line">  -output-kafka-topic string</span><br><span class="line">    Read request and response stats from Kafka:</span><br><span class="line">    gor --input-raw :8080 --output-kafka-topic <span class="string">'kafka-log'</span></span><br><span class="line">  -output-null</span><br><span class="line">    Used <span class="keyword">for</span> testing inputs. Drops all requests.</span><br><span class="line">  -output-stdout</span><br><span class="line">    Used <span class="keyword">for</span> testing inputs. Just prints to console data coming from inputs.</span><br><span class="line">  -output-tcp value//用来在多个gor之间流转流量</span><br><span class="line">    Used <span class="keyword">for</span> internal communication between Gor instances. Example: </span><br><span class="line">    <span class="comment"># Listen for requests on 80 port and forward them to other Gor instance on 28020 port</span></span><br><span class="line">    gor --input-raw :80 --output-tcp replay.local:28020</span><br><span class="line">  -output-tcp-secure</span><br><span class="line">    Use TLS secure connection. --input-file on another end should have TLS turned on as well.</span><br><span class="line">  -output-tcp-stats//每5秒钟报告一次tcp输出队列的状态</span><br><span class="line">    Report TCP output queue stats to console every 5 seconds.</span><br><span class="line">  -prettify-http</span><br><span class="line">    If enabled, will automatically decode requests and responses with: Content-Encodning: gzip and Transfer-Encoding: chunked. Useful <span class="keyword">for</span> debugging, <span class="keyword">in</span> conjuction with --output-stdout</span><br><span class="line">  -split-output <span class="literal">true</span></span><br><span class="line">    By default each output gets same traffic. If <span class="built_in">set</span> to <span class="literal">true</span> it splits traffic equally among all outputs.</span><br><span class="line">  -stats//打开输出队列的状态</span><br><span class="line">    Turn on queue stats output</span><br><span class="line">  -verbose</span><br><span class="line">    Turn on more verbose output</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#goreplay简介&quot;&gt;goreplay简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#goreplay工作原理&quot;&gt;goreplay工作原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#goreplay常见用法
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="工具" scheme="https://lxb.wiki/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>10大静态网站生成工具</title>
    <link href="https://lxb.wiki/690c8418/"/>
    <id>https://lxb.wiki/690c8418/</id>
    <published>2020-10-02T10:26:55.000Z</published>
    <updated>2020-11-12T15:23:48.853Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#静态网站是什么">静态网站是什么？</a></li><li><a href="#最好的开源静态网站生成工具">最好的开源静态网站生成工具</a><ul><li><a href="#1-jekyll">1、Jekyll</a></li><li><a href="#2-hugo">2、Hugo</a></li><li><a href="#3-hexo">3、Hexo</a></li><li><a href="#4-gatsby">4、Gatsby</a></li><li><a href="#5-vuepress">5、VuePress</a></li><li><a href="#6-nuxtjs">6、Nuxt.js</a></li><li><a href="#7-docusaurus">7、Docusaurus</a></li><li><a href="#8-eleventy">8、Eleventy</a></li><li><a href="#9-publii">9、Publii</a></li><li><a href="#10-primo">10、Primo</a></li></ul></li><li><a href="#结语">结语</a></li></ul><!-- tocstop --><p><img src="https://img.linux.net.cn/data/attachment/album/202010/01/123903lx1q0w2oh1lxx7wh.jpg" alt></p><blockquote><p>在寻找部署静态网页的方法吗？这几个开源的静态网站生成工具可以帮你迅速部署界面优美、功能强大的静态网站，无需掌握复杂的 HTML 和 CSS 技能。</p></blockquote><h3 id="静态网站是什么"><span id="静态网站是什么">静态网站是什么？</span></h3><p>技术上来讲，静态网站是指网页不是由服务器动态生成的。HTML、CSS 和 JavaScript 文件就静静地躺在服务器的某个路径下，它们的内容与终端用户接收到的版本是一样的。原始的源码文件已经提前编译好了，源码在每次请求后都不会变化。</p><p>Linux.CN 是一个依赖多个数据库的动态网站，当有浏览器的请求时，网页就会生成并提供服务。大部分网站是动态的，你与这些网站互动时，大量的内容会经常改变。</p><p>静态网站有一些好处，比如加载时间更短，请求的服务器资源更少、更安全（值得商榷）。</p><p>传统上，静态网站更适合于创建只有少量网页、内容变化不频繁的小网站。</p><p>然而，随着静态网站生成工具出现后，静态网站的适用范围越来越大。你还可以使用这些工具搭建博客网站。</p><p>我整理了几个开源的静态网站生成工具，这些工具可以帮你搭建界面优美的网站。</p><h3 id="最好的开源静态网站生成工具"><span id="最好的开源静态网站生成工具">最好的开源静态网站生成工具</span></h3><p>请注意，静态网站不会提供很复杂的功能。如果你需要复杂的功能，那么你可以参考适用于动态网站的<a href="https://itsfoss.com/open-source-cms/" target="_blank" rel="noopener">最佳开源 CMS</a>列表。</p><h4 id="1-jekyll"><span id="1-jekyll">1、Jekyll</span></h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2018/01/jekyll-screenshot.jpg?resize=800%2C450&ssl=1" alt></p><p>Jekyll 是用 <a href="https://www.ruby-lang.org/en/" target="_blank" rel="noopener">Ruby</a> 写的最受欢迎的开源静态生成工具之一。实际上，Jekyll 是 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub 页面</a> 的引擎，它可以让你免费用 GitHub 托管网站。</p><p>你可以很轻松地跨平台配置 Jekyll，包括 Ubuntu。它利用 <a href="https://github.com/Shopify/liquid/wiki" target="_blank" rel="noopener">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki" target="_blank" rel="noopener">Liquid</a>（模板语言）、HTML 和 CSS 来生成静态的网页文件。如果你要搭建一个没有广告或推广自己工具或服务的产品页的博客网站，它是个不错的选择。</p><p>它还支持从常见的 CMS（<ruby>内容管理系统<rt>Content management system</rt></ruby>）如 Ghost、WordPress、Drupal 7 迁移你的博客。你可以管理永久链接、类别、页面、文章，还可以自定义布局，这些功能都很强大。因此，即使你已经有了一个网站，如果你想转成静态网站，Jekyll 会是一个完美的解决方案。你可以参考<a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">官方文档</a>或 <a href="https://github.com/jekyll/jekyll" target="_blank" rel="noopener">GitHub 页面</a>了解更多内容。</p><ul><li><a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a></li></ul><h4 id="2-hugo"><span id="2-hugo">2、Hugo</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hugo.jpg?resize=800%2C414&ssl=1" alt></p><p>Hugo 是另一个很受欢迎的用于搭建静态网站的开源框架。它是用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>写的。</p><p>它运行速度快、使用简单、可靠性高。如果你需要，它也可以提供更高级的主题。它还提供了一些有用的快捷方式来帮助你轻松完成任务。无论是组合展示网站还是博客网站，Hogo 都有能力管理大量的内容类型。</p><p>如果你想使用 Hugo，你可以参照它的<a href="https://gohugo.io/getting-started/" target="_blank" rel="noopener">官方文档</a>或它的 <a href="https://github.com/gohugoio/hugo" target="_blank" rel="noopener">GitHub 页面</a>来安装以及了解更多相关的使用方法。如果需要的话，你还可以将 Hugo 部署在 GitHub 页面或任何 CDN 上。</p><ul><li><a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a></li></ul><h4 id="3-hexo"><span id="3-hexo">3、Hexo</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hexo.jpg?resize=800%2C213&ssl=1" alt></p><p>Hexo 是一个有趣的开源框架，基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>。像其他的工具一样，你可以用它搭建相当快速的网站，不仅如此，它还提供了丰富的主题和插件。</p><p>它还根据用户的每个需求提供了强大的 API 来扩展功能。如果你已经有一个网站，你可以用它的<a href="https://hexo.io/api/migrator.html" target="_blank" rel="noopener">迁移</a>扩展轻松完成迁移工作。</p><p>你可以参照<a href="https://hexo.io/docs/" target="_blank" rel="noopener">官方文档</a>或 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">GitHub 页面</a> 来使用 Hexo。</p><ul><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li></ul><h4 id="4-gatsby"><span id="4-gatsby">4、Gatsby</span></h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/gatsbyjs.png?resize=800%2C388&ssl=1" alt></p><p>Gatsby 是一个越来越流行的开源网站生成框架。它使用 <a href="https://reactjs.org/" target="_blank" rel="noopener">React.js</a> 来生成快速、界面优美的网站。</p><p>几年前在一个实验性的项目中，我曾经非常想尝试一下这个工具，它提供的成千上万的新插件和主题的能力让我印象深刻。与其他静态网站生成工具不同的是，你可以使用 Gatsby 生成一个网站，并在不损失任何功能的情况下获得静态网站的好处。</p><p>它提供了与很多流行的服务的整合功能。当然，你可以不使用它的复杂的功能，或将其与你选择的流行 CMS 配合使用，这也会很有趣。你可以查看他们的<a href="https://www.gatsbyjs.com/docs/" target="_blank" rel="noopener">官方文档</a>或它的 <a href="https://github.com/gatsbyjs/gatsby" target="_blank" rel="noopener">GitHub 页面</a>了解更多内容。</p><ul><li><a href="https://www.gatsbyjs.com/" target="_blank" rel="noopener">Gatsby</a></li></ul><h4 id="5-vuepress"><span id="5-vuepress">5、VuePress</span></h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/VuePress.jpg?resize=800%2C498&ssl=1" alt></p><p>VuePress 是由 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 支持的静态网站生成工具，而 Vue.js 是一个开源的渐进式 JavaScript 框架。</p><p>如果你了解 HTML、CSS 和 JavaScript，那么你可以无压力地使用 VuePress。你应该可以找到几个有用的插件和主题来为你的网站建设开个头。此外，看起来 Vue.js 的更新一直很活跃，很多开发者都在关注 Vue.js，这是一件好事。</p><p>你可以参照他们的<a href="https://vuepress.vuejs.org/guide/" target="_blank" rel="noopener">官方文档</a>和 <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener">GitHub 页面</a>了解更多。</p><ul><li><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener">VuePress</a></li></ul><h4 id="6-nuxtjs"><span id="6-nuxtjs">6、Nuxt.js</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/nuxtjs.jpg?resize=800%2C415&ssl=1" alt></p><p>Nuxt.js 使用了 Vue.js 和 Node.js，但它致力于模块化，并且有能力依赖服务端而非客户端。不仅如此，它的目标是为开发者提供直观的体验，并提供描述性错误，以及详细的文档等。</p><p>正如它声称的那样，在你用来搭建静态网站的所有工具中，Nuxt.js 可以做到功能和灵活性两全其美。他们还提供了一个 <a href="https://template.nuxtjs.org/" target="_blank" rel="noopener">Nuxt 线上沙盒</a>，让你不费吹灰之力就能直接测试它。</p><p>你可以查看它的 <a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">GitHub 页面</a>和<a href="https://nuxtjs.org/" target="_blank" rel="noopener">官方网站</a>了解更多。</p><ul><li><a href="https://nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a></li></ul><h4 id="7-docusaurus"><span id="7-docusaurus">7、Docusaurus</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/docusaurus.jpg?resize=800%2C278&ssl=1" alt></p><p>Docusaurus 是一个有趣的开源静态网站生成工具，为搭建文档类网站量身定制。它还是 <a href="https://opensource.facebook.com/" target="_blank" rel="noopener">Facebook 开源计划</a>的一个项目。</p><p>Docusaurus 是用 React 构建的。你可以使用所有的基本功能，像文档版本管理、文档搜索和翻译大多是预先配置的。如果你想为你的产品或服务搭建一个文档网站，那么可以试试 Docusaurus。</p><p>你可以从它的 <a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener">GitHub 页面</a>和它的<a href="https://docusaurus.io/" target="_blank" rel="noopener">官网</a>获取更多信息。</p><ul><li><a href="https://docusaurus.io/" target="_blank" rel="noopener">Docusaurus</a></li></ul><h4 id="8-eleventy"><span id="8-eleventy">8、Eleventy</span></h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/eleventy.png?resize=800%2C375&ssl=1" alt></p><p>Eleventy 自称是 Jekyll 的替代品，旨在以更简单的方法来制作更快的静态网站。</p><p>它似乎很容易上手，而且它还提供了适当的文档来帮助你。如果你想找一个简单的静态网站生成工具，Eleventy 似乎会是一个有趣的选择。</p><p>你可以参照它的 <a href="https://github.com/11ty/eleventy/" target="_blank" rel="noopener">GitHub 页面</a>和<a href="https://www.11ty.dev/" target="_blank" rel="noopener">官网</a>来了解更多的细节。</p><ul><li><a href="https://www.11ty.dev/" target="_blank" rel="noopener">Eleventy</a></li></ul><h4 id="9-publii"><span id="9-publii">9、Publii</span></h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/publii.jpg?resize=800%2C311&ssl=1" alt></p><p>Publii 是一个令人印象深刻的开源 CMS，它能使生成一个静态网站变得很容易。它是用 <a href="https://www.electronjs.org" target="_blank" rel="noopener">Electron</a> 和 Vue.js 构建的。如果有需要，你也可以把你的文章从 WorkPress 网站迁移过来。此外，它还提供了与 GitHub 页面、Netlify 及其它类似服务的一键同步功能。</p><p>如果你利用 Publii 生成一个静态网站，你还可以得到一个所见即所得的编辑器。你可以从<a href="https://getpublii.com/" target="_blank" rel="noopener">官网</a>下载它，或者从它的 <a href="https://github.com/GetPublii/Publii" target="_blank" rel="noopener">GitHub 页面</a>了解更多信息。</p><ul><li><a href="https://getpublii.com/" target="_blank" rel="noopener">Publii</a></li></ul><h4 id="10-primo"><span id="10-primo">10、Primo</span></h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/primo-af.jpg?resize=800%2C394&ssl=1" alt></p><p>一个有趣的开源静态网站生成工具，目前开发工作仍很活跃。虽然与其他的静态生成工具相比，它还不是一个成熟的解决方案，有些功能还不完善，但它是一个独特的项目。</p><p>Primo 旨在使用可视化的构建器帮你构建和搭建网站，这样你就可以轻松编辑和部署到任意主机上。</p><p>你可以参照<a href="https://primo.af/" target="_blank" rel="noopener">官网</a>或查看它的 <a href="https://github.com/primo-app/primo-desktop" target="_blank" rel="noopener">GitHub 页面</a>了解更多信息。</p><ul><li><a href="https://primo.af/" target="_blank" rel="noopener">Primo</a></li></ul><h3 id="结语"><span id="结语">结语</span></h3><p>还有很多文章中没有列出的网站生成工具。然而，我试图提到最好的静态生成器，为您提供最快的加载时间，最好的安全性和令人印象深刻的灵活性。</p><p>列表中没有你最喜欢的工具？在下面的评论中告诉我。</p><hr><p>via: <a href="https://itsfoss.com/open-source-static-site-generators/" target="_blank" rel="noopener">https://itsfoss.com/open-source-static-site-generators/</a></p><p>作者：<a href="https://itsfoss.com/author/ankush/" target="_blank" rel="noopener">Ankush Das</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#静态网站是什么&quot;&gt;静态网站是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#最好的开源静态网站生成工具&quot;&gt;最好的开源静态网站生成工具&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-jekyll&quot;&gt;1、Jek
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="工具" scheme="https://lxb.wiki/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>sed替换含有路径的字符串</title>
    <link href="https://lxb.wiki/e4c7cf89/"/>
    <id>https://lxb.wiki/e4c7cf89/</id>
    <published>2020-09-13T13:16:00.000Z</published>
    <updated>2020-11-13T15:25:50.434Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#问题描述">问题描述</a></li><li><a href="#初级思路">初级思路</a></li><li><a href="#更好的解决方案">更好的解决方案</a></li></ul><!-- tocstop --><h3 id="问题描述"><span id="问题描述">问题描述</span></h3><p><code>sed -i &quot;s/old/new/g&quot; file.txt</code></p><p>如果 <code>new</code> 是个路径，即字符串中含有<code>/</code>，这么执行会报错</p><h3 id="初级思路"><span id="初级思路">初级思路</span></h3><p>把 <code>new</code> 中的 <code>/</code> 进行转义</p><p>比如 <code>new</code> 为 <code>/home/users/config.yaml</code></p><p>替换时</p><p><code>sed -i &quot;s/old/\/home\/users\/config.yaml/g&quot; file.txt</code></p><p>如果 <code>new</code> 是变量，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new=<span class="string">"/home/users/config.yaml"</span></span><br><span class="line">new_sed=$(<span class="built_in">echo</span> <span class="variable">$new</span> | sed -e <span class="string">'s/\//\\\//g'</span>)</span><br><span class="line">sed -i <span class="string">"s/old/<span class="variable">$&#123;new_sed&#125;</span>/g"</span> file.txt</span><br></pre></td></tr></table></figure><h3 id="更好的解决方案"><span id="更好的解决方案">更好的解决方案</span></h3><p>转义会降低可读性，只需用其他特殊字符作为<code>sed</code>表达式的“分隔符”（取代默认的<code>/</code>）即可。<br>例如：<code>sed &#39;s#\$CONFIG#/home/users/config.yaml#g&#39;</code>，使用<code>#</code>代替<code>/</code>从而避免大量转义。</p><p>你可以尝试一下 <code>echo aabbccdd | sed &#39;s#aa#bb#g&#39; | sed &#39;s?bb?cc?g&#39; | sed &#39;s@cc@dd@g&#39; | sed &#39;s%dd%ee%g&#39;</code>  用任意字符作间隔</p><p>这是 <code>sed</code> 命令方便用户的一个特性，<code>vim</code> 中的 <code>:s</code> 也同样支持</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#问题描述&quot;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#初级思路&quot;&gt;初级思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#更好的解决方案&quot;&gt;更好的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- to
      
    
    </summary>
    
    
      <category term="Shell" scheme="https://lxb.wiki/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://lxb.wiki/tags/Shell/"/>
    
      <category term="sed" scheme="https://lxb.wiki/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用hexo-toc锚点失效问题</title>
    <link href="https://lxb.wiki/b4c41686/"/>
    <id>https://lxb.wiki/b4c41686/</id>
    <published>2020-09-03T13:02:23.000Z</published>
    <updated>2020-11-12T15:24:15.223Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#现象">现象</a></li><li><a href="#原因">原因</a></li><li><a href="#修复方法">修复方法</a></li></ul><!-- tocstop --><h4 id="现象"><span id="现象">现象</span></h4><p>使用 hexo-toc 生成文章目录时，点击某个目录，url 变成 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/690c8418/#null</span><br></pre></td></tr></table></figure><h4 id="原因"><span id="原因">原因</span></h4><p>插件在把 markdown 编译成 HTML 时，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## title</span><br></pre></td></tr></table></figure><p>会编译为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&lt;span id=&quot;title&quot;&gt;title&lt;/span&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>而在插件源码的<a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/helper/toc.js#L27" target="_blank" rel="noopener">这次提交</a>之前，是会编译成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 id=&quot;title&quot;&gt;title&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>因此新版本的 <code>hexo-toc</code> 生成 TOC 时，元素没有 <code>id</code> 这个属性，进而导致 TOC 中的锚点失效。</p><h4 id="修复方法"><span id="修复方法">修复方法</span></h4><p>修改 <code>node_modules/hexo-toc/lib/filter.js</code></p><p>把 28 行的 <code>$title.attr(&#39;id&#39;, id);</code> 注释打开</p><p>把 31 行的 <code>$title.removeAttr(&#39;id&#39;);</code> 注释掉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#现象&quot;&gt;现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#原因&quot;&gt;原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#修复方法&quot;&gt;修复方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;h4
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="hexo" scheme="https://lxb.wiki/tags/hexo/"/>
    
      <category term="hexo-toc" scheme="https://lxb.wiki/tags/hexo-toc/"/>
    
      <category term="锚点失效" scheme="https://lxb.wiki/tags/%E9%94%9A%E7%82%B9%E5%A4%B1%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lambda 表达式</title>
    <link href="https://lxb.wiki/e4d97659/"/>
    <id>https://lxb.wiki/e4d97659/</id>
    <published>2020-08-20T23:13:27.000Z</published>
    <updated>2021-04-07T15:35:12.610Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#基础">基础</a><ul><li><a href="#1-值捕获">1. 值捕获</a></li><li><a href="#2-引用捕获">2. 引用捕获</a></li><li><a href="#3-隐式捕获">3. 隐式捕获</a></li><li><a href="#4-表达式捕获">4. 表达式捕获</a></li></ul></li><li><a href="#泛型-lambda">泛型 Lambda</a></li></ul><!-- tocstop --><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p><h3 id="基础"><span id="基础">基础</span></h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) <span class="keyword">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h4 id="1-值捕获"><span id="1-值捕获">1. 值捕获</span></h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，<strong>被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = copy_value();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stored_value = "</span> &lt;&lt; stored_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用捕获"><span id="2-引用捕获">2. 引用捕获</span></h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = copy_value();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stored_value = "</span> &lt;&lt; stored_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-隐式捕获"><span id="3-隐式捕获">3. 隐式捕获</span></h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;] 引用捕获, 让编译器自行推导捕获列表</li><li>[=] 值捕获, 让编译器执行推导引用列表</li></ul><h4 id="4-表达式捕获"><span id="4-表达式捕获">4. 表达式捕获</span></h4><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>important</code> 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值， 在表达式中初始化。</p><h3 id="泛型-lambda"><span id="泛型-lambda">泛型 Lambda</span></h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。 这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。</p><p>幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始， Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-值捕获&quot;&gt;1. 值捕获&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-引用捕获&quot;&gt;2. 引用捕获&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-
      
    
    </summary>
    
    
      <category term="C++" scheme="https://lxb.wiki/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Pillow 库</title>
    <link href="https://lxb.wiki/ab6bf24d/"/>
    <id>https://lxb.wiki/ab6bf24d/</id>
    <published>2020-08-01T13:10:55.000Z</published>
    <updated>2020-11-12T15:25:17.170Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#pil中所涉及的基本概念">PIL中所涉及的基本概念</a></li><li><a href="#pil中有九种不同模式">PIL中有九种不同模式。</a></li><li><a href="#请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像">请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</a></li></ul><!-- tocstop --><p>Pillow(PIL) 库中的 Image 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; im = Image.open(&quot;lena.ppm&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from __future__ import print_function</span><br><span class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</span><br><span class="line">PPM (512, 512) RGB</span><br></pre></td></tr></table></figure><p>format 这个属性代表图片文件的扩展名, 如果图片文件打开失败, 则其值为None. size 这个属性代表图片的大小, 以像素为单位, 使用包含两个元素的元组来返回. mode 这个属性代表图片的band属性, 一般情况(黑白)下为 “L”, 当图片是彩色的时候是 “RGB”, 如果图片经过压缩, 则是 “CMYK”.</p><h3 id="pil中所涉及的基本概念"><span id="pil中所涉及的基本概念">PIL中所涉及的基本概念</span></h3><p>通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。</p><h3 id="pil中有九种不同模式"><span id="pil中有九种不同模式">PIL中有九种不同模式。</span></h3><p>分别为1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。</p><p><strong>模式 1</strong><br>二值图像</p><p>模式“1”为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.mode</span><br><span class="line"> </span><br><span class="line">&apos;RGB&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1 = lena.convert(&quot;1&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.mode</span><br><span class="line"> </span><br><span class="line">&apos;1&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.size</span><br><span class="line"> </span><br><span class="line">(512, 512)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.getpixel((10,10))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((10,120))</span><br><span class="line"> </span><br><span class="line">0</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((130,120))</span><br><span class="line"> </span><br><span class="line">255</span><br></pre></td></tr></table></figure><p><strong>模式 L</strong></p><p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度</p><p><strong>模式 P</strong></p><p>模式“P”为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的</p><p><strong>模式“RGBA”</strong></p><p>模式“RGBA”为32位彩色图像，它的每个像素用32个bit表示，其中24bit表示红色、绿色和蓝色三个通道，另外8bit表示alpha通道，即透明通道。</p><p>从实例中可以看到，使用当前这个方式将“RGB”图像转为“RGBA”图像时，alpha通道全部设置为255，即完全不透明。</p><p><strong>模式“CMYK”</strong></p><p>模式“CMYK”为32位彩色图像，它的每个像素用32个bit表示。模式“CMYK”就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</p><p>四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：Key Plate(blacK) = 定位套版色（黑色）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk =lena.convert(&quot;CMYK&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.mode</span><br><span class="line"> </span><br><span class="line">&apos;CMYK&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_cmyk.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(58, 144, 177, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(59, 145, 178, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(196, 110, 77)</span><br></pre></td></tr></table></figure><p>从实例中可以得知PIL中“RGB”转换为“CMYK”的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = 255 - R</span><br><span class="line">M = 255 - G</span><br><span class="line">Y = 255 - B</span><br><span class="line">K = 0</span><br></pre></td></tr></table></figure><p>由于该转换公式比较简单，转换后的图像颜色有些失真。</p><p><strong>模式“YCbCr”</strong></p><p>模式“YCbCr”为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。</p><p>模式“RGB”转换为“YCbCr”的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y= 0.257*R+0.504*G+0.098*B+16</span><br><span class="line">Cb = -0.148*R-0.291*G+0.439*B+128</span><br><span class="line">Cr = 0.439*R-0.368*G-0.071*B+128</span><br></pre></td></tr></table></figure><p><strong>模式“I”</strong></p><p>模式“I”为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“I”模式是按照下面的公式转换的：</p><p><code>I = R * 299/1000 + G * 587/1000 + B * 114/1000</code></p><p><strong>模式“F”</strong></p><p>模式“F”为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“F”模式是按照下面的公式转换的：</p><p><code>F = R * 299/1000+ G * 587/1000 + B * 114/1000</code></p><h3 id="请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像"><span id="请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像">请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</span></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#pil中所涉及的基本概念&quot;&gt;PIL中所涉及的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pil中有九种不同模式&quot;&gt;PIL中有九种不同模式。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#请注意gif文件
      
    
    </summary>
    
    
      <category term="Pic" scheme="https://lxb.wiki/categories/Pic/"/>
    
    
      <category term="Python" scheme="https://lxb.wiki/tags/Python/"/>
    
      <category term="Pic" scheme="https://lxb.wiki/tags/Pic/"/>
    
  </entry>
  
  <entry>
    <title>gif图片文件信息</title>
    <link href="https://lxb.wiki/2bf7952d/"/>
    <id>https://lxb.wiki/2bf7952d/</id>
    <published>2020-07-28T13:25:36.000Z</published>
    <updated>2020-11-30T16:53:29.927Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#文件头">文件头</a></li><li><a href="#帧信息描述">帧信息描述</a></li></ul><!-- tocstop --><p>一个GIF文件主要由以下几部分组成。</p><ul><li>文件头</li><li>图像帧信息</li><li>注释</li></ul><h4 id="文件头"><span id="文件头">文件头</span></h4><p>GIF格式文件头和一般文件头差别不大，也包含有</p><ul><li>格式声明</li><li>逻辑屏幕描述块</li><li>全局调色盘</li></ul><p><strong>格式声明</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005159.png" alt></p><p>Signature 为“GIF”3 个字符；Version 为“87a”或“89a”3 个字符。</p><p><strong>逻辑屏幕描述块</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005303.png" alt></p><p>前两字节为像素单位的宽、高，用以标识图片的视觉尺寸。</p><p>Packet里是调色盘信息，分别来看——</p><p>Global Color Table Flag 为全局颜色表标志，即为1时表明全局颜色表有定义。</p><p>Color Resolution 代表颜色表中每种基色位长（需要+1），为111时，每个颜色用8bit表示，即我们熟悉的RGB表示法，一个颜色三字节。</p><p>Sort Flag 表示是否对颜色表里的颜色进行优先度排序，把常用的排在前面，这个主要是为了适应一些颜色解析度低的早期渲染器，现在已经很少使用了。</p><p>Global Color Table 表示颜色表的长度，计算规则是值+1作为2的幂，得到的数字就是颜色表的项数，取最大值111时，项数=256，也就是说GIF格式最多支持256色的位图，再乘以Color Resolution算出的字节数，就是调色盘的总长度。</p><p>这四个字段一起定义了调色盘的信息。</p><p>Background color Index 定义了图像透明区域的背景色在调色盘里的索引。</p><p>Pixel Aspect Ratio 定义了像素宽高比，一般为0。</p><h4 id="帧信息描述"><span id="帧信息描述">帧信息描述</span></h4><p>帧信息描述就是每一帧的图像信息和相关标志位</p><p>大部分GIF存储时采用了公共区域排除和透明区域叠加的优化</p><p><strong>帧数据说明</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#文件头&quot;&gt;文件头&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#帧信息描述&quot;&gt;帧信息描述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;p&gt;一个GIF文件主要由以下几部分组成。&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
    
      <category term="Pic" scheme="https://lxb.wiki/categories/Pic/"/>
    
    
      <category term="GIF" scheme="https://lxb.wiki/tags/GIF/"/>
    
  </entry>
  
  <entry>
    <title>URL特殊字符处理</title>
    <link href="https://lxb.wiki/c587a198/"/>
    <id>https://lxb.wiki/c587a198/</id>
    <published>2020-07-09T22:45:47.000Z</published>
    <updated>2020-11-12T15:25:45.773Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> hexVals[<span class="number">16</span>] = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> CURLEncode::csUnsafeString= <span class="string">"\"&lt;&gt;%\\^[]`+$,@:;/!#?=&amp;"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> csRet;</span><br><span class="line">    csRet += <span class="string">"%"</span>;</span><br><span class="line">    csRet += decToHex(val, <span class="number">16</span>);   </span><br><span class="line">    <span class="keyword">return</span>  csRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decToHex</span><span class="params">(<span class="keyword">char</span> num, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>     temp=<span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">string</span>  csTmp;</span><br><span class="line">    <span class="keyword">int</span> num_char;</span><br><span class="line">    num_char = (<span class="keyword">int</span>) num;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// ISO-8859-1 </span></span><br><span class="line">    <span class="comment">// IF THE IF LOOP IS COMMENTED, THE CODE WILL FAIL TO GENERATE A </span></span><br><span class="line">    <span class="comment">// PROPER URL ENCODE FOR THE CHARACTERS WHOSE RANGE IN 127-255(DECIMAL)</span></span><br><span class="line">    <span class="keyword">if</span> (num_char &lt; <span class="number">0</span>)</span><br><span class="line">        num_char = <span class="number">256</span> + num_char;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (num_char &gt;= radix)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = num_char % radix;</span><br><span class="line">        num_char = (<span class="keyword">int</span>)<span class="built_in">floor</span>((num_char / radix) * <span class="number">1.0</span>);</span><br><span class="line">        csTmp = hexVals[temp];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    csTmp += hexVals[num_char];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(csTmp.length() &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        csTmp += <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> strdecToHex = csTmp;</span><br><span class="line">    <span class="comment">// Reverse the String</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(strdecToHex.begin(), strdecToHex.end());</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> strdecToHex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnsafe</span><span class="params">(<span class="keyword">char</span> compareChar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bcharfound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> tmpsafeChar;</span><br><span class="line">    <span class="keyword">int</span> m_strLen = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    m_strLen = csUnsafeString.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ichar_pos = <span class="number">0</span>; ichar_pos &lt; m_strLen ;ichar_pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpsafeChar = csUnsafeString[ichar_pos]; </span><br><span class="line">        <span class="keyword">if</span>(tmpsafeChar == compareChar)</span><br><span class="line">        &#123; </span><br><span class="line">            bcharfound = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> char_ascii_value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//char_ascii_value = __toascii(compareChar);</span></span><br><span class="line">    char_ascii_value = (<span class="keyword">int</span>) compareChar;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(bcharfound == <span class="literal">false</span> &amp;&amp;  char_ascii_value &gt; <span class="number">32</span> &amp;&amp; char_ascii_value &lt; <span class="number">123</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// found no unsafe chars, return false       </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">URLEncode</span><span class="params">(<span class="built_in">string</span> strEncode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>  strSrc;</span><br><span class="line">    <span class="built_in">string</span>    strDest;   </span><br><span class="line"> </span><br><span class="line">    strSrc = strEncode;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strSrc.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = strSrc[i];</span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="string">' '</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ch = ch;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!isUnsafe(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Safe Character               </span></span><br><span class="line">            strDest += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get Hex Value of the Character</span></span><br><span class="line">            strDest += convert(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;



&lt;!-- tocstop --&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
  </entry>
  
</feed>
