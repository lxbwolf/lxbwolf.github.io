<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxb.wiki/"/>
  <updated>2019-12-12T15:07:33.468Z</updated>
  <id>https://lxb.wiki/</id>
  
  <author>
    <name>Brooke Lau</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务中的熔断器和重试</title>
    <link href="https://lxb.wiki/c9399f4/"/>
    <id>https://lxb.wiki/c9399f4/</id>
    <published>2019-12-12T15:02:17.000Z</published>
    <updated>2019-12-12T15:07:33.468Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。</p><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/01.png" alt="01"></p><p>想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。</p><p>后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/02.png" alt="02"></p><p>熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/03.png" alt="03"></p><p>通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 <a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">wikipedia</a>）可能不会遇到这种网络模式。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/04.png" alt="04"></p><p>熔断器有三个主要的状态：</p><ul><li>Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 <strong>Max Concurrency</strong>（最大并发数）和 <strong>Timeout</strong>（超时）。</li><li>Open：所有的请求都会返回 <strong>Circuit Open</strong> 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。</li><li>Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。</li></ul><h2 id="熔断器原理"><a href="#熔断器原理" class="headerlink" title="熔断器原理"></a>熔断器原理</h2><p>控制熔断的设置共有 5 个主要参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommandConfig is used to tune circuit settings at runtime</span></span><br><span class="line"><span class="keyword">type</span> CommandConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Timeout                <span class="keyword">int</span> <span class="string">`json:"timeout"`</span></span><br><span class="line">MaxConcurrentRequests  <span class="keyword">int</span> <span class="string">`json:"max_concurrent_requests"`</span></span><br><span class="line">RequestVolumeThreshold <span class="keyword">int</span> <span class="string">`json:"request_volume_threshold"`</span></span><br><span class="line">SleepWindow            <span class="keyword">int</span> <span class="string">`json:"sleep_window"`</span></span><br><span class="line">ErrorPercentThreshold  <span class="keyword">int</span> <span class="string">`json:"error_percent_threshold"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go" target="_blank" rel="noopener">查看源码</a></p><p>可以通过根据两个服务的 SLA（‎ Service Level Agreement，<a href="https://zh.wikipedia.org/zh-hans/服务级别协议" target="_blank" rel="noopener">服务级别协议</a>）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。</p><p>一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。</p><h2 id="生产上的熔断器"><a href="#生产上的熔断器" class="headerlink" title="生产上的熔断器"></a>生产上的熔断器</h2><p>熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>这段实例代码用的是 <a href="http://github.com/afex/hystrix-go/hystrix" target="_blank" rel="noopener">hystrix-go</a> 库，hystrix Netflix 库在 Golang 的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/afex/hystrix-go/hystrix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandName = <span class="string">"producer_api"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hystrix.ConfigureCommand(commandName, hystrix.CommandConfig&#123;</span><br><span class="line">Timeout:                <span class="number">500</span>,</span><br><span class="line">MaxConcurrentRequests:  <span class="number">100</span>,</span><br><span class="line">ErrorPercentThreshold:  <span class="number">50</span>,</span><br><span class="line">RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">SleepWindow:            <span class="number">1000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, logger(handle))</span><br><span class="line">log.Println(<span class="string">"listening on :8080"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">errors := hystrix.Go(commandName, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// talk to other services</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="comment">// err := callWithRetryV1()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">output &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out := &lt;-output:</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">log.Printf(<span class="string">"success %v"</span>, out)</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errors:</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line">log.Printf(<span class="string">"failed %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger is Handler wrapper function for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(fn http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(r.URL.Path, r.Method)</span><br><span class="line">fn(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callChargeProducerAPI</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(os.Getenv(<span class="string">"SERVER_ERROR"</span>))</span><br><span class="line"><span class="keyword">if</span> os.Getenv(<span class="string">"SERVER_ERROR"</span>) == <span class="string">"1"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"503 error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 中分别测试了请求调用链 closed 和 open 两种情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Experiment 1: success path */</span><br><span class="line">// server</span><br><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">/* Experiment 2: circuit open */</span><br><span class="line">// server</span><br><span class="line">SERVER_ERROR=1 Go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试问题"><a href="#重试问题" class="headerlink" title="重试问题"></a>重试问题</h2><p>在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。</p><p>一段简单的重试代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callWithRetryV1</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">3</span>; index++ &#123;</span><br><span class="line"><span class="comment">// call producer API</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding backoff</span></span><br><span class="line"><span class="comment">// adding jitter</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h2><p>为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。</p><p>一起来看下列算法：</p><ul><li>Exponential: bash * 2<sup>attemp</sup></li><li>Full Jitter: sleep = rand(0, base * 2<sup>attempt</sup>)</li><li>Equal Jitter: temp = base * 2<sup>attemp</sup>; sleep = temp/2+rand(0, temp/2)</li><li>De-corredlated Jitter: sleep = rand(base, sleep*3)</li></ul><p>【译注】关于这几个算法，可以参考<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a> 。<strong>Full Jitter</strong>、 <strong>Equal Jitter</strong>、 <strong>De-corredlated</strong> 等都是原作者自己定义的名词。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/05.png" alt="05"></p><p>客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a>中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。</p><h2 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/06.png" alt="Example configuration of both tools"></p><p>熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://github.com/afex/hystrix-go/" target="_blank" rel="noopener">https://github.com/afex/hystrix-go/</a></li><li><a href="https://github.com/eapache/go-resiliency" target="_blank" rel="noopener">https://github.com/eapache/go-resiliency</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></li><li><a href="https://www.awsarchitectureblog.com/2015/03/backoff.html" target="_blank" rel="noopener">https://www.awsarchitectureblog.com/2015/03/backoff.html</a></li><li><a href="https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience" target="_blank" rel="noopener">https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience</a></li></ol><hr><p>via: <a href="https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/" target="_blank" rel="noopener">https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/</a></p><p>作者：<a href="http://github.com/titpetric" target="_blank" rel="noopener">Tit Petric</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25295" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。&lt;/p&gt;
&lt;h2 id=&quot;熔断器&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>协程，操作系统线程和 CPU 管理</title>
    <link href="https://lxb.wiki/4e717bb5/"/>
    <id>https://lxb.wiki/4e717bb5/</id>
    <published>2019-12-12T15:01:35.000Z</published>
    <updated>2019-12-12T15:06:59.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French."></p><p>ℹ️ <em>本文运行环境为 Go 1.13</em></p><p>对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。</p><h2 id="M-P-G-编排"><a href="#M-P-G-编排" class="headerlink" title="M, P, G 编排"></a>M, P, G 编排</h2><p>为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The main concepts are:</span><br><span class="line">G - goroutine.</span><br><span class="line">M - worker thread, or machine.</span><br><span class="line">P - processor, a resource that is required to execute Go code.</span><br><span class="line">    M must have an associated P to execute Go code[...].</span><br></pre></td></tr></table></figure><p><code>P</code>, <code>M</code>, <code>G</code> 模型图解：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/01.png" alt="P, M, G diagram"></p><p>每个协程（<code>G</code>）运行在与一个逻辑 CPU（<code>P</code>）相关联的 OS 线程（<code>M</code>）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`hello`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`world`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Go 根据机器逻辑 CPU 的个数来创建不同的 <code>P</code>，并且把它们保存在一个空闲 <code>P</code> 的 list 里。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/02.png" alt="P initialization"></p><p>然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 <code>P</code>。这个 <code>P</code> 通过与之相关联的 OS 线程来创建一个 <code>M</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/03.png" alt="OS thread creation"></p><p>然而，像 <code>P</code> 那样，系统调用返回的甚至被 gc 强行停止的空闲的 <code>M</code> — 比如没有协程在等待运行 — 也会被加到一个空闲 list：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/04.png" alt="M and P idle list"></p><p>在程序启动阶段，Go 就已经创建了一些 OS 线程并与 <code>M</code> 想关联了。在我们的例子中，打印 <code>hello</code> 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 <code>M</code> 和 <code>P</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/05.png" alt="M and P pulled from the idle list"></p><p>现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 <code>P</code> 多的 <code>M</code>，在系统调用时怎么管理协程。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 <code>P</code> 和线程 <code>M</code> 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   fd, _ := os.Open(<span class="string">"number.txt"</span>)</span><br><span class="line">   fd.Read(buf)</span><br><span class="line">   fd.Close()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="keyword">string</span>(buf)) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读取的流程如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/06.png" alt="Syscall handoffs P"></p><p><code>P0</code> 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。</p><ul><li>尝试去捕获相同的 <code>P</code>，在我们的例子中就是 <code>P0</code>，然后 resume 执行过程</li><li>尝试从空闲 list 中捕获一个 <code>P</code>，然后 resume 执行过程</li><li>把协程放到全局队列里，把与之相关联的 <code>M</code> 放回空闲 list 去</li></ul><p>然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 <code>M</code> 不会阻塞：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/07.png" alt="Network poller waiting for the resource"></p><p>在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/08.png" alt></p><p>如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。</p><h2 id="OS-线程方面的限制"><a href="#OS-线程方面的限制" class="headerlink" title="OS 线程方面的限制"></a>OS 线程方面的限制</h2><p>在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：</p><blockquote><p><em>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</em></p></blockquote><p>译注：<strong>GOMAXPROCS</strong> 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 <strong>GOMAXPROCS</strong> 没有影响。这个包的 <strong><em>GOMAXPROCS</em></strong> 函数查询和修改这个最大数限制。</p><p>对这种情形举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++  &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         http.Get(<span class="string">`https://httpstat.us/200?sleep=10000`</span>)</span><br><span class="line"></span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用追踪工具得到的线程数如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/09.png" alt></p><p>由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。</p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25292" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png&quot; alt=&quot;Illus
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Symbol Names of Keyboard</title>
    <link href="https://lxb.wiki/2d9f52fc/"/>
    <id>https://lxb.wiki/2d9f52fc/</id>
    <published>2019-12-07T02:22:50.000Z</published>
    <updated>2019-12-07T02:25:27.232Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">符号英文名中文名</span><br><span class="line">~tilde or swung dash波浪字符或代字号</span><br><span class="line">!exclamation mark惊叹号</span><br><span class="line">@at sign or commercial at爱特或小老鼠</span><br><span class="line"><span class="comment">#number sign井号</span></span><br><span class="line">$dollar sign美元符</span><br><span class="line">%percent sign百分号</span><br><span class="line">^caret脱字符</span><br><span class="line">&amp;ampersand与和符</span><br><span class="line">*asterisk星号</span><br><span class="line">()parentheses, round brackets, soft brackets, </span><br><span class="line">or circle brackets 小括号，圆括号</span><br><span class="line">[]brackets (US), square brackets, </span><br><span class="line">closed brackets or hard brackets中括号，方括号</span><br><span class="line">&#123;&#125;braces (UK and US), French brackets, </span><br><span class="line">curly brackets大括号，花括号</span><br><span class="line">&lt;&gt; angle brackets or chevrons尖括号</span><br><span class="line">_underscore下划线</span><br><span class="line">+plus sign加号</span><br><span class="line">−minus sign减号</span><br><span class="line">=equals sign等号</span><br><span class="line">&lt; less-than sign小于号</span><br><span class="line">&gt; greater-than sign大于号</span><br><span class="line">.period, full stop or dot句号，点</span><br><span class="line">,comma逗号</span><br><span class="line">:colon 冒号</span><br><span class="line">;semicolon分号</span><br><span class="line">?question mark问号</span><br><span class="line">-hyphen连字符</span><br><span class="line">...ellipsis省略号</span><br><span class="line">–dash破折号</span><br><span class="line">/slash, forward slash斜线</span><br><span class="line">\backslash反斜线</span><br><span class="line">|vertical bar竖线</span><br><span class="line">“quotation mark双引号</span><br><span class="line">‘apostrophe单引号，省略符号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="symbol" scheme="https://lxb.wiki/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>go匿名函数和闭包</title>
    <link href="https://lxb.wiki/e2c91def/"/>
    <id>https://lxb.wiki/e2c91def/</id>
    <published>2019-11-17T06:38:20.000Z</published>
    <updated>2019-11-17T06:39:01.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数变量-函数值"><a href="#函数变量-函数值" class="headerlink" title="函数变量(函数值)"></a>函数变量(函数值)</h3><p>在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func square(x int) &#123;</span><br><span class="line">println(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接调用：square(1)</li><li>把函数当成变量一样赋值：<code>s := square</code>；接着可以调用这个函数变量：s(1)。 注意：这里 square 后面没有圆括号，调用才有。</li></ol><ul><li>调用 <code>nil</code> 的函数变量会导致 panic。</li><li>函数变量的零值是 nil，这意味着它可以跟 nil 比较，但两个函数变量之间不能比较。</li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>作用: 在go语言中目前了解的作用就是用于构成闭包</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包通过引用的方式使用外部函数的变量<br>函数与 与其(直接)相关的环境形成闭包</p><p>简单来说: 因为把返回的函数赋给了一个变量, 虽然函数在执行完一瞬间会销毁其执行环境, 但是如果有闭包的话, 闭包会保存外部函数的活动对象(变量), 所以如果不对闭包的引用消除掉, 闭包会一直存在内存中, 垃圾收集器不会销毁闭包占用的内存</p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//函数A是一个不带参数，返回值是一个匿名函数，且该函数</span><br><span class="line">//带有一个int类型参数，返回值为一个int类型</span><br><span class="line">func A() func(int) int &#123;</span><br><span class="line">sum := 0</span><br><span class="line">return func(bb int) int &#123;</span><br><span class="line">sum += bb</span><br><span class="line">fmt.Println(&quot;bb=&quot;, bb, &quot;\tsum=&quot;, sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()//定义变量a,并将函数A的返回值赋给a // 这个时候, 虽然有小括号, 但是func A()还未真正执行, 只是赋值给了变量a</span><br><span class="line">b := a(4) //真正执行func A()</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：   </span><br><span class="line">**    bb= 4   sum= 4</span><br><span class="line">**    4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>调用2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()</span><br><span class="line">a(0)</span><br><span class="line">a(1)</span><br><span class="line">a(5)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 sum= 0</span><br><span class="line">**　　bb= 1 sum= 1</span><br><span class="line">**　　bb= 5 sum= 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>以上调用通过闭包实现了sum的累加</p><p>调用3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()</span><br><span class="line">c := A()</span><br><span class="line">a(0)</span><br><span class="line">a(5)</span><br><span class="line">c(10)</span><br><span class="line">c(20)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 sum= 0</span><br><span class="line">**　　bb= 5 sum= 5</span><br><span class="line">**　　bb= 10 sum= 10</span><br><span class="line">**　　bb= 20 sum= 30   </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>　可以看出，上例中调用了两次函数A，构成了两个闭包，这两个闭包维护的变量sum不是同一个变量。　　</p><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = func() &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := B() // 这个时候并未真正执行函数, 只是定义, 所以不会print</span><br><span class="line">c[0]() // 这个时候真正执行, 但是由于闭包, c[0] 中拿的i的引用</span><br><span class="line">c[1]()</span><br><span class="line">c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>闭包通过引用的方式使用外部函数的变量。</p><p>　　上例中只调用了一次函数B,构成一个闭包(<code>func() {fmt.Println(i)}</code> 与它的环境<code>func B() []func(){}</code> 构成闭包)，i 在外部函数B中定义，所以闭包维护该变量 i ，c[0]、c[1]、c[2]中的 i 都是闭包中 i 的引用。</p><p>　　因此执行<code>c:=B()</code>后，i 的值已经变为3，故再调用c<a href>0</a>时的输出是3而不是0。<br>　　<br>可作如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = (func(j int) func() &#123;</span><br><span class="line">return func() &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i) // 这个地方的小括号是真正执行了</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := B()</span><br><span class="line">c[0]()</span><br><span class="line">c[1]()</span><br><span class="line">c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：</span><br><span class="line">**        0</span><br><span class="line">**        1</span><br><span class="line">**        2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>函数<code>func() {fmt.Println(j)}</code> 与它的环境<code>func(j int) func() {}</code> 构成闭包, 变量<code>i</code>(实参) 并没有在它的环境范围内, 且 <code>j</code>是形参<br>以上修改可能没有什么实际意义，此处仅为说明问题使用。</p><p>在使用defer的时候可能出现类似问题，需要注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 2; j++ &#123;</span><br><span class="line">defer (func() &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;)()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：    </span><br><span class="line">**    2    </span><br><span class="line">**    2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3:"></a>实例3:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func incr() func() int &#123;</span><br><span class="line">var x int</span><br><span class="line">return func() int &#123;</span><br><span class="line">x++</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个函数会返回一个函数变量。<br><code>i := incr()</code> : 通过把这个函数变量赋值给<code>i</code>, <code>i</code> 就成为了一个闭包<br>所以<code>i</code> 保存着对<code>x</code> 的引用, 可以想象<code>i</code> 中有着一个指针指向<code>x</code> 或者 <code>i</code> 中有<code>x</code> 的地址</p><p>由于<code>i</code> 有着指向<code>x</code> 的指针, 所以可以修改<code>x</code> , 且保持着状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(i()) // 1</span><br><span class="line">println(i()) // 2</span><br><span class="line">println(i()) // 3</span><br></pre></td></tr></table></figure><p>也就是说, <code>x</code> 逃逸了, 它的声明周期没有随着它的作用域结束而结束<br>但是这段代码却不会递增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br></pre></td></tr></table></figure><p>这是因为这里调用了三次 <code>incr()</code>，返回了三个闭包，这三个闭包引用着三个不同的 <code>x</code>，它们的状态是各自独立的。</p><h4 id="实例4-闭包引用产生的问题"><a href="#实例4-闭包引用产生的问题" class="headerlink" title="实例4: 闭包引用产生的问题"></a>实例4: 闭包引用产生的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">f := func() &#123;</span><br><span class="line">println(x)</span><br><span class="line">&#125;</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br><span class="line">f() // 3</span><br></pre></td></tr></table></figure><p>因为闭包对外层词法域变量是引用的，所以这段代码会输出 3。<br>可以想象 f 中保存着 x 的地址，它使用 x 时会直接解引用，所以 x 的值改变了会导致 f 解引用得到的值也会改变。<br>但是，这段代码却会输出 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">println(x) // 1</span><br><span class="line">&#125;()</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br></pre></td></tr></table></figure><p>这是因为 f 调用时就已经解引用取值了，这之后的修改就与它无关了。</p><p>不过如果再次调用 f 还是会输出 3，这也再一次证明了 f 中保存着 x 的地址。<br>可以通过在闭包内外打印所引用变量的地址来证明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br><span class="line">&#125;()</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br></pre></td></tr></table></figure><p>可以看到引用的是同一个地址。</p><h4 id="实例5-1-循环闭包引用"><a href="#实例5-1-循环闭包引用" class="headerlink" title="实例5.1: 循环闭包引用"></a>实例5.1: 循环闭包引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">func() &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">f := func() &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次迭代后都对 i 进行了解引用并使用得到的值且不再使用，所以这段代码会正常输出。</p><h4 id="实例5-2"><a href="#实例5-2" class="headerlink" title="实例5.2"></a>实例5.2</h4><p>正常代码：输出 0, 1, 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这段代码会输出 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">var f func()</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">f = func() &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() // 3 这个地方i最后的值是3, 而不是2, 因为只有i的值是3时, 才会跳出循环</span><br></pre></td></tr></table></figure><h4 id="实例5-3"><a href="#实例5-3" class="headerlink" title="实例5.3"></a>实例5.3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">funcSlice[j]() // 3, 3, 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上面这种情况, 可以声明新的匿名函数并传参:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">func(k int) &#123;</span><br><span class="line">funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">println(k)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">funcSlice[j]() // 0, 1, 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>println(k)</code> 使用的 <code>k</code> 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。(把<code>k</code>换成<code>i</code>也没有问题, 即使它与for条件的中的<code>i</code> 和func的入参<code>i</code> 重名也能正常运行)</p><p>所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p><p>这里的解决方法可以用在大多数跟闭包引用有关的问题上，不局限于第三个例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数变量-函数值&quot;&gt;&lt;a href=&quot;#函数变量-函数值&quot; class=&quot;headerlink&quot; title=&quot;函数变量(函数值)&quot;&gt;&lt;/a&gt;函数变量(函数值)&lt;/h3&gt;&lt;p&gt;在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>合并区间56</title>
    <link href="https://lxb.wiki/a2b71d73/"/>
    <id>https://lxb.wiki/a2b71d73/</id>
    <published>2019-11-06T15:31:03.000Z</published>
    <updated>2019-11-06T16:00:13.168Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>思路: </p><ol start="0"><li>怎么判断重叠: 两区间的最小的右边界 大于或等于 两区间最大的左边界. 如<code>[1,5]</code>和<code>[2,8]</code></li><li>入参是切片的切片(intervals), 拿<code>intervals[0]</code>与它后面的所有区间对比, 从<code>intervals[1]</code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给<code>intervals[0]</code>, 并删除参与合并的那个旧区间</li><li><code>intervals[0]</code>完成后, 拿``intervals[1]<code>与它后边的所有区间对比, 从</code>intervals[2]<code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给</code>intervals[1]`, 并删除参与合并的那个就区间</li><li>拿<code>intervals[i]</code> 与它后边的所有区间对比, 从<code>intervals[i+1]</code> 开始, 如果有与之重叠的区间intervals[j]   , 就把合并后的新区间赋给 <code>intervals[i]</code> , 并删除参与合并的intervals[j]</li><li>如果第3步出现了有重叠的区间<code>intervals[j]</code>, 那么合并后<code>i</code>  的值变了, 就有可能由原来 在<code>i</code> 到<code>j</code> 之间没有重叠的区间 变成 有重叠的区间, 所以需要从头(<code>i+1</code>) 再遍历一次, 直到再也没有重叠的区间</li><li>重复, 一直到切片末尾</li></ol><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intervals); &#123;</span><br><span class="line">merged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(intervals); j++ &#123;</span><br><span class="line">x, y := intervals[i], intervals[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min(x[<span class="number">1</span>], y[<span class="number">1</span>]) &gt;= max(x[<span class="number">0</span>], y[<span class="number">0</span>]) &#123;</span><br><span class="line">merged = <span class="literal">true</span></span><br><span class="line"><span class="comment">//重新赋值</span></span><br><span class="line">intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] = min(x[<span class="number">0</span>], y[<span class="number">0</span>]), max(x[<span class="number">1</span>], y[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除j</span></span><br><span class="line">intervals[j] = intervals[<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">intervals = intervals[:<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merged &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang的反射</title>
    <link href="https://lxb.wiki/1d3c1f0e/"/>
    <id>https://lxb.wiki/1d3c1f0e/</id>
    <published>2019-11-03T13:21:59.000Z</published>
    <updated>2019-11-03T13:48:01.705Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编程语言中反射的概念"><a href="#编程语言中反射的概念" class="headerlink" title="编程语言中反射的概念"></a>编程语言中反射的概念</h4><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p><p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p><p>Golang的gRPC也是通过反射实现的。</p><h4 id="interface-和反射"><a href="#interface-和反射" class="headerlink" title="interface 和反射"></a>interface 和反射</h4><p>先来看看Golang关于类型设计的一些原则</p><ul><li>变量包括（value, type）两部分<ul><li>理解这一点就知道为什么nil != nil了</li></ul></li><li>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</li><li>类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</li></ul><p>反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><p><code>(value, type)</code></p><p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p><p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)</span><br><span class="line"></span><br><span class="line">var r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure><p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p><p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p><h4 id="reflect-基本功能TypeOf和ValueOf"><a href="#reflect-基本功能TypeOf和ValueOf" class="headerlink" title="reflect 基本功能TypeOf和ValueOf"></a>reflect 基本功能TypeOf和ValueOf</h4><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="line">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="line">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></pre></td></tr></table></figure><p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type: &quot;, reflect.TypeOf(num))</span><br><span class="line">fmt.Println(&quot;value: &quot;, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">type:  float64</span><br><span class="line">value:  1.2345</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li><li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li><li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li></ol><h4 id="从relfect-Value中获取接口interface的信息"><a href="#从relfect-Value中获取接口interface的信息" class="headerlink" title="从relfect.Value中获取接口interface的信息"></a>从relfect.Value中获取接口interface的信息</h4><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p><p><strong>已知原有类型【进行“强制转换”】</strong></p><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br><span class="line">// Golang 对类型要求非常严格，类型一定要完全符合</span><br><span class="line">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br><span class="line">convertPointer := pointer.Interface().(*float64)</span><br><span class="line">convertValue := value.Interface().(float64)</span><br><span class="line"></span><br><span class="line">fmt.Println(convertPointer)</span><br><span class="line">fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">0xc42000e238</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><ol><li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li><li>转换的时候，要区分是指针还是指</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li></ol><p><strong>未知原有类型【遍历探测其Filed】</strong></p><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFunc() &#123;</span><br><span class="line">fmt.Println(&quot;Allen.Wu ReflectCallFunc&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="line">func DoFiledAndMethod(input interface&#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(input)</span><br><span class="line">fmt.Println(&quot;get Type is :&quot;, getType.Name())</span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(input)</span><br><span class="line">fmt.Println(&quot;get all Fields is:&quot;, getValue)</span><br><span class="line"></span><br><span class="line">// 获取方法字段</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="line">// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="line">// 3. 最后通过Field的Interface()得到对应的value</span><br><span class="line">for i := 0; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(&quot;%s: %v = %v\n&quot;, field.Name, field.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br><span class="line">for i := 0; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(&quot;%s: %v\n&quot;, m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">get Type is : User</span><br><span class="line">get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="line">Id: int = 1</span><br><span class="line">Name: string = Allen.Wu</span><br><span class="line">Age: int = 25</span><br><span class="line">ReflectCallFunc: func(main.User)</span><br></pre></td></tr></table></figure><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.Value设置实际变量的值</strong></p><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var num float64 = 1.2345</span><br><span class="line">fmt.Println(&quot;old value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type of pointer:&quot;, newValue.Type())</span><br><span class="line">fmt.Println(&quot;settability of pointer:&quot;, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">// 重新赋值</span><br><span class="line">newValue.SetFloat(77)</span><br><span class="line">fmt.Println(&quot;new value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">////////////////////</span><br><span class="line">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br><span class="line">pointer = reflect.ValueOf(num)</span><br><span class="line">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: 1.2345</span><br><span class="line">type of pointer: float64</span><br><span class="line">settability of pointer: true</span><br><span class="line">new value of pointer: 77</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol><li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li><li>如果传入的参数不是指针，而是变量，那么<ul><li>通过Elem获取原始值对应的对象则直接panic</li><li>通过CanSet方法查询是否可以设置返回false</li></ul></li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.ValueOf来进行方法的调用</strong></p><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncHasArgs(name string, age int) &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncHasArgs name: &quot;, name, &quot;, age:&quot;, age, &quot;and origal User.Name:&quot;, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncNoArgs() &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何通过反射来进行方法的调用？</span><br><span class="line">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 2. 先看看带有参数的调用方法</span><br><span class="line">methodValue := getValue.MethodByName(&quot;ReflectCallFuncHasArgs&quot;)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(&quot;wudebao&quot;), reflect.ValueOf(30)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 3. 再看看无参数的调用方法</span><br><span class="line">methodValue = getValue.MethodByName(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">args = make([]reflect.Value, 0)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="line">ReflectCallFuncNoArgs</span><br></pre></td></tr></table></figure><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol><li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li><li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li><li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li><li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li><li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li></ol><p><strong>golang的反射reflect性能</strong></p><p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = clazz.getField(&quot;hello&quot;);</span><br><span class="line">field.get(obj1);</span><br><span class="line">field.get(obj2);</span><br></pre></td></tr></table></figure><p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。</p><p>但是Golang的反射不是这样设计的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.TypeOf(obj)</span><br><span class="line">field, _ := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.ValueOf(obj)</span><br><span class="line">fieldValue := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p><p>Golang reflect慢主要有两个原因</p><ol><li>涉及到内存分配以及后续的GC；</li><li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ul><li>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地<ul><li>反射必须结合interface才玩得转</li><li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li></ul></li><li>反射可以将“接口类型变量”转换为“反射类型对象”<ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul></li><li>反射可以将“反射类型对象”转换为“接口类型变量<ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历reflect.Type的Field获取其Field</li></ul></li><li>反射可以修改反射类型对象，但是其值必须是“addressable”<ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul></li><li>通过反射可以“动态”调用方法</li><li>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;编程语言中反射的概念&quot;&gt;&lt;a href=&quot;#编程语言中反射的概念&quot; class=&quot;headerlink&quot; title=&quot;编程语言中反射的概念&quot;&gt;&lt;/a&gt;编程语言中反射的概念&lt;/h4&gt;&lt;p&gt;在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>环形链表142</title>
    <link href="https://lxb.wiki/fb68a62c/"/>
    <id>https://lxb.wiki/fb68a62c/</id>
    <published>2019-10-30T16:09:51.000Z</published>
    <updated>2019-10-30T16:33:22.774Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p>解题关键是理解 <code>非环部分的长度</code>与<code>相遇点到环起点那部分环的长度</code> 是相等的 这个数学关系</p><p>假设非环部分长度为<code>x</code>, 从环起点到相遇点的长度为<code>y</code> , 环的长度为<code>c</code></p><p>慢指针(slow)走过的长度可以表示为``ds = x + n1 * c + y<code>, 快指针(fast) 的速度是慢指针的两倍, 意味着 快指针走过的长度为</code>df = 2(x + n1 * c + y)`</p><p>还有一个约束是, fast 走过的路程一定比slow走的路程多出环长度的整数倍(记为<code>n2 * c</code>)</p><p>所以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df - ds = n2 * c</span><br><span class="line">2(x + n1 * c + y) - (x + n1 * c + y) = n2 * c</span><br><span class="line">x + n1 * c + y = n2 * c</span><br></pre></td></tr></table></figure><p>解读下第三步的等式: 非环部分的长度 + 环起点到相遇点之间的长度 就是环的整数倍</p><p>意味着, 当以环的起点为原点时, 已经走过y(即前面<code>从环起点到相遇点的长度</code>)的前提下, 如果再走x , 就刚好走了很多圈(<code>n2 * c</code>). *”很多圈” 的意思, 就是从原点再到原点, 终点的位置和起点的位置重合.* </p><p>怎么才能再走x呢? 让一个指针从<code>head</code> 开始走, 另一个指针从相遇点开始走, 等这两个指针相遇, 就是走了x. 如果不能理解为何相遇恰好就在上面说的<strong>原点</strong>处, 应该反复琢磨斜体”很多圈”那句话</p><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">fast, slow := head, head</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="链表" scheme="https://lxb.wiki/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Github搜索</title>
    <link href="https://lxb.wiki/a813d59a/"/>
    <id>https://lxb.wiki/a813d59a/</id>
    <published>2019-10-28T15:03:30.000Z</published>
    <updated>2020-01-01T11:36:53.436Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 明确搜索仓库标题、仓库描述、README</strong></p><p><code>in:name 关键词</code></p><p>如果想查找描述的内容，可以使用这样的方式：</p><p><code>in:descripton 关键词</code></p><p>这里就是搜索上面项目描述的内容。</p><p>一般项目，都会有个README文件，如果要查该文件包含特定关键词的话</p><p><code>in:readme 关键词</code></p><p><strong>2. 明确搜索 star、fork 数大于多少的</strong></p><p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。</p><p><code>stars:&gt; 数字 关键字</code></p><p>比如要找 star 数大于 3000 的Spring Cloud 仓库，就可以这样</p><p><code>stars:&gt;3000 spring cloud</code></p><p>如果不加 &gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。</p><p>如果要找在指定数字区间的话，使用</p><p><code>stars: 10..20 关键词</code></p><p>fork 数同理，将上面的 stars 换成 <strong>fork</strong>，其它语法相同</p><p><strong>3. 明确搜索仓库大小的</strong></p><p>比如只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 <strong>size</strong> 。</p><p>使用方式：</p><p><code>size:&gt;=5000 关键词</code></p><p>这里注意下，这个数字代表K, 5000代表着5M。</p><p><strong>4. 明确仓库是否还在更新维护</strong></p><p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。</p><p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定<strong>更新时间</strong>在哪个时间前或后的</p><p>通过这样一条搜索 <code>pushed:&gt;2019-01-03 spring cloud</code></p><p>就找到了1月3号之后，还在更新的项目</p><p>想找指定时间之前或之后创建的仓库也是可以的，把 <strong>pushed</strong> 改成 <strong>created</strong> 就行。</p><p><strong>5. 明确搜索仓库的 LICENSE</strong></p><p>经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的<strong>LICENSE</strong>。开源不等于一切免费，不同的许可证要求也大不相同。 2018年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。</p><p>例如要找协议是最为宽松的 Apache License 2 的代码，可以这样</p><p><code>license:apache-2.0 spring cloud</code></p><p>其它协议就把 apache-2.0 替换一下即可，比如换成 <strong>mit</strong> 之类的。</p><p><strong>6. 明确搜索仓库的语言</strong></p><p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：</p><p><code>language:java 关键词</code></p><p><strong>7.明确搜索某个人或组织的仓库</strong></p><p><code>user:joshlong</code></p><p>组合使用一下，把 Java 项目过滤出来，多个查询之间「空格」分隔即可。</p><p><code>user:joshlong language:java</code></p><p>找某个组织的代码话，可以这样：</p><p><code>org:spring-cloud</code></p><p>就可以列出具体org 的仓库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. 明确搜索仓库标题、仓库描述、README&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:name 关键词&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想查找描述的内容，可以使用这样的方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:descripton 关键词&lt;/cod
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="github" scheme="https://lxb.wiki/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="https://lxb.wiki/6a0b412d/"/>
    <id>https://lxb.wiki/6a0b412d/</id>
    <published>2019-10-23T14:50:21.000Z</published>
    <updated>2019-10-30T16:10:24.866Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode-26</p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>理解题意:</p><pre><code>1. 当给定数组为空时, 返回0 2. 不能引入其他数组空间, 即不能再使用一个新的数组来存放结果 3. 最终结果不重复, 整体思路是把数组后面的几个元素挪到前面去, 用后面的元素覆盖掉前面重复了的元素, 保持数组的长度始终不变. 数组中超出新长度(去重后的长度) 后的元素无视</code></pre><p>用快慢指针的思路解答:</p><ol><li>给定两个游标 left和right</li><li>当给定数组的下标为left和right的值相等时,  就不管</li><li>当不相等时, 做一个操作: 把当前right的值赋给left的下一个坐标</li></ol><p>code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">    //如果是空切片，那就返回0</span><br><span class="line">    if len(nums) == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    //用两个标记来比较相邻位置的值</span><br><span class="line">    //当一样的话，那就不管继续</span><br><span class="line">    //当不一样的时候，就把right指向的值赋值给left下一位</span><br><span class="line">    left, right := 0, 1</span><br><span class="line">    for ; right &lt; len(nums); right++ &#123;</span><br><span class="line">        if nums[left] == nums[right] &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums[:left+1])</span><br><span class="line">    return left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode-26&lt;/p&gt;
&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://lxb.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang编译器漏洞和标准库设计失误</title>
    <link href="https://lxb.wiki/4fe063a2/"/>
    <id>https://lxb.wiki/4fe063a2/</id>
    <published>2019-10-20T03:29:37.000Z</published>
    <updated>2019-10-20T03:36:25.808Z</updated>
    
    <content type="html"><![CDATA[<p>字节切片（byte slice）相关的编译器漏洞和标准库设计失误</p><p>假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  x = []byte(y) // error: 非法的转换</span><br><span class="line">  y = []MyByte(x) // error: 非法的转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，在Go中，这两个类型的值之间的类型转换是非法的。因为Go规定两个切片只有在它们的类型的底层类型（underlying type）相同的情况下才能转换到对方的类型。而一个非定义类型（undefined type）的底层类型为此非定义类型本身。类型[]MyByte和[]byte均为非定义类型，所以它们的底层类型不同，从而它们的值也就不能转换到对方的类型。</p><p>难道真没有办法实现它们之间的转换了？有，而且有好几种。第一种方法是使用类型非安全指针来实现双向转换，另外两种方法只能实现单向转换。另外的这两种方法要么利用了编译器的漏洞，要么利用了reflect标准库包的设计失误。</p><p><strong>使用类型非安全指针的实现。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  p := unsafe.Pointer(&amp;y)</span><br><span class="line">  x = *(*[]byte)(p)</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用类型非安全指针的实现中，转换结果和原切片共享底层元素。</p><p><strong>利用标准编译器的bug</strong></p><p>我们可以将一个[]byte切片值转换为string, 再把string转换为类型[]MyByte。转换结果和原切片不共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go白皮书提到一个字节切片可以转换为一个字符串，反之亦然。但是什么是字节切片类型呢？底层类型为[]byte的切片类型还是元素类型的底层类型为byte的切片类型？如果字节切片类型定义为<strong>元素类型的底层类型为byte的切片类型</strong>，则[]MyByte和[]byte都可称为字节切片类型。如果字节切片类型定义为<strong>底层类型为[]byte的切片类型</strong>，则只有[]byte可以被称为字节切片类型。我们认为标准编译器采纳了<strong>底层类型为[]byte的切片类型才称为字节切片</strong>这一定义，因为下面这个程序使用标准编译器是编译不过的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">  _ = string(y) // error: 非法转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，标准编译器（v1.12）却认为转换[]MyByte(“abc”)是合法的。这显然是一个漏洞。</p><p>对于码点切片（rune slice）和字符串之间的转换，同样的情况也存在。</p><p>对于gccgo编译器来说，此漏洞是对称的，因而更严重。此更严重的漏洞使得上述两种类型的值之间的转换是双向有效的。比如，下面这段代码使用gccgo（v8.0）编译是没问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  x = []byte(string(y))</span><br><span class="line">  x[0] = 127</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，gccgo编译器在内置copy和append函数的实现中也存在着同样的漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  copy(y, string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = append([]MyByte(nil), string(x)...)</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法利用了<code>reflect</code>标准库包的设计失误。此失误导致将<code>[]MyByte</code>值单向转换为类型<code>[]byte</code>是可行的，虽然这违反了Go类型系统确定的规则。使用第三种方法得到的结果切片和原切片共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  v := reflect.ValueOf(y)</span><br><span class="line">  x = v.Bytes()</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字节切片（byte slice）相关的编译器漏洞和标准库设计失误&lt;/p&gt;
&lt;p&gt;假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="编译器" scheme="https://lxb.wiki/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁高并发优化</title>
    <link href="https://lxb.wiki/7db296fb/"/>
    <id>https://lxb.wiki/7db296fb/</id>
    <published>2019-10-18T14:38:39.000Z</published>
    <updated>2019-10-18T14:38:40.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景:"></a>问题场景:</h4><p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？</p><h4 id="库存超卖现象是怎么产生的？"><a href="#库存超卖现象是怎么产生的？" class="headerlink" title="库存超卖现象是怎么产生的？"></a>库存超卖现象是怎么产生的？</h4><p><img src="/images/kucunchaomai.png" alt="库存超卖"></p><p>假设订单系统部署两台机器上，不同的用户都要同时买10台iphone，分别发了一个请求给订单系统。<br>接着每个订单系统实例都去数据库里查了一下，当前iphone库存是12台<br>于是乎，每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台</p><h4 id="用分布式锁如何解决库存超卖问题？"><a href="#用分布式锁如何解决库存超卖问题？" class="headerlink" title="用分布式锁如何解决库存超卖问题？"></a>用分布式锁如何解决库存超卖问题？</h4><p>分布式锁的实现原理:<br>同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p><p><img src="/images/fenbushisuo_code.png" alt="分布式锁代码"></p><p><img src="/images/fenbushisuo_yuanli.png" alt="分布式锁原理"></p><p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</p><p>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的</p><h4 id="分布式锁的方案在高并发场景下"><a href="#分布式锁的方案在高并发场景下" class="headerlink" title="分布式锁的方案在高并发场景下"></a>分布式锁的方案在高并发场景下</h4><p>分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。</p><p>比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。</p><p>假设加锁之后，释放锁之前，查库存 -&gt; 创建订单 -&gt; 扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。</p><p>那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。</p><p>比如一秒钟来50个请求，都是对iphone下单的，那么每个请求处理20毫秒，一个一个来，最后1000毫秒正好处理完50个请求。</p><p><img src="/images/fenbushisuo_chuanxing.png" alt="分布式锁串行"></p><p>所以, 能看出来简单的使用分布式锁来处理库存超卖问题，存在的缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p><p>这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p><p>因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在一秒内瞬间下1000个订单，因为小电商系统没那场景。</p><h4 id="如何对分布式锁进行高并发优化？"><a href="#如何对分布式锁进行高并发优化？" class="headerlink" title="如何对分布式锁进行高并发优化？"></a>如何对分布式锁进行高并发优化？</h4><p>现在按照刚才的计算，你一秒钟只能处理针对iphone的50个订单。</p><p>其实说出来也很简单，相信很多人看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁！</p><p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。</p><p>另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p><p>LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p><p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p><p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p><p><img src="/images/fenbushisuo_fenduanjiasuo.png" alt="分段加锁"></p><p>其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。</p><p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p><p>接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p><p>这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&gt; 判断库存是否充足 -&gt; 扣减库存。</p><p>这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。</p><p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？</p><p>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现</p><h4 id="分布式锁并发优化方案有没有什么不足？"><a href="#分布式锁并发优化方案有没有什么不足？" class="headerlink" title="分布式锁并发优化方案有没有什么不足？"></a>分布式锁并发优化方案有没有什么不足？</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题场景&quot;&gt;&lt;a href=&quot;#问题场景&quot; class=&quot;headerlink&quot; title=&quot;问题场景:&quot;&gt;&lt;/a&gt;问题场景:&lt;/h4&gt;&lt;p&gt;假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？&lt;/p
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="redis" scheme="https://lxb.wiki/tags/redis/"/>
    
      <category term="优化" scheme="https://lxb.wiki/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="分布式" scheme="https://lxb.wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CentOS释放被占用端口</title>
    <link href="https://lxb.wiki/2d1cc7f9/"/>
    <id>https://lxb.wiki/2d1cc7f9/</id>
    <published>2019-10-09T16:36:59.000Z</published>
    <updated>2019-10-09T16:36:59.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>场景:</strong><br>在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错</p><p>1.输入netstat -tln,查看系统当前所有被占用端口,主要是为了查看你的端口是否真正的被占用着,搭建可以看到我的9001,和9002端口都已经被占用了,所以我需要释放这两个端口</p><p><img src="/images/listen-port.png" alt="listen-port"></p><p>2.根据端口查询进程,输入lsof -i :9001,切记不要忘了添加冒号,如下图,就可以看到当前被占用的端口的进程<br>的进程编号</p><p><img src="/images/lsof-port.png" alt></p><ol start="3"><li>kill 掉PID</li><li>再<code>netstat -tln</code> 确认下, 然后就可以起进程了 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt;&lt;br&gt;在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错&lt;/p&gt;
&lt;p&gt;1.输入netstat -tln,查看系统当前
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://lxb.wiki/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="端口" scheme="https://lxb.wiki/tags/%E7%AB%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>网易云音乐破版权</title>
    <link href="https://lxb.wiki/c6996379/"/>
    <id>https://lxb.wiki/c6996379/</id>
    <published>2019-10-08T10:07:13.000Z</published>
    <updated>2019-10-09T17:30:16.320Z</updated>
    
    <content type="html"><![CDATA[<p>源码地址: <a href="https://github.com/lxbwolf/UnblockNeteaseMusic" target="_blank" rel="noopener">https://github.com/lxbwolf/UnblockNeteaseMusic</a></p><p><strong>原理:</strong><br>使用其它音乐平台的歌曲替换网易云音乐无版权歌曲。<br>目前备用的平台有：网易云旧链 、QQ 、 虾米 、 百度 、酷狗 、酷我 、咕咪 、JOOX 音源替换变灰歌曲链接 (默认仅启用前四)。</p><p>1、打开网易云音乐客户端的时候，客户端不再直接访问网易云服务器而是访问UnblockNeteaseMusic服务。</p><p>2、UnblockNeteaseMusic收到客户端的请求后，透传给网易云音乐的服务器，并再拿到相关的数据后进行检查，如果发现其中的歌曲没有版权，那么去其它平台查询此歌曲的相关信息。</p><p>3、将查到的数据返回给网易云客户端。</p><p>4、至此完成网易云音乐的解锁。</p><p>整个流程要解决两个重要的问题。</p><p><strong>核心工作:</strong><br>1、将UnblockNeteaseMusic部署到服务器。可以是本地服务器也可以是云服务器。</p><p>2、为网易云客户端设置代理，以达到访问UnblockNeteaseMusic项目的目的。</p><p><strong>部署服务部分</strong></p><ol><li>安装node.js </li><li><code>git clone https://github.com/lxbwolf/UnblockNeteaseMusic.git</code></li><li>在<code>UnblockNeteaseMusic</code> 目录下, 执行<code>npx @nondanee/unblockneteasemusic(官方)</code> 或者 用docker 启动<code>docker run nondanee/unblockneteasemusic &amp;&amp; docker-compose up</code>, 还有另一种方式:<br>在<code>UnblockNeteaseMusic</code> 目录下, 执行<br><code>node app.js -p 8080:443 -f 59.111.160.195</code><br>其中<code>59.111.160.195</code> 这个地址是通过<br><code>ping music.163.com</code> 测出来的</li></ol><p>正常情况下, 服务端启动进程, 客户端配置好IP Port, 就可以用了, </p><p>此时服务端接收到请求会有log, 如果服务端log一直卡在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP Server running @ http://0.0.0.0:8080</span><br><span class="line">HTTPS Server running @ https://0.0.0.0:443</span><br></pre></td></tr></table></figure><p>说明客户端的请求并没有打到服务器上, 可能原因是8080和443端口还没有开启</p><p>配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ unblockneteasemusic -h</span><br><span class="line">usage: unblockneteasemusic [-v] [-p port] [-a address] [-u url] [-f host]</span><br><span class="line">                           [-o source [source ...]] [-t token] [-e url] [-s]</span><br><span class="line">                           [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -v, --version                   output the version number</span><br><span class="line">  -p port, --port port            specify server port</span><br><span class="line">  -a address, --address address   specify server host</span><br><span class="line">  -u url, --proxy-url url         request through upstream proxy</span><br><span class="line">  -f host, --force-host host      force the netease server ip</span><br><span class="line">  -o source [source ...], --match-order source [source ...]</span><br><span class="line">                                  set priority of sources</span><br><span class="line">  -t token, --token token         set up proxy authentication</span><br><span class="line">  -e url, --endpoint url          replace virtual endpoint with public host</span><br><span class="line">  -s, --strict                    enable proxy limitation</span><br><span class="line">  -h, --help                      output usage information</span><br></pre></td></tr></table></figure><p><strong>客户端配置</strong></p><p>源码中的<code>README</code> 有详细说明</p><table><thead><tr><th>平台</th><th>基础设置</th></tr></thead><tbody><tr><td>Windows</td><td>设置 &gt; 工具 &gt; 自定义代理 (客户端内)</td></tr><tr><td>UWP</td><td>Windows 设置 &gt; 网络和 Internet &gt; 代理</td></tr><tr><td>Linux</td><td>系统设置 &gt; 网络 &gt; 网络代理</td></tr><tr><td>macOS</td><td>系统偏好设置 &gt; 网络 &gt; 高级 &gt; 代理</td></tr><tr><td>Android</td><td>WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</td></tr><tr><td>iOS</td><td>无线局域网 &gt; HTTP 代理 &gt; 配置代理</td></tr></tbody></table><p><strong>Android 手机详细配置:</strong></p><p>设置 &gt; WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP: 106.13.86.198</span><br><span class="line">Port: 8080</span><br></pre></td></tr></table></figure><p><img src="/images/modify-network-android.png" alt></p><p><img src="/images/ip-port-163-android.png" alt></p><p>破解前效果<br><img src="/images/pojieqian-163.png" alt></p><p>破解后效果<br><img src="/images/pojiehou-163.png" alt><br><img src="/images/tingge-163.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码地址: &lt;a href=&quot;https://github.com/lxbwolf/UnblockNeteaseMusic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lxbwolf/UnblockNeteaseMu
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="破解" scheme="https://lxb.wiki/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Go闭包技术</title>
    <link href="https://lxb.wiki/eb01d7dc/"/>
    <id>https://lxb.wiki/eb01d7dc/</id>
    <published>2019-10-04T11:25:07.000Z</published>
    <updated>2019-10-04T11:25:07.539Z</updated>
    
    <content type="html"><![CDATA[<p>斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/B536914CD0194338915F9A7B18A754D7/1139" alt="fibonacci.png"></p><p>斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和.<br>为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 0 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">// a b</span><br><span class="line">// a b</span><br><span class="line">a, b := 0, 1</span><br></pre></td></tr></table></figure><p>初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    fmt.Print(a, &quot; &quot;)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        fmt.Print(a, &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacciByNormal(t *testing.T) &#123;</span><br><span class="line">    fibonacciByNormal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacci(t *testing.T) &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Print(f(), &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为”闭包”!</p><p>闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func autoIncrease() func() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        i = i + 1</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func TestAutoIncrease(t *testing.T) &#123;</span><br><span class="line">    a := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(a(), a(), a())</span><br><span class="line">    b := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(b(), b(), b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果.</p><p>普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生.</p><p>但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会”长生不老”,并不会因为出身于函数内就和普通变量拥有一样的短暂人生.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func fightWithHorse() func() int &#123;</span><br><span class="line">    horseShowTime := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        horseShowTime++</span><br><span class="line">        fmt.Printf(&quot;(%d)祖国需要我,我就提枪上马立即战斗!\n&quot;,horseShowTime)</span><br><span class="line">        return horseShowTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFightWithHorse(t *testing.T) &#123;</span><br><span class="line">    f := fightWithHorse()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心!<br>下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosure(t *testing.T) &#123;</span><br><span class="line">    // 4 4 4</span><br><span class="line">    for _, c := range countByClosureButWrong() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c.</p><p>当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4.<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/7BB3368DAC6A4AEB847EAB127682D486/1144" alt></p><p>原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了!<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/C4B872B0C6354133B321806B9AF02F85/1145" alt></p><p>长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4.</p><p>既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛!</p><p>最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        n := i</span><br><span class="line">        fmt.Printf(&quot;for i=%d n=%d \n&quot;, i,n)</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            fmt.Printf(&quot;append i=%d n=%d\n&quot;, i, n)</span><br><span class="line">            return n</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/957A722165B94E7785E0AB1DAE3B5B0C/1146" alt></p><p>上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级.</p><p>既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureWithOk() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;for i=%d \n&quot;, i)</span><br><span class="line">        func(n int) &#123;</span><br><span class="line">            arr = append(arr, func() int &#123;</span><br><span class="line">                fmt.Printf(&quot;append n=%d \n&quot;, n)</span><br><span class="line">                return n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosureWithOk(t *testing.T) &#123;</span><br><span class="line">    // 1 2 3</span><br><span class="line">    for _, c := range countByClosureWithOk() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模拟类和对象的关系,也可以实现封装,具备一定面向对象能力<ul><li>每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系.</li></ul></li><li>缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本.<ul><li>长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用.</li></ul></li><li>实现闭包成本较高,同时也增加了理解难度.<ul><li>普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性.</li></ul></li><li>滥用容易占用过多内存,可能造成内存泄漏.<ul><li>过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>github 博客绑定域名</title>
    <link href="https://lxb.wiki/e9fbcad9/"/>
    <id>https://lxb.wiki/e9fbcad9/</id>
    <published>2019-09-26T16:54:15.000Z</published>
    <updated>2019-10-03T16:52:39.427Z</updated>
    
    <content type="html"><![CDATA[<p>某篇文章说, CNAME 解析只支持 www 不支持@<br>所以@ 只能 解析到一个一个的 IP</p><h4 id="1-source-添加-CNAME-文件"><a href="#1-source-添加-CNAME-文件" class="headerlink" title="1. source 添加 CNAME 文件"></a>1. source 添加 CNAME 文件</h4><p>在源码的<code>source</code> 目录下, 添加一个<code>CNAME</code>文件<br>文件内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxb.wiki</span><br></pre></td></tr></table></figure><h4 id="2-DNS-设置"><a href="#2-DNS-设置" class="headerlink" title="2. DNS 设置"></a>2. DNS 设置</h4><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析路线(isp)</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>默认</td><td>lxbwolf.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.108.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.111.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.109.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr></tbody></table><h4 id="3-hexo-部署"><a href="#3-hexo-部署" class="headerlink" title="3. hexo 部署"></a>3. hexo 部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某篇文章说, CNAME 解析只支持 www 不支持@&lt;br&gt;所以@ 只能 解析到一个一个的 IP&lt;/p&gt;
&lt;h4 id=&quot;1-source-添加-CNAME-文件&quot;&gt;&lt;a href=&quot;#1-source-添加-CNAME-文件&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="博客" scheme="https://lxb.wiki/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://lxb.wiki/a1751c09/"/>
    <id>https://lxb.wiki/a1751c09/</id>
    <published>2019-09-26T16:14:22.211Z</published>
    <updated>2019-10-03T07:57:15.349Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xargs</title>
    <link href="https://lxb.wiki/38dfadad/"/>
    <id>https://lxb.wiki/38dfadad/</id>
    <published>2019-08-19T17:14:58.000Z</published>
    <updated>2019-10-03T07:57:15.416Z</updated>
    
    <content type="html"><![CDATA[<p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p><p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p><p>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p><p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p><p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p><p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /sbin -perm 700 |ls -l       #这个命令是错误的</span><br><span class="line">find /sbin -perm 700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure><p><strong>命令格式</strong><br><code>somecommand |xargs -item command</code></p><p><strong>重要参数:</strong></p><ul><li>-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</li></ul><p><strong>其他参数:</strong></p><ul><li>-a file 从文件中读入作为sdtin</li><li>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li><li>-p 当每次执行一个argument的时候询问一次用户。</li><li>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</li><li>-t 表示先打印命令，然后再执行。</li><li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</li><li>-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li><li>-L num 从标准输入一次读取 num 行送给 command 命令。</li><li>-l 同 -L。</li><li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li><li>-x exit的意思，主要是配合-s使用。。</li><li>-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h4><h5 id="1-多行变成单行"><a href="#1-多行变成单行" class="headerlink" title="1. 多行变成单行"></a>1. 多行变成单行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt</span><br><span class="line"></span><br><span class="line">a b c d e f g</span><br><span class="line">h i j k l m n</span><br><span class="line">o p q</span><br><span class="line">r s t</span><br><span class="line">u v w x y z</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt | xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure><h5 id="2-一次使用n个参数"><a href="#2-一次使用n个参数" class="headerlink" title="2. 一次使用n个参数"></a>2. 一次使用n个参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt | xargs -n3</span><br><span class="line"></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure><h5 id="3-d选项指定分隔符"><a href="#3-d选项指定分隔符" class="headerlink" title="3. d选项指定分隔符"></a>3. d选项指定分隔符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX</span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure><p>结合<code>-n</code> 选项使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span><br><span class="line"></span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure><h5 id="4-I选项的使用"><a href="#4-I选项的使用" class="headerlink" title="4. I选项的使用"></a>4. I选项的使用</h5><h6 id="4-1-获取参数并替换"><a href="#4-1-获取参数并替换" class="headerlink" title="4.1 获取参数并替换{}"></a>4.1 获取参数并替换<code>{}</code></h6><p>假设一个命令为 <a href="http://sk.sh/" target="_blank" rel="noopener">sk.sh</a> 和一个保存参数的文件 arg.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#sk.sh命令内容，打印出所有参数。</span><br><span class="line"></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><p>arg.txt.文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat arg.txt</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p><code>xargs</code> 的一个选项 <code>-I</code>，使用 <code>-I</code> 指定一个替换字符串 <code>{}</code>，这个字符串在 <code>xargs</code> 扩展时会被替换掉，当 <code>-I</code> 与 <code>xargs</code> 结合使用，每一个参数命令都会被执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat arg.txt | xargs -I &#123;&#125; ./sk.sh sombefore &#123;&#125; someafter</span><br><span class="line"></span><br><span class="line">sombefore aaa someafter</span><br><span class="line">sombefore bbb someafter</span><br><span class="line">sombefore ccc someafter</span><br></pre></td></tr></table></figure><h6 id="4-2-复制文件实例"><a href="#4-2-复制文件实例" class="headerlink" title="4.2 复制文件实例"></a>4.2 复制文件实例</h6><p>复制所有图片文件到 /data/images 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images/</span><br></pre></td></tr></table></figure><h6 id="4-3-xargs-结合find-使用"><a href="#4-3-xargs-结合find-使用" class="headerlink" title="4.3 xargs 结合find 使用"></a>4.3 xargs 结合find 使用</h6><p>用 rm 删除太多的文件时候，可能得到一个错误信息：<code>/bin/rm Argument list too long.</code> 用 xargs 去避免这个问题：</p><p><code>find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f</code> xargs -0 将 \0 作为定界符。</p><p>统计一个源代码目录中所有 php 文件的行数： <code>find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</code></p><p>查找所有的 jpg 文件，并且压缩它们： <code>find . -type f -name &quot;*.jpg&quot; -print | xargs tar -czvf images.tar.gz</code></p><h6 id="4-4-下载多个文件"><a href="#4-4-下载多个文件" class="headerlink" title="4.4 下载多个文件"></a>4.4 下载多个文件</h6><p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接： <code># cat url-list.txt | xargs wget -c</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。&lt;/p&gt;
&lt;p&gt;xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。&lt;/p&gt;
&lt;p&gt;xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行
      
    
    </summary>
    
    
      <category term="Shell" scheme="https://lxb.wiki/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>升级https</title>
    <link href="https://lxb.wiki/ddf7de45/"/>
    <id>https://lxb.wiki/ddf7de45/</id>
    <published>2019-08-07T18:53:34.000Z</published>
    <updated>2019-10-03T16:44:30.044Z</updated>
    
    <content type="html"><![CDATA[<p><em>环境</em></p><pre><code>CentOSnginx</code></pre><h3 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h3><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。 我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p><h4 id="1-安装-certbot"><a href="#1-安装-certbot" class="headerlink" title="1. 安装 certbot"></a>1. 安装 certbot</h4><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。</p><pre><code>yum install epel-releaseyum install certbot</code></pre><h4 id="2-生成证书"><a href="#2-生成证书" class="headerlink" title="2. 生成证书"></a>2. 生成证书</h4><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。</p><pre><code>certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</code></pre><p>webroot-path就是项目根路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p><ul><li>cert.pem: 服务端证书</li><li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li><li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li><li>privkey.pem: 证书私钥</li></ul><h4 id="3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）"><a href="#3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）" class="headerlink" title="3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）"></a>3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</h4><p>为了进一步提高安全性，也可以生成一个 Strong Diffie-Hellman Group。</p><pre><code>openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</code></pre><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。</p><pre><code>server {        listen 443 ssl;        # 启用http2        # 需要安装 Nginx Http2 Module        # listen 443 http2 ssl;        server_name my_server_name;        #证书文件        ssl_certificate /etc/letsencrypt/live/my_server_name/fullchain.pem;        #私钥文件        ssl_certificate_key /etc/letsencrypt/live/my_server_name/privkey.pem;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        # 优先采取服务器算法        ssl_prefer_server_ciphers on;        # 定义算法        ssl_ciphers &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&amp;quot;;        ssl_ecdh_curve secp384r1;        ssl_session_cache shared:SSL:10m;        ssl_session_tickets off;        ssl_stapling on;        ssl_stapling_verify on;        resolver 8.8.8.8 8.8.4.4 valid=300s;        resolver_timeout 5s;        add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;        add_header X-Frame-Options DENY;        add_header X-Content-Type-Options nosniff;        # 使用DH文件        ssl_dhparam /etc/ssl/certs/dhparam.pem;        location ~ /.well-known {            allow all;        }        location ~ \.php$ {            root           my_root;            fastcgi_pass   my_host:my_port;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            include        fastcgi_params;        }        root my_root;        index index.html index.php;        location / {            root my_root;            autoindex on;            index index.html index.php;            client_max_body_size 1024m;        }}</code></pre><p>其中的几项配置: <code>ssl_stapling on;</code> 开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。 <code>add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;</code> 启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接 <code>add_header X-Frame-Options DENY;</code> 添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少点击劫持 (clickjacking)攻击。 <code>add_header X-Content-Type-Options nosniff;</code> 添加 X-Content-Type-Options 响应头，防止 MIME 类型嗅探攻击 测试nginx.conf 是否有语法错误 <code>nginx -t</code> 重启nginx <code>nginx -s reload</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;环境&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CentOS
nginx&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取证书&quot;&gt;&lt;a href=&quot;#获取证书&quot; class=&quot;headerlink&quot; title=&quot;获取证书&quot;&gt;&lt;/a&gt;获取证书&lt;/h3&gt;&lt;p&gt;HTTPS 证
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="https" scheme="https://lxb.wiki/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>docker挂载目录失败/权限拒绝</title>
    <link href="https://lxb.wiki/498654c2/"/>
    <id>https://lxb.wiki/498654c2/</id>
    <published>2019-07-23T09:32:38.000Z</published>
    <updated>2019-10-03T07:57:15.287Z</updated>
    
    <content type="html"><![CDATA[<p>把宿主机的一个目录挂载到容器中的一个目录，当访问容器中的这个目录时，出现如下问题：<br> <code>ls: cannot open directory .: Permission denied</code><br>无法访问目录，权限拒绝。<br>该问题通常在centos7下出现。或者一个容器启动成功后，里面的服务无法成功访问，这是因为centos7中的安全模块selinux把权限禁掉了，一般的解决方案有以下两种：<br>（1）临时关闭selinux<br>直接在centos服务器上执行以下命令即可。执行完成以后建议重新<code>docker run</code>。 <code>setenforce 0</code><br>（2）给容器加权限<br>在<code>docker run</code>时给该容器加权限，加上以下参数即可：<br> <code>--privileged=true</code><br> 一般都推荐使用这种方式。<br> 按上述方法修改后, 如果执行下面命令失败<br> <code>docker run --name rookie-nginx-test -d -p 8082:80 -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx -v ~/nginx/conf/conf.d:/etc/nginx/conf.d --link php7-fpm:php nginx</code><br>则是因为<code>~/nginx/www/</code> 目录下没有index 文件导致. 手动创建<code>index.php</code> 文件解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把宿主机的一个目录挂载到容器中的一个目录，当访问容器中的这个目录时，出现如下问题：&lt;br&gt; &lt;code&gt;ls: cannot open directory .: Permission denied&lt;/code&gt;&lt;br&gt;无法访问目录，权限拒绝。&lt;br&gt;该问题通常在centos
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://lxb.wiki/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</title>
    <link href="https://lxb.wiki/784beb8f/"/>
    <id>https://lxb.wiki/784beb8f/</id>
    <published>2019-07-02T03:48:53.000Z</published>
    <updated>2019-10-03T16:55:28.088Z</updated>
    
    <content type="html"><![CDATA[<p>【报错原因】：没有utf-8这个语系（没添加语言_国名前缀），LC_ALL又没设定值。 <strong>服务端解决方法：</strong> 在远程系统上， <code>/etc/environment</code>加入以下两行，重新登陆即可。</p><pre><code>LANG=en_US.utf-8LC_ALL=en_US.utf-8</code></pre><p><strong>Mac终端解决方法：</strong> 编辑<code>~/.bashrc</code>或者<code>~/.zshrc</code>文件，添加</p><pre><code>export LC_ALL=en_US.UTF-8  export LANG=en_US.UTF-8</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【报错原因】：没有utf-8这个语系（没添加语言_国名前缀），LC_ALL又没设定值。 &lt;strong&gt;服务端解决方法：&lt;/strong&gt; 在远程系统上， &lt;code&gt;/etc/environment&lt;/code&gt;加入以下两行，重新登陆即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="iTerm2" scheme="https://lxb.wiki/tags/iTerm2/"/>
    
  </entry>
  
</feed>
