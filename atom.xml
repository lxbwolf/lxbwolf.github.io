<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxb.wiki/"/>
  <updated>2019-11-06T16:00:13.168Z</updated>
  <id>https://lxb.wiki/</id>
  
  <author>
    <name>Brooke Lau</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合并区间56</title>
    <link href="https://lxb.wiki/a2b71d73/"/>
    <id>https://lxb.wiki/a2b71d73/</id>
    <published>2019-11-06T15:31:03.000Z</published>
    <updated>2019-11-06T16:00:13.168Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>思路: </p><ol start="0"><li>怎么判断重叠: 两区间的最小的右边界 大于或等于 两区间最大的左边界. 如<code>[1,5]</code>和<code>[2,8]</code></li><li>入参是切片的切片(intervals), 拿<code>intervals[0]</code>与它后面的所有区间对比, 从<code>intervals[1]</code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给<code>intervals[0]</code>, 并删除参与合并的那个旧区间</li><li><code>intervals[0]</code>完成后, 拿``intervals[1]<code>与它后边的所有区间对比, 从</code>intervals[2]<code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给</code>intervals[1]`, 并删除参与合并的那个就区间</li><li>拿<code>intervals[i]</code> 与它后边的所有区间对比, 从<code>intervals[i+1]</code> 开始, 如果有与之重叠的区间intervals[j]   , 就把合并后的新区间赋给 <code>intervals[i]</code> , 并删除参与合并的intervals[j]</li><li>如果第3步出现了有重叠的区间<code>intervals[j]</code>, 那么合并后<code>i</code>  的值变了, 就有可能由原来 在<code>i</code> 到<code>j</code> 之间没有重叠的区间 变成 有重叠的区间, 所以需要从头(<code>i+1</code>) 再遍历一次, 直到再也没有重叠的区间</li><li>重复, 一直到切片末尾</li></ol><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intervals); &#123;</span><br><span class="line">merged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(intervals); j++ &#123;</span><br><span class="line">x, y := intervals[i], intervals[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min(x[<span class="number">1</span>], y[<span class="number">1</span>]) &gt;= max(x[<span class="number">0</span>], y[<span class="number">0</span>]) &#123;</span><br><span class="line">merged = <span class="literal">true</span></span><br><span class="line"><span class="comment">//重新赋值</span></span><br><span class="line">intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] = min(x[<span class="number">0</span>], y[<span class="number">0</span>]), max(x[<span class="number">1</span>], y[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除j</span></span><br><span class="line">intervals[j] = intervals[<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">intervals = intervals[:<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merged &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang的反射</title>
    <link href="https://lxb.wiki/1d3c1f0e/"/>
    <id>https://lxb.wiki/1d3c1f0e/</id>
    <published>2019-11-03T13:21:59.000Z</published>
    <updated>2019-11-03T13:48:01.705Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编程语言中反射的概念"><a href="#编程语言中反射的概念" class="headerlink" title="编程语言中反射的概念"></a>编程语言中反射的概念</h4><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p><p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p><p>Golang的gRPC也是通过反射实现的。</p><h4 id="interface-和反射"><a href="#interface-和反射" class="headerlink" title="interface 和反射"></a>interface 和反射</h4><p>先来看看Golang关于类型设计的一些原则</p><ul><li>变量包括（value, type）两部分<ul><li>理解这一点就知道为什么nil != nil了</li></ul></li><li>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</li><li>类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</li></ul><p>反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><p><code>(value, type)</code></p><p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p><p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)</span><br><span class="line"></span><br><span class="line">var r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure><p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p><p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p><h4 id="reflect-基本功能TypeOf和ValueOf"><a href="#reflect-基本功能TypeOf和ValueOf" class="headerlink" title="reflect 基本功能TypeOf和ValueOf"></a>reflect 基本功能TypeOf和ValueOf</h4><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="line">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="line">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></pre></td></tr></table></figure><p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type: &quot;, reflect.TypeOf(num))</span><br><span class="line">fmt.Println(&quot;value: &quot;, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">type:  float64</span><br><span class="line">value:  1.2345</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li><li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li><li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li></ol><h4 id="从relfect-Value中获取接口interface的信息"><a href="#从relfect-Value中获取接口interface的信息" class="headerlink" title="从relfect.Value中获取接口interface的信息"></a>从relfect.Value中获取接口interface的信息</h4><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p><p><strong>已知原有类型【进行“强制转换”】</strong></p><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br><span class="line">// Golang 对类型要求非常严格，类型一定要完全符合</span><br><span class="line">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br><span class="line">convertPointer := pointer.Interface().(*float64)</span><br><span class="line">convertValue := value.Interface().(float64)</span><br><span class="line"></span><br><span class="line">fmt.Println(convertPointer)</span><br><span class="line">fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">0xc42000e238</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><ol><li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li><li>转换的时候，要区分是指针还是指</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li></ol><p><strong>未知原有类型【遍历探测其Filed】</strong></p><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFunc() &#123;</span><br><span class="line">fmt.Println(&quot;Allen.Wu ReflectCallFunc&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="line">func DoFiledAndMethod(input interface&#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(input)</span><br><span class="line">fmt.Println(&quot;get Type is :&quot;, getType.Name())</span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(input)</span><br><span class="line">fmt.Println(&quot;get all Fields is:&quot;, getValue)</span><br><span class="line"></span><br><span class="line">// 获取方法字段</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="line">// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="line">// 3. 最后通过Field的Interface()得到对应的value</span><br><span class="line">for i := 0; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(&quot;%s: %v = %v\n&quot;, field.Name, field.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br><span class="line">for i := 0; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(&quot;%s: %v\n&quot;, m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">get Type is : User</span><br><span class="line">get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="line">Id: int = 1</span><br><span class="line">Name: string = Allen.Wu</span><br><span class="line">Age: int = 25</span><br><span class="line">ReflectCallFunc: func(main.User)</span><br></pre></td></tr></table></figure><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.Value设置实际变量的值</strong></p><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var num float64 = 1.2345</span><br><span class="line">fmt.Println(&quot;old value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type of pointer:&quot;, newValue.Type())</span><br><span class="line">fmt.Println(&quot;settability of pointer:&quot;, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">// 重新赋值</span><br><span class="line">newValue.SetFloat(77)</span><br><span class="line">fmt.Println(&quot;new value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">////////////////////</span><br><span class="line">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br><span class="line">pointer = reflect.ValueOf(num)</span><br><span class="line">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: 1.2345</span><br><span class="line">type of pointer: float64</span><br><span class="line">settability of pointer: true</span><br><span class="line">new value of pointer: 77</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol><li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li><li>如果传入的参数不是指针，而是变量，那么<ul><li>通过Elem获取原始值对应的对象则直接panic</li><li>通过CanSet方法查询是否可以设置返回false</li></ul></li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.ValueOf来进行方法的调用</strong></p><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncHasArgs(name string, age int) &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncHasArgs name: &quot;, name, &quot;, age:&quot;, age, &quot;and origal User.Name:&quot;, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncNoArgs() &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何通过反射来进行方法的调用？</span><br><span class="line">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 2. 先看看带有参数的调用方法</span><br><span class="line">methodValue := getValue.MethodByName(&quot;ReflectCallFuncHasArgs&quot;)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(&quot;wudebao&quot;), reflect.ValueOf(30)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 3. 再看看无参数的调用方法</span><br><span class="line">methodValue = getValue.MethodByName(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">args = make([]reflect.Value, 0)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="line">ReflectCallFuncNoArgs</span><br></pre></td></tr></table></figure><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol><li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li><li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li><li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li><li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li><li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li></ol><p><strong>golang的反射reflect性能</strong></p><p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = clazz.getField(&quot;hello&quot;);</span><br><span class="line">field.get(obj1);</span><br><span class="line">field.get(obj2);</span><br></pre></td></tr></table></figure><p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。</p><p>但是Golang的反射不是这样设计的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.TypeOf(obj)</span><br><span class="line">field, _ := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.ValueOf(obj)</span><br><span class="line">fieldValue := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p><p>Golang reflect慢主要有两个原因</p><ol><li>涉及到内存分配以及后续的GC；</li><li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ul><li>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地<ul><li>反射必须结合interface才玩得转</li><li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li></ul></li><li>反射可以将“接口类型变量”转换为“反射类型对象”<ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul></li><li>反射可以将“反射类型对象”转换为“接口类型变量<ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历reflect.Type的Field获取其Field</li></ul></li><li>反射可以修改反射类型对象，但是其值必须是“addressable”<ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul></li><li>通过反射可以“动态”调用方法</li><li>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;编程语言中反射的概念&quot;&gt;&lt;a href=&quot;#编程语言中反射的概念&quot; class=&quot;headerlink&quot; title=&quot;编程语言中反射的概念&quot;&gt;&lt;/a&gt;编程语言中反射的概念&lt;/h4&gt;&lt;p&gt;在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>环形链表142</title>
    <link href="https://lxb.wiki/fb68a62c/"/>
    <id>https://lxb.wiki/fb68a62c/</id>
    <published>2019-10-30T16:09:51.000Z</published>
    <updated>2019-10-30T16:33:22.774Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p>解题关键是理解 <code>非环部分的长度</code>与<code>相遇点到环起点那部分环的长度</code> 是相等的 这个数学关系</p><p>假设非环部分长度为<code>x</code>, 从环起点到相遇点的长度为<code>y</code> , 环的长度为<code>c</code></p><p>慢指针(slow)走过的长度可以表示为``ds = x + n1 * c + y<code>, 快指针(fast) 的速度是慢指针的两倍, 意味着 快指针走过的长度为</code>df = 2(x + n1 * c + y)`</p><p>还有一个约束是, fast 走过的路程一定比slow走的路程多出环长度的整数倍(记为<code>n2 * c</code>)</p><p>所以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df - ds = n2 * c</span><br><span class="line">2(x + n1 * c + y) - (x + n1 * c + y) = n2 * c</span><br><span class="line">x + n1 * c + y = n2 * c</span><br></pre></td></tr></table></figure><p>解读下第三步的等式: 非环部分的长度 + 环起点到相遇点之间的长度 就是环的整数倍</p><p>意味着, 当以环的起点为原点时, 已经走过y(即前面<code>从环起点到相遇点的长度</code>)的前提下, 如果再走x , 就刚好走了很多圈(<code>n2 * c</code>). *”很多圈” 的意思, 就是从原点再到原点, 终点的位置和起点的位置重合.* </p><p>怎么才能再走x呢? 让一个指针从<code>head</code> 开始走, 另一个指针从相遇点开始走, 等这两个指针相遇, 就是走了x. 如果不能理解为何相遇恰好就在上面说的<strong>原点</strong>处, 应该反复琢磨斜体”很多圈”那句话</p><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">fast, slow := head, head</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="链表" scheme="https://lxb.wiki/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>如果使用Github搜索</title>
    <link href="https://lxb.wiki/a813d59a/"/>
    <id>https://lxb.wiki/a813d59a/</id>
    <published>2019-10-28T15:03:30.000Z</published>
    <updated>2019-10-28T15:09:12.123Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 明确搜索仓库标题、仓库描述、README</strong></p><p><code>in:name 关键词</code></p><p>如果想查找描述的内容，可以使用这样的方式：</p><p><code>in:descripton 关键词</code></p><p>这里就是搜索上面项目描述的内容。</p><p>一般项目，都会有个README文件，如果要查该文件包含特定关键词的话</p><p><code>in:readme 关键词</code></p><p><strong>2. 明确搜索 star、fork 数大于多少的</strong></p><p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。</p><p><code>stars:&gt; 数字 关键字</code></p><p>比如要找 star 数大于 3000 的Spring Cloud 仓库，就可以这样</p><p><code>stars:&gt;3000 spring cloud</code></p><p>如果不加 &gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。</p><p>如果要找在指定数字区间的话，使用</p><p><code>stars: 10..20 关键词</code></p><p>fork 数同理，将上面的 stars 换成 <strong>fork</strong>，其它语法相同</p><p><strong>3. 明确搜索仓库大小的</strong></p><p>比如只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 <strong>size</strong> 。</p><p>使用方式：</p><p><code>size:&gt;=5000 关键词</code></p><p>这里注意下，这个数字代表K, 5000代表着5M。</p><p><strong>4. 明确仓库是否还在更新维护</strong></p><p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。</p><p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定<strong>更新时间</strong>在哪个时间前或后的</p><p>通过这样一条搜索 <code>pushed:&gt;2019-01-03 spring cloud</code></p><p>就找到了1月3号之后，还在更新的项目</p><p>想找指定时间之前或之后创建的仓库也是可以的，把 <strong>pushed</strong> 改成 <strong>created</strong> 就行。</p><p><strong>5. 明确搜索仓库的 LICENSE</strong></p><p>经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的<strong>LICENSE</strong>。开源不等于一切免费，不同的许可证要求也大不相同。 2018年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。</p><p>例如要找协议是最为宽松的 Apache License 2 的代码，可以这样</p><p><code>license:apache-2.0 spring cloud</code></p><p>其它协议就把 apache-2.0 替换一下即可，比如换成 <strong>mit</strong> 之类的。</p><p><strong>6. 明确搜索仓库的语言</strong></p><p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：</p><p><code>language:java 关键词</code></p><p><strong>7.明确搜索某个人或组织的仓库</strong></p><p><code>user:joshlong</code></p><p>组合使用一下，把 Java 项目过滤出来，多个查询之间「空格」分隔即可。</p><p><code>user:joshlong language:java</code></p><p>找某个组织的代码话，可以这样：</p><p><code>org:spring-cloud</code></p><p>就可以列出具体org 的仓库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. 明确搜索仓库标题、仓库描述、README&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:name 关键词&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想查找描述的内容，可以使用这样的方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:descripton 关键词&lt;/cod
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="github" scheme="https://lxb.wiki/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="https://lxb.wiki/6a0b412d/"/>
    <id>https://lxb.wiki/6a0b412d/</id>
    <published>2019-10-23T14:50:21.000Z</published>
    <updated>2019-10-30T16:10:24.866Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode-26</p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>理解题意:</p><pre><code>1. 当给定数组为空时, 返回0 2. 不能引入其他数组空间, 即不能再使用一个新的数组来存放结果 3. 最终结果不重复, 整体思路是把数组后面的几个元素挪到前面去, 用后面的元素覆盖掉前面重复了的元素, 保持数组的长度始终不变. 数组中超出新长度(去重后的长度) 后的元素无视</code></pre><p>用快慢指针的思路解答:</p><ol><li>给定两个游标 left和right</li><li>当给定数组的下标为left和right的值相等时,  就不管</li><li>当不相等时, 做一个操作: 把当前right的值赋给left的下一个坐标</li></ol><p>code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">    //如果是空切片，那就返回0</span><br><span class="line">    if len(nums) == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    //用两个标记来比较相邻位置的值</span><br><span class="line">    //当一样的话，那就不管继续</span><br><span class="line">    //当不一样的时候，就把right指向的值赋值给left下一位</span><br><span class="line">    left, right := 0, 1</span><br><span class="line">    for ; right &lt; len(nums); right++ &#123;</span><br><span class="line">        if nums[left] == nums[right] &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums[:left+1])</span><br><span class="line">    return left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode-26&lt;/p&gt;
&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://lxb.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang编译器漏洞和标准库设计失误</title>
    <link href="https://lxb.wiki/4fe063a2/"/>
    <id>https://lxb.wiki/4fe063a2/</id>
    <published>2019-10-20T03:29:37.000Z</published>
    <updated>2019-10-20T03:36:25.808Z</updated>
    
    <content type="html"><![CDATA[<p>字节切片（byte slice）相关的编译器漏洞和标准库设计失误</p><p>假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  x = []byte(y) // error: 非法的转换</span><br><span class="line">  y = []MyByte(x) // error: 非法的转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，在Go中，这两个类型的值之间的类型转换是非法的。因为Go规定两个切片只有在它们的类型的底层类型（underlying type）相同的情况下才能转换到对方的类型。而一个非定义类型（undefined type）的底层类型为此非定义类型本身。类型[]MyByte和[]byte均为非定义类型，所以它们的底层类型不同，从而它们的值也就不能转换到对方的类型。</p><p>难道真没有办法实现它们之间的转换了？有，而且有好几种。第一种方法是使用类型非安全指针来实现双向转换，另外两种方法只能实现单向转换。另外的这两种方法要么利用了编译器的漏洞，要么利用了reflect标准库包的设计失误。</p><p><strong>使用类型非安全指针的实现。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  p := unsafe.Pointer(&amp;y)</span><br><span class="line">  x = *(*[]byte)(p)</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用类型非安全指针的实现中，转换结果和原切片共享底层元素。</p><p><strong>利用标准编译器的bug</strong></p><p>我们可以将一个[]byte切片值转换为string, 再把string转换为类型[]MyByte。转换结果和原切片不共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go白皮书提到一个字节切片可以转换为一个字符串，反之亦然。但是什么是字节切片类型呢？底层类型为[]byte的切片类型还是元素类型的底层类型为byte的切片类型？如果字节切片类型定义为<strong>元素类型的底层类型为byte的切片类型</strong>，则[]MyByte和[]byte都可称为字节切片类型。如果字节切片类型定义为<strong>底层类型为[]byte的切片类型</strong>，则只有[]byte可以被称为字节切片类型。我们认为标准编译器采纳了<strong>底层类型为[]byte的切片类型才称为字节切片</strong>这一定义，因为下面这个程序使用标准编译器是编译不过的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">  _ = string(y) // error: 非法转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，标准编译器（v1.12）却认为转换[]MyByte(“abc”)是合法的。这显然是一个漏洞。</p><p>对于码点切片（rune slice）和字符串之间的转换，同样的情况也存在。</p><p>对于gccgo编译器来说，此漏洞是对称的，因而更严重。此更严重的漏洞使得上述两种类型的值之间的转换是双向有效的。比如，下面这段代码使用gccgo（v8.0）编译是没问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  x = []byte(string(y))</span><br><span class="line">  x[0] = 127</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，gccgo编译器在内置copy和append函数的实现中也存在着同样的漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  copy(y, string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = append([]MyByte(nil), string(x)...)</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法利用了<code>reflect</code>标准库包的设计失误。此失误导致将<code>[]MyByte</code>值单向转换为类型<code>[]byte</code>是可行的，虽然这违反了Go类型系统确定的规则。使用第三种方法得到的结果切片和原切片共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  v := reflect.ValueOf(y)</span><br><span class="line">  x = v.Bytes()</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字节切片（byte slice）相关的编译器漏洞和标准库设计失误&lt;/p&gt;
&lt;p&gt;假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="编译器" scheme="https://lxb.wiki/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁高并发优化</title>
    <link href="https://lxb.wiki/7db296fb/"/>
    <id>https://lxb.wiki/7db296fb/</id>
    <published>2019-10-18T14:38:39.000Z</published>
    <updated>2019-10-18T14:38:40.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景:"></a>问题场景:</h4><p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？</p><h4 id="库存超卖现象是怎么产生的？"><a href="#库存超卖现象是怎么产生的？" class="headerlink" title="库存超卖现象是怎么产生的？"></a>库存超卖现象是怎么产生的？</h4><p><img src="/images/kucunchaomai.png" alt="库存超卖"></p><p>假设订单系统部署两台机器上，不同的用户都要同时买10台iphone，分别发了一个请求给订单系统。<br>接着每个订单系统实例都去数据库里查了一下，当前iphone库存是12台<br>于是乎，每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台</p><h4 id="用分布式锁如何解决库存超卖问题？"><a href="#用分布式锁如何解决库存超卖问题？" class="headerlink" title="用分布式锁如何解决库存超卖问题？"></a>用分布式锁如何解决库存超卖问题？</h4><p>分布式锁的实现原理:<br>同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p><p><img src="/images/fenbushisuo_code.png" alt="分布式锁代码"></p><p><img src="/images/fenbushisuo_yuanli.png" alt="分布式锁原理"></p><p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</p><p>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的</p><h4 id="分布式锁的方案在高并发场景下"><a href="#分布式锁的方案在高并发场景下" class="headerlink" title="分布式锁的方案在高并发场景下"></a>分布式锁的方案在高并发场景下</h4><p>分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。</p><p>比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。</p><p>假设加锁之后，释放锁之前，查库存 -&gt; 创建订单 -&gt; 扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。</p><p>那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。</p><p>比如一秒钟来50个请求，都是对iphone下单的，那么每个请求处理20毫秒，一个一个来，最后1000毫秒正好处理完50个请求。</p><p><img src="/images/fenbushisuo_chuanxing.png" alt="分布式锁串行"></p><p>所以, 能看出来简单的使用分布式锁来处理库存超卖问题，存在的缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p><p>这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p><p>因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在一秒内瞬间下1000个订单，因为小电商系统没那场景。</p><h4 id="如何对分布式锁进行高并发优化？"><a href="#如何对分布式锁进行高并发优化？" class="headerlink" title="如何对分布式锁进行高并发优化？"></a>如何对分布式锁进行高并发优化？</h4><p>现在按照刚才的计算，你一秒钟只能处理针对iphone的50个订单。</p><p>其实说出来也很简单，相信很多人看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁！</p><p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。</p><p>另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p><p>LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p><p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p><p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p><p><img src="/images/fenbushisuo_fenduanjiasuo.png" alt="分段加锁"></p><p>其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。</p><p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p><p>接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p><p>这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&gt; 判断库存是否充足 -&gt; 扣减库存。</p><p>这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。</p><p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？</p><p>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现</p><h4 id="分布式锁并发优化方案有没有什么不足？"><a href="#分布式锁并发优化方案有没有什么不足？" class="headerlink" title="分布式锁并发优化方案有没有什么不足？"></a>分布式锁并发优化方案有没有什么不足？</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题场景&quot;&gt;&lt;a href=&quot;#问题场景&quot; class=&quot;headerlink&quot; title=&quot;问题场景:&quot;&gt;&lt;/a&gt;问题场景:&lt;/h4&gt;&lt;p&gt;假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？&lt;/p
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="redis" scheme="https://lxb.wiki/tags/redis/"/>
    
      <category term="优化" scheme="https://lxb.wiki/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="分布式" scheme="https://lxb.wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CentOS释放被占用端口</title>
    <link href="https://lxb.wiki/2d1cc7f9/"/>
    <id>https://lxb.wiki/2d1cc7f9/</id>
    <published>2019-10-09T16:36:59.000Z</published>
    <updated>2019-10-09T16:36:59.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>场景:</strong><br>在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错</p><p>1.输入netstat -tln,查看系统当前所有被占用端口,主要是为了查看你的端口是否真正的被占用着,搭建可以看到我的9001,和9002端口都已经被占用了,所以我需要释放这两个端口</p><p><img src="/images/listen-port.png" alt="listen-port"></p><p>2.根据端口查询进程,输入lsof -i :9001,切记不要忘了添加冒号,如下图,就可以看到当前被占用的端口的进程<br>的进程编号</p><p><img src="/images/lsof-port.png" alt></p><ol start="3"><li>kill 掉PID</li><li>再<code>netstat -tln</code> 确认下, 然后就可以起进程了 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt;&lt;br&gt;在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错&lt;/p&gt;
&lt;p&gt;1.输入netstat -tln,查看系统当前
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://lxb.wiki/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="端口" scheme="https://lxb.wiki/tags/%E7%AB%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>网易云音乐破版权</title>
    <link href="https://lxb.wiki/c6996379/"/>
    <id>https://lxb.wiki/c6996379/</id>
    <published>2019-10-08T10:07:13.000Z</published>
    <updated>2019-10-09T17:30:16.320Z</updated>
    
    <content type="html"><![CDATA[<p>源码地址: <a href="https://github.com/lxbwolf/UnblockNeteaseMusic" target="_blank" rel="noopener">https://github.com/lxbwolf/UnblockNeteaseMusic</a></p><p><strong>原理:</strong><br>使用其它音乐平台的歌曲替换网易云音乐无版权歌曲。<br>目前备用的平台有：网易云旧链 、QQ 、 虾米 、 百度 、酷狗 、酷我 、咕咪 、JOOX 音源替换变灰歌曲链接 (默认仅启用前四)。</p><p>1、打开网易云音乐客户端的时候，客户端不再直接访问网易云服务器而是访问UnblockNeteaseMusic服务。</p><p>2、UnblockNeteaseMusic收到客户端的请求后，透传给网易云音乐的服务器，并再拿到相关的数据后进行检查，如果发现其中的歌曲没有版权，那么去其它平台查询此歌曲的相关信息。</p><p>3、将查到的数据返回给网易云客户端。</p><p>4、至此完成网易云音乐的解锁。</p><p>整个流程要解决两个重要的问题。</p><p><strong>核心工作:</strong><br>1、将UnblockNeteaseMusic部署到服务器。可以是本地服务器也可以是云服务器。</p><p>2、为网易云客户端设置代理，以达到访问UnblockNeteaseMusic项目的目的。</p><p><strong>部署服务部分</strong></p><ol><li>安装node.js </li><li><code>git clone https://github.com/lxbwolf/UnblockNeteaseMusic.git</code></li><li>在<code>UnblockNeteaseMusic</code> 目录下, 执行<code>npx @nondanee/unblockneteasemusic(官方)</code> 或者 用docker 启动<code>docker run nondanee/unblockneteasemusic &amp;&amp; docker-compose up</code>, 还有另一种方式:<br>在<code>UnblockNeteaseMusic</code> 目录下, 执行<br><code>node app.js -p 8080:443 -f 59.111.160.195</code><br>其中<code>59.111.160.195</code> 这个地址是通过<br><code>ping music.163.com</code> 测出来的</li></ol><p>正常情况下, 服务端启动进程, 客户端配置好IP Port, 就可以用了, </p><p>此时服务端接收到请求会有log, 如果服务端log一直卡在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP Server running @ http://0.0.0.0:8080</span><br><span class="line">HTTPS Server running @ https://0.0.0.0:443</span><br></pre></td></tr></table></figure><p>说明客户端的请求并没有打到服务器上, 可能原因是8080和443端口还没有开启</p><p>配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ unblockneteasemusic -h</span><br><span class="line">usage: unblockneteasemusic [-v] [-p port] [-a address] [-u url] [-f host]</span><br><span class="line">                           [-o source [source ...]] [-t token] [-e url] [-s]</span><br><span class="line">                           [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -v, --version                   output the version number</span><br><span class="line">  -p port, --port port            specify server port</span><br><span class="line">  -a address, --address address   specify server host</span><br><span class="line">  -u url, --proxy-url url         request through upstream proxy</span><br><span class="line">  -f host, --force-host host      force the netease server ip</span><br><span class="line">  -o source [source ...], --match-order source [source ...]</span><br><span class="line">                                  set priority of sources</span><br><span class="line">  -t token, --token token         set up proxy authentication</span><br><span class="line">  -e url, --endpoint url          replace virtual endpoint with public host</span><br><span class="line">  -s, --strict                    enable proxy limitation</span><br><span class="line">  -h, --help                      output usage information</span><br></pre></td></tr></table></figure><p><strong>客户端配置</strong></p><p>源码中的<code>README</code> 有详细说明</p><table><thead><tr><th>平台</th><th>基础设置</th></tr></thead><tbody><tr><td>Windows</td><td>设置 &gt; 工具 &gt; 自定义代理 (客户端内)</td></tr><tr><td>UWP</td><td>Windows 设置 &gt; 网络和 Internet &gt; 代理</td></tr><tr><td>Linux</td><td>系统设置 &gt; 网络 &gt; 网络代理</td></tr><tr><td>macOS</td><td>系统偏好设置 &gt; 网络 &gt; 高级 &gt; 代理</td></tr><tr><td>Android</td><td>WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</td></tr><tr><td>iOS</td><td>无线局域网 &gt; HTTP 代理 &gt; 配置代理</td></tr></tbody></table><p><strong>Android 手机详细配置:</strong></p><p>设置 &gt; WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP: 106.13.86.198</span><br><span class="line">Port: 8080</span><br></pre></td></tr></table></figure><p><img src="/images/modify-network-android.png" alt></p><p><img src="/images/ip-port-163-android.png" alt></p><p>破解前效果<br><img src="/images/pojieqian-163.png" alt></p><p>破解后效果<br><img src="/images/pojiehou-163.png" alt><br><img src="/images/tingge-163.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码地址: &lt;a href=&quot;https://github.com/lxbwolf/UnblockNeteaseMusic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lxbwolf/UnblockNeteaseMu
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="破解" scheme="https://lxb.wiki/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Go闭包技术</title>
    <link href="https://lxb.wiki/eb01d7dc/"/>
    <id>https://lxb.wiki/eb01d7dc/</id>
    <published>2019-10-04T11:25:07.000Z</published>
    <updated>2019-10-04T11:25:07.539Z</updated>
    
    <content type="html"><![CDATA[<p>斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/B536914CD0194338915F9A7B18A754D7/1139" alt="fibonacci.png"></p><p>斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和.<br>为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 0 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">// a b</span><br><span class="line">// a b</span><br><span class="line">a, b := 0, 1</span><br></pre></td></tr></table></figure><p>初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    fmt.Print(a, &quot; &quot;)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        fmt.Print(a, &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacciByNormal(t *testing.T) &#123;</span><br><span class="line">    fibonacciByNormal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacci(t *testing.T) &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Print(f(), &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为”闭包”!</p><p>闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func autoIncrease() func() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        i = i + 1</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func TestAutoIncrease(t *testing.T) &#123;</span><br><span class="line">    a := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(a(), a(), a())</span><br><span class="line">    b := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(b(), b(), b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果.</p><p>普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生.</p><p>但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会”长生不老”,并不会因为出身于函数内就和普通变量拥有一样的短暂人生.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func fightWithHorse() func() int &#123;</span><br><span class="line">    horseShowTime := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        horseShowTime++</span><br><span class="line">        fmt.Printf(&quot;(%d)祖国需要我,我就提枪上马立即战斗!\n&quot;,horseShowTime)</span><br><span class="line">        return horseShowTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFightWithHorse(t *testing.T) &#123;</span><br><span class="line">    f := fightWithHorse()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心!<br>下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosure(t *testing.T) &#123;</span><br><span class="line">    // 4 4 4</span><br><span class="line">    for _, c := range countByClosureButWrong() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c.</p><p>当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4.<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/7BB3368DAC6A4AEB847EAB127682D486/1144" alt></p><p>原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了!<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/C4B872B0C6354133B321806B9AF02F85/1145" alt></p><p>长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4.</p><p>既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛!</p><p>最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        n := i</span><br><span class="line">        fmt.Printf(&quot;for i=%d n=%d \n&quot;, i,n)</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            fmt.Printf(&quot;append i=%d n=%d\n&quot;, i, n)</span><br><span class="line">            return n</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/957A722165B94E7785E0AB1DAE3B5B0C/1146" alt></p><p>上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级.</p><p>既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureWithOk() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;for i=%d \n&quot;, i)</span><br><span class="line">        func(n int) &#123;</span><br><span class="line">            arr = append(arr, func() int &#123;</span><br><span class="line">                fmt.Printf(&quot;append n=%d \n&quot;, n)</span><br><span class="line">                return n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosureWithOk(t *testing.T) &#123;</span><br><span class="line">    // 1 2 3</span><br><span class="line">    for _, c := range countByClosureWithOk() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模拟类和对象的关系,也可以实现封装,具备一定面向对象能力<ul><li>每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系.</li></ul></li><li>缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本.<ul><li>长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用.</li></ul></li><li>实现闭包成本较高,同时也增加了理解难度.<ul><li>普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性.</li></ul></li><li>滥用容易占用过多内存,可能造成内存泄漏.<ul><li>过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>github 博客绑定域名</title>
    <link href="https://lxb.wiki/e9fbcad9/"/>
    <id>https://lxb.wiki/e9fbcad9/</id>
    <published>2019-09-26T16:54:15.000Z</published>
    <updated>2019-10-03T16:52:39.427Z</updated>
    
    <content type="html"><![CDATA[<p>某篇文章说, CNAME 解析只支持 www 不支持@<br>所以@ 只能 解析到一个一个的 IP</p><h4 id="1-source-添加-CNAME-文件"><a href="#1-source-添加-CNAME-文件" class="headerlink" title="1. source 添加 CNAME 文件"></a>1. source 添加 CNAME 文件</h4><p>在源码的<code>source</code> 目录下, 添加一个<code>CNAME</code>文件<br>文件内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxb.wiki</span><br></pre></td></tr></table></figure><h4 id="2-DNS-设置"><a href="#2-DNS-设置" class="headerlink" title="2. DNS 设置"></a>2. DNS 设置</h4><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析路线(isp)</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>默认</td><td>lxbwolf.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.108.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.111.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.109.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr></tbody></table><h4 id="3-hexo-部署"><a href="#3-hexo-部署" class="headerlink" title="3. hexo 部署"></a>3. hexo 部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某篇文章说, CNAME 解析只支持 www 不支持@&lt;br&gt;所以@ 只能 解析到一个一个的 IP&lt;/p&gt;
&lt;h4 id=&quot;1-source-添加-CNAME-文件&quot;&gt;&lt;a href=&quot;#1-source-添加-CNAME-文件&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="博客" scheme="https://lxb.wiki/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://lxb.wiki/a1751c09/"/>
    <id>https://lxb.wiki/a1751c09/</id>
    <published>2019-09-26T16:14:22.211Z</published>
    <updated>2019-10-03T07:57:15.349Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xargs</title>
    <link href="https://lxb.wiki/38dfadad/"/>
    <id>https://lxb.wiki/38dfadad/</id>
    <published>2019-08-19T17:14:58.000Z</published>
    <updated>2019-10-03T07:57:15.416Z</updated>
    
    <content type="html"><![CDATA[<p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p><p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p><p>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p><p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p><p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p><p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /sbin -perm 700 |ls -l       #这个命令是错误的</span><br><span class="line">find /sbin -perm 700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure><p><strong>命令格式</strong><br><code>somecommand |xargs -item command</code></p><p><strong>重要参数:</strong></p><ul><li>-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</li></ul><p><strong>其他参数:</strong></p><ul><li>-a file 从文件中读入作为sdtin</li><li>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li><li>-p 当每次执行一个argument的时候询问一次用户。</li><li>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</li><li>-t 表示先打印命令，然后再执行。</li><li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</li><li>-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li><li>-L num 从标准输入一次读取 num 行送给 command 命令。</li><li>-l 同 -L。</li><li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li><li>-x exit的意思，主要是配合-s使用。。</li><li>-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h4><h5 id="1-多行变成单行"><a href="#1-多行变成单行" class="headerlink" title="1. 多行变成单行"></a>1. 多行变成单行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt</span><br><span class="line"></span><br><span class="line">a b c d e f g</span><br><span class="line">h i j k l m n</span><br><span class="line">o p q</span><br><span class="line">r s t</span><br><span class="line">u v w x y z</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt | xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure><h5 id="2-一次使用n个参数"><a href="#2-一次使用n个参数" class="headerlink" title="2. 一次使用n个参数"></a>2. 一次使用n个参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt | xargs -n3</span><br><span class="line"></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure><h5 id="3-d选项指定分隔符"><a href="#3-d选项指定分隔符" class="headerlink" title="3. d选项指定分隔符"></a>3. d选项指定分隔符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX</span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure><p>结合<code>-n</code> 选项使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span><br><span class="line"></span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure><h5 id="4-I选项的使用"><a href="#4-I选项的使用" class="headerlink" title="4. I选项的使用"></a>4. I选项的使用</h5><h6 id="4-1-获取参数并替换"><a href="#4-1-获取参数并替换" class="headerlink" title="4.1 获取参数并替换{}"></a>4.1 获取参数并替换<code>{}</code></h6><p>假设一个命令为 <a href="http://sk.sh/" target="_blank" rel="noopener">sk.sh</a> 和一个保存参数的文件 arg.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#sk.sh命令内容，打印出所有参数。</span><br><span class="line"></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><p>arg.txt.文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat arg.txt</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p><code>xargs</code> 的一个选项 <code>-I</code>，使用 <code>-I</code> 指定一个替换字符串 <code>{}</code>，这个字符串在 <code>xargs</code> 扩展时会被替换掉，当 <code>-I</code> 与 <code>xargs</code> 结合使用，每一个参数命令都会被执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat arg.txt | xargs -I &#123;&#125; ./sk.sh sombefore &#123;&#125; someafter</span><br><span class="line"></span><br><span class="line">sombefore aaa someafter</span><br><span class="line">sombefore bbb someafter</span><br><span class="line">sombefore ccc someafter</span><br></pre></td></tr></table></figure><h6 id="4-2-复制文件实例"><a href="#4-2-复制文件实例" class="headerlink" title="4.2 复制文件实例"></a>4.2 复制文件实例</h6><p>复制所有图片文件到 /data/images 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images/</span><br></pre></td></tr></table></figure><h6 id="4-3-xargs-结合find-使用"><a href="#4-3-xargs-结合find-使用" class="headerlink" title="4.3 xargs 结合find 使用"></a>4.3 xargs 结合find 使用</h6><p>用 rm 删除太多的文件时候，可能得到一个错误信息：<code>/bin/rm Argument list too long.</code> 用 xargs 去避免这个问题：</p><p><code>find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f</code> xargs -0 将 \0 作为定界符。</p><p>统计一个源代码目录中所有 php 文件的行数： <code>find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</code></p><p>查找所有的 jpg 文件，并且压缩它们： <code>find . -type f -name &quot;*.jpg&quot; -print | xargs tar -czvf images.tar.gz</code></p><h6 id="4-4-下载多个文件"><a href="#4-4-下载多个文件" class="headerlink" title="4.4 下载多个文件"></a>4.4 下载多个文件</h6><p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接： <code># cat url-list.txt | xargs wget -c</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。&lt;/p&gt;
&lt;p&gt;xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。&lt;/p&gt;
&lt;p&gt;xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行
      
    
    </summary>
    
    
      <category term="Shell" scheme="https://lxb.wiki/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>升级https</title>
    <link href="https://lxb.wiki/ddf7de45/"/>
    <id>https://lxb.wiki/ddf7de45/</id>
    <published>2019-08-07T18:53:34.000Z</published>
    <updated>2019-10-03T16:44:30.044Z</updated>
    
    <content type="html"><![CDATA[<p><em>环境</em></p><pre><code>CentOSnginx</code></pre><h3 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h3><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。 我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p><h4 id="1-安装-certbot"><a href="#1-安装-certbot" class="headerlink" title="1. 安装 certbot"></a>1. 安装 certbot</h4><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。</p><pre><code>yum install epel-releaseyum install certbot</code></pre><h4 id="2-生成证书"><a href="#2-生成证书" class="headerlink" title="2. 生成证书"></a>2. 生成证书</h4><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。</p><pre><code>certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</code></pre><p>webroot-path就是项目根路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p><ul><li>cert.pem: 服务端证书</li><li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li><li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li><li>privkey.pem: 证书私钥</li></ul><h4 id="3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）"><a href="#3-生成迪菲-赫尔曼密钥交换组（-Strong-Diffie-Hellman-Group）" class="headerlink" title="3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）"></a>3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</h4><p>为了进一步提高安全性，也可以生成一个 Strong Diffie-Hellman Group。</p><pre><code>openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</code></pre><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。</p><pre><code>server {        listen 443 ssl;        # 启用http2        # 需要安装 Nginx Http2 Module        # listen 443 http2 ssl;        server_name my_server_name;        #证书文件        ssl_certificate /etc/letsencrypt/live/my_server_name/fullchain.pem;        #私钥文件        ssl_certificate_key /etc/letsencrypt/live/my_server_name/privkey.pem;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        # 优先采取服务器算法        ssl_prefer_server_ciphers on;        # 定义算法        ssl_ciphers &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&amp;quot;;        ssl_ecdh_curve secp384r1;        ssl_session_cache shared:SSL:10m;        ssl_session_tickets off;        ssl_stapling on;        ssl_stapling_verify on;        resolver 8.8.8.8 8.8.4.4 valid=300s;        resolver_timeout 5s;        add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;        add_header X-Frame-Options DENY;        add_header X-Content-Type-Options nosniff;        # 使用DH文件        ssl_dhparam /etc/ssl/certs/dhparam.pem;        location ~ /.well-known {            allow all;        }        location ~ \.php$ {            root           my_root;            fastcgi_pass   my_host:my_port;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            include        fastcgi_params;        }        root my_root;        index index.html index.php;        location / {            root my_root;            autoindex on;            index index.html index.php;            client_max_body_size 1024m;        }}</code></pre><p>其中的几项配置: <code>ssl_stapling on;</code> 开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。 <code>add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;</code> 启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接 <code>add_header X-Frame-Options DENY;</code> 添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少点击劫持 (clickjacking)攻击。 <code>add_header X-Content-Type-Options nosniff;</code> 添加 X-Content-Type-Options 响应头，防止 MIME 类型嗅探攻击 测试nginx.conf 是否有语法错误 <code>nginx -t</code> 重启nginx <code>nginx -s reload</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;环境&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CentOS
nginx&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取证书&quot;&gt;&lt;a href=&quot;#获取证书&quot; class=&quot;headerlink&quot; title=&quot;获取证书&quot;&gt;&lt;/a&gt;获取证书&lt;/h3&gt;&lt;p&gt;HTTPS 证
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="https" scheme="https://lxb.wiki/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>docker挂载目录失败/权限拒绝</title>
    <link href="https://lxb.wiki/498654c2/"/>
    <id>https://lxb.wiki/498654c2/</id>
    <published>2019-07-23T09:32:38.000Z</published>
    <updated>2019-10-03T07:57:15.287Z</updated>
    
    <content type="html"><![CDATA[<p>把宿主机的一个目录挂载到容器中的一个目录，当访问容器中的这个目录时，出现如下问题：<br> <code>ls: cannot open directory .: Permission denied</code><br>无法访问目录，权限拒绝。<br>该问题通常在centos7下出现。或者一个容器启动成功后，里面的服务无法成功访问，这是因为centos7中的安全模块selinux把权限禁掉了，一般的解决方案有以下两种：<br>（1）临时关闭selinux<br>直接在centos服务器上执行以下命令即可。执行完成以后建议重新<code>docker run</code>。 <code>setenforce 0</code><br>（2）给容器加权限<br>在<code>docker run</code>时给该容器加权限，加上以下参数即可：<br> <code>--privileged=true</code><br> 一般都推荐使用这种方式。<br> 按上述方法修改后, 如果执行下面命令失败<br> <code>docker run --name rookie-nginx-test -d -p 8082:80 -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx -v ~/nginx/conf/conf.d:/etc/nginx/conf.d --link php7-fpm:php nginx</code><br>则是因为<code>~/nginx/www/</code> 目录下没有index 文件导致. 手动创建<code>index.php</code> 文件解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把宿主机的一个目录挂载到容器中的一个目录，当访问容器中的这个目录时，出现如下问题：&lt;br&gt; &lt;code&gt;ls: cannot open directory .: Permission denied&lt;/code&gt;&lt;br&gt;无法访问目录，权限拒绝。&lt;br&gt;该问题通常在centos
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://lxb.wiki/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</title>
    <link href="https://lxb.wiki/784beb8f/"/>
    <id>https://lxb.wiki/784beb8f/</id>
    <published>2019-07-02T03:48:53.000Z</published>
    <updated>2019-10-03T16:55:28.088Z</updated>
    
    <content type="html"><![CDATA[<p>【报错原因】：没有utf-8这个语系（没添加语言_国名前缀），LC_ALL又没设定值。 <strong>服务端解决方法：</strong> 在远程系统上， <code>/etc/environment</code>加入以下两行，重新登陆即可。</p><pre><code>LANG=en_US.utf-8LC_ALL=en_US.utf-8</code></pre><p><strong>Mac终端解决方法：</strong> 编辑<code>~/.bashrc</code>或者<code>~/.zshrc</code>文件，添加</p><pre><code>export LC_ALL=en_US.UTF-8  export LANG=en_US.UTF-8</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【报错原因】：没有utf-8这个语系（没添加语言_国名前缀），LC_ALL又没设定值。 &lt;strong&gt;服务端解决方法：&lt;/strong&gt; 在远程系统上， &lt;code&gt;/etc/environment&lt;/code&gt;加入以下两行，重新登陆即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="iTerm2" scheme="https://lxb.wiki/tags/iTerm2/"/>
    
  </entry>
  
  <entry>
    <title>升级到php7.1之后wordpress 网站出现Error establishing a database connection的解决方法</title>
    <link href="https://lxb.wiki/b6b408b2/"/>
    <id>https://lxb.wiki/b6b408b2/</id>
    <published>2019-06-12T15:37:00.000Z</published>
    <updated>2019-10-03T16:44:16.932Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多WordPress的插件都推荐将php版本升级到7.0或者7.1以上，于是就折腾了一下把几个blog升级到了7.1.5，升级的过程不难，无非就是额外安装一个php，然后启动自带的配套php-fpm7，然后nginx里location转发到新的php socket文件，这里就不表了。 升级完了，phpinfo()发现一切都正常，但是访问WordPress，却意外提示Error establishing a database connection，但是db的连接信息明明没有问题，经过反复搜索尝试，发现只要将 <code>/usr/share/nginx/html/wp-config.php</code> 文件里的 <code>define(&#39;DB_HOST&#39;, &#39;localhost&#39;);</code> 修改为 <code>define(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;);</code> 即可解决，猜测原因可能是php7.1中对域的resolve问题 另外, 为了 Debug, 可以把 <code>/usr/share/nginx/html/wp-config.php</code> 的 debug 改为 true <code>define(&#39;WP_DEBUG&#39;, true);</code> 改好了, 再改成 false.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在很多WordPress的插件都推荐将php版本升级到7.0或者7.1以上，于是就折腾了一下把几个blog升级到了7.1.5，升级的过程不难，无非就是额外安装一个php，然后启动自带的配套php-fpm7，然后nginx里location转发到新的php socket文件
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="wordpress" scheme="https://lxb.wiki/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>date 命令转换时间戳</title>
    <link href="https://lxb.wiki/7b4019ad/"/>
    <id>https://lxb.wiki/7b4019ad/</id>
    <published>2019-06-10T08:59:14.000Z</published>
    <updated>2019-10-03T07:57:15.285Z</updated>
    
    <content type="html"><![CDATA[<p>给定时间戳, 转换成日期<br>网上所有的命令都是<br><code>date -d @$stamp &quot;+%Y-%m-%d&quot;</code><br> 但是一直提示<br> <code>date: invalid date</code>@stamp’<code>带上&quot;@&quot; 符号, 就参数错误 正确使用方法:</code>date -d “1970-01-01 UTC 1287331200 seconds” +%F<code>或者使用awk</code>awk ‘{print strftime(“%Y%m”, 1287331200)}’<code>调用外部命令耗时比较长, 更高效的方法:</code>printf “%(%Y%m)T\n” “$str” &gt;&gt; file<code>如果bash 版本低于4, printf 不支持打印日期格式, 因此使用 下面这个bash</code>/opt/compiler/gcc-4.8.2/bin/bash`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定时间戳, 转换成日期&lt;br&gt;网上所有的命令都是&lt;br&gt;&lt;code&gt;date -d @$stamp &amp;quot;+%Y-%m-%d&amp;quot;&lt;/code&gt;&lt;br&gt; 但是一直提示&lt;br&gt; &lt;code&gt;date: invalid date&lt;/code&gt;@stamp’&lt;cod
      
    
    </summary>
    
    
      <category term="Shell" scheme="https://lxb.wiki/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>大小端</title>
    <link href="https://lxb.wiki/7ee0edaa/"/>
    <id>https://lxb.wiki/7ee0edaa/</id>
    <published>2019-05-24T10:37:53.000Z</published>
    <updated>2019-10-03T16:46:23.023Z</updated>
    
    <content type="html"><![CDATA[<p>计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构而已），比如C/C++中，short类型一般是2个字节，int类型一般4个字节等。因此这里就存在着一个如何安排多个字节数据中各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。</p><h4 id="1-解释"><a href="#1-解释" class="headerlink" title="1. 解释"></a>1. 解释</h4><p>假如有一个4字节的数据为 0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址 0x4000 8000中，则有：</p><p>内存地址</p><p>0x4000 8000（低地址）</p><p>0x4000 8001</p><p>0x4000 8002</p><p>0x4000 8003（高地址）</p><p>大端模式</p><p>0x12（高字节）</p><p>0x34</p><p>0x56</p><p>0x78（低字节）</p><p>小端模式</p><p>0x78（低字节）</p><p>0x56</p><p>0x34</p><p>0x12（高字节）</p><ul><li>大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</li><li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</li></ul><p>为什么截然相反的大小端存储模式能够并存至今？在标准化备受推崇的今天，为什么大小端谁都没有被另外一个所同化？我想这除了历史的惯性使然，还与它们各自的优缺点有关。 大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小 小端模式优点：1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）； 2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持（见1.3节），因此在多字节存储顺序上始终没有一个统一的标准</p><ul><li>Intel的80×86系列芯片使用小端存储模式</li><li>ARM芯片默认采用小端，但可以切换为大端</li><li>MIPS芯片采用大端，但可以在大小端之间切换</li><li>在网络上传输的数据普遍采用的都是大端</li></ul><h4 id="2-判断"><a href="#2-判断" class="headerlink" title="2. 判断"></a>2. 判断</h4><p>方法一：通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测</p><pre><code>// @Ret: 大端，返回true; 小端，返回falsebool IsBigEndian_1(){    int nNum = 0x12345678;    char cLowAddressValue = *(char*)&amp;nNum;    // 低地址处是高字节，则为大端    if ( cLowAddressValue == 0x12 )    return true;    return false; }</code></pre><p>方法二：利用联合体union的存放顺序是所有成员都从低地址开始存放这一特性进行检测</p><pre><code>// @Ret: 大端，返回true; 小端，返回falsebool isBigEndian_2(){    union uendian    {       int nNum;       char cLowAddressValue;    };    uendian u;    u.nNum = 0x12345678;    if ( u.cLowAddressValue == 0x12 )     return true;    return false;}</code></pre><h4 id="3-转换"><a href="#3-转换" class="headerlink" title="3. 转换"></a>3. 转换</h4><p>大小端转换</p><pre><code>// 实现16bit的数据之间的大小端转换#define BLSWITCH16(A)   (  ( ( (uint16)(A) &amp; 0xff00 ) &gt;&gt; 8  )    | \                             ( ( (uint16)(A) &amp; 0x00ff ) &lt;&lt; 8  )     )  // 实现32bit的数据之间的大小端转换#define BLSWITCH32(A)   (  ( ( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) |\         (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \         (((unit32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | \         (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 32)  )</code></pre><p>由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式发号器架构设计</title>
    <link href="https://lxb.wiki/3d5a1f1d/"/>
    <id>https://lxb.wiki/3d5a1f1d/</id>
    <published>2019-05-10T06:04:04.000Z</published>
    <updated>2019-10-03T16:41:41.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-需求设计"><a href="#一-需求设计" class="headerlink" title="一 需求设计"></a>一 需求设计</h3><ol><li><p>分布式环境下，保证每个序列号（sequence）是全系统唯一的；</p></li><li><p>序列号可排序，满足单调递增的规律；</p></li><li><p>特定场景下，能生成无规则（或者看不出规则）的序列号；</p></li><li><p>生成的序列号尽量短；</p></li><li><p>序列号可进行二次混淆，提供可扩展的interface，业务方自定义实现。</p></li></ol><h3 id="二-方案设计"><a href="#二-方案设计" class="headerlink" title="二 方案设计"></a>二 方案设计</h3><p>为了满足上述需求，发号器必须能够支持不同的生成策略，最好是还能支持自定义的生成策略，这就对系统本身的可扩展性提出了要求。 目前，发号器设计了两种比较通用的基础策略，各有优缺点，但结合起来，能达到优势互补的目的。</p><h4 id="1-segment"><a href="#1-segment" class="headerlink" title="1. segment"></a>1. segment</h4><p>第一种策略称之为『分段』（segment），下文将对其进行详细阐述： 整个segment发号器有两个重要的角色：Redis和MongoDB，理论上MongoDB是可以被MySQL或其他DB产品所替代的。 segment发号器所产生的号码满足单调递增的规律，短时间内产生的号码不会有过长的问题（可根据实际需要，设置初始值，比如 100）。</p><h5 id="Redis数据结构（Hash类型）"><a href="#Redis数据结构（Hash类型）" class="headerlink" title="Redis数据结构（Hash类型）"></a>Redis数据结构（Hash类型）</h5><pre><code>key: &lt;string&gt;，表示业务主键/名称value: {  cur: &lt;long&gt;，表示当前序列号  max: &lt;long&gt;，表示这个号段最大的可用序列号}</code></pre><p>取号的大部分操作都集中在Redis，为了保证序列号递增的原子性，取号的功能可以用Lua脚本实现。</p><pre><code>--[[  由于RedisTemplate设置的HashValueSerializer是GenericToStringSerializer，故此处的HASH结构中的  VALUE都是string类型，需要使用tonumber函数转换成数字类型。]]local max = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;max&quot;)  --获取一段序列号的maxlocal cur = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;cur&quot;)  --获取当前发号位置if tonumber(cur) &gt;= tonumber(max) then  --没有超过这段序列号的上限    local step = ARGV[1]    if (step == nil) then  --没有传入step参数        step = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;step&quot;)  --获取这段序列号的step配置参数值    end    redis.pcall(&quot;HSET&quot;, KEYS[1], &quot;max&quot;, tonumber(max) + tonumber(step))  --调整max参数值，扩展上限endreturn redis.pcall(&quot;HINCRBY&quot;, KEYS[1], &quot;cur&quot;, 1)  --触发HINCRBY操作，对cur自增，并返回自增后的值</code></pre><p>注意：在redis执行lua script期间，redis处于BUSY状态，这个时候对redis的任何形式的访问都会抛出JedisBusyException异常，所以lua script中的处理逻辑不得太复杂。 值得一提的是，即使切换到一个新的database，或者开启新线程执行lua script，都将会遇到同样的问题，毕竟redis是单进程单线程的。 如果不幸遇到上述问题，需要使用redis-cli客户端连上redis-server，向其发送SCRIPT KILL命令，即可终止脚本执行， 如果想避免上述问题，也可以直接使用Springboot提供的RedisTemplate，能支持绝大部分redis command。</p><h5 id="MongoDB-数据结构"><a href="#MongoDB-数据结构" class="headerlink" title="MongoDB 数据结构"></a>MongoDB 数据结构</h5><pre><code>{ bizTag: &lt;string&gt;,  表示业务主键/名称 max: &lt;long&gt;,  表示这个号段最大的可用序列号 step: &lt;int&gt;, 每次分段的步长 timestamp: &lt;long&gt;,  更新数据的时间戳（毫秒）}</code></pre><p>MongoDB部分主要是对号段的分配进行管理，一个号段不能多发，也可以根据发号情况，适当放缩号段步长（step）。 到此为止，segment发号器的雏形已经形成了。 一个比较突出的问题是在两个号段衔接的时间点，当一个segment派发完了后，会对MongoDB和Redis中的数据中的max扩容，I/O消耗比正常发号要稍多，会遇到“尖刺” 为了消除“尖刺”，可以使用双Buffer模型 <img src="http://lxb.wiki/wp-content/uploads/2019/06/9135a2df270662dedd513fa4258fc5ab.png" alt> 这个模型的核心思想就是“<strong>预分配</strong>”。可以设置一个阈值（threshold），比如20%，当Buffer-1里面的号段已经消耗了20%，那么立刻根据Buffer-1的max和step，开辟Buffer-2。 当Buffer-1完全消耗了，可以无缝衔接Buffer-2,。如果Buffer-2的消耗也达到阈值了，又可以开辟Buffer-1，如此往复。 接下来，我们来讨论一下<strong>异常/故障</strong>情况。 ① Redis宕机。因为大部分发号工作都是依靠Redis完成的，所以发生了这种情况是非常糟糕的。如果想有效降低此风险，最行之有效的办法是对Redis进行集群化，通常是1主2从，这样可以挺住非常高的QPS了。 当然也有退而求其次的办法，就是利用上述提到的双Buffer模型。不依赖Redis取号，直接通过程序控制，利用机器内存。所以当需要重启发号服务之前，要确保依赖的组件是运行良好的，不然号段就丢失了。 ② 要不要持久化的问题。这个问题主要是针对Redis，如果没有记录下当前的取号进度，那么随着Redis的宕机，取号现场就变得难以恢复了；如果每次都记录取号进度，那么这种I/O高密度型的作业会对服务性能 造成一定影响，并且随着取号的时间延长，恢复取号现场就变得越来越慢了，甚至到最后是无法忍受的。除了对Redis做高可用之外，引入MongoDB也是出于对Redis持久化功能辅助的考虑。 个人建议：如果Redis已经集群化了，而且还开启了双Buffer的策略，以及MongoDB的加持，可以不用再开启Redis的持久化了。 如果考虑到极端情况下，Redis还是宕机了，我们可以使用MongoDB里面存下来的max，就max+1赋值给cur（避免上个号段取完，正好宕机了）。 ③ MongoDB宕机。这个问题不是很严重，只要将step适当拉长一些（至少取号能支撑20分钟），利用Redis还在正常取号的时间来抢救MongoDB。不过，考虑到实际可能没这么快恢复mongo服务，可以在程序中采取 一些容错措施，比如号段用完了，mongo服务无法到达，直接关闭取号通道，直到MongoDB能正常使用；或者程序给一个默认的step，让MongoDB中的max延长到max+step*n（可能取了N个号段MongoDB才恢复过来）， 这样取号服务也可以继续。依靠程序本身继续服务，那么需要有相关的log，这样才有利于恢复MongoDB中的数据。 ④ 取号服务宕机。这个没什么好说的，只能尽快恢复服务运行了。 ⑤ Redis，MongoDB都宕机了。这种情况已经很极端了，只能利用双Buffer策略，以及程序默认的设置进行工作了，同样要有相关的log，以便恢复Redis和MongoDB。 ⑥ 都宕机了。我有一句mmp不知当讲不当讲……</p><h4 id="2、snowflake"><a href="#2、snowflake" class="headerlink" title="2、snowflake"></a>2、snowflake</h4><p>第二种策略是Twitter出品，算法思想比较巧妙，实现的难度也不大。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/91c86f2e2861b86d041ea16e874728a6.png" alt> 以上示意图描述了一个序列号的二进制组成结构。 第一位不用，恒为0，即表示正整数； 接下来的41位表示时间戳，精确到毫秒。为了节约空间，可以将此时间戳定义为距离某个时间点所经历的毫秒数（Java默认是1970-01-01 00:00:00）； 再后来的10位用来标识工作机器，如果出现了跨IDC的情况，可以将这10位一分为二，一部分用于标识IDC，一部分用于标识服务器； 最后12位是序列号，自增长。 snowflake的核心思想是64bit的合理分配，但不必要严格按照上图所示的分法。 如果在机器较少的情况下，可以适当缩短机器id的长度，留出来给序列号。 当然，snowflake的算法将会面临两个挑战： ① 机器id的指定。这个问题在分布式的环境下会比较突出，通常的解决方案是利用Redis或者Zookeeper进行机器注册，确保注册上去的机器id是唯一的。为了解决 强依赖Redis或者Zookeeper的问题，可以将机器id写入本地文件系统。 ② 机器id的生成规则。这个问题会有一些纠结，因为机器id的生成大致要满足三个条件：a. int类型(10bit)纯数字，b. 相对稳定，c. 与其他机器要有所区别。至于优雅美观，都是其次了。对于机器id的存储，可以使用HASH结构，KEY的规则是“application-name.port.ip”，其中ip是通过算法转换成了一段长整型的纯数字，VALUE则是机器id， 服务id，机房id，其中，可以通过服务id和机房id反推出机器id。 假设服务id(workerId)占8bit，机房id(rackId)占2bit，从1开始，workerId=00000001，rackId=01，machineId=00000000101 如果用Redis存储，其表现形式如下： <img src="http://lxb.wiki/wp-content/uploads/2019/06/f4da350756f1116434e6636a38888282.png" alt> 如果存储在文件中（建议properties文件），则文件名是sequence-client:8112:3232235742.properties，文件内容如下： <img src="http://lxb.wiki/wp-content/uploads/2019/06/3b1e3b6b90aaa663bb3a578bd98c1db1.png" alt> 如果发号服务上线，直接按照“application-name.port.ip”的规则取其内容。 ③ 时钟回拨。因为snowflake对系统时间是很依赖的，所以对于时钟的波动是很敏感的，尤其是时钟回拨，很有可能就会出现重复发号的情况。时钟回拨问题解决策略通常是直接拒绝发号，直到时钟正常，必要时进行告警。</p><h3 id="三-程序设计"><a href="#三-程序设计" class="headerlink" title="三 程序设计"></a>三 程序设计</h3><p>整个发号过程可以分成三个层次： 1、策略层(strategy layer)：这个层面决定的是发号方法/算法，涵盖了上述所讲的segment和snowflake两种方式，当然，用户也可以自己扩展实现其他发号策略。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/377252c9da3f792b50732cb650d42d8d.png" alt> 最顶上定义Sequence实际上就是发号的结果。bizType是对发号业务场景的定义，比如订单号，用户ID，邀请好友的分享码。 发号策略的init接口是发号前的初始化工作，而generate接口就是调用发号器的主入口了。 当然，考虑到各种异常情况，加入了拒绝发号的处理器（SequenceRejectedHandler），默认实现只是记录日志，用户可根据需求去实现该处理器，然后用set方法设置发号策略的拒绝处理器。 2、插件层(plugin layer)：此处的插件可以理解是一种拦截器，贯穿SequenceStrategy的发号全周期。引入插件后，无疑是丰富了整个发号的操作过程，用户可以从中干预到发号的整个流程，以便达到其他的目的，比如：记录发号历史，统计发号速率，发号二次混淆等。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/56fe2b69f67a1fc9cce3179163d76278.png" alt> 可以看出，插件被设计成『注册式』的，发号策略只有注册了相关插件之后，插件才能生效， 当然，一个插件能被多个发号策略所注册，一个发号策略也能同时注册多个插件，所以两者是多对多的关系，PluginManager的出现就是解决插件的注册管理问题。 从SequencePlugin的定义中可以发现，插件是有优先级（Order）的，通过getOrder()可以获得，在这套发号系统里，Order值越小，表示该插件越优先执行。此外，插件有三个重要的操作： before，表示发号之前的处理。若返回了false，那么该插件后面的操作都失效了，否则继续执行发号流程。 after，表示发号之后的处理。 doException，表示插件发生异常的处理方法。 3、持久层(persistence layer)：这个层面指代的是上述所提的MongoDB部分，如果不需要持久化的支持，可以不实现此接口，那么整个发号器就变成纯内存管理的了。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/f65af0475f67e95a778a92d6ef681f62.png" alt> PersistRepository定义了基本的CRUD方法，其中persistId可以理解成上述提到的BizType。 一切的持久化对象都是从PersistModel开始的，上图中的Segment、PersistDocument都是为了实现分段发号器而定义的。</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3><p>这篇文章详细阐述了分布式发号器系统的设计，旨在能做出一个可扩展，易维护的发号系统。业界比较知名的发号算法似乎也不多，整个发号系统不一定就按照笔者所做的设计，还是要立足于具体的业务需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-需求设计&quot;&gt;&lt;a href=&quot;#一-需求设计&quot; class=&quot;headerlink&quot; title=&quot;一 需求设计&quot;&gt;&lt;/a&gt;一 需求设计&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分布式环境下，保证每个序列号（sequence）是全系统唯一的；&lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="DB" scheme="https://lxb.wiki/categories/DB/"/>
    
    
      <category term="idalloc" scheme="https://lxb.wiki/tags/idalloc/"/>
    
  </entry>
  
</feed>
