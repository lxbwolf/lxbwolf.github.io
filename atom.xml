<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxb.wiki/"/>
  <updated>2020-05-01T02:57:16.426Z</updated>
  <id>https://lxb.wiki/</id>
  
  <author>
    <name>Brooke Lau</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Inlining Optimisations in Go</title>
    <link href="https://lxb.wiki/6ce34c49/"/>
    <id>https://lxb.wiki/6ce34c49/</id>
    <published>2020-04-29T13:05:10.000Z</published>
    <updated>2020-05-01T02:57:16.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内联是什么？"><a href="#内联是什么？" class="headerlink" title="内联是什么？"></a>内联是什么？</h2><p>内联就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经成为编译过程中自动实现的基本优化过程的其中一步。</p><h2 id="为什么内联很重要？"><a href="#为什么内联很重要？" class="headerlink" title="为什么内联很重要？"></a>为什么内联很重要？</h2><p>有两个原因。第一个是它消除了函数调用本身的开销。第二个是它使得编译器能更高效地执行其他的优化策略。</p><h3 id="函数调用的开销"><a href="#函数调用的开销" class="headerlink" title="函数调用的开销"></a>函数调用的开销</h3><p>在任何语言中，调用一个函数 <sup><a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-bottom-1-4053" target="_blank" rel="noopener">1</a></sup> 都会有消耗。把参数编组进寄存器或放入栈中（取决于 ABI），在返回结果时倒序取出时会有开销。引入一次函数调用会导致程序计数器从指令流的一点跳到另一点，这可能导致管道阻塞。函数内部通常有前置处理，需要为函数执行准备新的栈帧，还有与前置相似的后续处理，需要在返回给调用方之前释放栈帧空间。</p><p>在 Go 中函数调用会消耗额外的资源来支持栈的动态增长。在进入函数时，goroutine 可用的栈空间与函数需要的空间大小相等。如果可用空间不同，前置处理就会跳到把数据复制到一块新的、更大的空间的运行时逻辑，而这会导致栈空间变大。当这个复制完成后，运行时跳回到原来的函数入口，再执行栈空间检查，函数调用继续执行。这种方式下，goroutine 开始时可以申请很小的栈空间，在有需要时再申请更大的空间。<sup><a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-bottom-2-4053" target="_blank" rel="noopener">2</a></sup></p><p>这个检查消耗很小 — 只有几个指令 — 而且由于 goroutine 是成几何级数增长的，因此这个检查很少失败。这样，现代处理器的分支预测单元会通过假定检查肯定会成功来隐藏栈空间检查的消耗。当处理器预测错了栈空间检查，必须要抛弃它推测性执行的操作时，与为了增加 goroutine 的栈空间运行时所需的操作消耗的资源相比，管道阻塞的代价更小。</p><p>虽然现代处理器可以用预测性执行技术优化每次函数调用中的泛型和 Go 特定的元素的开销，但那些开销不能被完全消除，因此在每次函数调用执行必要的工作过程中都会有性能消耗。一次函数调用本身的开销是固定的，与更大的函数相比，调用小函数的代价更大，因为在每次调用过程中它们做的有用的工作更少。</p><p>消除这些开销的方法必须是要消除函数调用本身，Go 的编译器就是这么做的，在某些条件下通过用函数的内容来替换函数调用来实现。这个过程被称为<em>内联</em>，因为它在函数调用处把函数体展开了。</p><h3 id="改进的优化机会"><a href="#改进的优化机会" class="headerlink" title="改进的优化机会"></a>改进的优化机会</h3><p>Cliff Click 博士把内联描述为现代编译器做的优化措施，像常量传播（译注：此处作者笔误，原文为 constant proportion，修正为 constant propagation）和死码消除一样，都是编译器的基本优化方法。实际上，内联可以让编译器看得更深，使编译器可以观察调用的特定函数的上下文内容，可以看到能继续简化或彻底消除的逻辑。由于可以递归地执行内联，因此不仅可以在每个独立的函数上下文处进行这种优化，也可以在整个函数调用链中进行。</p><h2 id="实践中的内联"><a href="#实践中的内联" class="headerlink" title="实践中的内联"></a>实践中的内联</h2><p>下面这个例子可以演示内联的影响：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(<span class="number">-1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个基准，会得到如下结果：<a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-bottom-3-4053" target="_blank" rel="noopener">3</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=.</span><br><span class="line">BenchmarkMax-4   530687617         2.24 ns/op</span><br></pre></td></tr></table></figure><p>在我的 2015 MacBook Air 上  <code>max(-1, i)</code> 的耗时约为 2.24 纳秒。现在去掉 <code>//go:noinline</code> 编译指令，再看下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=.</span><br><span class="line">BenchmarkMax-4   1000000000         0.514 ns/op</span><br></pre></td></tr></table></figure><p>从 2.24 纳秒降到了 0.51 纳秒，或者从 <code>benchstat</code> 的结果可以看出，有 78% 的提升。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old time/op  new time/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.49ns ± 6%  -77.96%  (p=0.000 n=18+19)</span><br></pre></td></tr></table></figure><p>这个提升是从哪儿来的呢？</p><p>首先，移除掉函数调用以及与之关联的前置处理 <a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-bottom-4-4053" target="_blank" rel="noopener">4</a> 是主要因素。把 <code>max</code> 函数的函数体在调用处展开，减少了处理器执行的指令数量并且消除了一些分支。</p><p>现在由于编译器优化了 <code>BenchmarkMax</code>，因此它可以看到 <code>max</code> 函数的内容，进而可以做更多的提升。当 <code>max</code> 被内联后，<code>BenchmarkMax</code> 呈现给编译器的样子，看起来是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">-1</span> &gt; i &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行一次基准，我们看一下手动内联的版本和编译器内联的版本的表现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old time/op  new time/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.48ns ± 3%  -78.14%  (p=0.000 n=18+18)</span><br></pre></td></tr></table></figure><p>现在编译器能看到在 <code>BenchmarkMax</code> 里内联 <code>max</code> 的结果，可以执行以前不能执行的优化措施。例如，编译器注意到 <code>i</code> 初始值为 <code>0</code>，仅做自增操作，因此所有与 <code>i</code> 的比较都可以假定 <code>i</code> 不是负值。这样条件表达式 <code>-1 &gt; i</code> 永远不是 true。<a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-bottom-5-4053" target="_blank" rel="noopener">5</a></p><p>证明了 <code>-1 &gt; i</code> 永远不为 true 后，编译器可以把代码简化为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且因为分支里是个常量，编译器可以通过下面的方式移除不会走到的分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = i</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过内联和由内联解锁的优化过程，编译器把表达式 <code>r = max(-1, i))</code> 简化为 <code>r = i</code>。</p><h2 id="内联的限制"><a href="#内联的限制" class="headerlink" title="内联的限制"></a>内联的限制</h2><p>本文中我论述的内联称作<em>叶子</em>内联；把函数调用栈中最底层的函数在调用它的函数处展开的行为。内联是个递归的过程，当把函数内联到调用它的函数 A 处后，编译器会把内联后的结果代码再内联到 A 的调用方，这样持续内联下去。例如，下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxMaxMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(max(<span class="number">-1</span>, i), max(<span class="number">0</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的例子中的代码运行速度一样快，因为编译器可以对上面的代码重复地进行内联，也把代码简化到 <code>r = i</code> 表达式。</p><p>下一篇文章中，我会论述当 Go 编译器想要内联函数调用栈中间的某个函数时选用的另一种内联策略。最后我会论述编译器为了内联代码准备好要达到的极限，这个极限 Go 现在的能力还达不到。</p><!--1. 在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。[][7]2. 在 Go 1.14 以前，栈检查的前置处理也被 gc 用于 STW，通过把所有活跃的 goroutine 栈空间设为 0，来强制它们切换为下一次函数调用时的运行时状态。这个机制[最近被替换][8]为一种新机制，新机制下运行时可以不用等 goroutine 进行函数调用就可以暂停 goroutine。[][9]3. 我用 `//go:noinline` 编译指令来阻止编译器内联 `max`。这是因为我想把内联 `max` 的影响与其他影响隔离开，而不是用 `-gcflags='-l -N'` 选项在全局范围内禁止优化。关于 `//go:` 注释在[这篇文章][10]中详细论述。[][11]4. 你可以自己通过比较 `go test -bench=. -gcflags=-S`有无 `//go:noinline` 注释时的不同结果来验证一下。[][12]5. 你可以用 `-gcflags=-d=ssa/prove/debug=on` 选项来自己验证一下。[][13]--><h2 id="相关文章："><a href="#相关文章：" class="headerlink" title="相关文章："></a>相关文章：</h2><ol><li><a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast" target="_blank" rel="noopener">使 Go 变快的 5 件事</a></li><li><a href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite" target="_blank" rel="noopener">为什么 Goroutine 的栈空间会无限增长？</a></li><li><a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go" target="_blank" rel="noopener">Go 中怎么写基准测试</a></li><li><a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas" target="_blank" rel="noopener">Go 中隐藏的编译指令</a></li></ol><hr><p>via: <a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go" target="_blank" rel="noopener">https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go</a></p><p>作者：<a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p><!--[a]: https://dave.cheney.net/author/davecheney[1]: https://github.com/golang/go[2]: tmp.gBQ2tEtMHc#easy-footnote-bottom-1-4053 "在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。"[3]: tmp.gBQ2tEtMHc#easy-footnote-bottom-2-4053 "Up until Go 1.14 the stack check preamble was also used by the garbage collector to stop the world by setting all active goroutine’s stacks to zero, forcing them to trap into the runtime the next time they made a function call. This system was <a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">recently replaced</a> with a mechanism which allowed the runtime to pause an goroutine without waiting for it to make a function call."[4]: tmp.gBQ2tEtMHc#easy-footnote-bottom-3-4053 "I’m using the <code>//go:noinline</code> pragma to prevent the compiler from inlining <code>max</code>. This is because I want to isolate the effects of inlining on <code>max</code> rather than disabling optimisations globally with <code>-gcflags='-l -N'</code>. I go into detail about the <code>//go:</code> comments in <a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas">this presentation</a>."[5]: tmp.gBQ2tEtMHc#easy-footnote-bottom-4-4053 "You can check this for yourself by comparing the output of <code>go test -bench=. -gcflags=-S</code> with and without the <code>//go:noinline</code> annotation."[6]: tmp.gBQ2tEtMHc#easy-footnote-bottom-5-4053 "You can check this yourself with the <code>-gcflags=-d=ssa/prove/debug=on</code> flag."[7]: tmp.gBQ2tEtMHc#easy-footnote-1-4053[8]: https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md[9]: tmp.gBQ2tEtMHc#easy-footnote-2-4053[10]: https://dave.cheney.net/2018/01/08/gos-hidden-pragmas[11]: tmp.gBQ2tEtMHc#easy-footnote-3-4053[12]: tmp.gBQ2tEtMHc#easy-footnote-4-4053[13]: tmp.gBQ2tEtMHc#easy-footnote-5-4053[14]: https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast "Five things that make Go fast"[15]: https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite "Why is a Goroutine’s stack infinite ?"[16]: https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go "How to write benchmarks in Go"[17]: https://dave.cheney.net/2018/01/08/gos-hidden-pragmas "Go’s hidden #pragmas"-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内联是什么？&quot;&gt;&lt;a href=&quot;#内联是什么？&quot; class=&quot;headerlink&quot; title=&quot;内联是什么？&quot;&gt;&lt;/a&gt;内联是什么？&lt;/h2&gt;&lt;p&gt;内联就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>关于 CGo 的字符串函数的解释</title>
    <link href="https://lxb.wiki/8c45788a/"/>
    <id>https://lxb.wiki/8c45788a/</id>
    <published>2020-02-09T12:55:26.000Z</published>
    <updated>2020-05-01T02:57:04.593Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="noopener">cgo</a> 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。在 CGo 的文档中有简洁的解释，但我认为解释得太简洁了，因为文档只涉及了定义中的某些特定字符串，而忽略了两个很重要的注意事项。我曾经踩过这里的坑，现在我要详细解释一下。</p><p>四个函数分别是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">CString</span><span class="params">(<span class="keyword">string</span>)</span> *<span class="title">C</span>.<span class="title">char</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoString</span><span class="params">(*C.char)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoStringN</span><span class="params">(*C.char, C.<span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoBytes</span><span class="params">(unsafe.Pointer, C.<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure><p><code>C.CString()</code> 等价于 C 的 <code>strdup()</code>，像文档中提到的那样，把 Go 的字符串复制为可以传递给 C 函数的 C 的 <code>char *</code>。很讨厌的一件事是，由于 Go 和 CGo 类型的定义方式，调用 <code>C.free</code> 时需要做一个转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cs := C.CString(<span class="string">"a string"</span>)</span><br><span class="line">C.free(unsafe.Pointer(cs))</span><br></pre></td></tr></table></figure><p>请留意，Go 字符串中可能嵌入了 <code>\0</code> 字符，而 C 字符串不会。如果你的 Go 字符串中有 <code>\0</code> 字符，当你调用 <code>C.CString()</code> 时，C 代码会从 <code>\0</code> 字符处截断你的字符串。这往往不会被注意到，但<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString" target="_blank" rel="noopener">有时文本并不保证不含 null 字符</a>。</p><p><code>C.GoString()</code> 也等价于 <code>strdup()</code>，但与 <code>C.CString()</code> 相反，是把 C 字符串转换为 Go 字符串。你可以用它定义结构体的字段，或者是声明为 C 的 <code>char *</code>（在 Go 中叫 <code>*C.cahr</code>） 的其他变量，抑或其他的一些变量（我们后面会看到）。</p><p><code>C.GoStringN()</code> 等价于 C 的 <code>memmove()</code>，与 C 中普通的字符串函数不同。<strong>它把整个 N 长度的 C buffer 复制为一个 Go 字符串，不单独处理 null 字符。</strong>再详细点，它也通过复制来实现。如果你有一个定义为 <code>char feild[64]</code> 的结构体的字段，然后调用了 <code>C.GoStringN(&amp;field, 64)</code>，那么你得到的 Go 字符串一定是 64 个字符，字符串的末尾有可能是一串 <code>\0</code> 字符。</p><p>(我认为这是 cgo 文档中的一个 bug。它宣称 GoStringN 的入参是一个 C 的字符串，但实际上很明显不是，因为 C 的字符串不能以 null 字符结束，而 GoStringN 不会在 null 字符处结束处理。)</p><p><code>C.GoBytes()</code> 是 <code>C.GoStringN()</code> 的另一个版本，不返回 <code>string</code> 而是返回 <code>[]byte</code>。它没有宣称以 C 字符串作为入参，它仅仅是对整个 buffer 做了内存拷贝。</p><p>如果你要拷贝的东西不是以 null 字符结尾的 C 字符串，而是固定长度的 memory buffer，那么 <code>C.GoString()</code> 正好能满足需求；它避开了 C 中传统的问题<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString" target="_blank" rel="noopener">处理不是 C 字符串的 ’string‘</a>。然而，如果你要处理定义为 <code>char field[N]</code> 的结构体字段这种限定长度的 C 字符串时，这些函数<em>都不能</em>满足需求。</p><p>传统语义的结构体中固定长度的字符串变量，定义为 <code>char field[N]</code> 的字段，以及“包含一个字符串”等描述，都表示当且仅当字符串有足够空间时以 null 字符结尾，换句话说，字符串最多有 N-1 个字符。如果字符串正好有 N 个字符，那么它不会以 null 字符结尾。这是 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/UnixAPIMistake" target="_blank" rel="noopener">C 代码中诸多 bug 的根源</a>，也不是一个好的 API，但我们却摆脱不了这个 API。每次我们遇到这样的字段，文档不会明确告诉你字段的内容并不一定是 null 字符结尾的，你需要自己假设你有这种 API。</p><p><code>C.GoString()</code> 或 <code>C.GoStringN()</code> 都不能正确处理这些字段。使用 <code>GoStringN()</code> 相对来说出错更少；它仅仅返回一个末尾有一串 <code>\0</code> 字符长度为 N 的 Go 字符串（如果你仅仅是把这些字段打印出来，那么你可能不会留意到；我经常干这种事）。使用有诱惑力的 <code>GoString()</code> 更是引狼入室，因为它内部会对入参做 <code>strlen()</code>；如果字符末尾没有 null 字符，<code>strlen()</code> 会访问越界的内存地址。如果你走运，你得到的 Go 字符串末尾会有大量的垃圾。如果你不走运，你的 Go 程序出现段错误，因为 <code>strlen()</code> 访问了未映射的内存地址。</p><p>（总的来说，如果字符串末尾出现了大量垃圾，通常意味着在某处有不含结束符的 C 字符串。）</p><p>你需要的是与 C 的 <code>strndup()</code> 等价的 Go 函数，以此来确保复制不超过 N 个字符且在 null 字符处终止。下面是我写的版本，不保证无错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   s := C.GoStringN(cs, C.<span class="keyword">int</span>(<span class="built_in">len</span>))</span><br><span class="line">   i := strings.IndexByte(s, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> C.GoString(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于有 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding" target="_blank" rel="noopener">Go 的字符串怎样占用内存</a>的问题，这段代码做了些额外的工作来最小化额外的内存占用。你可能想用另一种方法，返回一个 <code>GoStringN()</code> 字符串的切片。你也可以写复杂的代码，根据 i 和 len 的不同来决定选用哪种方法。</p><p>更新：<a href="https://github.com/golang/go/issues/12428#issuecomment-136581154" target="_blank" rel="noopener">Ian Lance Taylor 给我展示了份更好的代码</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> C.GoStringN(cs, C.<span class="keyword">int</span>(C.strnlen(cs, C.size_t(<span class="built_in">len</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，这里有大量的转换。这篇文章就是你看到的 Go 和 Gco 类型的结合。</p><hr><p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions" target="_blank" rel="noopener">https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions</a></p><p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann" target="_blank" rel="noopener">ChrisSiebenmann</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/cgo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cgo&lt;/a&gt; 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go 字符串中的潜在问题</title>
    <link href="https://lxb.wiki/10e5e8ba/"/>
    <id>https://lxb.wiki/10e5e8ba/</id>
    <published>2020-01-16T16:12:58.000Z</published>
    <updated>2020-04-28T16:59:35.711Z</updated>
    
    <content type="html"><![CDATA[<p>在我之前的文章 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike" target="_blank" rel="noopener">Go 中我喜欢的东西</a>中提到过，我喜欢的 <a href="https://golang.org/" target="_blank" rel="noopener">Go</a> 的东西其中之一就是它的字符串（通常还有切片）。从一个 Python 开发者的角度看，它们之所以伟大，是因为创建它们时开销很少，因为它们通常不需要复制。在 Python 中，任何时候操作字符串都需要复制一部分或全部字符串，而 <a href="https://utcc.utoronto.ca/~cks/space/blog/python/StringSpeedSurprises" target="_blank" rel="noopener">这很容易对性能造成影响</a>。想要写高性能的 Python 代码需要谨慎考虑复制的问题。在 Go 中，几乎所有的字符串操作都是不复制的，仅仅是从原字符串取一个子集（例如去除字符串首尾的空白字符），因此你可以更自由地操作字符串。这个机制可以非常直接地解决你的问题，并且非常高效。</p><p>（当然，不是所有的字符串操作都不复制。例如，把一个字符串转换成大写需要复制，尽管 Go 中的实现已经足够智能，在不需要改变原字符串时 — 例如由于它已经是一个全大写的字符串 — 可以规避掉复制。）</p><p>但是这个优势也带来了潜在的坏处，那些没有开销的子字符串使原来的整个字符串一直存在于内存中。Go 中的字符串（和切片）操作之所以内存开销很少，是因为它们只是底层存储（字符串或切片底层的数组的真实数据）的一些部分的引用；创建一个字符串做的操作就是创建了一个新的引用。但是 Go（目前）不会对字符串数据或数组进行部分的垃圾回收，所以即使它一个很小的 bit 被其它元素引用，整个对象也会一直保持在内存中。换句话说，一个单字符的字符串（目前）足够让一个巨大的字符串不被 GC 回收。</p><p>当然，不会有很多人遇到这个问题。为了遇到它，你需要处理一个非常庞大的原字符串，或造成大量的内存消耗（或者两者都做），在这个基础上，你必须创建那些不持久的字符串的持久的小子字符串（好吧，你是多么希望它是非持久的）。很多使用场景不会复现这个问题；要么你的原字符串不够大，要么你的子集获取了大部分原字符串（例如你把原字符串进行了分词处理），要么子字符串生命周期不够长。简而言之，如果你是一个普通的 Go 开发者，你可以忽略这个问题。处理长字符串并且长时间维持原字符串的很小部分的人才会关注这个问题。</p><p>（我之所以关注到这个问题，是因为一次我花了大量精力用尽可能少的内存写 Python 程序，尽管它是从一个大的配置文件解析结果然后分块储存。这让我联想到了一些其他的事，如字符串的生命周期、限制字符串只复制一次，等等。然后我用 Go 语言写了一个解析器，这让我由重新考虑了一下这些问题，我意识到由于我的解析器截取出和维持的 bit 一直存在于内存中，从输入文件解析出的庞大字符串也会一直存在与内存中。）</p><p>顺便说一下，我认为这是 Go 做了权衡之后的正确结果。大部分使用字符串的开发者不会遇到这个问题，而且截取子字符串开销很小对于开发者来说用处很大。这种低开销的截取操作也减轻了 GC 的负担；当代码使用大量的子字符串截取（像 Python 中那样）时，你只需要处理固定长度的字符串引用就可以了，而不是需要处理长度变化的字符串。</p><p>当你的代码遇到这个问题时，当然有明显的解决方法：创建一个函数，通过把字符串转换成 <code>[]byte</code> 来 ”最小化“ 字符串，然后返回。这种方法生成了一个最小化的字符串，内存开销是理论上最完美实现的只复制一次，而 Go 现在很容易就可以实现。</p><h2 id="附加问题：strings-ToUpper-等怎样规避没有必要的复制"><a href="#附加问题：strings-ToUpper-等怎样规避没有必要的复制" class="headerlink" title="附加问题：strings.ToUpper() 等怎样规避没有必要的复制"></a>附加问题：<code>strings.ToUpper()</code> 等怎样规避没有必要的复制</h2><p>所有的主动转换函数像 <code>ToUpper()</code> 和 <code>ToTitle()</code> 是用 <code>strings.Map()</code> 和 <a href="http://golang.org/pkg/unicode/" target="_blank" rel="noopener">unicode 包</a> 中的函数实现的。<code>Map()</code> 足够智能，在映射的函数返回一个与已存在的 <code>rune</code> 不同的结果之前不会创建新的字符串。因此，你代码中所有类似的直接使用 <code>Map()</code> 的地方都不会有内存开销。</p><hr><p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding" target="_blank" rel="noopener">https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding</a></p><p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann" target="_blank" rel="noopener">Chris Siebenmann</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/校对者ID" target="_blank" rel="noopener">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我之前的文章 &lt;a href=&quot;https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 中我喜欢的东西&lt;/a&gt;中提到过，我喜
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go GC 怎么标记内存</title>
    <link href="https://lxb.wiki/b3baee92/"/>
    <id>https://lxb.wiki/b3baee92/</id>
    <published>2020-01-13T16:06:31.000Z</published>
    <updated>2020-04-28T16:59:24.007Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p><p>ℹ️ 本文基于 <em>Go 1.13</em>。关于内存管理的概念的讨论在我的文章 <a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44" target="_blank" rel="noopener">Go 中的内存管理和分配</a> 中有详细的解释。</p><p>Go GC 的作用是回收不再使用的内存。实现的算法是并发的三色标记和清除回收法。本中文，我们研究三色标记法，以及各个颜色的不同用处。</p><p>你可以在 Ken Fox 的 <a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/" target="_blank" rel="noopener">解读垃圾回收算法</a> 中了解更多关于不同垃圾回收机制的信息。</p><h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><p>这个阶段浏览内存来了解哪些块儿是在被我们的代码使用和哪些块儿应该被回收。</p><p>然而，因为 GC 和我们的 Go 程序并行，GC 扫描期间内存中某些对象的状态可能被改变，所以需要一个检测这种可能的变化的方法。为了解决这个潜在的问题，实现了 <a href="https://en.wikipedia.org/wiki/Write_barrier" target="_blank" rel="noopener">写屏障</a> 算法，GC 可以追踪到任何的指针修改。使写屏障生效的唯一条件是短暂终止程序，又名 “Stop the World”。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/01.png" alt></p><p>在进程启动时，Go 也在每个 processor 起了一个标记 worker 来辅助标记内存。</p><p>然后，当 root 被加入到处理队列中后，标记阶段就开始遍历和用颜色标记内存。</p><p>为了了解在标记阶段的每一步，我们来看一个简单的程序示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct1 <span class="keyword">struct</span> &#123;</span><br><span class="line">a, b <span class="keyword">int64</span></span><br><span class="line">c, d <span class="keyword">float64</span></span><br><span class="line">e *struct2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> struct2 <span class="keyword">struct</span> &#123;</span><br><span class="line">f, g <span class="keyword">int64</span></span><br><span class="line">h, i <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := allocStruct1()</span><br><span class="line">s2 := allocStruct2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">_ = allocStruct2()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"s1 = %X, s2 = %X\n"</span>, &amp;s1, &amp;s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct1</span><span class="params">()</span> *<span class="title">struct1</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;struct1&#123;</span><br><span class="line">e: allocStruct2(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct2</span><span class="params">()</span> *<span class="title">struct2</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;struct2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct2</code> 不包含指针，因此它被储存在一个专门存放不被其他对象引用的对象的 span 中。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/02.png" alt="不包含指针的结构体储存在专有的 span 中"></p><p>这减少了 GC 的工作，因为标记内存时不需要扫描这个 span。</p><p>分配工作结束后，我们的程序强迫 GC 重复前面的步骤。下面是流程图：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/03.png" alt="扫描内存"></p><p>GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。扫描到被标记为 <code>no scan</code> 的 span 时，停止扫描。然而，这个工作是在多个协程中完成的，每个指针被加入到一个 work pool 中的队列。然后，后台运行的标记 worker 从这个 work pool 中拿到前面出列的 work，扫描这个对象然后把在这个对象里找到的指针加入到队列。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/04.png" alt="garbage collector work pool"></p><h2 id="颜色标记"><a href="#颜色标记" class="headerlink" title="颜色标记"></a>颜色标记</h2><p>worker 需要一种记录哪些内存需要扫描的方法。GC 使用一种 <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking" target="_blank" rel="noopener">三色标记算法</a>，工作流程如下：</p><ul><li>开始时，所有对象都被认为是<strong>白色</strong></li><li>root 对象（栈，堆，全局变量）被标记为<strong>灰色</strong></li></ul><p>这个初始步骤完成后，GC 会：</p><ul><li>选择一个<strong>灰色</strong>的对象，标记为<strong>黑色</strong></li><li>追踪这个对象的所有指针，把所有引用的对象标记为<strong>灰色</strong></li></ul><p>然后，GC 重复以上两步，直到没有对象可被标记。在这一时刻，对象非黑即白，没有灰色。白色的对象表示没有其他对象引用，可以被回收。</p><p>下面是前面例子的图示：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/05.png" alt></p><p>初始状态下，所有的对象被认为是白色的。然后，遍历到的且被其他对象引用的对象，被标记为灰色。如果一个对象在被标记为 <code>no scan</code> 的 span 中，因为它不需要被扫描，所以可以标记为黑色。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/06.png" alt></p><p>现在灰色的对象被加入到扫描队列并被标记为黑色：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/07.png" alt></p><p>对加入到扫描队列的所有对象重复做相同的操作，直到没有对象需要被处理：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/08.png" alt></p><p>处理结束时，黑色对象表示内存中在使用的对象，白色对象是要被回收的对象。我们可以看到，由于 <code>struct2</code> 的实例是在一个匿名函数中创建的且不再存在于栈上，因此它是白色的且可以被回收。</p><p>归功于每一个 span 中的名为 <code>gcmarkBits</code> 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 scan。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/09.png" alt></p><p>我们可以看到，黑色和灰色表示的意义相同。处理的不同之处在于，标记为灰色时是把对象加入到扫描队列，而标记为黑色时，不再扫描。</p><p>GC 最终 STW，清除每一次写屏障对 work pool 做的改变，继续后续的标记。</p><p><em>你可以在我的文章 <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35" target="_blank" rel="noopener">Go GC 怎样监控你的应用</a> 中找到关于并发处理和 GC 的标记阶段更详细的描述</em>。</p><h2 id="runtime-分析器"><a href="#runtime-分析器" class="headerlink" title="runtime 分析器"></a>runtime 分析器</h2><p>Go 提供的工具使我们可以对每一步进行可视化，观察 GC 在我们的程序中的影响。开启 tracing 运行我们的代码，可以看到前面所有步骤的一个概览。下面是追踪结果：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/10.png" alt="traces of the garbage collector"></p><p>标记 worker 的生命周期也可以在追踪结果中以协程等级可视化。下面是在启动之前先在后台等待标记内存的 goroutine #33 的例子。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/11.png" alt="marking worker"></p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/校对者ID" target="_blank" rel="noopener">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
      <category term="gc" scheme="https://lxb.wiki/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>微服务中的熔断器和重试</title>
    <link href="https://lxb.wiki/c9399f4/"/>
    <id>https://lxb.wiki/c9399f4/</id>
    <published>2019-12-12T15:02:17.000Z</published>
    <updated>2019-12-12T15:07:33.468Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。</p><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/01.png" alt="01"></p><p>想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。</p><p>后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/02.png" alt="02"></p><p>熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/03.png" alt="03"></p><p>通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 <a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">wikipedia</a>）可能不会遇到这种网络模式。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/04.png" alt="04"></p><p>熔断器有三个主要的状态：</p><ul><li>Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 <strong>Max Concurrency</strong>（最大并发数）和 <strong>Timeout</strong>（超时）。</li><li>Open：所有的请求都会返回 <strong>Circuit Open</strong> 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。</li><li>Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。</li></ul><h2 id="熔断器原理"><a href="#熔断器原理" class="headerlink" title="熔断器原理"></a>熔断器原理</h2><p>控制熔断的设置共有 5 个主要参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommandConfig is used to tune circuit settings at runtime</span></span><br><span class="line"><span class="keyword">type</span> CommandConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Timeout                <span class="keyword">int</span> <span class="string">`json:"timeout"`</span></span><br><span class="line">MaxConcurrentRequests  <span class="keyword">int</span> <span class="string">`json:"max_concurrent_requests"`</span></span><br><span class="line">RequestVolumeThreshold <span class="keyword">int</span> <span class="string">`json:"request_volume_threshold"`</span></span><br><span class="line">SleepWindow            <span class="keyword">int</span> <span class="string">`json:"sleep_window"`</span></span><br><span class="line">ErrorPercentThreshold  <span class="keyword">int</span> <span class="string">`json:"error_percent_threshold"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go" target="_blank" rel="noopener">查看源码</a></p><p>可以通过根据两个服务的 SLA（‎ Service Level Agreement，<a href="https://zh.wikipedia.org/zh-hans/服务级别协议" target="_blank" rel="noopener">服务级别协议</a>）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。</p><p>一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。</p><h2 id="生产上的熔断器"><a href="#生产上的熔断器" class="headerlink" title="生产上的熔断器"></a>生产上的熔断器</h2><p>熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>这段实例代码用的是 <a href="http://github.com/afex/hystrix-go/hystrix" target="_blank" rel="noopener">hystrix-go</a> 库，hystrix Netflix 库在 Golang 的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/afex/hystrix-go/hystrix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandName = <span class="string">"producer_api"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hystrix.ConfigureCommand(commandName, hystrix.CommandConfig&#123;</span><br><span class="line">Timeout:                <span class="number">500</span>,</span><br><span class="line">MaxConcurrentRequests:  <span class="number">100</span>,</span><br><span class="line">ErrorPercentThreshold:  <span class="number">50</span>,</span><br><span class="line">RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">SleepWindow:            <span class="number">1000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, logger(handle))</span><br><span class="line">log.Println(<span class="string">"listening on :8080"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">errors := hystrix.Go(commandName, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// talk to other services</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="comment">// err := callWithRetryV1()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">output &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out := &lt;-output:</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">log.Printf(<span class="string">"success %v"</span>, out)</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errors:</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line">log.Printf(<span class="string">"failed %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger is Handler wrapper function for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(fn http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(r.URL.Path, r.Method)</span><br><span class="line">fn(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callChargeProducerAPI</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(os.Getenv(<span class="string">"SERVER_ERROR"</span>))</span><br><span class="line"><span class="keyword">if</span> os.Getenv(<span class="string">"SERVER_ERROR"</span>) == <span class="string">"1"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"503 error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 中分别测试了请求调用链 closed 和 open 两种情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Experiment 1: success path */</span><br><span class="line">// server</span><br><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">/* Experiment 2: circuit open */</span><br><span class="line">// server</span><br><span class="line">SERVER_ERROR=1 Go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试问题"><a href="#重试问题" class="headerlink" title="重试问题"></a>重试问题</h2><p>在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。</p><p>一段简单的重试代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callWithRetryV1</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">3</span>; index++ &#123;</span><br><span class="line"><span class="comment">// call producer API</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding backoff</span></span><br><span class="line"><span class="comment">// adding jitter</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h2><p>为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。</p><p>一起来看下列算法：</p><ul><li>Exponential: bash * 2<sup>attemp</sup></li><li>Full Jitter: sleep = rand(0, base * 2<sup>attempt</sup>)</li><li>Equal Jitter: temp = base * 2<sup>attemp</sup>; sleep = temp/2+rand(0, temp/2)</li><li>De-corredlated Jitter: sleep = rand(base, sleep*3)</li></ul><p>【译注】关于这几个算法，可以参考<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a> 。<strong>Full Jitter</strong>、 <strong>Equal Jitter</strong>、 <strong>De-corredlated</strong> 等都是原作者自己定义的名词。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/05.png" alt="05"></p><p>客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a>中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。</p><h2 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/06.png" alt="Example configuration of both tools"></p><p>熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://github.com/afex/hystrix-go/" target="_blank" rel="noopener">https://github.com/afex/hystrix-go/</a></li><li><a href="https://github.com/eapache/go-resiliency" target="_blank" rel="noopener">https://github.com/eapache/go-resiliency</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></li><li><a href="https://www.awsarchitectureblog.com/2015/03/backoff.html" target="_blank" rel="noopener">https://www.awsarchitectureblog.com/2015/03/backoff.html</a></li><li><a href="https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience" target="_blank" rel="noopener">https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience</a></li></ol><hr><p>via: <a href="https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/" target="_blank" rel="noopener">https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/</a></p><p>作者：<a href="http://github.com/titpetric" target="_blank" rel="noopener">Tit Petric</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25295" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。&lt;/p&gt;
&lt;h2 id=&quot;熔断器&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>协程，操作系统线程和 CPU 管理</title>
    <link href="https://lxb.wiki/4e717bb5/"/>
    <id>https://lxb.wiki/4e717bb5/</id>
    <published>2019-12-12T15:01:35.000Z</published>
    <updated>2019-12-12T15:06:59.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French."></p><p>ℹ️ <em>本文运行环境为 Go 1.13</em></p><p>对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。</p><h2 id="M-P-G-编排"><a href="#M-P-G-编排" class="headerlink" title="M, P, G 编排"></a>M, P, G 编排</h2><p>为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The main concepts are:</span><br><span class="line">G - goroutine.</span><br><span class="line">M - worker thread, or machine.</span><br><span class="line">P - processor, a resource that is required to execute Go code.</span><br><span class="line">    M must have an associated P to execute Go code[...].</span><br></pre></td></tr></table></figure><p><code>P</code>, <code>M</code>, <code>G</code> 模型图解：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/01.png" alt="P, M, G diagram"></p><p>每个协程（<code>G</code>）运行在与一个逻辑 CPU（<code>P</code>）相关联的 OS 线程（<code>M</code>）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`hello`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`world`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Go 根据机器逻辑 CPU 的个数来创建不同的 <code>P</code>，并且把它们保存在一个空闲 <code>P</code> 的 list 里。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/02.png" alt="P initialization"></p><p>然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 <code>P</code>。这个 <code>P</code> 通过与之相关联的 OS 线程来创建一个 <code>M</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/03.png" alt="OS thread creation"></p><p>然而，像 <code>P</code> 那样，系统调用返回的甚至被 gc 强行停止的空闲的 <code>M</code> — 比如没有协程在等待运行 — 也会被加到一个空闲 list：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/04.png" alt="M and P idle list"></p><p>在程序启动阶段，Go 就已经创建了一些 OS 线程并与 <code>M</code> 想关联了。在我们的例子中，打印 <code>hello</code> 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 <code>M</code> 和 <code>P</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/05.png" alt="M and P pulled from the idle list"></p><p>现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 <code>P</code> 多的 <code>M</code>，在系统调用时怎么管理协程。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 <code>P</code> 和线程 <code>M</code> 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   fd, _ := os.Open(<span class="string">"number.txt"</span>)</span><br><span class="line">   fd.Read(buf)</span><br><span class="line">   fd.Close()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="keyword">string</span>(buf)) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读取的流程如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/06.png" alt="Syscall handoffs P"></p><p><code>P0</code> 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。</p><ul><li>尝试去捕获相同的 <code>P</code>，在我们的例子中就是 <code>P0</code>，然后 resume 执行过程</li><li>尝试从空闲 list 中捕获一个 <code>P</code>，然后 resume 执行过程</li><li>把协程放到全局队列里，把与之相关联的 <code>M</code> 放回空闲 list 去</li></ul><p>然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 <code>M</code> 不会阻塞：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/07.png" alt="Network poller waiting for the resource"></p><p>在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/08.png" alt></p><p>如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。</p><h2 id="OS-线程方面的限制"><a href="#OS-线程方面的限制" class="headerlink" title="OS 线程方面的限制"></a>OS 线程方面的限制</h2><p>在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：</p><blockquote><p><em>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</em></p></blockquote><p>译注：<strong>GOMAXPROCS</strong> 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 <strong>GOMAXPROCS</strong> 没有影响。这个包的 <strong><em>GOMAXPROCS</em></strong> 函数查询和修改这个最大数限制。</p><p>对这种情形举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++  &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         http.Get(<span class="string">`https://httpstat.us/200?sleep=10000`</span>)</span><br><span class="line"></span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用追踪工具得到的线程数如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/09.png" alt></p><p>由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。</p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25292" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png&quot; alt=&quot;Illus
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Symbol Names of Keyboard</title>
    <link href="https://lxb.wiki/2d9f52fc/"/>
    <id>https://lxb.wiki/2d9f52fc/</id>
    <published>2019-12-07T02:22:50.000Z</published>
    <updated>2019-12-07T02:25:27.232Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">符号英文名中文名</span><br><span class="line">~tilde or swung dash波浪字符或代字号</span><br><span class="line">!exclamation mark惊叹号</span><br><span class="line">@at sign or commercial at爱特或小老鼠</span><br><span class="line"><span class="comment">#number sign井号</span></span><br><span class="line">$dollar sign美元符</span><br><span class="line">%percent sign百分号</span><br><span class="line">^caret脱字符</span><br><span class="line">&amp;ampersand与和符</span><br><span class="line">*asterisk星号</span><br><span class="line">()parentheses, round brackets, soft brackets, </span><br><span class="line">or circle brackets 小括号，圆括号</span><br><span class="line">[]brackets (US), square brackets, </span><br><span class="line">closed brackets or hard brackets中括号，方括号</span><br><span class="line">&#123;&#125;braces (UK and US), French brackets, </span><br><span class="line">curly brackets大括号，花括号</span><br><span class="line">&lt;&gt; angle brackets or chevrons尖括号</span><br><span class="line">_underscore下划线</span><br><span class="line">+plus sign加号</span><br><span class="line">−minus sign减号</span><br><span class="line">=equals sign等号</span><br><span class="line">&lt; less-than sign小于号</span><br><span class="line">&gt; greater-than sign大于号</span><br><span class="line">.period, full stop or dot句号，点</span><br><span class="line">,comma逗号</span><br><span class="line">:colon 冒号</span><br><span class="line">;semicolon分号</span><br><span class="line">?question mark问号</span><br><span class="line">-hyphen连字符</span><br><span class="line">...ellipsis省略号</span><br><span class="line">–dash破折号</span><br><span class="line">/slash, forward slash斜线</span><br><span class="line">\backslash反斜线</span><br><span class="line">|vertical bar竖线</span><br><span class="line">“quotation mark双引号</span><br><span class="line">‘apostrophe单引号，省略符号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="symbol" scheme="https://lxb.wiki/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>go匿名函数和闭包</title>
    <link href="https://lxb.wiki/e2c91def/"/>
    <id>https://lxb.wiki/e2c91def/</id>
    <published>2019-11-17T06:38:20.000Z</published>
    <updated>2019-11-17T06:39:01.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数变量-函数值"><a href="#函数变量-函数值" class="headerlink" title="函数变量(函数值)"></a>函数变量(函数值)</h3><p>在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func square(x int) &#123;</span><br><span class="line">println(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接调用：square(1)</li><li>把函数当成变量一样赋值：<code>s := square</code>；接着可以调用这个函数变量：s(1)。 注意：这里 square 后面没有圆括号，调用才有。</li></ol><ul><li>调用 <code>nil</code> 的函数变量会导致 panic。</li><li>函数变量的零值是 nil，这意味着它可以跟 nil 比较，但两个函数变量之间不能比较。</li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>作用: 在go语言中目前了解的作用就是用于构成闭包</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包通过引用的方式使用外部函数的变量<br>函数与 与其(直接)相关的环境形成闭包</p><p>简单来说: 因为把返回的函数赋给了一个变量, 虽然函数在执行完一瞬间会销毁其执行环境, 但是如果有闭包的话, 闭包会保存外部函数的活动对象(变量), 所以如果不对闭包的引用消除掉, 闭包会一直存在内存中, 垃圾收集器不会销毁闭包占用的内存</p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//函数A是一个不带参数，返回值是一个匿名函数，且该函数</span><br><span class="line">//带有一个int类型参数，返回值为一个int类型</span><br><span class="line">func A() func(int) int &#123;</span><br><span class="line">sum := 0</span><br><span class="line">return func(bb int) int &#123;</span><br><span class="line">sum += bb</span><br><span class="line">fmt.Println(&quot;bb=&quot;, bb, &quot;\tsum=&quot;, sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()//定义变量a,并将函数A的返回值赋给a // 这个时候, 虽然有小括号, 但是func A()还未真正执行, 只是赋值给了变量a</span><br><span class="line">b := a(4) //真正执行func A()</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：   </span><br><span class="line">**    bb= 4   sum= 4</span><br><span class="line">**    4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>调用2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()</span><br><span class="line">a(0)</span><br><span class="line">a(1)</span><br><span class="line">a(5)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 sum= 0</span><br><span class="line">**　　bb= 1 sum= 1</span><br><span class="line">**　　bb= 5 sum= 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>以上调用通过闭包实现了sum的累加</p><p>调用3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()</span><br><span class="line">c := A()</span><br><span class="line">a(0)</span><br><span class="line">a(5)</span><br><span class="line">c(10)</span><br><span class="line">c(20)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 sum= 0</span><br><span class="line">**　　bb= 5 sum= 5</span><br><span class="line">**　　bb= 10 sum= 10</span><br><span class="line">**　　bb= 20 sum= 30   </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>　可以看出，上例中调用了两次函数A，构成了两个闭包，这两个闭包维护的变量sum不是同一个变量。　　</p><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = func() &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := B() // 这个时候并未真正执行函数, 只是定义, 所以不会print</span><br><span class="line">c[0]() // 这个时候真正执行, 但是由于闭包, c[0] 中拿的i的引用</span><br><span class="line">c[1]()</span><br><span class="line">c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>闭包通过引用的方式使用外部函数的变量。</p><p>　　上例中只调用了一次函数B,构成一个闭包(<code>func() {fmt.Println(i)}</code> 与它的环境<code>func B() []func(){}</code> 构成闭包)，i 在外部函数B中定义，所以闭包维护该变量 i ，c[0]、c[1]、c[2]中的 i 都是闭包中 i 的引用。</p><p>　　因此执行<code>c:=B()</code>后，i 的值已经变为3，故再调用c<a href>0</a>时的输出是3而不是0。<br>　　<br>可作如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = (func(j int) func() &#123;</span><br><span class="line">return func() &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i) // 这个地方的小括号是真正执行了</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := B()</span><br><span class="line">c[0]()</span><br><span class="line">c[1]()</span><br><span class="line">c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：</span><br><span class="line">**        0</span><br><span class="line">**        1</span><br><span class="line">**        2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>函数<code>func() {fmt.Println(j)}</code> 与它的环境<code>func(j int) func() {}</code> 构成闭包, 变量<code>i</code>(实参) 并没有在它的环境范围内, 且 <code>j</code>是形参<br>以上修改可能没有什么实际意义，此处仅为说明问题使用。</p><p>在使用defer的时候可能出现类似问题，需要注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 2; j++ &#123;</span><br><span class="line">defer (func() &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;)()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：    </span><br><span class="line">**    2    </span><br><span class="line">**    2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3:"></a>实例3:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func incr() func() int &#123;</span><br><span class="line">var x int</span><br><span class="line">return func() int &#123;</span><br><span class="line">x++</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个函数会返回一个函数变量。<br><code>i := incr()</code> : 通过把这个函数变量赋值给<code>i</code>, <code>i</code> 就成为了一个闭包<br>所以<code>i</code> 保存着对<code>x</code> 的引用, 可以想象<code>i</code> 中有着一个指针指向<code>x</code> 或者 <code>i</code> 中有<code>x</code> 的地址</p><p>由于<code>i</code> 有着指向<code>x</code> 的指针, 所以可以修改<code>x</code> , 且保持着状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(i()) // 1</span><br><span class="line">println(i()) // 2</span><br><span class="line">println(i()) // 3</span><br></pre></td></tr></table></figure><p>也就是说, <code>x</code> 逃逸了, 它的声明周期没有随着它的作用域结束而结束<br>但是这段代码却不会递增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br></pre></td></tr></table></figure><p>这是因为这里调用了三次 <code>incr()</code>，返回了三个闭包，这三个闭包引用着三个不同的 <code>x</code>，它们的状态是各自独立的。</p><h4 id="实例4-闭包引用产生的问题"><a href="#实例4-闭包引用产生的问题" class="headerlink" title="实例4: 闭包引用产生的问题"></a>实例4: 闭包引用产生的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">f := func() &#123;</span><br><span class="line">println(x)</span><br><span class="line">&#125;</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br><span class="line">f() // 3</span><br></pre></td></tr></table></figure><p>因为闭包对外层词法域变量是引用的，所以这段代码会输出 3。<br>可以想象 f 中保存着 x 的地址，它使用 x 时会直接解引用，所以 x 的值改变了会导致 f 解引用得到的值也会改变。<br>但是，这段代码却会输出 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">println(x) // 1</span><br><span class="line">&#125;()</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br></pre></td></tr></table></figure><p>这是因为 f 调用时就已经解引用取值了，这之后的修改就与它无关了。</p><p>不过如果再次调用 f 还是会输出 3，这也再一次证明了 f 中保存着 x 的地址。<br>可以通过在闭包内外打印所引用变量的地址来证明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br><span class="line">&#125;()</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br></pre></td></tr></table></figure><p>可以看到引用的是同一个地址。</p><h4 id="实例5-1-循环闭包引用"><a href="#实例5-1-循环闭包引用" class="headerlink" title="实例5.1: 循环闭包引用"></a>实例5.1: 循环闭包引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">func() &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">f := func() &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次迭代后都对 i 进行了解引用并使用得到的值且不再使用，所以这段代码会正常输出。</p><h4 id="实例5-2"><a href="#实例5-2" class="headerlink" title="实例5.2"></a>实例5.2</h4><p>正常代码：输出 0, 1, 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这段代码会输出 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">var f func()</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">f = func() &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() // 3 这个地方i最后的值是3, 而不是2, 因为只有i的值是3时, 才会跳出循环</span><br></pre></td></tr></table></figure><h4 id="实例5-3"><a href="#实例5-3" class="headerlink" title="实例5.3"></a>实例5.3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">funcSlice[j]() // 3, 3, 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上面这种情况, 可以声明新的匿名函数并传参:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">func(k int) &#123;</span><br><span class="line">funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">println(k)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">funcSlice[j]() // 0, 1, 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>println(k)</code> 使用的 <code>k</code> 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。(把<code>k</code>换成<code>i</code>也没有问题, 即使它与for条件的中的<code>i</code> 和func的入参<code>i</code> 重名也能正常运行)</p><p>所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p><p>这里的解决方法可以用在大多数跟闭包引用有关的问题上，不局限于第三个例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数变量-函数值&quot;&gt;&lt;a href=&quot;#函数变量-函数值&quot; class=&quot;headerlink&quot; title=&quot;函数变量(函数值)&quot;&gt;&lt;/a&gt;函数变量(函数值)&lt;/h3&gt;&lt;p&gt;在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>合并区间56</title>
    <link href="https://lxb.wiki/a2b71d73/"/>
    <id>https://lxb.wiki/a2b71d73/</id>
    <published>2019-11-06T15:31:03.000Z</published>
    <updated>2019-11-06T16:00:13.168Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>思路: </p><ol start="0"><li>怎么判断重叠: 两区间的最小的右边界 大于或等于 两区间最大的左边界. 如<code>[1,5]</code>和<code>[2,8]</code></li><li>入参是切片的切片(intervals), 拿<code>intervals[0]</code>与它后面的所有区间对比, 从<code>intervals[1]</code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给<code>intervals[0]</code>, 并删除参与合并的那个旧区间</li><li><code>intervals[0]</code>完成后, 拿``intervals[1]<code>与它后边的所有区间对比, 从</code>intervals[2]<code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给</code>intervals[1]`, 并删除参与合并的那个就区间</li><li>拿<code>intervals[i]</code> 与它后边的所有区间对比, 从<code>intervals[i+1]</code> 开始, 如果有与之重叠的区间intervals[j]   , 就把合并后的新区间赋给 <code>intervals[i]</code> , 并删除参与合并的intervals[j]</li><li>如果第3步出现了有重叠的区间<code>intervals[j]</code>, 那么合并后<code>i</code>  的值变了, 就有可能由原来 在<code>i</code> 到<code>j</code> 之间没有重叠的区间 变成 有重叠的区间, 所以需要从头(<code>i+1</code>) 再遍历一次, 直到再也没有重叠的区间</li><li>重复, 一直到切片末尾</li></ol><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intervals); &#123;</span><br><span class="line">merged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(intervals); j++ &#123;</span><br><span class="line">x, y := intervals[i], intervals[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min(x[<span class="number">1</span>], y[<span class="number">1</span>]) &gt;= max(x[<span class="number">0</span>], y[<span class="number">0</span>]) &#123;</span><br><span class="line">merged = <span class="literal">true</span></span><br><span class="line"><span class="comment">//重新赋值</span></span><br><span class="line">intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] = min(x[<span class="number">0</span>], y[<span class="number">0</span>]), max(x[<span class="number">1</span>], y[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除j</span></span><br><span class="line">intervals[j] = intervals[<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">intervals = intervals[:<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merged &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang的反射</title>
    <link href="https://lxb.wiki/1d3c1f0e/"/>
    <id>https://lxb.wiki/1d3c1f0e/</id>
    <published>2019-11-03T13:21:59.000Z</published>
    <updated>2019-11-03T13:48:01.705Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编程语言中反射的概念"><a href="#编程语言中反射的概念" class="headerlink" title="编程语言中反射的概念"></a>编程语言中反射的概念</h4><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p><p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p><p>Golang的gRPC也是通过反射实现的。</p><h4 id="interface-和反射"><a href="#interface-和反射" class="headerlink" title="interface 和反射"></a>interface 和反射</h4><p>先来看看Golang关于类型设计的一些原则</p><ul><li>变量包括（value, type）两部分<ul><li>理解这一点就知道为什么nil != nil了</li></ul></li><li>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</li><li>类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</li></ul><p>反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><p><code>(value, type)</code></p><p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p><p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)</span><br><span class="line"></span><br><span class="line">var r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure><p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p><p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p><h4 id="reflect-基本功能TypeOf和ValueOf"><a href="#reflect-基本功能TypeOf和ValueOf" class="headerlink" title="reflect 基本功能TypeOf和ValueOf"></a>reflect 基本功能TypeOf和ValueOf</h4><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="line">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="line">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></pre></td></tr></table></figure><p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type: &quot;, reflect.TypeOf(num))</span><br><span class="line">fmt.Println(&quot;value: &quot;, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">type:  float64</span><br><span class="line">value:  1.2345</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li><li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li><li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li></ol><h4 id="从relfect-Value中获取接口interface的信息"><a href="#从relfect-Value中获取接口interface的信息" class="headerlink" title="从relfect.Value中获取接口interface的信息"></a>从relfect.Value中获取接口interface的信息</h4><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p><p><strong>已知原有类型【进行“强制转换”】</strong></p><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br><span class="line">// Golang 对类型要求非常严格，类型一定要完全符合</span><br><span class="line">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br><span class="line">convertPointer := pointer.Interface().(*float64)</span><br><span class="line">convertValue := value.Interface().(float64)</span><br><span class="line"></span><br><span class="line">fmt.Println(convertPointer)</span><br><span class="line">fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">0xc42000e238</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><ol><li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li><li>转换的时候，要区分是指针还是指</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li></ol><p><strong>未知原有类型【遍历探测其Filed】</strong></p><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFunc() &#123;</span><br><span class="line">fmt.Println(&quot;Allen.Wu ReflectCallFunc&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="line">func DoFiledAndMethod(input interface&#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(input)</span><br><span class="line">fmt.Println(&quot;get Type is :&quot;, getType.Name())</span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(input)</span><br><span class="line">fmt.Println(&quot;get all Fields is:&quot;, getValue)</span><br><span class="line"></span><br><span class="line">// 获取方法字段</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="line">// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="line">// 3. 最后通过Field的Interface()得到对应的value</span><br><span class="line">for i := 0; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(&quot;%s: %v = %v\n&quot;, field.Name, field.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br><span class="line">for i := 0; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(&quot;%s: %v\n&quot;, m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">get Type is : User</span><br><span class="line">get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="line">Id: int = 1</span><br><span class="line">Name: string = Allen.Wu</span><br><span class="line">Age: int = 25</span><br><span class="line">ReflectCallFunc: func(main.User)</span><br></pre></td></tr></table></figure><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.Value设置实际变量的值</strong></p><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var num float64 = 1.2345</span><br><span class="line">fmt.Println(&quot;old value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type of pointer:&quot;, newValue.Type())</span><br><span class="line">fmt.Println(&quot;settability of pointer:&quot;, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">// 重新赋值</span><br><span class="line">newValue.SetFloat(77)</span><br><span class="line">fmt.Println(&quot;new value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">////////////////////</span><br><span class="line">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br><span class="line">pointer = reflect.ValueOf(num)</span><br><span class="line">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: 1.2345</span><br><span class="line">type of pointer: float64</span><br><span class="line">settability of pointer: true</span><br><span class="line">new value of pointer: 77</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol><li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li><li>如果传入的参数不是指针，而是变量，那么<ul><li>通过Elem获取原始值对应的对象则直接panic</li><li>通过CanSet方法查询是否可以设置返回false</li></ul></li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.ValueOf来进行方法的调用</strong></p><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncHasArgs(name string, age int) &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncHasArgs name: &quot;, name, &quot;, age:&quot;, age, &quot;and origal User.Name:&quot;, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncNoArgs() &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何通过反射来进行方法的调用？</span><br><span class="line">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 2. 先看看带有参数的调用方法</span><br><span class="line">methodValue := getValue.MethodByName(&quot;ReflectCallFuncHasArgs&quot;)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(&quot;wudebao&quot;), reflect.ValueOf(30)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 3. 再看看无参数的调用方法</span><br><span class="line">methodValue = getValue.MethodByName(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">args = make([]reflect.Value, 0)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="line">ReflectCallFuncNoArgs</span><br></pre></td></tr></table></figure><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol><li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li><li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li><li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li><li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li><li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li></ol><p><strong>golang的反射reflect性能</strong></p><p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = clazz.getField(&quot;hello&quot;);</span><br><span class="line">field.get(obj1);</span><br><span class="line">field.get(obj2);</span><br></pre></td></tr></table></figure><p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。</p><p>但是Golang的反射不是这样设计的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.TypeOf(obj)</span><br><span class="line">field, _ := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.ValueOf(obj)</span><br><span class="line">fieldValue := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p><p>Golang reflect慢主要有两个原因</p><ol><li>涉及到内存分配以及后续的GC；</li><li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ul><li>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地<ul><li>反射必须结合interface才玩得转</li><li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li></ul></li><li>反射可以将“接口类型变量”转换为“反射类型对象”<ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul></li><li>反射可以将“反射类型对象”转换为“接口类型变量<ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历reflect.Type的Field获取其Field</li></ul></li><li>反射可以修改反射类型对象，但是其值必须是“addressable”<ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul></li><li>通过反射可以“动态”调用方法</li><li>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;编程语言中反射的概念&quot;&gt;&lt;a href=&quot;#编程语言中反射的概念&quot; class=&quot;headerlink&quot; title=&quot;编程语言中反射的概念&quot;&gt;&lt;/a&gt;编程语言中反射的概念&lt;/h4&gt;&lt;p&gt;在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>环形链表142</title>
    <link href="https://lxb.wiki/fb68a62c/"/>
    <id>https://lxb.wiki/fb68a62c/</id>
    <published>2019-10-30T16:09:51.000Z</published>
    <updated>2019-10-30T16:33:22.774Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p>解题关键是理解 <code>非环部分的长度</code>与<code>相遇点到环起点那部分环的长度</code> 是相等的 这个数学关系</p><p>假设非环部分长度为<code>x</code>, 从环起点到相遇点的长度为<code>y</code> , 环的长度为<code>c</code></p><p>慢指针(slow)走过的长度可以表示为``ds = x + n1 * c + y<code>, 快指针(fast) 的速度是慢指针的两倍, 意味着 快指针走过的长度为</code>df = 2(x + n1 * c + y)`</p><p>还有一个约束是, fast 走过的路程一定比slow走的路程多出环长度的整数倍(记为<code>n2 * c</code>)</p><p>所以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df - ds = n2 * c</span><br><span class="line">2(x + n1 * c + y) - (x + n1 * c + y) = n2 * c</span><br><span class="line">x + n1 * c + y = n2 * c</span><br></pre></td></tr></table></figure><p>解读下第三步的等式: 非环部分的长度 + 环起点到相遇点之间的长度 就是环的整数倍</p><p>意味着, 当以环的起点为原点时, 已经走过y(即前面<code>从环起点到相遇点的长度</code>)的前提下, 如果再走x , 就刚好走了很多圈(<code>n2 * c</code>). *”很多圈” 的意思, 就是从原点再到原点, 终点的位置和起点的位置重合.* </p><p>怎么才能再走x呢? 让一个指针从<code>head</code> 开始走, 另一个指针从相遇点开始走, 等这两个指针相遇, 就是走了x. 如果不能理解为何相遇恰好就在上面说的<strong>原点</strong>处, 应该反复琢磨斜体”很多圈”那句话</p><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">fast, slow := head, head</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="链表" scheme="https://lxb.wiki/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Github搜索</title>
    <link href="https://lxb.wiki/a813d59a/"/>
    <id>https://lxb.wiki/a813d59a/</id>
    <published>2019-10-28T15:03:30.000Z</published>
    <updated>2020-01-01T11:36:53.436Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 明确搜索仓库标题、仓库描述、README</strong></p><p><code>in:name 关键词</code></p><p>如果想查找描述的内容，可以使用这样的方式：</p><p><code>in:descripton 关键词</code></p><p>这里就是搜索上面项目描述的内容。</p><p>一般项目，都会有个README文件，如果要查该文件包含特定关键词的话</p><p><code>in:readme 关键词</code></p><p><strong>2. 明确搜索 star、fork 数大于多少的</strong></p><p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。</p><p><code>stars:&gt; 数字 关键字</code></p><p>比如要找 star 数大于 3000 的Spring Cloud 仓库，就可以这样</p><p><code>stars:&gt;3000 spring cloud</code></p><p>如果不加 &gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。</p><p>如果要找在指定数字区间的话，使用</p><p><code>stars: 10..20 关键词</code></p><p>fork 数同理，将上面的 stars 换成 <strong>fork</strong>，其它语法相同</p><p><strong>3. 明确搜索仓库大小的</strong></p><p>比如只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 <strong>size</strong> 。</p><p>使用方式：</p><p><code>size:&gt;=5000 关键词</code></p><p>这里注意下，这个数字代表K, 5000代表着5M。</p><p><strong>4. 明确仓库是否还在更新维护</strong></p><p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。</p><p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定<strong>更新时间</strong>在哪个时间前或后的</p><p>通过这样一条搜索 <code>pushed:&gt;2019-01-03 spring cloud</code></p><p>就找到了1月3号之后，还在更新的项目</p><p>想找指定时间之前或之后创建的仓库也是可以的，把 <strong>pushed</strong> 改成 <strong>created</strong> 就行。</p><p><strong>5. 明确搜索仓库的 LICENSE</strong></p><p>经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的<strong>LICENSE</strong>。开源不等于一切免费，不同的许可证要求也大不相同。 2018年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。</p><p>例如要找协议是最为宽松的 Apache License 2 的代码，可以这样</p><p><code>license:apache-2.0 spring cloud</code></p><p>其它协议就把 apache-2.0 替换一下即可，比如换成 <strong>mit</strong> 之类的。</p><p><strong>6. 明确搜索仓库的语言</strong></p><p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：</p><p><code>language:java 关键词</code></p><p><strong>7.明确搜索某个人或组织的仓库</strong></p><p><code>user:joshlong</code></p><p>组合使用一下，把 Java 项目过滤出来，多个查询之间「空格」分隔即可。</p><p><code>user:joshlong language:java</code></p><p>找某个组织的代码话，可以这样：</p><p><code>org:spring-cloud</code></p><p>就可以列出具体org 的仓库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. 明确搜索仓库标题、仓库描述、README&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:name 关键词&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想查找描述的内容，可以使用这样的方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in:descripton 关键词&lt;/cod
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="github" scheme="https://lxb.wiki/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="https://lxb.wiki/6a0b412d/"/>
    <id>https://lxb.wiki/6a0b412d/</id>
    <published>2019-10-23T14:50:21.000Z</published>
    <updated>2019-10-30T16:10:24.866Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode-26</p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>理解题意:</p><pre><code>1. 当给定数组为空时, 返回0 2. 不能引入其他数组空间, 即不能再使用一个新的数组来存放结果 3. 最终结果不重复, 整体思路是把数组后面的几个元素挪到前面去, 用后面的元素覆盖掉前面重复了的元素, 保持数组的长度始终不变. 数组中超出新长度(去重后的长度) 后的元素无视</code></pre><p>用快慢指针的思路解答:</p><ol><li>给定两个游标 left和right</li><li>当给定数组的下标为left和right的值相等时,  就不管</li><li>当不相等时, 做一个操作: 把当前right的值赋给left的下一个坐标</li></ol><p>code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">    //如果是空切片，那就返回0</span><br><span class="line">    if len(nums) == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    //用两个标记来比较相邻位置的值</span><br><span class="line">    //当一样的话，那就不管继续</span><br><span class="line">    //当不一样的时候，就把right指向的值赋值给left下一位</span><br><span class="line">    left, right := 0, 1</span><br><span class="line">    for ; right &lt; len(nums); right++ &#123;</span><br><span class="line">        if nums[left] == nums[right] &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums[:left+1])</span><br><span class="line">    return left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode-26&lt;/p&gt;
&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://lxb.wiki/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://lxb.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang编译器漏洞和标准库设计失误</title>
    <link href="https://lxb.wiki/4fe063a2/"/>
    <id>https://lxb.wiki/4fe063a2/</id>
    <published>2019-10-20T03:29:37.000Z</published>
    <updated>2019-10-20T03:36:25.808Z</updated>
    
    <content type="html"><![CDATA[<p>字节切片（byte slice）相关的编译器漏洞和标准库设计失误</p><p>假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  x = []byte(y) // error: 非法的转换</span><br><span class="line">  y = []MyByte(x) // error: 非法的转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，在Go中，这两个类型的值之间的类型转换是非法的。因为Go规定两个切片只有在它们的类型的底层类型（underlying type）相同的情况下才能转换到对方的类型。而一个非定义类型（undefined type）的底层类型为此非定义类型本身。类型[]MyByte和[]byte均为非定义类型，所以它们的底层类型不同，从而它们的值也就不能转换到对方的类型。</p><p>难道真没有办法实现它们之间的转换了？有，而且有好几种。第一种方法是使用类型非安全指针来实现双向转换，另外两种方法只能实现单向转换。另外的这两种方法要么利用了编译器的漏洞，要么利用了reflect标准库包的设计失误。</p><p><strong>使用类型非安全指针的实现。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  p := unsafe.Pointer(&amp;y)</span><br><span class="line">  x = *(*[]byte)(p)</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用类型非安全指针的实现中，转换结果和原切片共享底层元素。</p><p><strong>利用标准编译器的bug</strong></p><p>我们可以将一个[]byte切片值转换为string, 再把string转换为类型[]MyByte。转换结果和原切片不共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go白皮书提到一个字节切片可以转换为一个字符串，反之亦然。但是什么是字节切片类型呢？底层类型为[]byte的切片类型还是元素类型的底层类型为byte的切片类型？如果字节切片类型定义为<strong>元素类型的底层类型为byte的切片类型</strong>，则[]MyByte和[]byte都可称为字节切片类型。如果字节切片类型定义为<strong>底层类型为[]byte的切片类型</strong>，则只有[]byte可以被称为字节切片类型。我们认为标准编译器采纳了<strong>底层类型为[]byte的切片类型才称为字节切片</strong>这一定义，因为下面这个程序使用标准编译器是编译不过的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">  _ = string(y) // error: 非法转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，标准编译器（v1.12）却认为转换[]MyByte(“abc”)是合法的。这显然是一个漏洞。</p><p>对于码点切片（rune slice）和字符串之间的转换，同样的情况也存在。</p><p>对于gccgo编译器来说，此漏洞是对称的，因而更严重。此更严重的漏洞使得上述两种类型的值之间的转换是双向有效的。比如，下面这段代码使用gccgo（v8.0）编译是没问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  x = []byte(string(y))</span><br><span class="line">  x[0] = 127</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，gccgo编译器在内置copy和append函数的实现中也存在着同样的漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  copy(y, string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = append([]MyByte(nil), string(x)...)</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法利用了<code>reflect</code>标准库包的设计失误。此失误导致将<code>[]MyByte</code>值单向转换为类型<code>[]byte</code>是可行的，虽然这违反了Go类型系统确定的规则。使用第三种方法得到的结果切片和原切片共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  v := reflect.ValueOf(y)</span><br><span class="line">  x = v.Bytes()</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字节切片（byte slice）相关的编译器漏洞和标准库设计失误&lt;/p&gt;
&lt;p&gt;假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
      <category term="go" scheme="https://lxb.wiki/tags/go/"/>
    
      <category term="编译器" scheme="https://lxb.wiki/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁高并发优化</title>
    <link href="https://lxb.wiki/7db296fb/"/>
    <id>https://lxb.wiki/7db296fb/</id>
    <published>2019-10-18T14:38:39.000Z</published>
    <updated>2019-10-18T14:38:40.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景:"></a>问题场景:</h4><p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？</p><h4 id="库存超卖现象是怎么产生的？"><a href="#库存超卖现象是怎么产生的？" class="headerlink" title="库存超卖现象是怎么产生的？"></a>库存超卖现象是怎么产生的？</h4><p><img src="/images/kucunchaomai.png" alt="库存超卖"></p><p>假设订单系统部署两台机器上，不同的用户都要同时买10台iphone，分别发了一个请求给订单系统。<br>接着每个订单系统实例都去数据库里查了一下，当前iphone库存是12台<br>于是乎，每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台</p><h4 id="用分布式锁如何解决库存超卖问题？"><a href="#用分布式锁如何解决库存超卖问题？" class="headerlink" title="用分布式锁如何解决库存超卖问题？"></a>用分布式锁如何解决库存超卖问题？</h4><p>分布式锁的实现原理:<br>同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p><p><img src="/images/fenbushisuo_code.png" alt="分布式锁代码"></p><p><img src="/images/fenbushisuo_yuanli.png" alt="分布式锁原理"></p><p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</p><p>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的</p><h4 id="分布式锁的方案在高并发场景下"><a href="#分布式锁的方案在高并发场景下" class="headerlink" title="分布式锁的方案在高并发场景下"></a>分布式锁的方案在高并发场景下</h4><p>分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。</p><p>比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。</p><p>假设加锁之后，释放锁之前，查库存 -&gt; 创建订单 -&gt; 扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。</p><p>那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。</p><p>比如一秒钟来50个请求，都是对iphone下单的，那么每个请求处理20毫秒，一个一个来，最后1000毫秒正好处理完50个请求。</p><p><img src="/images/fenbushisuo_chuanxing.png" alt="分布式锁串行"></p><p>所以, 能看出来简单的使用分布式锁来处理库存超卖问题，存在的缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p><p>这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p><p>因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在一秒内瞬间下1000个订单，因为小电商系统没那场景。</p><h4 id="如何对分布式锁进行高并发优化？"><a href="#如何对分布式锁进行高并发优化？" class="headerlink" title="如何对分布式锁进行高并发优化？"></a>如何对分布式锁进行高并发优化？</h4><p>现在按照刚才的计算，你一秒钟只能处理针对iphone的50个订单。</p><p>其实说出来也很简单，相信很多人看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁！</p><p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。</p><p>另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p><p>LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p><p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p><p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p><p><img src="/images/fenbushisuo_fenduanjiasuo.png" alt="分段加锁"></p><p>其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。</p><p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p><p>接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p><p>这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&gt; 判断库存是否充足 -&gt; 扣减库存。</p><p>这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。</p><p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？</p><p>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现</p><h4 id="分布式锁并发优化方案有没有什么不足？"><a href="#分布式锁并发优化方案有没有什么不足？" class="headerlink" title="分布式锁并发优化方案有没有什么不足？"></a>分布式锁并发优化方案有没有什么不足？</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题场景&quot;&gt;&lt;a href=&quot;#问题场景&quot; class=&quot;headerlink&quot; title=&quot;问题场景:&quot;&gt;&lt;/a&gt;问题场景:&lt;/h4&gt;&lt;p&gt;假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？&lt;/p
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="redis" scheme="https://lxb.wiki/tags/redis/"/>
    
      <category term="优化" scheme="https://lxb.wiki/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="分布式" scheme="https://lxb.wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CentOS释放被占用端口</title>
    <link href="https://lxb.wiki/2d1cc7f9/"/>
    <id>https://lxb.wiki/2d1cc7f9/</id>
    <published>2019-10-09T16:36:59.000Z</published>
    <updated>2019-10-09T16:36:59.584Z</updated>
    
    <content type="html"><![CDATA[<p><strong>场景:</strong><br>在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错</p><p>1.输入netstat -tln,查看系统当前所有被占用端口,主要是为了查看你的端口是否真正的被占用着,搭建可以看到我的9001,和9002端口都已经被占用了,所以我需要释放这两个端口</p><p><img src="/images/listen-port.png" alt="listen-port"></p><p>2.根据端口查询进程,输入lsof -i :9001,切记不要忘了添加冒号,如下图,就可以看到当前被占用的端口的进程<br>的进程编号</p><p><img src="/images/lsof-port.png" alt></p><ol start="3"><li>kill 掉PID</li><li>再<code>netstat -tln</code> 确认下, 然后就可以起进程了 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt;&lt;br&gt;在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错&lt;/p&gt;
&lt;p&gt;1.输入netstat -tln,查看系统当前
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://lxb.wiki/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://lxb.wiki/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="端口" scheme="https://lxb.wiki/tags/%E7%AB%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>网易云音乐破版权</title>
    <link href="https://lxb.wiki/c6996379/"/>
    <id>https://lxb.wiki/c6996379/</id>
    <published>2019-10-08T10:07:13.000Z</published>
    <updated>2019-10-09T17:30:16.320Z</updated>
    
    <content type="html"><![CDATA[<p>源码地址: <a href="https://github.com/lxbwolf/UnblockNeteaseMusic" target="_blank" rel="noopener">https://github.com/lxbwolf/UnblockNeteaseMusic</a></p><p><strong>原理:</strong><br>使用其它音乐平台的歌曲替换网易云音乐无版权歌曲。<br>目前备用的平台有：网易云旧链 、QQ 、 虾米 、 百度 、酷狗 、酷我 、咕咪 、JOOX 音源替换变灰歌曲链接 (默认仅启用前四)。</p><p>1、打开网易云音乐客户端的时候，客户端不再直接访问网易云服务器而是访问UnblockNeteaseMusic服务。</p><p>2、UnblockNeteaseMusic收到客户端的请求后，透传给网易云音乐的服务器，并再拿到相关的数据后进行检查，如果发现其中的歌曲没有版权，那么去其它平台查询此歌曲的相关信息。</p><p>3、将查到的数据返回给网易云客户端。</p><p>4、至此完成网易云音乐的解锁。</p><p>整个流程要解决两个重要的问题。</p><p><strong>核心工作:</strong><br>1、将UnblockNeteaseMusic部署到服务器。可以是本地服务器也可以是云服务器。</p><p>2、为网易云客户端设置代理，以达到访问UnblockNeteaseMusic项目的目的。</p><p><strong>部署服务部分</strong></p><ol><li>安装node.js </li><li><code>git clone https://github.com/lxbwolf/UnblockNeteaseMusic.git</code></li><li>在<code>UnblockNeteaseMusic</code> 目录下, 执行<code>npx @nondanee/unblockneteasemusic(官方)</code> 或者 用docker 启动<code>docker run nondanee/unblockneteasemusic &amp;&amp; docker-compose up</code>, 还有另一种方式:<br>在<code>UnblockNeteaseMusic</code> 目录下, 执行<br><code>node app.js -p 8080:443 -f 59.111.160.195</code><br>其中<code>59.111.160.195</code> 这个地址是通过<br><code>ping music.163.com</code> 测出来的</li></ol><p>正常情况下, 服务端启动进程, 客户端配置好IP Port, 就可以用了, </p><p>此时服务端接收到请求会有log, 如果服务端log一直卡在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP Server running @ http://0.0.0.0:8080</span><br><span class="line">HTTPS Server running @ https://0.0.0.0:443</span><br></pre></td></tr></table></figure><p>说明客户端的请求并没有打到服务器上, 可能原因是8080和443端口还没有开启</p><p>配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ unblockneteasemusic -h</span><br><span class="line">usage: unblockneteasemusic [-v] [-p port] [-a address] [-u url] [-f host]</span><br><span class="line">                           [-o source [source ...]] [-t token] [-e url] [-s]</span><br><span class="line">                           [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -v, --version                   output the version number</span><br><span class="line">  -p port, --port port            specify server port</span><br><span class="line">  -a address, --address address   specify server host</span><br><span class="line">  -u url, --proxy-url url         request through upstream proxy</span><br><span class="line">  -f host, --force-host host      force the netease server ip</span><br><span class="line">  -o source [source ...], --match-order source [source ...]</span><br><span class="line">                                  set priority of sources</span><br><span class="line">  -t token, --token token         set up proxy authentication</span><br><span class="line">  -e url, --endpoint url          replace virtual endpoint with public host</span><br><span class="line">  -s, --strict                    enable proxy limitation</span><br><span class="line">  -h, --help                      output usage information</span><br></pre></td></tr></table></figure><p><strong>客户端配置</strong></p><p>源码中的<code>README</code> 有详细说明</p><table><thead><tr><th>平台</th><th>基础设置</th></tr></thead><tbody><tr><td>Windows</td><td>设置 &gt; 工具 &gt; 自定义代理 (客户端内)</td></tr><tr><td>UWP</td><td>Windows 设置 &gt; 网络和 Internet &gt; 代理</td></tr><tr><td>Linux</td><td>系统设置 &gt; 网络 &gt; 网络代理</td></tr><tr><td>macOS</td><td>系统偏好设置 &gt; 网络 &gt; 高级 &gt; 代理</td></tr><tr><td>Android</td><td>WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</td></tr><tr><td>iOS</td><td>无线局域网 &gt; HTTP 代理 &gt; 配置代理</td></tr></tbody></table><p><strong>Android 手机详细配置:</strong></p><p>设置 &gt; WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP: 106.13.86.198</span><br><span class="line">Port: 8080</span><br></pre></td></tr></table></figure><p><img src="/images/modify-network-android.png" alt></p><p><img src="/images/ip-port-163-android.png" alt></p><p>破解前效果<br><img src="/images/pojieqian-163.png" alt></p><p>破解后效果<br><img src="/images/pojiehou-163.png" alt><br><img src="/images/tingge-163.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码地址: &lt;a href=&quot;https://github.com/lxbwolf/UnblockNeteaseMusic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lxbwolf/UnblockNeteaseMu
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://lxb.wiki/categories/Tools/"/>
    
    
      <category term="破解" scheme="https://lxb.wiki/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Go闭包技术</title>
    <link href="https://lxb.wiki/eb01d7dc/"/>
    <id>https://lxb.wiki/eb01d7dc/</id>
    <published>2019-10-04T11:25:07.000Z</published>
    <updated>2019-10-04T11:25:07.539Z</updated>
    
    <content type="html"><![CDATA[<p>斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/B536914CD0194338915F9A7B18A754D7/1139" alt="fibonacci.png"></p><p>斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和.<br>为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 0 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">// a b</span><br><span class="line">// a b</span><br><span class="line">a, b := 0, 1</span><br></pre></td></tr></table></figure><p>初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    fmt.Print(a, &quot; &quot;)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        fmt.Print(a, &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacciByNormal(t *testing.T) &#123;</span><br><span class="line">    fibonacciByNormal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacci(t *testing.T) &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Print(f(), &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为”闭包”!</p><p>闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func autoIncrease() func() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        i = i + 1</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func TestAutoIncrease(t *testing.T) &#123;</span><br><span class="line">    a := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(a(), a(), a())</span><br><span class="line">    b := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(b(), b(), b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果.</p><p>普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生.</p><p>但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会”长生不老”,并不会因为出身于函数内就和普通变量拥有一样的短暂人生.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func fightWithHorse() func() int &#123;</span><br><span class="line">    horseShowTime := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        horseShowTime++</span><br><span class="line">        fmt.Printf(&quot;(%d)祖国需要我,我就提枪上马立即战斗!\n&quot;,horseShowTime)</span><br><span class="line">        return horseShowTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFightWithHorse(t *testing.T) &#123;</span><br><span class="line">    f := fightWithHorse()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心!<br>下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosure(t *testing.T) &#123;</span><br><span class="line">    // 4 4 4</span><br><span class="line">    for _, c := range countByClosureButWrong() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c.</p><p>当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4.<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/7BB3368DAC6A4AEB847EAB127682D486/1144" alt></p><p>原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了!<br><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/C4B872B0C6354133B321806B9AF02F85/1145" alt></p><p>长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4.</p><p>既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛!</p><p>最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        n := i</span><br><span class="line">        fmt.Printf(&quot;for i=%d n=%d \n&quot;, i,n)</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            fmt.Printf(&quot;append i=%d n=%d\n&quot;, i, n)</span><br><span class="line">            return n</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/public/resource/723251c4553dc65b7ea84b37b0d5788d/xmlnote/957A722165B94E7785E0AB1DAE3B5B0C/1146" alt></p><p>上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级.</p><p>既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureWithOk() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;for i=%d \n&quot;, i)</span><br><span class="line">        func(n int) &#123;</span><br><span class="line">            arr = append(arr, func() int &#123;</span><br><span class="line">                fmt.Printf(&quot;append n=%d \n&quot;, n)</span><br><span class="line">                return n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosureWithOk(t *testing.T) &#123;</span><br><span class="line">    // 1 2 3</span><br><span class="line">    for _, c := range countByClosureWithOk() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模拟类和对象的关系,也可以实现封装,具备一定面向对象能力<ul><li>每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系.</li></ul></li><li>缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本.<ul><li>长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用.</li></ul></li><li>实现闭包成本较高,同时也增加了理解难度.<ul><li>普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性.</li></ul></li><li>滥用容易占用过多内存,可能造成内存泄漏.<ul><li>过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://lxb.wiki/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>github 博客绑定域名</title>
    <link href="https://lxb.wiki/e9fbcad9/"/>
    <id>https://lxb.wiki/e9fbcad9/</id>
    <published>2019-09-26T16:54:15.000Z</published>
    <updated>2019-10-03T16:52:39.427Z</updated>
    
    <content type="html"><![CDATA[<p>某篇文章说, CNAME 解析只支持 www 不支持@<br>所以@ 只能 解析到一个一个的 IP</p><h4 id="1-source-添加-CNAME-文件"><a href="#1-source-添加-CNAME-文件" class="headerlink" title="1. source 添加 CNAME 文件"></a>1. source 添加 CNAME 文件</h4><p>在源码的<code>source</code> 目录下, 添加一个<code>CNAME</code>文件<br>文件内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxb.wiki</span><br></pre></td></tr></table></figure><h4 id="2-DNS-设置"><a href="#2-DNS-设置" class="headerlink" title="2. DNS 设置"></a>2. DNS 设置</h4><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析路线(isp)</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>默认</td><td>lxbwolf.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.108.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.111.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.109.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr></tbody></table><h4 id="3-hexo-部署"><a href="#3-hexo-部署" class="headerlink" title="3. hexo 部署"></a>3. hexo 部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某篇文章说, CNAME 解析只支持 www 不支持@&lt;br&gt;所以@ 只能 解析到一个一个的 IP&lt;/p&gt;
&lt;h4 id=&quot;1-source-添加-CNAME-文件&quot;&gt;&lt;a href=&quot;#1-source-添加-CNAME-文件&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Web" scheme="https://lxb.wiki/categories/Web/"/>
    
    
      <category term="博客" scheme="https://lxb.wiki/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://lxb.wiki/a1751c09/"/>
    <id>https://lxb.wiki/a1751c09/</id>
    <published>2019-09-26T16:14:22.211Z</published>
    <updated>2019-10-03T07:57:15.349Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
