<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tmux 使用教程</title>
      <link href="/176a23be/"/>
      <url>/176a23be/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-tmux-是什么">1 Tmux 是什么？</a><ul><li><a href="#11-会话与进程">1.1 会话与进程</a></li><li><a href="#12-tmux-的作用">1.2 Tmux 的作用</a></li></ul></li><li><a href="#2-基本用法">2 基本用法</a><ul><li><a href="#21-安装">2.1 安装</a></li><li><a href="#22-启动与退出">2.2 启动与退出</a></li><li><a href="#23-前缀键">2.3 前缀键</a></li></ul></li><li><a href="#3-会话管理">3 会话管理</a><ul><li><a href="#31-新建会话">3.1 新建会话</a></li><li><a href="#32-分离会话">3.2 分离会话</a></li><li><a href="#33-接入会话">3.3 接入会话</a></li><li><a href="#34-杀死会话">3.4 杀死会话</a></li><li><a href="#35-切换会话">3.5 切换会话</a></li><li><a href="#36-重命名会话">3.6 重命名会话</a></li><li><a href="#37-会话快捷键">3.7 会话快捷键</a></li></ul></li><li><a href="#4-最简操作流程">4 最简操作流程</a></li><li><a href="#5-窗格操作">5 窗格操作</a><ul><li><a href="#51-划分窗格">5.1 划分窗格</a></li><li><a href="#52-移动光标">5.2 移动光标</a></li><li><a href="#53-交换窗格位置">5.3 交换窗格位置</a></li><li><a href="#54-窗格快捷键">5.4 窗格快捷键</a></li></ul></li><li><a href="#6-窗口管理">6 窗口管理</a><ul><li><a href="#61-新建窗口">6.1 新建窗口</a></li><li><a href="#62-切换窗口">6.2 切换窗口</a></li><li><a href="#63-重命名窗口">6.3 重命名窗口</a></li><li><a href="#64-窗口快捷键">6.4 窗口快捷键</a></li></ul></li><li><a href="#7-其他命令">7 其他命令</a></li><li><a href="#8-参考链接">8 参考链接</a></li></ul><!-- tocstop --><h2 id="1-tmux-是什么"><span id="1-tmux-是什么">1 Tmux 是什么？</span></h2><h3 id="11-会话与进程"><span id="11-会话与进程">1.1 会话与进程</span></h3><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://lxb.wiki/2e3ff18f/">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p><p>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><h3 id="12-tmux-的作用"><span id="12-tmux-的作用">1.2 Tmux 的作用</span></h3><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p><blockquote><p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p><p>（2） 它可以让新窗口”接入”已经存在的会话。</p><p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p><p>（4）它还支持窗口任意的垂直和水平拆分。</p></blockquote><p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p><h2 id="2-基本用法"><span id="2-基本用法">2 基本用法</span></h2><h3 id="21-安装"><span id="21-安装">2.1 安装</span></h3><p>Tmux 一般需要自己安装。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># Ubuntu 或 Debian</span></span><br><span class="line">&gt; $ sudo apt-get install tmux</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># CentOS 或 Fedora</span></span><br><span class="line">&gt; $ sudo yum install tmux</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># Mac</span></span><br><span class="line">&gt; $ brew install tmux</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="22-启动与退出"><span id="22-启动与退出">2.2 启动与退出</span></h3><p>安装完成后，键入<code>tmux</code>命令，就进入了 Tmux 窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201001437.png" alt></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ <span class="built_in">exit</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="23-前缀键"><span id="23-前缀键">2.3 前缀键</span></h3><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h2 id="3-会话管理"><span id="3-会话管理">3 会话管理</span></h2><h3 id="31-新建会话"><span id="31-新建会话">3.1 新建会话</span></h3><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux new -s &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令新建一个指定名称的会话。</p><h3 id="32-分离会话"><span id="32-分离会话">3.2 分离会话</span></h3><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux detach</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux ls</span><br><span class="line">&gt; <span class="comment"># or</span></span><br><span class="line">&gt; $ tmux list-session</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="33-接入会话"><span id="33-接入会话">3.3 接入会话</span></h3><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用会话编号</span></span><br><span class="line">&gt; $ tmux attach -t 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 使用会话名称</span></span><br><span class="line">&gt; $ tmux attach -t &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="34-杀死会话"><span id="34-杀死会话">3.4 杀死会话</span></h3><p><code>tmux kill-session</code>命令用于杀死某个会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用会话编号</span></span><br><span class="line">&gt; $ tmux <span class="built_in">kill</span>-session -t 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 使用会话名称</span></span><br><span class="line">&gt; $ tmux <span class="built_in">kill</span>-session -t &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="35-切换会话"><span id="35-切换会话">3.5 切换会话</span></h3><p><code>tmux switch</code>命令用于切换会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用会话编号</span></span><br><span class="line">&gt; $ tmux switch -t 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 使用会话名称</span></span><br><span class="line">&gt; $ tmux switch -t &lt;session-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="36-重命名会话"><span id="36-重命名会话">3.6 重命名会话</span></h3><p><code>tmux rename-session</code>命令用于重命名会话。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux rename-session -t 0 &lt;new-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面命令将0号会话重命名。</p><h3 id="37-会话快捷键"><span id="37-会话快捷键">3.7 会话快捷键</span></h3><p>下面是一些会话相关的快捷键。</p><blockquote><ul><li><code>Ctrl+b d</code>：分离当前会话。</li><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>Ctrl+b $</code>：重命名当前会话。</li></ul></blockquote><h2 id="4-最简操作流程"><span id="4-最简操作流程">4 最简操作流程</span></h2><p>综上所述，以下是 Tmux 的最简操作流程。</p><blockquote><ol><li>新建会话<code>tmux new -s my_session</code>。</li><li>在 Tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux attach-session -t my_session</code>。</li></ol></blockquote><h2 id="5-窗格操作"><span id="5-窗格操作">5 窗格操作</span></h2><p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。</p><h3 id="51-划分窗格"><span id="51-划分窗格">5.1 划分窗格</span></h3><p><code>tmux split-window</code>命令用来划分窗格。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 划分上下两个窗格</span></span><br><span class="line">&gt; $ tmux split-window</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 划分左右两个窗格</span></span><br><span class="line">&gt; $ tmux split-window -h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201002216.png" alt></p><h3 id="52-移动光标"><span id="52-移动光标">5.2 移动光标</span></h3><p><code>tmux select-pane</code>命令用来移动光标位置。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 光标切换到上方窗格</span></span><br><span class="line">&gt; $ tmux select-pane -U</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 光标切换到下方窗格</span></span><br><span class="line">&gt; $ tmux select-pane -D</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 光标切换到左边窗格</span></span><br><span class="line">&gt; $ tmux select-pane -L</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 光标切换到右边窗格</span></span><br><span class="line">&gt; $ tmux select-pane -R</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="53-交换窗格位置"><span id="53-交换窗格位置">5.3 交换窗格位置</span></h3><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 当前窗格上移</span></span><br><span class="line">&gt; $ tmux swap-pane -U</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 当前窗格下移</span></span><br><span class="line">&gt; $ tmux swap-pane -D</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="54-窗格快捷键"><span id="54-窗格快捷键">5.4 窗格快捷键</span></h3><p>下面是一些窗格操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b %</code>：划分左右两个窗格。</li><li><code>Ctrl+b &quot;</code>：划分上下两个窗格。</li><li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li><li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li><li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li><li><code>Ctrl+b {</code>：当前窗格与上一个窗格交换位置。</li><li><code>Ctrl+b }</code>：当前窗格与下一个窗格交换位置。</li><li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li><li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li><li><code>Ctrl+b x</code>：关闭当前窗格。</li><li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li><li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li><li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li><li><code>Ctrl+b q</code>：显示窗格编号。</li></ul></blockquote><h2 id="6-窗口管理"><span id="6-窗口管理">6 窗口管理</span></h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p><h3 id="61-新建窗口"><span id="61-新建窗口">6.1 新建窗口</span></h3><p><code>tmux new-window</code>命令用来创建新窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux new-window</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 新建一个指定名称的窗口</span></span><br><span class="line">&gt; $ tmux new-window -n &lt;window-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="62-切换窗口"><span id="62-切换窗口">6.2 切换窗口</span></h3><p><code>tmux select-window</code>命令用来切换窗口。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 切换到指定编号的窗口</span></span><br><span class="line">&gt; $ tmux select-window -t &lt;window-number&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 切换到指定名称的窗口</span></span><br><span class="line">&gt; $ tmux select-window -t &lt;window-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="63-重命名窗口"><span id="63-重命名窗口">6.3 重命名窗口</span></h3><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux rename-window &lt;new-name&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="64-窗口快捷键"><span id="64-窗口快捷键">6.4 窗口快捷键</span></h3><p>下面是一些窗口操作的快捷键。</p><blockquote><ul><li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li><li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li><li><code>Ctrl+b n</code>：切换到下一个窗口。</li><li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li><li><code>Ctrl+b w</code>：从列表中选择窗口。</li><li><code>Ctrl+b ,</code>：窗口重命名。</li></ul></blockquote><h2 id="7-其他命令"><span id="7-其他命令">7 其他命令</span></h2><p>下面是一些其他命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 列出所有快捷键，及其对应的 Tmux 命令</span></span><br><span class="line">&gt; $ tmux list-keys</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有 Tmux 命令及其参数</span></span><br><span class="line">&gt; $ tmux list-commands</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出当前所有 Tmux 会话的信息</span></span><br><span class="line">&gt; $ tmux info</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 重新加载当前的 Tmux 配置</span></span><br><span class="line">&gt; $ tmux <span class="built_in">source</span>-file ~/.tmux.conf</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="8-参考链接"><span id="8-参考链接">8 参考链接</span></h2><ul><li><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/" target="_blank" rel="noopener">A Quick and Easy Guide to tmux</a></li><li><a href="https://danielmiessler.com/study/tmux/" target="_blank" rel="noopener">Tactical tmux: The 10 Most Important Commands</a></li><li><a href="https://linuxize.com/post/getting-started-with-tmux/" target="_blank" rel="noopener">Getting started with Tmux</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 守护进程的启动方法</title>
      <link href="/2e3ff18f/"/>
      <url>/2e3ff18f/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-问题的由来">1 问题的由来</a></li><li><a href="#2-前台任务与后台任务">2 前台任务与后台任务</a></li><li><a href="#3-sighup信号">3 SIGHUP信号</a></li><li><a href="#4-disown-命令">4 disown 命令</a></li><li><a href="#5-标准-io">5 标准 I/O</a></li><li><a href="#6-nohup-命令">6 nohup 命令</a></li><li><a href="#7-screen-命令与-tmux-命令">7 Screen 命令与 Tmux 命令</a></li><li><a href="#8-node-工具">8 Node 工具</a></li><li><a href="#9-systemd">9 Systemd</a></li></ul><!-- tocstop --><p><a href="http://baike.baidu.com/view/53123.htm" target="_blank" rel="noopener">“守护进程”</a>（daemon）就是一直在后台运行的进程（daemon）。</p><p>如何将一个 Web 应用，启动为守护进程。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/201130/00.png" alt></p><h2 id="1-问题的由来"><span id="1-问题的由来">1 问题的由来</span></h2><p>Web应用写好后，下一件事就是启动，让它一直在后台运行。</p><p>这并不容易。举例来说，下面是一个最简单的Node应用<code>server.js</code>，只有6行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>你在命令行下启动它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br></pre></td></tr></table></figure><p>看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。</p><p>怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？</p><h2 id="2-前台任务与后台任务"><span id="2-前台任务与后台任务">2 前台任务与后台任务</span></h2><p>上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。</p><p>变成守护进程的第一步，就是把它改成”后台任务”（background job）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js &amp;</span><br></pre></td></tr></table></figure><p>只要在命令的尾部加上符号<code>&amp;</code>，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按<code>ctrl + z</code>，然后执行<code>bg</code>命令（让最近一个暂停的”后台任务”继续执行）。</p><p>“后台任务”有两个特点。</p><ol><li>继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。</li><li>不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。</li></ol><p>可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。</p><h2 id="3-sighup信号"><span id="3-sighup信号">3 SIGHUP信号</span></h2><p>变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？</p><p>Linux系统是这样设计的。</p><ol><li>用户准备退出 session</li><li>系统向该 session 发出<code>SIGHUP</code>信号</li><li>session 将<code>SIGHUP</code>信号发给所有子进程</li><li>子进程收到<code>SIGHUP</code>信号后，自动退出</li></ol><p>上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了<code>SIGHUP</code>信号。</p><p>那么，”后台任务”是否也会收到<code>SIGHUP</code>信号？</p><p>这由 Shell 的<code>huponexit</code>参数决定的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> | grep huponexit</span><br></pre></td></tr></table></figure><p>执行上面的命令，就会看到<code>huponexit</code>参数的值。</p><p>大多数Linux系统，这个参数默认关闭（<code>off</code>）。因此，session 退出的时候，不会把<code>SIGHUP</code>信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出。</p><h2 id="4-disown-命令"><span id="4-disown-命令">4 disown 命令</span></h2><p>通过”后台任务”启动”守护进程”并不保险，因为有的系统的<code>huponexit</code>参数可能是打开的（<code>on</code>）。</p><p>更保险的方法是使用<code>disown</code>命令。它可以将指定任务从”后台任务”列表（<code>jobs</code>命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session 就肯定不会向它发出<code>SIGHUP</code>信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure><p>执行上面的命令以后，<code>server.js</code>进程就被移出了”后台任务”列表。你可以执行<code>jobs</code>命令验证，输出结果里面，不会有这个进程。</p><p><code>disown</code>的用法如下。</p><p>​    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移出最近一个正在执行的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出所有正在执行的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出所有后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不移出后台任务，但是让它们不会收到SIGHUP信号</span></span><br><span class="line">$ <span class="built_in">disown</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据jobId，移出指定的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> %2</span><br><span class="line">$ <span class="built_in">disown</span> -h %2</span><br></pre></td></tr></table></figure><h2 id="5-标准-io"><span id="5-标准-io">5 标准 I/O</span></h2><p>使用<code>disown</code>命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准I/O有交互，它还是会挂掉。</p><p>还是以上面的脚本为例，现在加入一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server starts...'</span>); <span class="comment">// 加入此行</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>启动上面的脚本，然后再执行<code>disown</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure><p>接着，你退出 session，访问5000端口，就会发现连不上。</p><p>这是因为”后台任务”的标准 I/O 继承自当前 session，<code>disown</code>命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。</p><p>为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ node server.js &gt; stdout.txt 2&gt; stderr.txt &lt; /dev/null &amp;</span><br><span class="line">&gt; $ <span class="built_in">disown</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面这样执行，基本上就没有问题了。</p><h2 id="6-nohup-命令"><span id="6-nohup-命令">6 nohup 命令</span></h2><p>还有比<code>disown</code>更方便的命令，就是<code>nohup</code>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ nohup node server.js &amp;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>nohup</code>命令对<code>server.js</code>进程做了三件事。</p><blockquote><ul><li>阻止<code>SIGHUP</code>信号发到这个进程。</li><li>关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。</li><li>重定向标准输出和标准错误到文件<code>nohup.out</code>。</li></ul></blockquote><p>也就是说，<code>nohup</code>命令实际上将子进程与它所在的 session 分离了。</p><p>注意，<code>nohup</code>命令不会自动把进程变为”后台任务”，所以必须加上<code>&amp;</code>符号。</p><h2 id="7-screen-命令与-tmux-命令"><span id="7-screen-命令与-tmux-命令">7 Screen 命令与 Tmux 命令</span></h2><p>另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 <a href="https://www.gnu.org/software/screen/" target="_blank" rel="noopener">Screen</a> 命令和 <a href="https://tmux.github.io/" target="_blank" rel="noopener">Tmux</a> 命令。</p><p>它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。</p><p>Screen 的用法如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 新建一个 session</span></span><br><span class="line">&gt; $ screen</span><br><span class="line">&gt; $ node server.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>然后，按下<code>ctrl + A</code>和<code>ctrl + D</code>，回到原来的 session，从那里退出登录。下次登录时，再切回去。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ screen -r</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果新建多个后台 session，就需要为它们指定名字。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ screen -S name</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 切回指定 session</span></span><br><span class="line">&gt; $ screen -r name</span><br><span class="line">&gt; $ screen -r pid_number</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有 session</span></span><br><span class="line">&gt; $ screen -ls</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果要停掉某个 session，可以先切回它，然后按下<code>ctrl + c</code>和<code>ctrl + d</code>。</p><p>Tmux 比 Screen 功能更多、更强大，它的基本用法如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ tmux</span><br><span class="line">&gt; $ node server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 返回原来的session</span></span><br><span class="line">&gt; $ tmux detach</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>除了<code>tmux detach</code>，另一种方法是按下<code>Ctrl + B</code>和<code>d</code> ，也可以回到原来的 session。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 下次登录时，返回后台正在运行服务session</span></span><br><span class="line">&gt; $ tmux attach</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果新建多个 session，就需要为每个 session 指定名字。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 新建 session</span></span><br><span class="line">&gt; $ tmux new -s session_name</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 切换到指定 session</span></span><br><span class="line">&gt; $ tmux attach -t session_name</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有 session</span></span><br><span class="line">&gt; $ tmux list-sessions</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 退出当前 session，返回前一个 session </span></span><br><span class="line">&gt; $ tmux detach</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 杀死指定 session</span></span><br><span class="line">&gt; $ tmux <span class="built_in">kill</span>-session -t session-name</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="8-node-工具"><span id="8-node-工具">8 Node 工具</span></h2><p>对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：<a href="https://github.com/foreverjs/forever" target="_blank" rel="noopener">forever</a>，<a href="http://nodemon.io/" target="_blank" rel="noopener">nodemon</a> 和 <a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">pm2</a>。</p><p>forever 的功能很简单，就是保证进程退出时，应用会自动重启。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 作为前台任务启动</span></span><br><span class="line">&gt; $ forever server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 作为服务进程启动 </span></span><br><span class="line">&gt; $ forever start app.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 停止服务进程</span></span><br><span class="line">&gt; $ forever stop Id</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 重启服务进程</span></span><br><span class="line">&gt; $ forever restart Id</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 监视当前目录的文件变动，一有变动就重启</span></span><br><span class="line">&gt; $ forever -w server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># -m 参数指定最多重启次数</span></span><br><span class="line">&gt; $ forever -m 5 server.js </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有进程</span></span><br><span class="line">&gt; $ forever list</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>nodemon</code>一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 默认监视当前目录的文件变化</span></span><br><span class="line">&gt; $ nodemon server.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; ＃ 监视指定文件的变化   </span><br><span class="line">&gt; $ nodemon --watch app --watch libs server.js  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 启动应用</span></span><br><span class="line">&gt; $ pm2 start app.js</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 指定同时起多少个进程（由CPU核心数决定），组成一个集群</span></span><br><span class="line">&gt; $ pm2 start app.js -i max</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出所有任务</span></span><br><span class="line">&gt; $ pm2 list</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 停止指定任务</span></span><br><span class="line">&gt; $ pm2 stop 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; ＃ 重启指定任务</span><br><span class="line">&gt; $ pm2 restart 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 删除指定任务</span></span><br><span class="line">&gt; $ pm2 delete 0</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 保存当前的所有任务，以后可以恢复</span></span><br><span class="line">&gt; $ pm2 save</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出每个进程的统计数据</span></span><br><span class="line">&gt; $ pm2 monit</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 查看所有日志</span></span><br><span class="line">&gt; $ pm2 logs</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 导出数据</span></span><br><span class="line">&gt; $ pm2 dump</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 重启所有进程</span></span><br><span class="line">&gt; $ pm2 <span class="built_in">kill</span></span><br><span class="line">&gt; $ pm2 resurect</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 启动web界面 http://localhost:9615</span></span><br><span class="line">&gt; $ pm2 web</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="9-systemd"><span id="9-systemd">9 Systemd</span></h2><p>除了专用工具以外，Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> daemon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目录切换：dirs、pushd、popd命令</title>
      <link href="/1ca354f7/"/>
      <url>/1ca354f7/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#目录栈指令">目录栈指令</a><ul><li><a href="#1-dirs">1 dirs</a><ul><li><a href="#11-功能">1.1 功能</a></li><li><a href="#12-语法">1.2 语法</a></li></ul></li><li><a href="#2-pushd">2 pushd</a><ul><li><a href="#21-功能">2.1 功能</a></li><li><a href="#22-语法">2.2 语法</a></li></ul></li><li><a href="#3-popd">3 popd</a><ul><li><a href="#31-功能">3.1 功能</a></li><li><a href="#32-语法">3.2 语法</a></li></ul></li><li><a href="#4-示例">4 示例</a></li></ul></li></ul><!-- tocstop --><h2 id="目录栈指令"><span id="目录栈指令">目录栈指令</span></h2><p>目录栈是用户最近访问过的系统目录列表，并以堆栈的形式管理。栈中的内容与Shell环境变量 <code>DIRSTACK</code> 的值对应</p><h3 id="1-dirs"><span id="1-dirs">1 dirs</span></h3><h4 id="11-功能"><span id="11-功能">1.1 功能</span></h4><p>显示当前目录栈中的所有记录（不带参数的dirs命令显示当前目录栈中的记录）</p><h4 id="12-语法"><span id="12-语法">1.2 语法</span></h4><p><strong>格式：</strong></p><p><code>dirs [-clpv] [+n] [-n]</code></p><p><strong>选项</strong></p><ul><li>-c  删除目录栈中的所有记录</li><li>-l   以完整格式显示(绝对路径)</li><li>-p  一个目录一行的方式显示</li><li>-v  每行一个目录来显示目录栈的内容，每个目录前加上的编号</li><li>+N 显示从左到右的第n个目录，数字从0开始</li><li>-N  显示从右到左的第n个日录，数字从0开始</li></ul><p>注意：dirs始终显示当人们目录, 再是堆栈中的内容；即使目录堆栈为空, dirs命令仍然只显示当前目录</p><h3 id="2-pushd"><span id="2-pushd">2 pushd</span></h3><h4 id="21-功能"><span id="21-功能">2.1 功能</span></h4><p>将目录加入到栈顶部，并切换到该目录；若 <code>pushd</code> 命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置</p><h4 id="22-语法"><span id="22-语法">2.2 语法</span></h4><p><strong>格式：</strong></p><p><code>pushd [目录 | -N | +N]  [-n]</code></p><p><strong>选项</strong></p><ul><li>目录  将该目录加入到栈顶，并执行”cd 目录”，切换到该目录</li><li>+N  将第N个目录移至栈顶（从左边数起，数字从0开始）</li><li>-N  将第N个目录移至栈顶（从右边数起，数字从0开始）</li><li>-n  将目录入栈时，不切换目录</li></ul><h3 id="3-popd"><span id="3-popd">3 popd</span></h3><h4 id="31-功能"><span id="31-功能">3.1 功能</span></h4><p>删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录</p><h4 id="32-语法"><span id="32-语法">3.2 语法</span></h4><p><strong>格式：</strong></p><p><code>pushd [-N | +N]  [-n]</code></p><p><strong>选项</strong></p><ul><li>+N  将第N个目录删除（从左边数起，数字从0开始）</li><li>-N  将第N个目录删除（从右边数起，数字从0开始）</li><li>-n  将目录出栈时，不切换目录</li></ul><h3 id="4-示例"><span id="4-示例">4 示例</span></h3><p><strong>入栈与出栈</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@root]:~<span class="comment"># mkdir /root/dir&#123;1,2,3,4&#125;</span></span><br><span class="line">[root@root]:~<span class="comment"># for ((i=1;i&lt;=4;i++)); do pushd /root/dir$&#123;i&#125;; done</span></span><br><span class="line">/root/dir1 ~</span><br><span class="line">/root/dir2 /root/dir1 ~</span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># dirs </span></span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line"><span class="built_in">dirs</span>显出了栈中的所有目录</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># popd（相当于popd +0）</span></span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">[root@root:/root/dir3]<span class="comment"># dirs</span></span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">可以看出/root/dir4目录已被清除，此时栈里已经没有了dir4目录，切当前目录切换为dir3</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir3]<span class="comment"># pushd /root/dir4 </span></span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">[root@root:/root/dir4]</span><br><span class="line">不推荐以上面的方法进行切换，因为这种方式和<span class="built_in">cd</span>没有区别。</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># popd +1</span></span><br><span class="line">/root/dir4 /root/dir2 /root/dir1 ~</span><br><span class="line">推荐以这种方式进行切换，尤其是目录层次比较多时</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]<span class="comment"># popd -2</span></span><br><span class="line">/root/dir4 /root/dir1 ~</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir2]<span class="comment"># pushd -1</span></span><br><span class="line">/root/dir1 ~ /root/dir2 /root/dir3 /root/dir4</span><br><span class="line">[root@root:/root/dir3]</span><br><span class="line">注意：最左边表示栈顶，最右边表示栈底</span><br></pre></td></tr></table></figure><p><strong>清空栈</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@root]:~<span class="comment"># dirs</span></span><br><span class="line">~ /root/dir2 /root/dir3 /root/dir4 /root/dir1</span><br><span class="line">[root@root]:~<span class="comment"># dirs -c</span></span><br><span class="line">[root@root](mailto:root@root):~<span class="comment"># dirs</span></span><br><span class="line">~</span><br></pre></td></tr></table></figure><p><strong>列表形式显示的栈的内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@root:/root/dir4]<span class="comment"># dirs -l -v</span></span><br><span class="line">0 /root/dir4</span><br><span class="line">1 /root/dir3</span><br><span class="line">2 /root/dir2</span><br><span class="line">3 /root/dir1</span><br><span class="line">4 /root</span><br></pre></td></tr></table></figure><p>注：如果只是两个目录之间的切换 <code>cd -</code>足矣，而且方便。</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> dirs </tag>
            
            <tag> pushd </tag>
            
            <tag> popd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 gosec 检查 Go 代码中的安全问题</title>
      <link href="/a59515fd/"/>
      <url>/a59515fd/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#开始使用-gosec">开始使用 gosec</a><ul><li><a href="#安装-go-和-gosec">安装 Go 和 gosec</a></li></ul></li><li><a href="#使用默认选项运行-gosec">使用默认选项运行 gosec</a><ul><li><a href="#关于误判">关于误判</a></li><li><a href="#高优先级问题">高优先级问题</a></li><li><a href="#中优先级问题">中优先级问题</a></li><li><a href="#低优先级问题">低优先级问题</a></li></ul></li><li><a href="#自定义-gosec-扫描">自定义 gosec 扫描</a><ul><li><a href="#排除指定的测试">排除指定的测试</a></li><li><a href="#运行指定的检查">运行指定的检查</a></li><li><a href="#扫描测试文件">扫描测试文件</a></li><li><a href="#修改输出的格式">修改输出的格式</a></li></ul></li><li><a href="#用-gosec-检查容易被发现的问题">用 gosec 检查容易被发现的问题</a></li></ul><!-- tocstop --><blockquote><p>来学习下 Go 语言的安全检查工具 gosec。</p></blockquote><p><img src="https://img.linux.net.cn/data/attachment/album/202010/04/125129bh4qxxsyqpvqjtx4.jpg" alt></p><p><a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>写的代码越来越常见，尤其是在容器、Kubernetes 或云生态相关的开发中。Docker 是最早采用 Golang 的项目之一，随后是 Kubernetes，之后大量的新项目在众多编程语言中选择了 Go。</p><p>像其他语言一样，Go 也有它的长处和短处（如安全缺陷）。这些缺陷可能会因为语言本身的缺陷加上程序员编码不当而产生，例如，C 代码中的内存安全问题。</p><p>无论它们出现的原因是什么，安全问题都应该在开发过程的早期修复，以免在封装好的软件中出现。幸运的是，静态分析工具可以帮你以更可重复的方式处理这些问题。静态分析工具通过解析用某种编程语言写的代码来找到问题。</p><p>这类工具中很多被称为 linter。传统意义上，linter 更注重的是检查代码中编码问题、bug、代码风格之类的问题，它们可能不会发现代码中的安全问题。例如，<a href="https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html" target="_blank" rel="noopener">Coverity</a> 是一个很流行的工具，它可以帮助寻找 C/C++ 代码中的问题。然而，也有一些工具专门用来检查源码中的安全问题。例如，<a href="https://pypi.org/project/bandit/" target="_blank" rel="noopener">Bandit</a> 可以检查 Python 代码中的安全缺陷。而 <a href="https://github.com/securego/gosec" target="_blank" rel="noopener">gosec</a> 则用来搜寻 Go 源码中的安全缺陷。<code>gosec</code> 通过扫描 Go 的 AST（抽象语法树abstract syntax tree<ruby>抽象语法树<rt>abstract syntax tree</rt></ruby>）来检查源码中的安全问题。</p><h3 id="开始使用-gosec"><span id="开始使用-gosec">开始使用 gosec</span></h3><p>在开始学习和使用 <code>gosec</code> 之前，你需要准备一个 Go 语言写的项目。有这么多开源软件，我相信这不是问题。你可以在 GitHub 的 <a href="https://github.com/trending/go" target="_blank" rel="noopener">热门 Golang 仓库</a>中找一个。</p><p>本文中，我随机选了 <a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">Docker CE</a> 项目，但你可以选择任意的 Go 项目。</p><h4 id="安装-go-和-gosec"><span id="安装-go-和-gosec">安装 Go 和 gosec</span></h4><p>如果你还没安装 Go，你可以先从仓库中拉取下来。如果你用的是 Fedora 或其他基于 RPM 的 Linux 发行版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dnf install golang.x86_64</span><br></pre></td></tr></table></figure><p>如果你用的是其他操作系统，请参照 <a href="https://golang.org/doc/install" target="_blank" rel="noopener">Golang 安装</a>页面。</p><p>使用 <code>version</code> 参数来验证 Go 是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.14.6 linux/amd64</span><br></pre></td></tr></table></figure><p>运行 <code>go get</code> 命令就可以轻松地安装 <code>gosec</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/securego/gosec/cmd/gosec</span><br></pre></td></tr></table></figure><p>上面这行命令会从 GitHub 下载 <code>gosec</code> 的源码，编译并安装到指定位置。在仓库的 <code>README</code> 中你还可以看到<a href="https://github.com/securego/gosec#install" target="_blank" rel="noopener">安装该工具的其他方法</a>。</p><p><code>gosec</code> 的源码会被下载到 <code>$GOPATH</code> 的位置，编译出的二进制文件会被安装到你系统上设置的 <code>bin</code> 目录下。你可以运行下面的命令来查看 <code>$GOPATH</code> 和 <code>$GOBIN</code> 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go env | grep GOBIN</span><br><span class="line">GOBIN=&quot;/root/go/gobin&quot;</span><br><span class="line">$ go env | grep GOPATH</span><br><span class="line">GOPATH=&quot;/root/go&quot;</span><br></pre></td></tr></table></figure><p>如果 <code>go get</code> 命令执行成功，那么 <code>gosec</code> 二进制应该就可以使用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l ~/go/bin/</span><br><span class="line">total 9260</span><br><span class="line">-rwxr-xr-x. 1 root root 9482175 Aug 20 04:17 gosec</span><br></pre></td></tr></table></figure><p>你可以把 <code>$GOPATH</code> 下的 <code>bin</code> 目录添加到 <code>$PATH</code> 中。这样你就可以像使用系统上的其他命令一样来使用 <code>gosec</code> 命令行工具（CLI）了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ which gosec</span><br><span class="line">/root/go/bin/gosec</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>使用 <code>gosec</code> 命令行工具的 <code>-help</code> 选项来看看运行是否符合预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -help</span><br><span class="line"></span><br><span class="line">gosec - Golang security checker</span><br><span class="line"></span><br><span class="line">gosec analyzes Go source code to look for common programming mistakes that</span><br><span class="line">can lead to security problems.</span><br><span class="line"></span><br><span class="line">VERSION: dev</span><br><span class="line">GIT TAG:</span><br><span class="line">BUILD DATE:</span><br><span class="line"></span><br><span class="line">USAGE:</span><br></pre></td></tr></table></figure><p>之后，创建一个目录，把源码下载到这个目录作为实例项目（本例中，我用的是 Docker CE）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir gosec-demo</span><br><span class="line">$ cd gosec-demo/</span><br><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo</span><br><span class="line">$ git clone https://github.com/docker/docker-ce.git</span><br><span class="line">Cloning into &apos;docker-ce&apos;...</span><br><span class="line">remote: Enumerating objects: 1271, done.</span><br><span class="line">remote: Counting objects: 100% (1271/1271), done.</span><br><span class="line">remote: Compressing objects: 100% (722/722), done.</span><br><span class="line">remote: Total 431003 (delta 384), reused 981 (delta 318), pack-reused 429732</span><br><span class="line">Receiving objects: 100% (431003/431003), 166.84 MiB | 28.94 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (221338/221338), done.</span><br><span class="line">Updating files: 100% (10861/10861), done.</span><br></pre></td></tr></table></figure><p>代码统计工具（本例中用的是 <code>cloc</code>）显示这个项目大部分是用 Go 写的，恰好迎合了 <code>gosec</code> 的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./cloc /root/gosec-demo/docker-ce/</span><br><span class="line">   10771 text files.</span><br><span class="line">    8724 unique files.                                          </span><br><span class="line">    2560 files ignored.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Go                                7222         190785         230478        1574580</span><br><span class="line">YAML                                37           4831            817         156762</span><br><span class="line">Markdown                           529          21422              0          67893</span><br><span class="line">Protocol Buffers                   149           5014          16562          10071</span><br></pre></td></tr></table></figure><h3 id="使用默认选项运行-gosec"><span id="使用默认选项运行-gosec">使用默认选项运行 gosec</span></h3><p>在 Docker CE 项目中使用默认选项运行 <code>gosec</code>，执行 <code>gosec ./...</code> 命令。屏幕上会有很多输出内容。在末尾你会看到一个简短的 “Summary”，列出了浏览的文件数、所有文件的总行数，以及源码中发现的问题数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo/docker-ce</span><br><span class="line">$ time gosec ./...</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Including rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Excluding rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Import directory: /root/gosec-demo/docker-ce/components/engine/opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking package: opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/address_pools.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/env.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/hosts.go</span><br><span class="line"></span><br><span class="line"># End of gosec run</span><br><span class="line"></span><br><span class="line">Summary:</span><br><span class="line">   Files: 1278</span><br><span class="line">   Lines: 173979</span><br><span class="line">   Nosec: 4</span><br><span class="line">  Issues: 644</span><br><span class="line"></span><br><span class="line">real    0m52.019s</span><br><span class="line">user    0m37.284s</span><br><span class="line">sys     0m12.734s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>滚动屏幕你会看到不同颜色高亮的行：红色表示需要尽快查看的高优先级问题，黄色表示中优先级的问题。</p><h4 id="关于误判"><span id="关于误判">关于误判</span></h4><p>在开始检查代码之前，我想先分享几条基本原则。默认情况下，静态检查工具会基于一系列的规则对测试代码进行分析，并报告出它们发现的<em>所有</em>问题。这是否意味着工具报出来的每一个问题都需要修复？非也。这个问题最好的解答者是设计和开发这个软件的人。他们最熟悉代码，更重要的是，他们了解软件会在什么环境下部署以及会被怎样使用。</p><p>这个知识点对于判定工具标记出来的某段代码到底是不是安全缺陷至关重要。随着工作时间和经验的积累，你会慢慢学会怎样让静态分析工具忽略非安全缺陷，使报告内容的可执行性更高。因此，要判定 <code>gosec</code> 报出来的某个问题是否需要修复，让一名有经验的开发者对源码做人工审计会是比较好的办法。</p><h4 id="高优先级问题"><span id="高优先级问题">高优先级问题</span></h4><p>从输出内容看，<code>gosec</code> 发现了 Docker CE 的一个高优先级问题，它使用的是低版本的 TLS（传输层安全Transport Layer Security<ruby>传输层安全<rt>Transport Layer Security<rt></rt></rt></ruby>）。无论什么时候，使用软件和库的最新版本都是确保它更新及时、没有安全问题的最好的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/daemon/logger/splunk/splunk.go:173] - G402 (CWE-295): TLS MinVersion too low. (Confidence: HIGH, Severity: HIGH)</span><br><span class="line">    172:</span><br><span class="line">  &gt; 173:        tlsConfig := &amp;tls.Config&#123;&#125;</span><br><span class="line">    174:</span><br></pre></td></tr></table></figure><p>它还发现了一个弱随机数生成器。它是不是一个安全缺陷，取决于生成的随机数的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/namesgenerator/names-generator.go:843] - G404 (CWE-338): Use of weak random number generator (math/rand instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)</span><br><span class="line">    842: begin:</span><br><span class="line">  &gt; 843:        name := fmt.Sprintf(&quot;%s_%s&quot;, left[rand.Intn(len(left))], right[rand.Intn(len(right))])</span><br><span class="line">    844:        if name == &quot;boring_wozniak&quot; /* Steve Wozniak is not boring */ &#123;</span><br></pre></td></tr></table></figure><h4 id="中优先级问题"><span id="中优先级问题">中优先级问题</span></h4><p>这个工具还发现了一些中优先级问题。它标记了一个通过与 <code>tar</code> 相关的解压炸弹这种方式实现的潜在的 DoS 威胁，这种方式可能会被恶意的攻击者利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/copy.go:357] - G110 (CWE-409): Potential DoS vulnerability via decompression bomb (Confidence: MEDIUM, Severity: MEDIUM)</span><br><span class="line">    356:</span><br><span class="line">  &gt; 357:                        if _, err = io.Copy(rebasedTar, srcTar); err != nil &#123;</span><br><span class="line">    358:                                w.CloseWithError(err)</span><br></pre></td></tr></table></figure><p>它还发现了一个通过变量访问文件的问题。如果恶意使用者能访问这个变量，那么他们就可以改变变量的值去读其他文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/context/tlsdata.go:80] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    79:         if caPath != &quot;&quot; &#123;</span><br><span class="line">  &gt; 80:                 if ca, err = ioutil.ReadFile(caPath); err != nil &#123;</span><br><span class="line">    81:                         return nil, err</span><br></pre></td></tr></table></figure><p>文件和目录通常是操作系统安全的最基础的元素。这里，<code>gosec</code> 报出了一个可能需要你检查目录的权限是否安全的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/contrib/apparmor/main.go:41] - G301 (CWE-276): Expect directory permissions to be 0750 or less (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    40:         // make sure /etc/apparmor.d exists</span><br><span class="line">  &gt; 41:         if err := os.MkdirAll(path.Dir(apparmorProfilePath), 0755); err != nil &#123;</span><br><span class="line">    42:                 log.Fatal(err)</span><br></pre></td></tr></table></figure><p>你经常需要在源码中启动命令行工具。Go 使用内建的 exec 库来实现。仔细地分析用来调用这些工具的变量，就能发现安全缺陷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/testutil/fakestorage/fixtures.go:59] - G204 (CWE-78): Subprocess launched with variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    58:</span><br><span class="line">  &gt; 59:              cmd := exec.Command(goCmd, &quot;build&quot;, &quot;-o&quot;, filepath.Join(tmp, &quot;httpserver&quot;), &quot;github.com/docker/docker/contrib/httpserver&quot;)</span><br><span class="line">    60:                 cmd.Env = append(os.Environ(), []string&#123;</span><br></pre></td></tr></table></figure><h4 id="低优先级问题"><span id="低优先级问题">低优先级问题</span></h4><p>在这个输出中，gosec 报出了一个 <code>unsafe</code> 调用相关的低优先级问题，这个调用会绕开 Go 提供的内存保护。再仔细分析下你调用 <code>unsafe</code> 的方式，看看是否有被别人利用的可能性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/changes_linux.go:264] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    263:        for len(buf) &gt; 0 &#123;</span><br><span class="line">  &gt; 264:                dirent := (*unix.Dirent)(unsafe.Pointer(&amp;buf[0]))</span><br><span class="line">    265:                buf = buf[dirent.Reclen:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/devicemapper/devmapper_wrapper.go:88] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    87: func free(p *C.char) &#123;</span><br><span class="line">  &gt; 88:         C.free(unsafe.Pointer(p))</span><br><span class="line">    89: &#125;</span><br></pre></td></tr></table></figure><p>它还标记了源码中未处理的错误。源码中出现的错误你都应该处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/command/image/build/context.go:172] - G104 (CWE-703): Errors unhandled. (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    171:                err := tar.Close()</span><br><span class="line">  &gt; 172:                os.RemoveAll(dockerfileDir)</span><br><span class="line">    173:                return err</span><br></pre></td></tr></table></figure><h3 id="自定义-gosec-扫描"><span id="自定义-gosec-扫描">自定义 gosec 扫描</span></h3><p>使用 <code>gosec</code> 的默认选项会带来很多的问题。然而，经过人工审计，随着时间推移你会掌握哪些问题是不需要标记的。你可以自己指定排除和包含哪些测试。</p><p>我上面提到过，<code>gosec</code> 是基于一系列的规则从 Go 源码中查找问题的。下面是它使用的完整的<a href="https://github.com/securego/gosec#available-rules" target="_blank" rel="noopener">规则</a>列表：</p><ul><li>G101：查找硬编码凭证</li><li>G102：绑定到所有接口</li><li>G103：审计 <code>unsafe</code> 块的使用</li><li>G104：审计未检查的错误</li><li>G106：审计 <code>ssh.InsecureIgnoreHostKey</code> 的使用</li><li>G107: 提供给 HTTP 请求的 url 作为污点输入</li><li>G108: <code>/debug/pprof</code> 上自动暴露的剖析端点</li><li>G109: <code>strconv.Atoi</code> 转换到 int16 或 int32 时潜在的整数溢出</li><li>G110: 潜在的通过解压炸弹实现的 DoS</li><li>G201：SQL 查询构造使用格式字符串</li><li>G202：SQL 查询构造使用字符串连接</li><li>G203：在 HTML 模板中使用未转义的数据</li><li>G204：审计命令执行情况</li><li>G301：创建目录时文件权限分配不合理</li><li>G302：使用 <code>chmod</code> 时文件权限分配不合理</li><li>G303：使用可预测的路径创建临时文件</li><li>G304：通过污点输入提供的文件路径</li><li>G305：提取 zip/tar 文档时遍历文件</li><li>G306: 写到新文件时文件权限分配不合理</li><li>G307: 把返回错误的函数放到 <code>defer</code> 内</li><li>G401：检测 DES、RC4、MD5 或 SHA1 的使用</li><li>G402：查找错误的 TLS 连接设置</li><li>G403：确保最小 RSA 密钥长度为 2048 位</li><li>G404：不安全的随机数源（<code>rand</code>）</li><li>G501：导入黑名单列表：crypto/md5</li><li>G502：导入黑名单列表：crypto/des</li><li>G503：导入黑名单列表：crypto/rc4</li><li>G504：导入黑名单列表：net/http/cgi</li><li>G505：导入黑名单列表：crypto/sha1</li><li>G601: 在 <code>range</code> 语句中使用隐式的元素别名</li></ul><h4 id="排除指定的测试"><span id="排除指定的测试">排除指定的测试</span></h4><p>你可以自定义 <code>gosec</code> 来避免对已知为安全的问题进行扫描和报告。你可以使用 <code>-exclude</code> 选项和上面的规则编号来忽略指定的问题。</p><p>例如，如果你不想让 <code>gosec</code> 检查源码中硬编码凭证相关的未处理的错误，那么你可以运行下面的命令来忽略这些错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -exclude=G104 ./...</span><br><span class="line">$ gosec -exclude=G104,G101 ./...</span><br></pre></td></tr></table></figure><p>有时候你知道某段代码是安全的，但是 <code>gosec</code> 还是会报出问题。然而，你又不想完全排除掉整个检查，因为你想让 <code>gosec</code> 检查新增的代码。通过在你已知为安全的代码块添加 <code>#nosec</code> 标记可以避免 <code>gosec</code> 扫描。这样 <code>gosec</code> 会继续扫描新增代码，而忽略掉 <code>#nosec</code> 标记的代码块。</p><h4 id="运行指定的检查"><span id="运行指定的检查">运行指定的检查</span></h4><p>另一方面，如果你只想检查指定的问题，你可以通过 <code>-include</code> 选项和规则编号来告诉 <code>gosec</code> 运行哪些检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -include=G201,G202 ./...</span><br></pre></td></tr></table></figure><h4 id="扫描测试文件"><span id="扫描测试文件">扫描测试文件</span></h4><p>Go 语言自带对测试的支持，通过单元测试来检验一个元素是否符合预期。在默认模式下，<code>gosec</code> 会忽略测试文件，你可以使用 <code>-tests</code> 选项把它们包含进来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gosec -tests ./...</span><br></pre></td></tr></table></figure><h4 id="修改输出的格式"><span id="修改输出的格式">修改输出的格式</span></h4><p>找出问题只是它的一半功能；另一半功能是把它检查到的问题以用户友好同时又方便工具处理的方式报告出来。幸运的是，<code>gosec</code> 可以用不同的方式输出。例如，如果你想看 JSON 格式的报告，那么就使用 <code>-fmt</code> 选项指定 JSON 格式并把结果保存到 <code>results.json</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gosec -fmt=json -out=results.json ./...</span><br><span class="line"></span><br><span class="line">$ ls -l results.json</span><br><span class="line">-rw-r--r--. 1 root root 748098 Aug 20 05:06 results.json</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line">             &quot;severity&quot;: &quot;LOW&quot;,</span><br><span class="line">             &quot;confidence&quot;: &quot;HIGH&quot;,</span><br><span class="line">             &quot;cwe&quot;: &#123;</span><br><span class="line">                 &quot;ID&quot;: &quot;242&quot;,</span><br><span class="line">                 &quot;URL&quot;: &quot;https://cwe.mitre.org/data/definitions/242.html&quot;</span><br><span class="line">             &#125;,</span><br><span class="line">             &quot;rule_id&quot;: &quot;G103&quot;,</span><br><span class="line">             &quot;details&quot;: &quot;Use of unsafe calls should be audited&quot;,</span><br><span class="line">             &quot;file&quot;: &quot;/root/gosec-demo/docker-ce/components/engine/daemon/graphdriver/graphtest/graphtest_unix.go&quot;,</span><br><span class="line">             &quot;code&quot;: &quot;304: \t// Cast to []byte\n305: \theader := *(*reflect.SliceHeader)(unsafe.Pointer(\u0026buf))\n306: \theader.      Len *= 8\n&quot;,</span><br><span class="line">             &quot;line&quot;: &quot;305&quot;,</span><br><span class="line">             &quot;column&quot;: &quot;36&quot;</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure><h3 id="用-gosec-检查容易被发现的问题"><span id="用-gosec-检查容易被发现的问题">用 gosec 检查容易被发现的问题</span></h3><p>静态检查工具不能完全代替人工代码审计。然而，当代码量变大、有众多开发者时，这样的工具往往有助于以可重复的方式找出容易被发现的问题。它对于帮助新开发者识别和在编码时避免引入这些安全缺陷很有用。</p><hr><p>via: <a href="https://opensource.com/article/20/9/gosec" target="_blank" rel="noopener">https://opensource.com/article/20/9/gosec</a></p><p>作者：<a href="https://opensource.com/users/gkamathe" target="_blank" rel="noopener">Gaurav Kamathe</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbowlf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> gosec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP检测图片是否有木马</title>
      <link href="/9a49b652/"/>
      <url>/9a49b652/</url>
      
        <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Content-type: text/html; charset=utf-8"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHex</span><span class="params">($img)</span> </span>&#123;</span><br><span class="line">  $status = <span class="number">0</span>;</span><br><span class="line">  $tips = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"0"</span> =&gt; <span class="string">"文件没问题"</span>,</span><br><span class="line">    <span class="string">"5"</span> =&gt; <span class="string">"文件有毒"</span>,</span><br><span class="line">    <span class="string">"-1"</span> =&gt; <span class="string">"文件没有上传"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (file_exists($img)) &#123;</span><br><span class="line">    $resource = fopen($img, <span class="string">'rb'</span>);</span><br><span class="line">    $fileSize = filesize($img);</span><br><span class="line">    fseek($resource, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ($fileSize &gt; <span class="number">512</span>) &#123; <span class="comment">// 取头和尾</span></span><br><span class="line">      $hexCode = bin2hex(fread($resource, <span class="number">512</span>));</span><br><span class="line">      fseek($resource, $fileSize - <span class="number">512</span>);</span><br><span class="line">      $hexCode .= bin2hex(fread($resource, <span class="number">512</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 取全部</span></span><br><span class="line">      $hexCode = bin2hex(fread($resource, $fileSize));</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($resource);</span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;% ( ) %&gt; */</span></span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;? ( ) ?&gt; */</span></span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;script | /script&gt; 大小写亦可 */</span></span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">"/(3c25.*?28.*?29.*?253e)|(3c3f.*?28.*?29.*?3f3e)|(3C534352495054)|(2F5343524950543E)|(3C736372697074)|(2F7363726970743E)/is"</span>, $hexCode)) &#123;</span><br><span class="line">      $status = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $status = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $tips[$status];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$rs = checkHex(<span class="string">"du.png"</span>);</span><br><span class="line"></span><br><span class="line">print_r($rs);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量复制重放工具goreplay</title>
      <link href="/8c9efcce/"/>
      <url>/8c9efcce/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#goreplay简介">goreplay简介</a></li><li><a href="#goreplay工作原理">goreplay工作原理</a><ul><li><a href="#goreplay常见用法">goreplay常见用法</a></li><li><a href="#gor参数">gor参数</a></li></ul></li></ul><!-- tocstop --><h1 id="goreplay简介"><span id="goreplay简介">goreplay简介</span></h1><p><a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">https://github.com/buger/goreplay</a></p><p><a href="https://goreplay.org/" target="_blank" rel="noopener">https://goreplay.org</a></p><p>GoReplay是一个开源工具，用于捕获实时HTTP流量并将其重放到测试环境中，以便使用真实数据持续测试系统。<br>GoReplay不是代理，而是监听网络接口上的流量，不需要更改生产基础架构，而是在与服务相同的计算机上运行GoReplay守护程序。</p><h1 id="goreplay工作原理"><span id="goreplay工作原理">goreplay工作原理</span></h1><p><img src="https://camo.githubusercontent.com/1c65a684aeb1d16343d59c3ab6d3f9d41c77c36f/68747470733a2f2f692e696d6775722e636f6d2f494e327866446d2e706e67" alt></p><h2 id="goreplay常见用法"><span id="goreplay常见用法">goreplay常见用法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 简单的 HTTP 流量复制：</span><br><span class="line">gor –input-raw :80 –output-http “http://staging.com”</span><br><span class="line"></span><br><span class="line">2.HTTP 流量复制频率控制：</span><br><span class="line">gor –input-tcp :28020 –output-http “http://staging.com|10″</span><br><span class="line"></span><br><span class="line">3.HTTP 流量复制缩小：</span><br><span class="line">gor –input-raw :80 –output-tcp “replay.local:28020|10%”</span><br><span class="line"></span><br><span class="line">4.HTTP 流量记录到本地文件：</span><br><span class="line">gor –input-raw :80 –output-file requests.gor</span><br><span class="line"></span><br><span class="line">5.HTTP 流量回放和压测：</span><br><span class="line">gor –input-file “requests.gor|200%” –output-http “staging.com”</span><br><span class="line"></span><br><span class="line">6.HTTP 流量过滤复制：</span><br><span class="line">gor –input-raw :8080 –output-http staging.com –output-http-url-regexp ^www.</span><br><span class="line"></span><br><span class="line">7.HTTP指定接口流量复制：</span><br><span class="line">gor --input-raw :80 --http-allow-url <span class="string">'/api/v1'</span> --output-stdout      //--output-stdout表示直接在控制台输出</span><br></pre></td></tr></table></figure><h2 id="gor参数"><span id="gor参数">gor参数</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">[root@~]<span class="comment"># gor --help</span></span><br><span class="line">Gor is a simple http traffic replication tool written <span class="keyword">in</span> Go. Its main goal is to replay traffic from production servers to staging and dev environments.</span><br><span class="line">Project page: https://github.com/buger/gor</span><br><span class="line">Author: &lt;Leonid Bugaev&gt; leonsbox@gmail.com</span><br><span class="line">Current Version: 1.0.0</span><br><span class="line"></span><br><span class="line">  -copy-buffer-size int</span><br><span class="line">    Set the buffer size <span class="keyword">for</span> an individual request (default 5M) (default 5242880)</span><br><span class="line">  -cpuprofile string</span><br><span class="line">    write cpu profile to file</span><br><span class="line">  -debug verbose//打开debug模式，显示所有接口的流量 </span><br><span class="line">    Turn on debug output, shows all intercepted traffic. Works only when with verbose flag</span><br><span class="line">  -<span class="built_in">exit</span>-after duration</span><br><span class="line">    <span class="built_in">exit</span> after specified duration</span><br><span class="line">  -http-allow-header value      //用一个正则表达式来匹配http头部，如果请求的头部没有匹配上，则被拒绝</span><br><span class="line">    A regexp to match a specific header against. Requests with non-matching headers will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-allow-header api-version:^v1</span><br><span class="line">  -http-allow-method value      // 类似于一个白名单机制来允许通过的http请求方法，除此之外的方法都被拒绝.</span><br><span class="line">    Whitelist of HTTP methods to replay. Anything <span class="keyword">else</span> will be dropped:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-allow-method GET --http-allow-method OPTIONS</span><br><span class="line">  -http-allow-url value             //一个正则表达式用来匹配url， 用来过滤完全匹配的的url，在此之外的都被过滤掉</span><br><span class="line">    A regexp to match requests against. Filter get matched against full url with domain. Anything <span class="keyword">else</span> will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-allow-url ^www.</span><br><span class="line">  -http-basic-auth-filter value         //匹配认证头重放</span><br><span class="line">    A regexp to match the decoded basic auth string against. Requests with non-matching headers will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-basic-auth-filter <span class="string">"^customer[0-9].*"</span></span><br><span class="line">  -http-disallow-header value       //用一个正则表达式来匹配http头部，匹配到的请求会被拒绝掉</span><br><span class="line">    A regexp to match a specific header against. Requests with matching headers will be dropped:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-disallow-header <span class="string">"User-Agent: Replayed by Gor"</span></span><br><span class="line">  -http-disallow-url value      //用一个正则表达式来匹配url，如果请求匹配上了，则会被拒绝</span><br><span class="line">    A regexp to match requests against. Filter get matched against full url with domain. Anything <span class="keyword">else</span> will be forwarded:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-disallow-url ^www.</span><br><span class="line">  -http-header-limiter value//读取请求，基于FNV32-1A散列来拒绝一定比例的特殊请求 </span><br><span class="line">    Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A <span class="built_in">hash</span> of a specific header:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-header-limiter user-id:25%</span><br><span class="line">  -http-original-host       //在--output-http的输出中，通常gor会使用取代请求的http头，所以应该禁用该选项，保留原始的主机头</span><br><span class="line">    Normally gor replaces the Host http header with the host supplied with --output-http.  This option disables that behavior, preserving the original Host header.</span><br><span class="line">  -http-param-limiter value</span><br><span class="line">    Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A <span class="built_in">hash</span> of a specific GET param:</span><br><span class="line">     gor --input-raw :8080 --output-http staging.com --http-param-limiter user_id:25%</span><br><span class="line">  -http-pprof :8181</span><br><span class="line">    Enable profiling. Starts  http server on specified port, exposing special /debug/pprof endpoint. Example: :8181</span><br><span class="line">  -http-rewrite-header value</span><br><span class="line">    Rewrite the request header based on a mapping:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-rewrite-header Host: (.*).example.com,<span class="variable">$1</span>.beta.example.com</span><br><span class="line">  -http-rewrite-url value</span><br><span class="line">    Rewrite the request url based on a mapping:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-rewrite-url /v1/user/([^\/]+)/ping:/v2/user/<span class="variable">$1</span>/ping</span><br><span class="line">  -http-set-header value</span><br><span class="line">    Inject additional headers to http reqest:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-set-header <span class="string">'User-Agent: Gor'</span></span><br><span class="line">  -http-set-param value</span><br><span class="line">    Set request url param, <span class="keyword">if</span> param already exists it will be overwritten:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --http-set-param api_key=1</span><br><span class="line">  -input-dummy value</span><br><span class="line">    Used <span class="keyword">for</span> testing outputs. Emits <span class="string">'Get /'</span> request every 1s</span><br><span class="line">  -input-file value//从一个文件中读取请求</span><br><span class="line">    Read requests from file: </span><br><span class="line">    gor --input-file ./requests.gor --output-http staging.com</span><br><span class="line">  -input-file-loop</span><br><span class="line">    Loop input files, useful <span class="keyword">for</span> performance testing.</span><br><span class="line">  -input-kafka-host string</span><br><span class="line">    Send request and response stats to Kafka:</span><br><span class="line">    gor --output-stdout --input-kafka-host <span class="string">'192.168.0.1:9092,192.168.0.2:9092'</span></span><br><span class="line">  -input-kafka-json-format</span><br><span class="line">    If turned on, it will assume that messages coming <span class="keyword">in</span> JSON format rather than  GoReplay text format.</span><br><span class="line">  -input-kafka-topic string</span><br><span class="line">    Send request and response stats to Kafka:</span><br><span class="line">    gor --output-stdout --input-kafka-topic <span class="string">'kafka-log'</span></span><br><span class="line">  -input-raw value</span><br><span class="line">    Capture traffic from given port (use RAW sockets and require *sudo* access):</span><br><span class="line">    <span class="comment"># Capture traffic from 8080 port</span></span><br><span class="line">    gor --input-raw :8080 --output-http staging.com</span><br><span class="line">  -input-raw-bpf-filter string</span><br><span class="line">    BPF filter to write custom expressions. Can be useful <span class="keyword">in</span> <span class="keyword">case</span> of non standard network interfaces like tunneling or SPAN port. Example: --input-raw-bpf-filter <span class="string">'dst port 80'</span></span><br><span class="line">  -input-raw-buffer-size int</span><br><span class="line">    Controls size of the OS buffer (<span class="keyword">in</span> bytes) <span class="built_in">which</span> holds packets until they dispatched. Default value depends by system: <span class="keyword">in</span> Linux around 2MB. If you see big package drop, increase this value.</span><br><span class="line">  -input-raw-engine libpcap</span><br><span class="line">    Intercept traffic using libpcap (default), and `raw_socket` (default <span class="string">"libpcap"</span>)</span><br><span class="line">  -input-raw-expire duration</span><br><span class="line">    How much it should <span class="built_in">wait</span> <span class="keyword">for</span> the last TCP packet, till consider that TCP message complete. (default 2s)</span><br><span class="line">  -input-raw-immediate-mode</span><br><span class="line">    Set pcap interface to immediate mode.</span><br><span class="line">  -input-raw-override-snaplen</span><br><span class="line">    Override the capture snaplen to be 64k. Required <span class="keyword">for</span> some Virtualized environments</span><br><span class="line">  -input-raw-realip-header string</span><br><span class="line">    If not blank, injects header with given name and real IP value to the request payload. Usually this header should be named: X-Real-IP</span><br><span class="line">  -input-raw-timestamp-type string</span><br><span class="line">    Possible values: PCAP_TSTAMP_HOST, PCAP_TSTAMP_HOST_LOWPREC, PCAP_TSTAMP_HOST_HIPREC, PCAP_TSTAMP_ADAPTER, PCAP_TSTAMP_ADAPTER_UNSYNCED. This values not supported on all systems, GoReplay will tell you available values of you put wrong one.</span><br><span class="line">  -input-raw-track-response</span><br><span class="line">    If turned on Gor will track responses <span class="keyword">in</span> addition to requests, and they will be available to middleware and file output.</span><br><span class="line">  -input-tcp value// 用来在多个gor之间流转流量</span><br><span class="line">    Used <span class="keyword">for</span> internal communication between Gor instances. Example: </span><br><span class="line">    <span class="comment"># Receive requests from other Gor instances on 28020 port, and redirect output to staging</span></span><br><span class="line">    gor --input-tcp :28020 --output-http staging.com</span><br><span class="line">  -input-tcp-certificate string</span><br><span class="line">    Path to PEM encoded certificate file. Used when TLS turned on.</span><br><span class="line">  -input-tcp-certificate-key string</span><br><span class="line">    Path to PEM encoded certificate key file. Used when TLS turned on.</span><br><span class="line">  -input-tcp-secure</span><br><span class="line">    Turn on TLS security. Do not forget to specify certificate and key files.</span><br><span class="line">  -memprofile string</span><br><span class="line">    write memory profile to this file</span><br><span class="line">  -middleware string</span><br><span class="line">    Used <span class="keyword">for</span> modifying traffic using external <span class="built_in">command</span></span><br><span class="line">  -output-dummy value//用来测试输入，打印出接收的数据.</span><br><span class="line">    DEPRECATED: use --output-stdout instead</span><br><span class="line">  -output-file value//把进入的请求写入一个文件中 </span><br><span class="line">    Write incoming requests to file: </span><br><span class="line">    gor --input-raw :80 --output-file ./requests.gor</span><br><span class="line">  -output-file-append</span><br><span class="line">    The flushed chunk is appended to existence file or not. </span><br><span class="line">  -output-file-flush-interval duration</span><br><span class="line">    Interval <span class="keyword">for</span> forcing buffer flush to the file, default: 1s. (default 1s)</span><br><span class="line">  -output-file-max-size-limit value</span><br><span class="line">    Max size of output file, Default: 1TB (default -1)</span><br><span class="line">  -output-file-queue-limit int</span><br><span class="line">    The length of the chunk queue. Default: 256 (default 256)</span><br><span class="line">  -output-file-size-limit value</span><br><span class="line">    Size of each chunk. Default: 32mb (default 33554432)</span><br><span class="line">  -output-http value//转发进入的请求到一个http地址上</span><br><span class="line">    Forwards incoming requests to given http address.</span><br><span class="line">    <span class="comment"># Redirect all incoming requests to staging.com address </span></span><br><span class="line">    gor --input-raw :80 --output-http http://staging.com</span><br><span class="line">  -output-http-compatibility-mode</span><br><span class="line">    Use standard Go client, instead of built-in implementation. Can be slower, but more compatible.</span><br><span class="line">  -output-http-debug</span><br><span class="line">    Enables http debug output.</span><br><span class="line">  -output-http-elasticsearch string//把请求和响应状态发送到ElasticSearch</span><br><span class="line">    Send request and response stats to ElasticSearch:</span><br><span class="line">    gor --input-raw :8080 --output-http staging.com --output-http-elasticsearch <span class="string">'es_host:api_port/index_name'</span></span><br><span class="line">  -output-http-header --output-http-header</span><br><span class="line">    WARNING: --output-http-header DEPRECATED, use `--http-set-header` instead</span><br><span class="line">  -output-http-header-filter --output-http-header-filter</span><br><span class="line">    WARNING: --output-http-header-filter DEPRECATED, use `--http-allow-header` instead</span><br><span class="line">  -output-http-header-hash-filter output-http-header-hash-filter</span><br><span class="line">    WARNING: output-http-header-hash-filter DEPRECATED, use `--http-header-hash-limiter` instead</span><br><span class="line">  -output-http-method --output-http-method</span><br><span class="line">    WARNING: --output-http-method DEPRECATED, use `--http-allow-method` instead</span><br><span class="line">  -output-http-queue-len int</span><br><span class="line">    Number of requests that can be queued <span class="keyword">for</span> output, <span class="keyword">if</span> all workers are busy. default = 1000 (default 1000)</span><br><span class="line">  -output-http-redirects int//设置多少次重定向被允许</span><br><span class="line">    Enable how often redirects should be followed.</span><br><span class="line">  -output-http-response-buffer int</span><br><span class="line">    HTTP response buffer size, all data after this size will be discarded.</span><br><span class="line">  -output-http-rewrite-url --output-http-rewrite-url</span><br><span class="line">    WARNING: --output-http-rewrite-url DEPRECATED, use `--http-rewrite-url` instead</span><br><span class="line">  -output-http-stats//每5秒钟输出一次输出队列的状态</span><br><span class="line">    Report http output queue stats to console every N milliseconds. See output-http-stats-ms</span><br><span class="line">  -output-http-stats-ms int</span><br><span class="line">    Report http output queue stats to console every N milliseconds. default: 5000 (default 5000)</span><br><span class="line">  -output-http-timeout duration//指定http的request/response超时时间，默认是5秒 </span><br><span class="line">    Specify HTTP request/response timeout. By default 5s. Example: --output-http-timeout 30s (default 5s)</span><br><span class="line">  -output-http-track-response</span><br><span class="line">    If turned on, HTTP output responses will be <span class="built_in">set</span> to all outputs like stdout, file and etc.</span><br><span class="line">  -output-http-url-regexp --output-http-url-regexp</span><br><span class="line">    WARNING: --output-http-url-regexp DEPRECATED, use `--http-allow-url` instead</span><br><span class="line">  -output-http-workers int// gor默认是动态的扩展工作者数量，你也可以指定固定数量的工作者</span><br><span class="line">    Gor uses dynamic worker scaling. Enter a number to <span class="built_in">set</span> a maximum number of workers. default = 0 = unlimited.</span><br><span class="line">  -output-http-workers-min int</span><br><span class="line">    Gor uses dynamic worker scaling. Enter a number to <span class="built_in">set</span> a minimum number of workers. default = 1.</span><br><span class="line">  -output-kafka-host string</span><br><span class="line">    Read request and response stats from Kafka:</span><br><span class="line">    gor --input-raw :8080 --output-kafka-host <span class="string">'192.168.0.1:9092,192.168.0.2:9092'</span></span><br><span class="line">  -output-kafka-json-format</span><br><span class="line">    If turned on, it will serialize messages from GoReplay text format to JSON.</span><br><span class="line">  -output-kafka-topic string</span><br><span class="line">    Read request and response stats from Kafka:</span><br><span class="line">    gor --input-raw :8080 --output-kafka-topic <span class="string">'kafka-log'</span></span><br><span class="line">  -output-null</span><br><span class="line">    Used <span class="keyword">for</span> testing inputs. Drops all requests.</span><br><span class="line">  -output-stdout</span><br><span class="line">    Used <span class="keyword">for</span> testing inputs. Just prints to console data coming from inputs.</span><br><span class="line">  -output-tcp value//用来在多个gor之间流转流量</span><br><span class="line">    Used <span class="keyword">for</span> internal communication between Gor instances. Example: </span><br><span class="line">    <span class="comment"># Listen for requests on 80 port and forward them to other Gor instance on 28020 port</span></span><br><span class="line">    gor --input-raw :80 --output-tcp replay.local:28020</span><br><span class="line">  -output-tcp-secure</span><br><span class="line">    Use TLS secure connection. --input-file on another end should have TLS turned on as well.</span><br><span class="line">  -output-tcp-stats//每5秒钟报告一次tcp输出队列的状态</span><br><span class="line">    Report TCP output queue stats to console every 5 seconds.</span><br><span class="line">  -prettify-http</span><br><span class="line">    If enabled, will automatically decode requests and responses with: Content-Encodning: gzip and Transfer-Encoding: chunked. Useful <span class="keyword">for</span> debugging, <span class="keyword">in</span> conjuction with --output-stdout</span><br><span class="line">  -split-output <span class="literal">true</span></span><br><span class="line">    By default each output gets same traffic. If <span class="built_in">set</span> to <span class="literal">true</span> it splits traffic equally among all outputs.</span><br><span class="line">  -stats//打开输出队列的状态</span><br><span class="line">    Turn on queue stats output</span><br><span class="line">  -verbose</span><br><span class="line">    Turn on more verbose output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10大静态网站生成工具</title>
      <link href="/690c8418/"/>
      <url>/690c8418/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#静态网站是什么">静态网站是什么？</a></li><li><a href="#最好的开源静态网站生成工具">最好的开源静态网站生成工具</a><ul><li><a href="#1-jekyll">1、Jekyll</a></li><li><a href="#2-hugo">2、Hugo</a></li><li><a href="#3-hexo">3、Hexo</a></li><li><a href="#4-gatsby">4、Gatsby</a></li><li><a href="#5-vuepress">5、VuePress</a></li><li><a href="#6-nuxtjs">6、Nuxt.js</a></li><li><a href="#7-docusaurus">7、Docusaurus</a></li><li><a href="#8-eleventy">8、Eleventy</a></li><li><a href="#9-publii">9、Publii</a></li><li><a href="#10-primo">10、Primo</a></li></ul></li><li><a href="#结语">结语</a></li></ul><!-- tocstop --><p><img src="https://img.linux.net.cn/data/attachment/album/202010/01/123903lx1q0w2oh1lxx7wh.jpg" alt></p><blockquote><p>在寻找部署静态网页的方法吗？这几个开源的静态网站生成工具可以帮你迅速部署界面优美、功能强大的静态网站，无需掌握复杂的 HTML 和 CSS 技能。</p></blockquote><h3 id="静态网站是什么"><span id="静态网站是什么">静态网站是什么？</span></h3><p>技术上来讲，静态网站是指网页不是由服务器动态生成的。HTML、CSS 和 JavaScript 文件就静静地躺在服务器的某个路径下，它们的内容与终端用户接收到的版本是一样的。原始的源码文件已经提前编译好了，源码在每次请求后都不会变化。</p><p>Linux.CN 是一个依赖多个数据库的动态网站，当有浏览器的请求时，网页就会生成并提供服务。大部分网站是动态的，你与这些网站互动时，大量的内容会经常改变。</p><p>静态网站有一些好处，比如加载时间更短，请求的服务器资源更少、更安全（值得商榷）。</p><p>传统上，静态网站更适合于创建只有少量网页、内容变化不频繁的小网站。</p><p>然而，随着静态网站生成工具出现后，静态网站的适用范围越来越大。你还可以使用这些工具搭建博客网站。</p><p>我整理了几个开源的静态网站生成工具，这些工具可以帮你搭建界面优美的网站。</p><h3 id="最好的开源静态网站生成工具"><span id="最好的开源静态网站生成工具">最好的开源静态网站生成工具</span></h3><p>请注意，静态网站不会提供很复杂的功能。如果你需要复杂的功能，那么你可以参考适用于动态网站的<a href="https://itsfoss.com/open-source-cms/" target="_blank" rel="noopener">最佳开源 CMS</a>列表。</p><h4 id="1-jekyll"><span id="1-jekyll">1、Jekyll</span></h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2018/01/jekyll-screenshot.jpg?resize=800%2C450&ssl=1" alt></p><p>Jekyll 是用 <a href="https://www.ruby-lang.org/en/" target="_blank" rel="noopener">Ruby</a> 写的最受欢迎的开源静态生成工具之一。实际上，Jekyll 是 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub 页面</a> 的引擎，它可以让你免费用 GitHub 托管网站。</p><p>你可以很轻松地跨平台配置 Jekyll，包括 Ubuntu。它利用 <a href="https://github.com/Shopify/liquid/wiki" target="_blank" rel="noopener">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki" target="_blank" rel="noopener">Liquid</a>（模板语言）、HTML 和 CSS 来生成静态的网页文件。如果你要搭建一个没有广告或推广自己工具或服务的产品页的博客网站，它是个不错的选择。</p><p>它还支持从常见的 CMS（<ruby>内容管理系统<rt>Content management system</rt></ruby>）如 Ghost、WordPress、Drupal 7 迁移你的博客。你可以管理永久链接、类别、页面、文章，还可以自定义布局，这些功能都很强大。因此，即使你已经有了一个网站，如果你想转成静态网站，Jekyll 会是一个完美的解决方案。你可以参考<a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">官方文档</a>或 <a href="https://github.com/jekyll/jekyll" target="_blank" rel="noopener">GitHub 页面</a>了解更多内容。</p><ul><li><a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a></li></ul><h4 id="2-hugo"><span id="2-hugo">2、Hugo</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hugo.jpg?resize=800%2C414&ssl=1" alt></p><p>Hugo 是另一个很受欢迎的用于搭建静态网站的开源框架。它是用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>写的。</p><p>它运行速度快、使用简单、可靠性高。如果你需要，它也可以提供更高级的主题。它还提供了一些有用的快捷方式来帮助你轻松完成任务。无论是组合展示网站还是博客网站，Hogo 都有能力管理大量的内容类型。</p><p>如果你想使用 Hugo，你可以参照它的<a href="https://gohugo.io/getting-started/" target="_blank" rel="noopener">官方文档</a>或它的 <a href="https://github.com/gohugoio/hugo" target="_blank" rel="noopener">GitHub 页面</a>来安装以及了解更多相关的使用方法。如果需要的话，你还可以将 Hugo 部署在 GitHub 页面或任何 CDN 上。</p><ul><li><a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a></li></ul><h4 id="3-hexo"><span id="3-hexo">3、Hexo</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hexo.jpg?resize=800%2C213&ssl=1" alt></p><p>Hexo 是一个有趣的开源框架，基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>。像其他的工具一样，你可以用它搭建相当快速的网站，不仅如此，它还提供了丰富的主题和插件。</p><p>它还根据用户的每个需求提供了强大的 API 来扩展功能。如果你已经有一个网站，你可以用它的<a href="https://hexo.io/api/migrator.html" target="_blank" rel="noopener">迁移</a>扩展轻松完成迁移工作。</p><p>你可以参照<a href="https://hexo.io/docs/" target="_blank" rel="noopener">官方文档</a>或 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">GitHub 页面</a> 来使用 Hexo。</p><ul><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li></ul><h4 id="4-gatsby"><span id="4-gatsby">4、Gatsby</span></h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/gatsbyjs.png?resize=800%2C388&ssl=1" alt></p><p>Gatsby 是一个越来越流行的开源网站生成框架。它使用 <a href="https://reactjs.org/" target="_blank" rel="noopener">React.js</a> 来生成快速、界面优美的网站。</p><p>几年前在一个实验性的项目中，我曾经非常想尝试一下这个工具，它提供的成千上万的新插件和主题的能力让我印象深刻。与其他静态网站生成工具不同的是，你可以使用 Gatsby 生成一个网站，并在不损失任何功能的情况下获得静态网站的好处。</p><p>它提供了与很多流行的服务的整合功能。当然，你可以不使用它的复杂的功能，或将其与你选择的流行 CMS 配合使用，这也会很有趣。你可以查看他们的<a href="https://www.gatsbyjs.com/docs/" target="_blank" rel="noopener">官方文档</a>或它的 <a href="https://github.com/gatsbyjs/gatsby" target="_blank" rel="noopener">GitHub 页面</a>了解更多内容。</p><ul><li><a href="https://www.gatsbyjs.com/" target="_blank" rel="noopener">Gatsby</a></li></ul><h4 id="5-vuepress"><span id="5-vuepress">5、VuePress</span></h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/VuePress.jpg?resize=800%2C498&ssl=1" alt></p><p>VuePress 是由 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 支持的静态网站生成工具，而 Vue.js 是一个开源的渐进式 JavaScript 框架。</p><p>如果你了解 HTML、CSS 和 JavaScript，那么你可以无压力地使用 VuePress。你应该可以找到几个有用的插件和主题来为你的网站建设开个头。此外，看起来 Vue.js 的更新一直很活跃，很多开发者都在关注 Vue.js，这是一件好事。</p><p>你可以参照他们的<a href="https://vuepress.vuejs.org/guide/" target="_blank" rel="noopener">官方文档</a>和 <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener">GitHub 页面</a>了解更多。</p><ul><li><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener">VuePress</a></li></ul><h4 id="6-nuxtjs"><span id="6-nuxtjs">6、Nuxt.js</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/nuxtjs.jpg?resize=800%2C415&ssl=1" alt></p><p>Nuxt.js 使用了 Vue.js 和 Node.js，但它致力于模块化，并且有能力依赖服务端而非客户端。不仅如此，它的目标是为开发者提供直观的体验，并提供描述性错误，以及详细的文档等。</p><p>正如它声称的那样，在你用来搭建静态网站的所有工具中，Nuxt.js 可以做到功能和灵活性两全其美。他们还提供了一个 <a href="https://template.nuxtjs.org/" target="_blank" rel="noopener">Nuxt 线上沙盒</a>，让你不费吹灰之力就能直接测试它。</p><p>你可以查看它的 <a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">GitHub 页面</a>和<a href="https://nuxtjs.org/" target="_blank" rel="noopener">官方网站</a>了解更多。</p><ul><li><a href="https://nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a></li></ul><h4 id="7-docusaurus"><span id="7-docusaurus">7、Docusaurus</span></h4><p><img src="https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/docusaurus.jpg?resize=800%2C278&ssl=1" alt></p><p>Docusaurus 是一个有趣的开源静态网站生成工具，为搭建文档类网站量身定制。它还是 <a href="https://opensource.facebook.com/" target="_blank" rel="noopener">Facebook 开源计划</a>的一个项目。</p><p>Docusaurus 是用 React 构建的。你可以使用所有的基本功能，像文档版本管理、文档搜索和翻译大多是预先配置的。如果你想为你的产品或服务搭建一个文档网站，那么可以试试 Docusaurus。</p><p>你可以从它的 <a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener">GitHub 页面</a>和它的<a href="https://docusaurus.io/" target="_blank" rel="noopener">官网</a>获取更多信息。</p><ul><li><a href="https://docusaurus.io/" target="_blank" rel="noopener">Docusaurus</a></li></ul><h4 id="8-eleventy"><span id="8-eleventy">8、Eleventy</span></h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/eleventy.png?resize=800%2C375&ssl=1" alt></p><p>Eleventy 自称是 Jekyll 的替代品，旨在以更简单的方法来制作更快的静态网站。</p><p>它似乎很容易上手，而且它还提供了适当的文档来帮助你。如果你想找一个简单的静态网站生成工具，Eleventy 似乎会是一个有趣的选择。</p><p>你可以参照它的 <a href="https://github.com/11ty/eleventy/" target="_blank" rel="noopener">GitHub 页面</a>和<a href="https://www.11ty.dev/" target="_blank" rel="noopener">官网</a>来了解更多的细节。</p><ul><li><a href="https://www.11ty.dev/" target="_blank" rel="noopener">Eleventy</a></li></ul><h4 id="9-publii"><span id="9-publii">9、Publii</span></h4><p><img src="https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/publii.jpg?resize=800%2C311&ssl=1" alt></p><p>Publii 是一个令人印象深刻的开源 CMS，它能使生成一个静态网站变得很容易。它是用 <a href="https://www.electronjs.org" target="_blank" rel="noopener">Electron</a> 和 Vue.js 构建的。如果有需要，你也可以把你的文章从 WorkPress 网站迁移过来。此外，它还提供了与 GitHub 页面、Netlify 及其它类似服务的一键同步功能。</p><p>如果你利用 Publii 生成一个静态网站，你还可以得到一个所见即所得的编辑器。你可以从<a href="https://getpublii.com/" target="_blank" rel="noopener">官网</a>下载它，或者从它的 <a href="https://github.com/GetPublii/Publii" target="_blank" rel="noopener">GitHub 页面</a>了解更多信息。</p><ul><li><a href="https://getpublii.com/" target="_blank" rel="noopener">Publii</a></li></ul><h4 id="10-primo"><span id="10-primo">10、Primo</span></h4><p><img src="https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/primo-af.jpg?resize=800%2C394&ssl=1" alt></p><p>一个有趣的开源静态网站生成工具，目前开发工作仍很活跃。虽然与其他的静态生成工具相比，它还不是一个成熟的解决方案，有些功能还不完善，但它是一个独特的项目。</p><p>Primo 旨在使用可视化的构建器帮你构建和搭建网站，这样你就可以轻松编辑和部署到任意主机上。</p><p>你可以参照<a href="https://primo.af/" target="_blank" rel="noopener">官网</a>或查看它的 <a href="https://github.com/primo-app/primo-desktop" target="_blank" rel="noopener">GitHub 页面</a>了解更多信息。</p><ul><li><a href="https://primo.af/" target="_blank" rel="noopener">Primo</a></li></ul><h3 id="结语"><span id="结语">结语</span></h3><p>还有很多文章中没有列出的网站生成工具。然而，我试图提到最好的静态生成器，为您提供最快的加载时间，最好的安全性和令人印象深刻的灵活性。</p><p>列表中没有你最喜欢的工具？在下面的评论中告诉我。</p><hr><p>via: <a href="https://itsfoss.com/open-source-static-site-generators/" target="_blank" rel="noopener">https://itsfoss.com/open-source-static-site-generators/</a></p><p>作者：<a href="https://itsfoss.com/author/ankush/" target="_blank" rel="noopener">Ankush Das</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed替换含有路径的字符串</title>
      <link href="/e4c7cf89/"/>
      <url>/e4c7cf89/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#问题描述">问题描述</a></li><li><a href="#初级思路">初级思路</a></li><li><a href="#更好的解决方案">更好的解决方案</a></li></ul><!-- tocstop --><h3 id="问题描述"><span id="问题描述">问题描述</span></h3><p><code>sed -i &quot;s/old/new/g&quot; file.txt</code></p><p>如果 <code>new</code> 是个路径，即字符串中含有<code>/</code>，这么执行会报错</p><h3 id="初级思路"><span id="初级思路">初级思路</span></h3><p>把 <code>new</code> 中的 <code>/</code> 进行转义</p><p>比如 <code>new</code> 为 <code>/home/users/config.yaml</code></p><p>替换时</p><p><code>sed -i &quot;s/old/\/home\/users\/config.yaml/g&quot; file.txt</code></p><p>如果 <code>new</code> 是变量，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new=<span class="string">"/home/users/config.yaml"</span></span><br><span class="line">new_sed=$(<span class="built_in">echo</span> <span class="variable">$new</span> | sed -e <span class="string">'s/\//\\\//g'</span>)</span><br><span class="line">sed -i <span class="string">"s/old/<span class="variable">$&#123;new_sed&#125;</span>/g"</span> file.txt</span><br></pre></td></tr></table></figure><h3 id="更好的解决方案"><span id="更好的解决方案">更好的解决方案</span></h3><p>转义会降低可读性，只需用其他特殊字符作为<code>sed</code>表达式的“分隔符”（取代默认的<code>/</code>）即可。<br>例如：<code>sed &#39;s#\$CONFIG#/home/users/config.yaml#g&#39;</code>，使用<code>#</code>代替<code>/</code>从而避免大量转义。</p><p>你可以尝试一下 <code>echo aabbccdd | sed &#39;s#aa#bb#g&#39; | sed &#39;s?bb?cc?g&#39; | sed &#39;s@cc@dd@g&#39; | sed &#39;s%dd%ee%g&#39;</code>  用任意字符作间隔</p><p>这是 <code>sed</code> 命令方便用户的一个特性，<code>vim</code> 中的 <code>:s</code> 也同样支持</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用hexo-toc锚点失效问题</title>
      <link href="/b4c41686/"/>
      <url>/b4c41686/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#现象">现象</a></li><li><a href="#原因">原因</a></li><li><a href="#修复方法">修复方法</a></li></ul><!-- tocstop --><h4 id="现象"><span id="现象">现象</span></h4><p>使用 hexo-toc 生成文章目录时，点击某个目录，url 变成 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/690c8418/#null</span><br></pre></td></tr></table></figure><h4 id="原因"><span id="原因">原因</span></h4><p>插件在把 markdown 编译成 HTML 时，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## title</span><br></pre></td></tr></table></figure><p>会编译为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&lt;span id=&quot;title&quot;&gt;title&lt;/span&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>而在插件源码的<a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/helper/toc.js#L27" target="_blank" rel="noopener">这次提交</a>之前，是会编译成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 id=&quot;title&quot;&gt;title&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>因此新版本的 <code>hexo-toc</code> 生成 TOC 时，元素没有 <code>id</code> 这个属性，进而导致 TOC 中的锚点失效。</p><h4 id="修复方法"><span id="修复方法">修复方法</span></h4><p>修改 <code>node_modules/hexo-toc/lib/filter.js</code></p><p>把 28 行的 <code>$title.attr(&#39;id&#39;, id);</code> 注释打开</p><p>把 31 行的 <code>$title.removeAttr(&#39;id&#39;);</code> 注释掉</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-toc </tag>
            
            <tag> 锚点失效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Lambda 表达式</title>
      <link href="/e4d97659/"/>
      <url>/e4d97659/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#基础">基础</a><ul><li><a href="#1-值捕获">1. 值捕获</a></li><li><a href="#2-引用捕获">2. 引用捕获</a></li><li><a href="#3-隐式捕获"><strong>3. 隐式捕获</strong></a></li><li><a href="#4-表达式捕获"><strong>4. 表达式捕获</strong></a></li></ul></li><li><a href="#泛型-lambda">泛型 Lambda</a></li></ul><!-- tocstop --><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p><h3 id="基础"><span id="基础">基础</span></h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) <span class="keyword">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h4 id="1-值捕获"><span id="1-值捕获">1. 值捕获</span></h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，<strong>被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = copy_value();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stored_value = "</span> &lt;&lt; stored_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用捕获"><span id="2-引用捕获">2. 引用捕获</span></h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = copy_value();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stored_value = "</span> &lt;&lt; stored_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-隐式捕获"><span id="3-隐式捕获"><strong>3. 隐式捕获</strong></span></h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;] 引用捕获, 让编译器自行推导捕获列表</li><li>[=] 值捕获, 让编译器执行推导引用列表</li></ul><h4 id="4-表达式捕获"><span id="4-表达式捕获"><strong>4. 表达式捕获</strong></span></h4><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>important</code> 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值， 在表达式中初始化。</p><h3 id="泛型-lambda"><span id="泛型-lambda">泛型 Lambda</span></h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。 这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。</p><p>幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始， Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pillow 库</title>
      <link href="/ab6bf24d/"/>
      <url>/ab6bf24d/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#pil中所涉及的基本概念">PIL中所涉及的基本概念</a></li><li><a href="#pil中有九种不同模式">PIL中有九种不同模式。</a></li><li><a href="#请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像">请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</a></li></ul><!-- tocstop --><p>Pillow(PIL) 库中的 Image 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; im = Image.open(&quot;lena.ppm&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from __future__ import print_function</span><br><span class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</span><br><span class="line">PPM (512, 512) RGB</span><br></pre></td></tr></table></figure><p>format 这个属性代表图片文件的扩展名, 如果图片文件打开失败, 则其值为None. size 这个属性代表图片的大小, 以像素为单位, 使用包含两个元素的元组来返回. mode 这个属性代表图片的band属性, 一般情况(黑白)下为 “L”, 当图片是彩色的时候是 “RGB”, 如果图片经过压缩, 则是 “CMYK”.</p><h3 id="pil中所涉及的基本概念"><span id="pil中所涉及的基本概念">PIL中所涉及的基本概念</span></h3><p>通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。</p><h3 id="pil中有九种不同模式"><span id="pil中有九种不同模式">PIL中有九种不同模式。</span></h3><p>分别为1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。</p><p><strong>模式 1</strong><br>二值图像</p><p>模式“1”为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.mode</span><br><span class="line"> </span><br><span class="line">&apos;RGB&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1 = lena.convert(&quot;1&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.mode</span><br><span class="line"> </span><br><span class="line">&apos;1&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.size</span><br><span class="line"> </span><br><span class="line">(512, 512)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.getpixel((10,10))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((10,120))</span><br><span class="line"> </span><br><span class="line">0</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((130,120))</span><br><span class="line"> </span><br><span class="line">255</span><br></pre></td></tr></table></figure><p><strong>模式 L</strong></p><p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度</p><p><strong>模式 P</strong></p><p>模式“P”为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的</p><p><strong>模式“RGBA”</strong></p><p>模式“RGBA”为32位彩色图像，它的每个像素用32个bit表示，其中24bit表示红色、绿色和蓝色三个通道，另外8bit表示alpha通道，即透明通道。</p><p>从实例中可以看到，使用当前这个方式将“RGB”图像转为“RGBA”图像时，alpha通道全部设置为255，即完全不透明。</p><p><strong>模式“CMYK”</strong></p><p>模式“CMYK”为32位彩色图像，它的每个像素用32个bit表示。模式“CMYK”就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</p><p>四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：Key Plate(blacK) = 定位套版色（黑色）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk =lena.convert(&quot;CMYK&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.mode</span><br><span class="line"> </span><br><span class="line">&apos;CMYK&apos;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_cmyk.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(58, 144, 177, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(59, 145, 178, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(196, 110, 77)</span><br></pre></td></tr></table></figure><p>从实例中可以得知PIL中“RGB”转换为“CMYK”的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = 255 - R</span><br><span class="line">M = 255 - G</span><br><span class="line">Y = 255 - B</span><br><span class="line">K = 0</span><br></pre></td></tr></table></figure><p>由于该转换公式比较简单，转换后的图像颜色有些失真。</p><p><strong>模式“YCbCr”</strong></p><p>模式“YCbCr”为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。</p><p>模式“RGB”转换为“YCbCr”的公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y= 0.257*R+0.504*G+0.098*B+16</span><br><span class="line">Cb = -0.148*R-0.291*G+0.439*B+128</span><br><span class="line">Cr = 0.439*R-0.368*G-0.071*B+128</span><br></pre></td></tr></table></figure><p><strong>模式“I”</strong></p><p>模式“I”为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“I”模式是按照下面的公式转换的：</p><p><code>I = R * 299/1000 + G * 587/1000 + B * 114/1000</code></p><p><strong>模式“F”</strong></p><p>模式“F”为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“F”模式是按照下面的公式转换的：</p><p><code>F = R * 299/1000+ G * 587/1000 + B * 114/1000</code></p><h3 id="请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像"><span id="请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像">请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</span></h3>]]></content>
      
      
      <categories>
          
          <category> Pic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gif图片文件信息</title>
      <link href="/2bf7952d/"/>
      <url>/2bf7952d/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#文件头">文件头</a></li><li><a href="#帧信息描述">帧信息描述</a></li></ul><!-- tocstop --><p>一个GIF文件主要由以下几部分组成。</p><ul><li>文件头</li><li>图像帧信息</li><li>注释</li></ul><h4 id="文件头"><span id="文件头">文件头</span></h4><p>GIF格式文件头和一般文件头差别不大，也包含有</p><ul><li>格式声明</li><li>逻辑屏幕描述块</li><li>全局调色盘</li></ul><p><strong>格式声明</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005159.png" alt></p><p>Signature 为“GIF”3 个字符；Version 为“87a”或“89a”3 个字符。</p><p><strong>逻辑屏幕描述块</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005303.png" alt></p><p>前两字节为像素单位的宽、高，用以标识图片的视觉尺寸。</p><p>Packet里是调色盘信息，分别来看——</p><p>Global Color Table Flag 为全局颜色表标志，即为1时表明全局颜色表有定义。</p><p>Color Resolution 代表颜色表中每种基色位长（需要+1），为111时，每个颜色用8bit表示，即我们熟悉的RGB表示法，一个颜色三字节。</p><p>Sort Flag 表示是否对颜色表里的颜色进行优先度排序，把常用的排在前面，这个主要是为了适应一些颜色解析度低的早期渲染器，现在已经很少使用了。</p><p>Global Color Table 表示颜色表的长度，计算规则是值+1作为2的幂，得到的数字就是颜色表的项数，取最大值111时，项数=256，也就是说GIF格式最多支持256色的位图，再乘以Color Resolution算出的字节数，就是调色盘的总长度。</p><p>这四个字段一起定义了调色盘的信息。</p><p>Background color Index 定义了图像透明区域的背景色在调色盘里的索引。</p><p>Pixel Aspect Ratio 定义了像素宽高比，一般为0。</p><h4 id="帧信息描述"><span id="帧信息描述">帧信息描述</span></h4><p>帧信息描述就是每一帧的图像信息和相关标志位</p><p>大部分GIF存储时采用了公共区域排除和透明区域叠加的优化</p><p><strong>帧数据说明</strong></p>]]></content>
      
      
      <categories>
          
          <category> Pic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL特殊字符处理</title>
      <link href="/c587a198/"/>
      <url>/c587a198/</url>
      
        <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> hexVals[<span class="number">16</span>] = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> CURLEncode::csUnsafeString= <span class="string">"\"&lt;&gt;%\\^[]`+$,@:;/!#?=&amp;"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> csRet;</span><br><span class="line">    csRet += <span class="string">"%"</span>;</span><br><span class="line">    csRet += decToHex(val, <span class="number">16</span>);   </span><br><span class="line">    <span class="keyword">return</span>  csRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decToHex</span><span class="params">(<span class="keyword">char</span> num, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>     temp=<span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">string</span>  csTmp;</span><br><span class="line">    <span class="keyword">int</span> num_char;</span><br><span class="line">    num_char = (<span class="keyword">int</span>) num;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// ISO-8859-1 </span></span><br><span class="line">    <span class="comment">// IF THE IF LOOP IS COMMENTED, THE CODE WILL FAIL TO GENERATE A </span></span><br><span class="line">    <span class="comment">// PROPER URL ENCODE FOR THE CHARACTERS WHOSE RANGE IN 127-255(DECIMAL)</span></span><br><span class="line">    <span class="keyword">if</span> (num_char &lt; <span class="number">0</span>)</span><br><span class="line">        num_char = <span class="number">256</span> + num_char;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (num_char &gt;= radix)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = num_char % radix;</span><br><span class="line">        num_char = (<span class="keyword">int</span>)<span class="built_in">floor</span>((num_char / radix) * <span class="number">1.0</span>);</span><br><span class="line">        csTmp = hexVals[temp];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    csTmp += hexVals[num_char];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(csTmp.length() &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        csTmp += <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> strdecToHex = csTmp;</span><br><span class="line">    <span class="comment">// Reverse the String</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(strdecToHex.begin(), strdecToHex.end());</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> strdecToHex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnsafe</span><span class="params">(<span class="keyword">char</span> compareChar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bcharfound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> tmpsafeChar;</span><br><span class="line">    <span class="keyword">int</span> m_strLen = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    m_strLen = csUnsafeString.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ichar_pos = <span class="number">0</span>; ichar_pos &lt; m_strLen ;ichar_pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpsafeChar = csUnsafeString[ichar_pos]; </span><br><span class="line">        <span class="keyword">if</span>(tmpsafeChar == compareChar)</span><br><span class="line">        &#123; </span><br><span class="line">            bcharfound = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> char_ascii_value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//char_ascii_value = __toascii(compareChar);</span></span><br><span class="line">    char_ascii_value = (<span class="keyword">int</span>) compareChar;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(bcharfound == <span class="literal">false</span> &amp;&amp;  char_ascii_value &gt; <span class="number">32</span> &amp;&amp; char_ascii_value &lt; <span class="number">123</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// found no unsafe chars, return false       </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">URLEncode</span><span class="params">(<span class="built_in">string</span> strEncode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>  strSrc;</span><br><span class="line">    <span class="built_in">string</span>    strDest;   </span><br><span class="line"> </span><br><span class="line">    strSrc = strEncode;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strSrc.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = strSrc[i];</span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="string">' '</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ch = ch;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!isUnsafe(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Safe Character               </span></span><br><span class="line">            strDest += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get Hex Value of the Character</span></span><br><span class="line">            strDest += convert(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>url编码解码</title>
      <link href="/fdc9c210/"/>
      <url>/fdc9c210/</url>
      
        <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BURSIZE 2048</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex2dec</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dec2hex</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= c &amp;&amp; c &lt;= <span class="number">9</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">'0'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">10</span> &lt;= c &amp;&amp; c &lt;= <span class="number">15</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">'A'</span> - <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//编码一个url</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urlencode</span><span class="params">(<span class="keyword">char</span> url[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(url);</span><br><span class="line">    <span class="keyword">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> res[BURSIZE];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = url[i];</span><br><span class="line">        <span class="keyword">if</span> (    (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) ||</span><br><span class="line">                (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>) ||</span><br><span class="line">                (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>) || </span><br><span class="line">                c == <span class="string">'/'</span> || c == <span class="string">'.'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res[res_len++] = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (<span class="keyword">short</span> <span class="keyword">int</span>)c;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                j += <span class="number">256</span>;</span><br><span class="line">            <span class="keyword">int</span> i1, i0;</span><br><span class="line">            i1 = j / <span class="number">16</span>;</span><br><span class="line">            i0 = j - i1 * <span class="number">16</span>;</span><br><span class="line">            res[res_len++] = <span class="string">'%'</span>;</span><br><span class="line">            res[res_len++] = dec2hex(i1);</span><br><span class="line">            res[res_len++] = dec2hex(i0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[res_len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(url, res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 解码url</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urldecode</span><span class="params">(<span class="keyword">char</span> url[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(url);</span><br><span class="line">    <span class="keyword">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> res[BURSIZE];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = url[i];</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'%'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res[res_len++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = url[++i];</span><br><span class="line">            <span class="keyword">char</span> c0 = url[++i];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            num = hex2dec(c1) * <span class="number">16</span> + hex2dec(c0);</span><br><span class="line">            res[res_len++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[res_len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(url, res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> url[<span class="number">100</span>] = <span class="string">"http://'测试/@mike"</span>;</span><br><span class="line">    urlencode(url); <span class="comment">//编码后</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"http://'测试/@mike  ----&gt; %s\n"</span>, url);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">"http%3A//%27%E6%B5%8B%E8%AF%95/%40mike"</span>;</span><br><span class="line">    urldecode(buf); <span class="comment">//解码后</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"http%%3A//%%27%%E6%%B5%%8B%%E8%%AF%%95/%%40mike  ----&gt; %s\n"</span>, buf);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从图片头信息中获取图片格式</title>
      <link href="/be14bd28/"/>
      <url>/be14bd28/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#图片文件头标识分析">图片文件头标识分析</a></li></ul><!-- tocstop --><h3 id="图片文件头标识分析"><span id="图片文件头标识分析">图片文件头标识分析</span></h3><p>一个图片文件的后缀名并不能说明这个图片的真正格式什么，读取图片文件的文件头标识可以获取图片的格式。用十六进制编辑器察看图片的文件头</p><p>1.JPEG</p><ul><li>文件头标识 (2 bytes): $ff, $d8 (SOI) (JPEG 文件标识) </li><li>文件结束标识 (2 bytes): $ff, $d9 (EOI)</li></ul><p>2.TGA</p><ul><li>未压缩的前5字节    00 00 02 00 00</li><li>RLE压缩的前5字节   00 00 10 00 00</li></ul><p>3.PNG</p><ul><li>文件头标识 (8 bytes)   89 50 4E 47 0D 0A 1A 0A</li></ul><p>4.GIF</p><ul><li>文件头标识 (6 bytes)   47 49 46 38 39(37) 61<pre><code>G    I    F     8    9 (7)     a</code></pre></li></ul><p>5.BMP</p><ul><li>文件头标识 (2 bytes)   42 4D<pre><code>B    M</code></pre></li></ul><p>6.PCX</p><ul><li>文件头标识 (1 bytes)   0A</li></ul><p>7.TIFF</p><ul><li>文件头标识 (2 bytes)   4D 4D 或 49 49</li></ul><p>8.ICO</p><ul><li>文件头标识 (8 bytes)   00 00 01 00 01 00 20 20</li></ul><p>9.CUR</p><ul><li>文件头标识 (8 bytes)   00 00 02 00 01 00 20 20</li></ul><p>10.IFF</p><ul><li>文件头标识 (4 bytes)   46 4F 52 4D<pre><code>F    O   R    M</code></pre></li></ul><p>11.ANI</p><ul><li>文件头标识 (4 bytes)   52 49 46 46<pre><code>R     I     F    F</code></pre></li></ul><p>根据这些文件头标识的收集，我可以写一个识别图像格式的模块了。但是在写这个模块之前可以对收集到的文件头标识进行优化，使得程序中字符串比对次数尽量的少。<br>1.JPEG我们知需要比对文件头的$ff, $d8这两个字符，而不用读取最后的两个结束标识了。<br>2.TGA，ICO，CUR只需比对第三个与第五个字符即可。<br>3.PNG比对[89][50]这两个字符。<br>4.GIF比对[47][49][46]与第五个字符。</p><p>模块代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&apos;枚举图片格式种类</span><br><span class="line">Public Enum ImageForm</span><br><span class="line">   [BMP] = 0</span><br><span class="line">   [JPEG] = 1</span><br><span class="line">   [GIF87] = 2</span><br><span class="line">   [GIF89] = 3</span><br><span class="line">   [PNG] = 4</span><br><span class="line">   [TGA Normal] = 5 &apos;TGA未压缩</span><br><span class="line">   [TGA RLE] = 6     &apos;TGA经过RLE压缩后的</span><br><span class="line">   [PCX] = 7</span><br><span class="line">   [TIFF] = 8</span><br><span class="line">   [ICO] = 9</span><br><span class="line">   [CUR] = 10</span><br><span class="line">   [IFF] = 11</span><br><span class="line">   [ANI] = 12</span><br><span class="line">   [Other] = 13</span><br><span class="line">   [FileError] = 14</span><br><span class="line">End Enum</span><br></pre></td></tr></table></figure><p>常用的图片格式有一下几种。</p><ul><li>PNG</li><li>JPEG</li><li>GIF</li><li>WebP 是 Google 制造的一个图片格式，针对网络上快速传输就行了优化</li><li>TIFF/TIF 在数字影响、遥感、医学等领域中得到了广泛的应用。TIFF文件的后缀是.tif或者.tiff</li><li>HEIC iOS11 后，苹果拍照图片的默认格式</li><li>HEIF 用于存储动态图像</li></ul><h5 id="jpge-二进制数据前两个字节数据为"><span id="jpge-二进制数据前两个字节数据为">JPGE 二进制数据前两个字节数据为</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">FF D8</span><br></pre></td></tr></table></figure><h5 id="png"><span id="png">PNG</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">89 50 4E 47 0D 0A 1A 0A</span><br></pre></td></tr></table></figure><h5 id="gif"><span id="gif">GIF</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">47 49 46 38 37 61 or</span><br><span class="line">47 49 46 38 39 61</span><br></pre></td></tr></table></figure><h5 id="tiff"><span id="tiff">TIFF</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">49 20 49 or</span><br><span class="line">49 49 2A 00 or</span><br><span class="line">4D 4D 00 2B or</span><br><span class="line">4D 4D 00 2A</span><br></pre></td></tr></table></figure><h5 id="heic"><span id="heic">HEIC</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">00</span><br></pre></td></tr></table></figure><h5 id="heif"><span id="heif">HEIF</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">00</span><br></pre></td></tr></table></figure><h5 id="webp"><span id="webp">WEBP</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">52</span><br></pre></td></tr></table></figure><p>判断 Webp 为什么是截取 0-12 的长度？转换成 ASCII 之后判断的依据？</p><p>在 Google 官方介绍中找到了此图。说明的是：头文件的大小是 <code>12Bytes</code></p><p>WEBP的 header 中写明了 <code>ASCII</code> 是 <code>RIFF</code> 或者 <code>WEBP</code> Google Developer: <a href="https://developers.google.com/speed/webp/docs/riff_container" target="_blank" rel="noopener">developers.google.com/speed/webp/…</a></p><p>demo 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">enum ImageFormat &#123;</span><br><span class="line">    case Unknow</span><br><span class="line">    case JPEG</span><br><span class="line">    case PNG</span><br><span class="line">    case GIF</span><br><span class="line">    case TIFF</span><br><span class="line">    case WebP</span><br><span class="line">    case HEIC</span><br><span class="line">    case HEIF</span><br><span class="line">&#125;</span><br><span class="line">extension Data &#123;</span><br><span class="line">    func getImageFormat() -&gt; ImageFormat  &#123;</span><br><span class="line">        var buffer = [UInt8](repeating: 0, count: 1)</span><br><span class="line">        self.copyBytes(to: &amp;buffer, count: 1)</span><br><span class="line">        </span><br><span class="line">        switch buffer &#123;</span><br><span class="line">        case [0xFF]: return .JPEG</span><br><span class="line">        case [0x89]: return .PNG</span><br><span class="line">        case [0x47]: return .GIF</span><br><span class="line">        case [0x49],[0x4D]: return .TIFF</span><br><span class="line">        case [0x52] where self.count &gt;= 12:</span><br><span class="line">            if let str = String(data: self[0...11], encoding: .ascii), str.hasPrefix(&quot;RIFF&quot;), str.hasSuffix(&quot;WEBP&quot;) &#123;</span><br><span class="line">                return .WebP</span><br><span class="line">            &#125;</span><br><span class="line">        case [0x00] where self.count &gt;= 12:</span><br><span class="line">            if let str = String(data: self[8...11], encoding: .ascii) &#123;</span><br><span class="line">                let HEICBitMaps = Set([&quot;heic&quot;, &quot;heis&quot;, &quot;heix&quot;, &quot;hevc&quot;, &quot;hevx&quot;])</span><br><span class="line">                if HEICBitMaps.contains(str) &#123;</span><br><span class="line">                    return .HEIC</span><br><span class="line">                &#125;</span><br><span class="line">                let HEIFBitMaps = Set([&quot;mif1&quot;, &quot;msf1&quot;])</span><br><span class="line">                if HEIFBitMaps.contains(str) &#123;</span><br><span class="line">                    return .HEIF</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        default: break;</span><br><span class="line">        &#125;</span><br><span class="line">        return .Unknow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++ 代码1</strong></p><p>Image_file.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;config.h&quot;</span><br><span class="line">#include &quot;ImageFile.h&quot;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">namespace blink &#123;</span><br><span class="line"></span><br><span class="line">#define JPEG_FILE_TYPE          1</span><br><span class="line">#define BMP_FILE_TYPE           2</span><br><span class="line">#define PNG_FILE_TYPE           3</span><br><span class="line">#define GIF_FILE_TYPE           4</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">　　通过文件头标识判断图片格式，</span><br><span class="line">　　jpg： FF, D8</span><br><span class="line">　　bmp： 42 4D</span><br><span class="line">　　gif： 47 49 46 38</span><br><span class="line">　　png： 89 50 4E 47</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int check_fileType(const unsigned char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    if(buf[0] == 0xFF &amp;&amp; buf[1] == 0xd8 &amp;&amp; buf[2] == 0xFF) </span><br><span class="line">    &#123;</span><br><span class="line">        return JPEG_FILE_TYPE; </span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[0] == 0x42 &amp;&amp; buf[1] == 0x4d)</span><br><span class="line">    &#123;</span><br><span class="line">        return BMP_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[0] == 0x47 &amp;&amp; buf[1] == 0x49 &amp;&amp; buf[2] == 0x46 &amp;&amp; buf[3] == 0x38)</span><br><span class="line">    &#123;</span><br><span class="line">        return GIF_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[0] == 0x89 &amp;&amp; buf[1] == 0x50 &amp;&amp; buf[2] == 0x4e &amp;&amp; buf[3] == 0x47)</span><br><span class="line">    &#123;</span><br><span class="line">        return PNG_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*在构造函数内获取像素宽高：mwidth、mheigh*/</span><br><span class="line"></span><br><span class="line">ImageFile::ImageFile(const String&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    int type;</span><br><span class="line">    mpath = path;</span><br><span class="line">    mwidth = 0;</span><br><span class="line">    mheight = 0;</span><br><span class="line">    mtype = &quot;&quot;;</span><br><span class="line">    src = (char *)path.utf8().data();</span><br><span class="line">    int i = 0;</span><br><span class="line">    int size;</span><br><span class="line">    unsigned char *buff = NULL;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if((fp = fopen(src,&quot;rb+&quot;)) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        mtype = &quot;The file was not opened!&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fp,0,SEEK_END);</span><br><span class="line">    size = ftell(fp);</span><br><span class="line">    buff = (unsigned char*)malloc(size);</span><br><span class="line">    if(buff)</span><br><span class="line">        memset(buff,0,size);</span><br><span class="line">    fseek(fp,0,SEEK_SET);   </span><br><span class="line">    if(fread(buff,1,size,fp)!=size)</span><br><span class="line">    &#123;</span><br><span class="line">        mtype =&quot;read error!&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    type = check_fileType(buff);</span><br><span class="line">    switch(type)</span><br><span class="line">    &#123;</span><br><span class="line">        case JPEG_FILE_TYPE:</span><br><span class="line">            mtype = &quot;jpg file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0xff &amp;&amp; buff[i+1] == 0xc0)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i+7]&lt;&lt;8) | buff[i+8];</span><br><span class="line">                    mheight = (buff[i+5]&lt;&lt;8) | buff[i+6];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case BMP_FILE_TYPE:</span><br><span class="line">            mtype = &quot;bmp file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0x28 &amp;&amp; buff[i+1] == 0x00)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i+7]&lt;&lt;24) | buff[i+6]&lt;&lt;16 | buff[i+5]&lt;&lt;8 | buff[i+4];</span><br><span class="line">                    mheight = (buff[i+11]&lt;&lt;24) | buff[i+10]&lt;&lt;16 | buff[i+9]&lt;&lt;8 | buff[i+8];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case PNG_FILE_TYPE:</span><br><span class="line">            mtype = &quot;png file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0x49 &amp;&amp; buff[i+1] == 0x48)</span><br><span class="line">                &#123;</span><br><span class="line">                    mheight = (buff[i+8]&lt;&lt;24) | buff[i+9]&lt;&lt;16 | buff[i+10]&lt;&lt;8 | buff[i+11];</span><br><span class="line">                    mwidth = (buff[i+4]&lt;&lt;24) | buff[i+5]&lt;&lt;16 | buff[i+6]&lt;&lt;8 | buff[i+7];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case GIF_FILE_TYPE:</span><br><span class="line">            mtype = &quot;gif file!&quot;;</span><br><span class="line">            for(i = 0; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(buff[i] == 0x00 &amp;&amp; buff[i+1] == 0x2c)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i+7]&lt;&lt;8) | buff[i+6];</span><br><span class="line">                    mheight = (buff[i+9]&lt;&lt;8) | buff[i+8];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    free(buff);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String ImageFile::type() const</span><br><span class="line">&#123;</span><br><span class="line">    return mtype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String ImageFile::location() const</span><br><span class="line">&#123;</span><br><span class="line">    int length = mpath.length();</span><br><span class="line">    int pos = mpath.reverseFind(&apos;/&apos;);</span><br><span class="line">    </span><br><span class="line">    while (pos == length - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = mpath.reverseFind(&apos;/&apos; ,pos - 1);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pos &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return mpath.substring(0,pos + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String ImageFile::fileName() const</span><br><span class="line">&#123;</span><br><span class="line">    int length = mpath.length();</span><br><span class="line">    int pos = mpath.reverseFind(&apos;/&apos;);</span><br><span class="line">    </span><br><span class="line">    while (pos == length - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = mpath.reverseFind(&apos;/&apos; , pos - 1);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pos &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return mpath.substring(pos + 1,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ImageFile::width() const</span><br><span class="line">&#123;</span><br><span class="line">    return mwidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ImageFile::height() const</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return mheight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image_file.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ImageFile_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ImageFile_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> blink &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ImageFile</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ImageFile* <span class="title">create</span><span class="params">(<span class="keyword">const</span> String&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FILE* fS;</span><br><span class="line">        fS =fopen(path.utf8().data(),<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span>(fS !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> iLen = path.length() ;</span><br><span class="line">            <span class="keyword">int</span> iPos = path.reverseFind(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">if</span> (iPos &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String name=path.substring(iPos + <span class="number">1</span>, iLen);</span><br><span class="line">            <span class="keyword">char</span> s1[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">char</span> s2[]=<span class="string">"jpg"</span>;</span><br><span class="line">            <span class="keyword">char</span> s3[]=<span class="string">"bmp"</span>;</span><br><span class="line">            <span class="keyword">char</span> s4[]=<span class="string">"gif"</span>;</span><br><span class="line">            <span class="keyword">char</span> s5[]=<span class="string">"png"</span>;</span><br><span class="line">            <span class="keyword">char</span> s6[]=<span class="string">"jpeg"</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;name.length();i++)</span><br><span class="line">                s1[i] = name[i];</span><br><span class="line">            s1[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s1,s2,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s3,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s4,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s5,<span class="number">3</span>)==<span class="number">0</span>|| <span class="built_in">strncmp</span>(s1,s6,<span class="number">4</span>)==<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NGBImageFile(path);     <span class="comment">//路径正确且图片文件格式是以上四种，创建文件对象</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">location</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">fileName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">width</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">height</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ImageFile(<span class="keyword">const</span> String&amp; path);</span><br><span class="line">    <span class="keyword">char</span>* src;</span><br><span class="line">    String mpath;</span><br><span class="line">    String mtype;</span><br><span class="line">    <span class="keyword">double</span> mwidth;</span><br><span class="line">    <span class="keyword">double</span> mheight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace blink</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ImageFile_H</span></span></span><br></pre></td></tr></table></figure><p><strong>Qt 代码</strong></p><p>imageinfo.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#ifndef IMAGEINFO_H</span><br><span class="line">#define IMAGEINFO_H</span><br><span class="line">#include &lt;QObject&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QUrl&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;QSize&gt;</span><br><span class="line">#include &lt;QDate&gt;</span><br><span class="line">class ImageInfo : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    enum IMAGE_FORMAT&#123;</span><br><span class="line">        BMP_FORMAT,</span><br><span class="line">        JPG_FORMAT,</span><br><span class="line">        GIF_FORMAT,</span><br><span class="line">        PNG_FORMAT,</span><br><span class="line">        NVL_FORMAT</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    explicit ImageInfo(QObject *parent = 0);</span><br><span class="line">    ~ImageInfo();</span><br><span class="line">public:</span><br><span class="line">    Q_INVOKABLE QString getImageFormat(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QString getImageSize(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QSize getImageDimension(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QDate getImageDate(QString imageUrl);</span><br><span class="line">    Q_INVOKABLE QString getImageTitle(QString imageUrl);</span><br><span class="line">Q_SIGNALS:</span><br><span class="line">public Q_SLOTS :</span><br><span class="line">private:</span><br><span class="line">    int getImageFormat(std::string path);</span><br><span class="line">    long getBMPSize(std::string path);</span><br><span class="line">    long getGIFSize(std::string path);</span><br><span class="line">    long getPNGSize(std::string path);</span><br><span class="line">    long getJPGSize(std::string path);</span><br><span class="line">    QSize getBMPDimension(std::string path);</span><br><span class="line">    QSize getPNGDimension(std::string path);</span><br><span class="line">    QSize getJPGDimension(std::string path);</span><br><span class="line">    QSize getGIFDimension(std::string path);</span><br><span class="line">&#125;;</span><br><span class="line">#endif // IMAGEINFO_H</span><br></pre></td></tr></table></figure><p>imageinfo.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"imageinfo.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileInfo&gt;</span></span></span><br><span class="line"></span><br><span class="line">ImageInfo::ImageInfo(QObject *parent) :</span><br><span class="line">    QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"---------------------------- image info constructed "</span>;</span><br><span class="line">&#125;</span><br><span class="line">ImageInfo::~ImageInfo()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">QDate ImageInfo::getImageDate(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QDate date;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            date = fileinfo.lastModified().date();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从文件头中读取相应字段以判断图片格式</span></span><br><span class="line"><span class="comment">//详情参看: http://www.garykessler.net/library/file_sigs.html</span></span><br><span class="line"><span class="keyword">int</span> ImageInfo::getImageFormat(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//BMP格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> BMPHeader[] = &#123;<span class="number">0x42</span>, <span class="number">0x4d</span>&#125;;</span><br><span class="line">    <span class="comment">//JPG,JPEG格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader1[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xdb</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader2[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader3[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe1</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader4[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe2</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader5[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe3</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> JPGHeader6[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe8</span>&#125;;</span><br><span class="line">    <span class="comment">//GIF格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> GIFHeader1[] = &#123;<span class="number">0x47</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x38</span>, <span class="number">0x37</span>, <span class="number">0x61</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> GIFHeader2[] = &#123;<span class="number">0x47</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x61</span>&#125;;</span><br><span class="line">    <span class="comment">//PNG格式特征码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> PNGHeader[] = &#123;<span class="number">0x89</span>, <span class="number">0x50</span>, <span class="number">0x4E</span>, <span class="number">0x47</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//以二进制方式打开文件并读取前几个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> header[<span class="number">16</span>];</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"文件路径: "</span>&lt;&lt;path.c_str();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">readf</span><span class="params">(path.c_str(), <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!readf.is_open()) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> NVL_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先读两个，判断是否BMP格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(header, BMPHeader, count) == <span class="number">0</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"BMP格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> BMP_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读两个，判断是否JPG格式、PNG格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">memcmp</span>(header, JPGHeader1, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader2, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader3, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader4, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader5, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader6, count) == <span class="number">0</span>)) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"JPG格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> JPG_FORMAT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">memcmp</span>(header, PNGHeader, count) == <span class="number">0</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"PNG格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> PNG_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读两个，判断是否GIF格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">memcmp</span>(header, GIFHeader1, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, GIFHeader2, count) == <span class="number">0</span>)) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"GIF格式"</span>;</span><br><span class="line">        <span class="keyword">return</span> GIF_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"文件格式特征码:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0x\t"</span>,header[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"不属于以上任何一种格式"</span>;</span><br><span class="line">    <span class="keyword">return</span> NVL_FORMAT;</span><br><span class="line">&#125;</span><br><span class="line">QString ImageInfo::getImageFormat(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QString strFormat = <span class="string">"NA"</span>;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> path = filePath.toStdString();</span><br><span class="line">            <span class="keyword">int</span> iFormat = getImageFormat(path);</span><br><span class="line">            <span class="keyword">switch</span>(iFormat) &#123;</span><br><span class="line">            <span class="keyword">case</span> BMP_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"BMP"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JPG_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"JPG"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GIF_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"GIF"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PNG_FORMAT:</span><br><span class="line">                strFormat = <span class="string">"PNG"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strFormat;</span><br><span class="line">&#125;</span><br><span class="line">QString ImageInfo::getImageSize(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QString strSize;</span><br><span class="line">    <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            <span class="keyword">bool</span> ret = file.open(QIODevice::ReadOnly);</span><br><span class="line">            <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size = file.size();</span><br><span class="line">            &#125;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"!!!!!"</span>&lt;&lt;size;</span><br><span class="line">    strSize = QString::number(size, <span class="number">10</span>);</span><br><span class="line">    qDebug()&lt;&lt;strSize;</span><br><span class="line">    <span class="keyword">return</span> strSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BMP文件头的第2、3字为文件大小信息</span></span><br><span class="line"><span class="keyword">long</span> ImageInfo::getBMPSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">if</span>((fid=fopen(path.c_str(),<span class="string">"rb+"</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳过图片特征码</span></span><br><span class="line">    fseek(fid, <span class="number">2</span>, SEEK_SET);</span><br><span class="line">    fread(&amp;size, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    fclose(fid);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"size="</span>&lt;&lt;size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> ImageInfo::getGIFSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> ImageInfo::getPNGSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> ImageInfo::getJPGSize(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">if</span>((fid = fopen(path.c_str(),<span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fid, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = ftell(fid);</span><br><span class="line">    fclose(fid);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"size="</span>&lt;&lt;size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BMP文件头的第10、11字为文件宽度信息</span></span><br><span class="line"><span class="comment">//BMP文件头的第12、13字为文件高度信息</span></span><br><span class="line">QSize ImageInfo::getBMPDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">if</span>((fid=fopen(path.c_str(),<span class="string">"rb+"</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">//读取宽度和高度</span></span><br><span class="line">    fseek(fid, <span class="number">18</span>, SEEK_SET); <span class="comment">//偏移18个字节</span></span><br><span class="line">    fread(&amp;width, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    fread(&amp;height, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    fclose(fid);</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考： http://mcljc.blog.163.com/blog/static/83949820102239610974/</span></span><br><span class="line"><span class="comment">//http://download.csdn.net/download/chp845/4255011</span></span><br><span class="line">QSize ImageInfo::getJPGDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">if</span>((fid = fopen(path.c_str(),<span class="string">"rb+"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    fseek(fid,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="keyword">long</span> length = ftell(fid);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[length];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer_bakup = buffer;</span><br><span class="line">    fseek(fid, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    fread(buffer, length, <span class="number">1</span>, fid);</span><br><span class="line">    fclose(fid);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *temp = buffer + length;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *temp_ori = buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ff;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type=<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> m_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//跳过文件头中标志文件类型的两个字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">        buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((temp &gt; buffer) &amp;&amp; (type != <span class="number">0xDA</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ff = *buffer++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(ff != <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            type = *buffer++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(type == <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD7</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xC0</span>:<span class="comment">//SOF0段</span></span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            buffer++; <span class="comment">//舍弃精度值</span></span><br><span class="line">            height = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            height += *buffer++;</span><br><span class="line">            width = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            width += *buffer;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xE0</span>: <span class="comment">//APP0段</span></span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"APP0段"</span>;</span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            buffer = buffer + <span class="number">12</span>;</span><br><span class="line">            <span class="comment">//丢弃APP0标记(5bytes)、主版本号(1bytes)、次版本号(1bytes)、像素点单位(1bytes)、垂直像素点(2bytes)、 水平像素点(2bytes)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = temp_ori + m_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    <span class="comment">//记得释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer_bakup;</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PNG文件头的第9字为文件宽度信息</span></span><br><span class="line"><span class="comment">//PNG文件头的第10字为文件高度信息</span></span><br><span class="line"><span class="comment">//参考：http://blog.chinaunix.net/uid-25799257-id-3358174.html</span></span><br><span class="line">QSize ImageInfo::getPNGDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((fid=fopen(path.c_str(),<span class="string">"rb+"</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"打开文件失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> wtmp[<span class="number">4</span>]=&#123;<span class="string">'0'</span>&#125;;   <span class="comment">//宽度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> htmp[<span class="number">4</span>]=&#123;<span class="string">'0'</span>&#125;;   <span class="comment">//高度</span></span><br><span class="line">    fseek(fid, <span class="number">16</span>, SEEK_SET);</span><br><span class="line">    fread(wtmp, <span class="number">4</span>, <span class="number">1</span>, fid);         <span class="comment">// example 00000080</span></span><br><span class="line">    fread(htmp, <span class="number">4</span>, <span class="number">1</span>, fid);         <span class="comment">// example 00000080</span></span><br><span class="line">    fclose(fid);</span><br><span class="line">    width = ((<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)wtmp[<span class="number">2</span>]) * <span class="number">256</span> + (<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)wtmp[<span class="number">3</span>];</span><br><span class="line">    height = ((<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)htmp[<span class="number">2</span>]) * <span class="number">256</span> + (<span class="keyword">int</span>)(<span class="keyword">unsigned</span> <span class="keyword">char</span>)htmp[<span class="number">3</span>];</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GIF文件头的第4字为文件宽度信息</span></span><br><span class="line"><span class="comment">//GIF文件头的第5字为文件高度信息</span></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/zhaoweikid/article/details/156422</span></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/asaasa66/article/details/5875340</span></span><br><span class="line">QSize ImageInfo::getGIFDimension(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">ffin</span><span class="params">(path.c_str(), <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ffin)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Can not open this file."</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> QSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;, s2[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ffin.seekg(<span class="number">6</span>);</span><br><span class="line">    ffin.read(s1, <span class="number">2</span>);</span><br><span class="line">    ffin.read(s2, <span class="number">2</span>);</span><br><span class="line">    width = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s1[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>|(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s1[<span class="number">0</span>]);</span><br><span class="line">    height = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s2[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>|(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(s2[<span class="number">0</span>]);</span><br><span class="line">    ffin.close();</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"width="</span>&lt;&lt;width;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"height="</span>&lt;&lt;height;</span><br><span class="line">    <span class="keyword">return</span> QSize(width, height);</span><br><span class="line">&#125;</span><br><span class="line">QSize ImageInfo::getImageDimension(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QSize dimension;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> path = filePath.toStdString();</span><br><span class="line">            <span class="keyword">int</span> iFormat = getImageFormat(path);</span><br><span class="line">            <span class="keyword">switch</span>(iFormat) &#123;</span><br><span class="line">            <span class="keyword">case</span> BMP_FORMAT:</span><br><span class="line">                dimension = getBMPDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JPG_FORMAT:</span><br><span class="line">                dimension = getJPGDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GIF_FORMAT:</span><br><span class="line">                dimension = getGIFDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PNG_FORMAT:</span><br><span class="line">                dimension = getPNGDimension(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"图片尺寸:"</span>&lt;&lt;dimension;</span><br><span class="line">    <span class="keyword">return</span> dimension;</span><br><span class="line">&#125;</span><br><span class="line">QString ImageInfo::getImageTitle(QString imageUrl)</span><br><span class="line">&#123;</span><br><span class="line">    QString title;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.isEmpty()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.toLocalFile();</span><br><span class="line">        <span class="keyword">if</span>(QFile::exists(filePath)) &#123;</span><br><span class="line">            <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            title = fileinfo.baseName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 1.14 中接口的菱形组合</title>
      <link href="/ace0b2ab/"/>
      <url>/ace0b2ab/</url>
      
        <content type="html"><![CDATA[<p>按照<a href="https://github.com/golang/proposal/blob/master/design/6977-overlapping-interfaces.md" target="_blank" rel="noopener">部分重叠的接口提议</a>，Go 1.14 现在允许嵌入有部分方法重叠的接口。本文是一篇解释这次修改的简要说明。</p><p>我们先来看 io 包中的三个关键接口：io.Reader、io.Writer 和 io.Closer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在结构体中嵌入类型时，如果在结构体中声明了被嵌入的类型，那么该类型的字段和方法允许被访问<a href="也就是说，嵌入提升了类型的字段和方法。">^1</a>，对于接口来说这个处理也成立。因此下面两种方式：显式声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Read([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和使用嵌入来组成接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有区别。</p><p>你甚至可以混合使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在 Go 1.14 之前，如果你用这种方式来声明接口，你可能会得到类似这样的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">ReadCloser</span><br><span class="line">WriterCloser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% Go build interfaces.go</span><br><span class="line"><span class="built_in">command</span>-line-arguments</span><br><span class="line">./interfaces.go:27:2: duplicate method Close</span><br></pre></td></tr></table></figure><p>幸运的是，在 Go 1.14 中这不再是一个限制了，因此这个改动解决了在菱形嵌入时出现的问题。</p><p>然而，在我向本地的用户组解释这个特性时也陷入了麻烦 — 只有 Go 编译器使用 1.14（或更高版本）语言规范时才支持这个特性。</p><p>我理解的编译过程中 Go 语言规范所使用的版本的规则似乎是这样的：</p><ol><li>如果你的源码是在 GOPATH 下（或者你用 GO111MODULE=off <em>关闭</em>了 module），那么 Go 语言规范会使用你编译器的版本来编译。换句话说，如果安装了 Go 1.13，那么你的 Go 版本就是 1.13。如果你安装了 Go 1.14，那么你的版本就是 1.14。这里符合认知。</li><li>如果你的源码保存在 GOPATH 外（或你用 GO111MODULE=on 强制开启了 module），那么 Go tool 会从 go.mod 文件中获取 Go 版本。</li><li>如果 go.mod 中没有列出 Go 版本，那么语言规范会使用安装的 Go 的版本。这跟第 1 点是一致的。</li><li>如果你用的是 Go module 模式，不管是源码在 GOPATH 外还是设置了 GO111MODULE=on，但是在当前目录或所有父目录中都没有 go.mod 文件，那么 Go 语言规范会默认用 Go 1.13 版本来编译你的代码。</li></ol><p>我曾经遇到过第 4 点的情况。</p><hr><p>via: <a href="https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14" target="_blank" rel="noopener">https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14</a></p><p>作者：<a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a> </p><p>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> </p><p>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装TT-RSS</title>
      <link href="/afdc720c/"/>
      <url>/afdc720c/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tt-rss.org/" target="_blank" rel="noopener">Tiny Tiny RSS</a>（TT-RSS）是一个自由开源的基于 Web 的新闻<ruby>馈送<rt>feed</rt></ruby>（RSS/Atom）阅读器和聚合工具。它非常适合那些注重隐私，并且仍然依赖 RSS 来获取日常新闻的人。TT-RSS 是自行托管的软件，因此你可以 100% 的掌控你的服务器、数据以及你的全部隐私。它还支持大量的插件、扩展和主题。你喜欢黑暗模式的界面？没问题。想基于关键词过滤发来的消息？TT-RSS 也能让你得偿所愿。</p><p><img src="https://opensource.com/sites/default/files/uploads/tt-rss.jpeg" alt="Tiny Tiny RSS screenshot" title="Tiny Tiny RSS screenshot"></p><p>现在你知道 TT-RSS 是什么了，那么为什么你可能会想用它。我会讲述要把它安装到树莓派或 Debian 10 服务器上你需要了解的所有的东西。</p><h3 id="安装和配置-tt-rss"><span id="安装和配置-tt-rss">安装和配置 TT-RSS</span></h3><p>要把 TT-RSS 安装到树莓派上，你还需要安装和配置最新版本的 PHP（本文撰写时 PHP 最新版本是 7.3）、后端数据库 PostgreSQL、Nginx web 服务器、Git，最后才是 TT-RSS。</p><h4 id="1-安装-php-7"><span id="1-安装-php-7">1、安装 PHP 7</span></h4><p>安装 PHP 7 是整个过程中最复杂的部分。幸运的是，它并不像看起来那样困难。从安装下面的支持包开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y ca-certificates apt-transport-https</span><br></pre></td></tr></table></figure><p>现在，添加存储库 PGP 密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q https://packages.sury.org/php/apt.gpg -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>下一步，把 PHP 库添加到你的 apt 源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;deb https://packages.sury.org/php/ buster main&quot; | sudo tee /etc/apt/sources.list.d/php.list</span><br></pre></td></tr></table></figure><p>然后更新你的存储库索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure><p>最后，安装 PHP 7.3（或最新版本）和一些通用组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y php7.3 php7.3-cli php7.3-fpm php7.3-opcache php7.3-curl php7.3-mbstring php7.3-pgsql php7.3-zip php7.3-xml php7.3-gd php7.3-intl</span><br></pre></td></tr></table></figure><p>上面的命令默认你使用的后端数据库是 PostgreSQL，会安装 <code>php7.3-pgsql</code>。如果你想用 MySQL 或 MariaDB，你可以把命令参数改为 <code>php7.3-mysql</code>。</p><p>下一步，确认 PHP 已安装并在你的树莓派上运行着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php -v</span><br></pre></td></tr></table></figure><p>现在是时候安装和配置 Web 服务器了。</p><h4 id="2-安装-nginx"><span id="2-安装-nginx">2、安装 Nginx</span></h4><p>可以用下面的命令安装 Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y nginx</span><br></pre></td></tr></table></figure><p>修改默认的 Nginx 虚拟主机配置，这样 Web 服务器才能识别 PHP 文件以及知道如何处理它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>你可以安全地删除原文件中的所有内容，用下面的内容替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        server_name _;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">          include snippets/fastcgi-php.conf;</span><br><span class="line">          fastcgi_pass unix:/run/php/php7.3-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 <code>Ctrl+O</code> 保存修改后的配置文件，然后按 <code>Ctrl+X</code> 退出 Nano。你可以用下面的命令测试你的新配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t</span><br></pre></td></tr></table></figure><p>如果没有报错，重启 Nginx 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart nginx</span><br></pre></td></tr></table></figure><h4 id="3-安装-postgresql"><span id="3-安装-postgresql">3、安装 PostgreSQL</span></h4><p>接下来是安装数据库服务器。在树莓派上安装 PostgreSQL 超级简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y postgresql postgresql-client postgis</span><br></pre></td></tr></table></figure><p>输入下面的命令看一下数据库服务器安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ psql --version</span><br></pre></td></tr></table></figure><h4 id="4-创建-tiny-tiny-rss-数据库"><span id="4-创建-tiny-tiny-rss-数据库">4、创建 Tiny Tiny RSS 数据库</span></h4><p>在做其他事之前，你需要创建一个数数据库，用来给 TT-RSS 软件保存数据。首先，登录 PostgreSQL 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql</span><br></pre></td></tr></table></figure><p>下一步，新建一个用户，设置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER username WITH PASSWORD &apos;your_password&apos; VALID UNTIL &apos;infinity&apos;;</span><br></pre></td></tr></table></figure><p>然后创建一个给 TT-RSS 用的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE tinyrss;</span><br></pre></td></tr></table></figure><p>最后，给新建的用户赋最高权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON DATABASE tinyrss to user_name;</span><br></pre></td></tr></table></figure><p>这是安装数据库的步骤。你可以输入 <code>\q</code> 来退出 <code>psql</code> 程序。</p><h4 id="5-安装-git"><span id="5-安装-git">5、安装 Git</span></h4><p>安装 TT-RSS 需要用 Git，所以输入下面的命令安装 Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git -y</span><br></pre></td></tr></table></figure><p>现在，进入到 Nginx 服务器的根目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/www/html</span><br></pre></td></tr></table></figure><p>下载 TT-RSS 最新源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://git.tt-rss.org/fox/tt-rss.git tt-rss</span><br></pre></td></tr></table></figure><p>注意，这一步会创建一个 <code>tt-rss</code> 文件夹。</p><h4 id="6-安装和配置tiny-tiny-rss"><span id="6-安装和配置tiny-tiny-rss">6、安装和配置Tiny Tiny RSS</span></h4><p>现在是安装和配置你的新 TT-RSS 服务器的最后时刻了。首先，确认下你在浏览器中能打开 <code>http://your.site/tt-rss/install/index.php</code>。如果浏览器显示 <code>403 Forbidden</code>，那么就证明 <code>/var/www/html</code> 文件夹的权限没有设置正确。下面的命令通常能解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 /var/www/html/ -v</span><br></pre></td></tr></table></figure><p>如果一切正常，你会看到 TT-RSS 安装页面，它会让你输入一些数据的信息。你只需要输入前面你创建的数据库用户名和密码；数据库名；主机名填 <code>localhost</code>；端口填 <code>5432</code>。</p><p>点击“Test Configuration”。如果一切正常，你会看到一个标记着“Initialize Database”的红色按钮。点击它来开始安装。结束后，你会看到一个配置文件，你可以把它复制到 TT-RSS 的目录，另存为 <code>config.php</code>。</p><p>安装过程结束后，浏览器输入 <code>http://yoursite/tt-rss/</code> 打开 TT-RSS，使用默认的凭证登录（用户名：<code>admin</code>，密码：<code>password</code>）。登录后系统会提示你修改密码。我强烈建议你尽快修改密码。</p><h3 id="配置-tt-rss"><span id="配置-tt-rss">配置 TT-RSS</span></h3><p>如果一切正常，你现在就可以开始使用 TT-RSS 了。建议你新建一个非管理员用户，使用新用户名登录，并开始导入你的馈送、订阅，按照你的意愿来配置它。</p><p>最后，并且是超级重要的事，不要忘了阅读 TT-RSS 维基上的 <a href="https://tt-rss.org/wiki/UpdatingFeeds" target="_blank" rel="noopener">Updating Feeds</a> 部分。它讲述了如何创建一个简单的 systemd 服务来更新馈送。如果你跳过了这一步，你的 RSS 馈送就不会自动更新。</p><h3 id="总结"><span id="总结">总结</span></h3><p>呵！工作量不小，但是你做完了！你现在有自己的 RSS 聚合服务器了。想了解 TT-RSS 更多的知识？我推荐你去看官方的 <a href="https://tt-rss.org/wiki/FAQ" target="_blank" rel="noopener">FAQ</a>、<a href="https://community.tt-rss.org/c/tiny-tiny-rss/support" target="_blank" rel="noopener">支持</a>论坛，和详细的<a href="https://tt-rss.org/wiki/InstallationNotes" target="_blank" rel="noopener">安装</a>笔记。如果你有任何问题，尽情地在下面评论吧。</p><hr><p>via: <a href="https://opensource.com/article/20/2/ttrss-raspberry-pi" target="_blank" rel="noopener">https://opensource.com/article/20/2/ttrss-raspberry-pi</a></p><p>作者：<a href="https://opensource.com/users/pmullins" target="_blank" rel="noopener">Patrick H. Mullins</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过禁止比较让 Go 二进制文件变小</title>
      <link href="/27d7ea27/"/>
      <url>/27d7ea27/</url>
      
        <content type="html"><![CDATA[<!-----![](https://img.linux.net.cn/data/attachment/album/202005/22/101617lcha7vvqzhh7d565.jpg)------><p>大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件就越大。这个符合直觉，毕竟如果你写的代码不去操作定义的类型，那么定义一堆类型就没有意义了。然而，链接器的部分工作就是检测没有被程序引用的函数（比如说它们是一个库的一部分，其中只有一个子集的功能被使用），然后把它们从最后的编译产出中删除。常言道，“类型越多，二进制文件越大”，对于多数 Go 程序还是正确的。</p><p>本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么<a href="https://github.com/golang/net/commit/e0ff5e5a1de5b859e2d48a2830d7933b3ab5b75f" target="_blank" rel="noopener">像这样</a>的修改会对 Go 程序的大小有重大的影响。</p><h3 id="定义两个值相等"><span id="定义两个值相等">定义两个值相等</span></h3><p>Go 的语法定义了“赋值”和“相等”的概念。赋值是把一个值赋给一个标识符的行为。并不是所有声明的标识符都可以被赋值，如常量和函数就不可以。相等是通过检查标识符的内容是否相等来比较两个标识符的行为。</p><p>作为强类型语言，“相同”的概念从根源上被植入标识符的类型中。两个标识符只有是相同类型的前提下，才有可能相同。除此之外，值的类型定义了如何比较该类型的两个值。</p><p>例如，整型是用算数方法进行比较的。对于指针类型，是否相等是指它们指向的地址是否相同。映射和通道等引用类型，跟指针类似，如果它们指向相同的地址，那么就认为它们是相同的。</p><p>上面都是按位比较相等的例子，即值占用的内存的位模式是相同的，那么这些值就相等。这就是所谓的 memcmp，即内存比较，相等是通过比较两个内存区域的内容来定义的。</p><p>记住这个思路，我过会儿再来谈。</p><h3 id="结构体相等"><span id="结构体相等">结构体相等</span></h3><p>除了整型、浮点型和指针等标量类型，还有复合类型：结构体。所有的结构体以程序中的顺序被排列在内存中。因此下面这个声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a, b, c, d int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会占用 32 字节的内存空间；<code>a</code> 占用 8 个字节，<code>b</code> 占用 8 个字节，以此类推。Go 的规则说如果结构体所有的字段都是可以比较的，那么结构体的值就是可以比较的。因此如果两个结构体所有的字段都相等，那么它们就相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">b := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">fmt.Println(a == b) // 输出 true</span><br></pre></td></tr></table></figure><p>编译器在底层使用 memcmp 来比较 <code>a</code> 的 32 个字节和 <code>b</code> 的 32 个字节。</p><h3 id="填充和对齐"><span id="填充和对齐">填充和对齐</span></h3><p>然而，在下面的场景下过分简单化的按位比较的策略会返回错误的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a byte</span><br><span class="line">    b uint64</span><br><span class="line">    c int16</span><br><span class="line">    d uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()</span><br><span class="line">    a := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">    b := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">    fmt.Println(a == b) // 输出 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译代码后，这个比较表达式的结果还是 <code>true</code>，但是编译器在底层并不能仅依赖比较 <code>a</code> 和 <code>b</code> 的位模式，因为结构体有<em>填充</em>。</p><p>Go 要求结构体的所有字段都对齐。2 字节的值必须从偶数地址开始，4 字节的值必须从 4 的倍数地址开始，以此类推。编译器根据字段的类型和底层平台加入了填充来确保字段都<em>对齐</em>。在填充之后，编译器实际上看到的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a byte</span><br><span class="line">    _ [7]byte // 填充</span><br><span class="line">    b uint64</span><br><span class="line">    c int16</span><br><span class="line">    _ [2]int16 // 填充</span><br><span class="line">    d uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充的存在保证了字段正确对齐，而填充确实占用了内存空间，但是填充字节的内容是未知的。你可能会认为在 Go 中 填充字节都是 0，但实际上并不是 — 填充字节的内容是未定义的。由于它们并不是被定义为某个确定的值，因此按位比较会因为分布在 <code>s</code> 的 24 字节中的 9 个填充字节不一样而返回错误结果。</p><p>Go 通过生成所谓的相等函数来解决这个问题。在这个例子中，<code>s</code> 的相等函数只比较函数中的字段略过填充部分，这样就能正确比较类型 <code>s</code> 的两个值。</p><h3 id="类型算法"><span id="类型算法">类型算法</span></h3><p>呵，这是个很大的设置，说明了为什么，对于 Go 程序中定义的每种类型，编译器都会生成几个支持函数，编译器内部把它们称作类型的算法。如果类型是一个映射的键，那么除相等函数外，编译器还会生成一个哈希函数。为了维持稳定，哈希函数在计算结果时也会像相等函数一样考虑诸如填充等因素。</p><p>凭直觉判断编译器什么时候生成这些函数实际上很难，有时并不明显，（因为）这超出了你的预期，而且链接器也很难消除没有被使用的函数，因为反射往往导致链接器在裁剪类型时变得更保守。</p><h3 id="通过禁止比较来减小二进制文件的大小"><span id="通过禁止比较来减小二进制文件的大小">通过禁止比较来减小二进制文件的大小</span></h3><p>现在，我们来解释一下 Brad 的修改。向类型添加一个不可比较的字段，结构体也随之变成不可比较的，从而强制编译器不再生成相等函数和哈希函数，规避了链接器对那些类型的消除，在实际应用中减小了生成的二进制文件的大小。作为这项技术的一个例子，下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    type t struct &#123;</span><br><span class="line">        // _ [0][]byte // 取消注释以阻止比较</span><br><span class="line">        a byte</span><br><span class="line">        b uint16</span><br><span class="line">        c int32</span><br><span class="line">        d uint64</span><br><span class="line">    &#125;</span><br><span class="line">    var a t</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 Go 1.14.2（darwin/amd64）编译，大小从 2174088 降到了 2174056，节省了 32 字节。单独看节省的这 32 字节似乎微不足道，但是考虑到你的程序中每个类型及其传递闭包都会生成相等和哈希函数，还有它们的依赖，这些函数的大小随类型大小和复杂度的不同而不同，禁止它们会大大减小最终的二进制文件的大小，效果比之前使用 <code>-ldflags=&quot;-s -w&quot;</code> 还要好。</p><p>最后总结一下，如果你不想把类型定义为可比较的，可以在源码层级强制实现像这样的奇技淫巧，会使生成的二进制文件变小。</p><hr><p>via: <a href="https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons" target="_blank" rel="noopener">https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons</a></p><p>作者：<a href="https://dave.cheney.net/author/davecheney" target="_blank" rel="noopener">Dave Cheney</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Go </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go：异步抢占</title>
      <link href="/5698ca18/"/>
      <url>/5698ca18/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p><p>ℹ️ 本文基于 Go 1.14。</p><p>抢占是调度器的重要部分，基于抢占调度器可以在各个协程中分配运行的时间。实际上，如果没有抢占机制，一个长时间占用 CPU 的协程会阻塞其他的协程被调度。1.14 版本引入了一项新的异步抢占的技术，赋予了调度器更大的能力和控制力。</p><p><em>我推荐你阅读我的文章<a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7" target="_blank" rel="noopener">”Go：协程和抢占“</a>来了解更多之前的特性和它的弊端。</em></p><h2 id="工作流"><span id="工作流">工作流</span></h2><p>我们以一个需要抢占的例子来开始。下面一段代码开启了几个协程，在几个循环中没有其他的函数调用，意味着调度器没有机会抢占它们：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/01.png" alt></p><p>然而，当把这个程序的追踪过程可视化后，我们清晰地看到了协程间的抢占和切换：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/02.png" alt></p><p>我们还可以看到表示协程的每个块儿的长度都相等。所有的协程运行时间相同（约 10 到 20 毫秒）。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/03.png" alt></p><p>异步抢占是基于一个时间条件触发的。当一个协程运行超过 10ms 时，Go 会尝试抢占它。</p><p>抢占是由线程 <code>sysmon</code> 初始化的，该线程专门用于监控包括长时间运行的协程在内的运行时。当某个协程被检测到运行超过 10ms 后，<code>sysmon</code> 向当前的线程发出一个抢占信号。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/04.png" alt></p><p>之后，当信息被信号处理器接收到时，线程中断当前的操作来处理信号，因此不会再运行当前的协程，在我们的例子中是 <code>G7</code>。取而代之的是，<code>gsignal</code> 被调度为管理发送来的信号。当它发现它是一个抢占指令后，在程序处理信号后恢复时它准备好指令来中止当前的协程。下面是这第二个阶段的示意图：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/05.png" alt></p><p><em>如果你想了解更多关于 <code>gsignal</code> 的信息，我推荐你读一下我的文章<a href="https://medium.com/a-journey-with-go/go-gsignal-master-of-signals-329f7ff39391" target="_blank" rel="noopener">”Go：gsignal，信号的掌控者“</a>。</em></p><h2 id="实现"><span id="实现">实现</span></h2><p>我们在被选中的信号 <code>SIGURG</code> 中第一次看到了实现的细节。这个选择在提案<a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">”提案：非合作式协程抢占“</a>中有详细的解释：</p><blockquote><ul><li>它应该是调试者默认传递过来的一个信号。</li><li>它不应该是 Go/C 混合二进制中 libc 内部使用的信号。</li><li>它应该是一个可以伪造而没有其他后果的信号。</li><li>我们需要在没有实时信号时与平台打交道。<br>然后，当信号被注入和接收时，Go 需要一种在程序恢复时能终止当前协程的方式。为了实现这个过程，Go 会把一条指令推进程序计数器，这样看起来运行中的程序调用了运行时的函数。该函数暂停了协程并把它交给了调度器，调度器之后还会运行其他的协程。</li></ul></blockquote><p><em>我们应该注意到 Go 不能做到在任何地方终止程序；当前的指令必须是一个安全点。例如，如果程序现在正在调用运行时，那么抢占协程并不安全，因为运行时很多函数不应该被抢占。</em></p><p>这个新的抢占机制也让垃圾回收器受益，可以用更高效的方式终止所有的协程。诚然，STW 现在非常容易，Go 仅需要向所有运行的线程发出一个信号就可以了。下面是垃圾回收器运行时的一个例子：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/06.png" alt></p><p>然后，所有的线程都接收到这个信号，在垃圾回收器重新开启全局之前会暂停执行。</p><p><em>如果你想了解更多关于 STW 的信息，我建议你阅读我的文章<a href="https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846" target="_blank" rel="noopener">”Go：Go 怎样实现 STW？“</a>。</em></p><p>最后，这个特性被封装在一个参数中，你可以用这个参数关闭异步抢占。你可以用 <code>GODEBUG=asyncpreemptoff=1</code> 来运行你的程序，如果你因为升级到了 Go 1.14 发现了不正常的现象就可以调试你的程序，或者观察你的程序有无异步抢占时的不同表现。</p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inlining Optimisations in Go</title>
      <link href="/6ce34c49/"/>
      <url>/6ce34c49/</url>
      
        <content type="html"><![CDATA[<h1 id="go-中的内联优化"><span id="go-中的内联优化">Go 中的内联优化</span></h1><blockquote><p>本文讨论 Go 编译器是如何实现内联的，以及这种优化方法如何影响你的 Go 代码。</p></blockquote><p><img src="https://img.linux.net.cn/data/attachment/album/202005/02/222202e3v3pppkhnndpbpn.jpg" alt></p><p><em>请注意：</em>本文重点讨论 <em>gc</em>，这是来自 <a href="https://github.com/golang/go" target="_blank" rel="noopener">golang.org</a> 的事实标准的 Go 编译器。讨论到的概念可以广泛适用于其它 Go 编译器，如 gccgo 和 llgo，但它们在实现方式和功效上可能有所差异。</p><h3 id="内联是什么"><span id="内联是什么">内联是什么？</span></h3><p><ruby>内联<rt>inlining</rt></ruby>就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经成为编译过程中自动实现的基本优化过程的其中一步。</p><h3 id="为什么内联很重要"><span id="为什么内联很重要">为什么内联很重要？</span></h3><p>有两个原因。第一个是它消除了函数调用本身的开销。第二个是它使得编译器能更高效地执行其他的优化策略。</p><h4 id="函数调用的开销"><span id="函数调用的开销">函数调用的开销</span></h4><p>在任何语言中，调用一个函数 [^1] 都会有消耗。把参数编组进寄存器或放入栈中（取决于 ABI），在返回结果时的逆反过程都会有开销。引入一次函数调用会导致程序计数器从指令流的一点跳到另一点，这可能导致管道滞后。函数内部通常有<ruby>前置处理<rt>preamble</rt></ruby>，需要为函数执行准备新的栈帧，还有与前置相似的<ruby>后续处理<rt>epilogue</rt></ruby>，需要在返回给调用方之前释放栈帧空间。</p><p>在 Go 中函数调用会消耗额外的资源来支持栈的动态增长。在进入函数时，goroutine 可用的栈空间与函数需要的空间大小进行比较。如果可用空间不同，前置处理就会跳到<ruby>运行时<rt>runtime</rt></ruby>的逻辑中，通过把数据复制到一块新的、更大的空间的来增长栈空间。当这个复制完成后，运行时就会跳回到原来的函数入口，再执行栈空间检查，现在通过了检查，函数调用继续执行。这种方式下，goroutine 开始时可以申请很小的栈空间，在有需要时再申请更大的空间。[^2]</p><p>这个检查消耗很小，只有几个指令，而且由于 goroutine 的栈是成几何级数增长的，因此这个检查很少失败。这样，现代处理器的分支预测单元可以通过假定检查肯定会成功来隐藏栈空间检查的消耗。当处理器预测错了栈空间检查，不得不放弃它在推测性执行所做的操作时，与为了增加 goroutine 的栈空间运行时所需的操作消耗的资源相比，管道滞后的代价更小。</p><p>虽然现代处理器可以用预测性执行技术优化每次函数调用中的泛型和 Go 特定的元素的开销，但那些开销不能被完全消除，因此在每次函数调用执行必要的工作过程中都会有性能消耗。一次函数调用本身的开销是固定的，与更大的函数相比，调用小函数的代价更大，因为在每次调用过程中它们做的有用的工作更少。</p><p>因此，消除这些开销的方法必须是要消除函数调用本身，Go 的编译器就是这么做的，在某些条件下通过用函数的内容来替换函数调用来实现。这个过程被称为<em>内联</em>，因为它在函数调用处把函数体展开了。</p><h4 id="改进的优化机会"><span id="改进的优化机会">改进的优化机会</span></h4><p>Cliff Click 博士把内联描述为现代编译器做的优化措施，像常量传播（LCTT 译注：此处作者笔误，原文为 constant proportion，修正为 constant propagation）和死代码消除一样，都是编译器的基本优化方法。实际上，内联可以让编译器看得更深，使编译器可以观察调用的特定函数的上下文内容，可以看到能继续简化或彻底消除的逻辑。由于可以递归地执行内联，因此不仅可以在每个独立的函数上下文处进行这种优化决策，也可以在整个函数调用链中进行。</p><h3 id="实践中的内联"><span id="实践中的内联">实践中的内联</span></h3><p>下面这个例子可以演示内联的影响：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(<span class="number">-1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个基准，会得到如下结果：[^3]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=. </span><br><span class="line">BenchmarkMax-4   530687617         2.24 ns/op</span><br></pre></td></tr></table></figure><p>在我的 2015 MacBook Air 上 <code>max(-1, i)</code> 的耗时约为 2.24 纳秒。现在去掉 <code>//go:noinline</code> 编译指令，再看下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=. </span><br><span class="line">BenchmarkMax-4   1000000000         0.514 ns/op</span><br></pre></td></tr></table></figure><p>从 2.24 纳秒降到了 0.51 纳秒，或者从 <code>benchstat</code> 的结果可以看出，有 78% 的提升。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old time/op  new time/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.49ns ± 6%  -77.96%  (p=0.000 n=18+19)</span><br></pre></td></tr></table></figure><p>这个提升是从哪儿来的呢？</p><p>首先，移除掉函数调用以及与之关联的前置处理 [^4] 是主要因素。把 <code>max</code> 函数的函数体在调用处展开，减少了处理器执行的指令数量并且消除了一些分支。</p><p>现在由于编译器优化了 <code>BenchmarkMax</code>，因此它可以看到 <code>max</code> 函数的内容，进而可以做更多的提升。当 <code>max</code> 被内联后，<code>BenchmarkMax</code> 呈现给编译器的样子，看起来是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">-1</span> &gt; i &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行一次基准，我们看一下手动内联的版本和编译器内联的版本的表现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old time/op  new time/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.48ns ± 3%  -78.14%  (p=0.000 n=18+18)</span><br></pre></td></tr></table></figure><p>现在编译器能看到在 <code>BenchmarkMax</code> 里内联 <code>max</code> 的结果，可以执行以前不能执行的优化措施。例如，编译器注意到 <code>i</code> 初始值为 <code>0</code>，仅做自增操作，因此所有与 <code>i</code> 的比较都可以假定 <code>i</code> 不是负值。这样条件表达式 <code>-1 &gt; i</code> 永远不是 <code>true</code>。[^5]</p><p>证明了 <code>-1 &gt; i</code> 永远不为 true 后，编译器可以把代码简化为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且因为分支里是个常量，编译器可以通过下面的方式移除不会走到的分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = i</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过内联和由内联解锁的优化过程，编译器把表达式 <code>r = max(-1, i))</code> 简化为 <code>r = i</code>。</p><h3 id="内联的限制"><span id="内联的限制">内联的限制</span></h3><p>本文中我论述的内联称作<ruby>叶子内联<rt>leaf inlining</rt></ruby>：把函数调用栈中最底层的函数在调用它的函数处展开的行为。内联是个递归的过程，当把函数内联到调用它的函数 A 处后，编译器会把内联后的结果代码再内联到 A 的调用方，这样持续内联下去。例如，下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxMaxMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(max(<span class="number">-1</span>, i), max(<span class="number">0</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的例子中的代码运行速度一样快，因为编译器可以对上面的代码重复地进行内联，也把代码简化到 <code>r = i</code> 表达式。</p><p>下一篇文章中，我会论述当 Go 编译器想要内联函数调用栈中间的某个函数时选用的另一种内联策略。最后我会论述编译器为了内联代码准备好要达到的极限，这个极限 Go 现在的能力还达不到。</p><p>[^1]: 在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。<br>[^2]: 在 Go 1.14 以前，栈检查的前置处理也被垃圾回收器用于 STW，通过把所有活跃的 goroutine 栈空间设为 0，来强制它们切换为下一次函数调用时的运行时状态。这个机制<a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">最近被替换</a>为一种新机制，新机制下运行时可以不用等 goroutine 进行函数调用就可以暂停 goroutine。<br>[^3]: 我用 <code>//go:noinline</code> 编译指令来阻止编译器内联 <code>max</code>。这是因为我想把内联 <code>max</code> 的影响与其他影响隔离开，而不是用 <code>-gcflags=&#39;-l -N&#39;</code> 选项在全局范围内禁止优化。关于 <code>//go:</code> 注释在<a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas" target="_blank" rel="noopener">这篇文章</a>中详细论述。<br>[^4]: 你可以自己通过比较 <code>go test -bench=. -gcflags=-S</code> 有无 <code>//go:noinline</code> 注释时的不同结果来验证一下。<br>[^5]: 你可以用 <code>-gcflags=-d=ssa/prove/debug=on</code> 选项来自己验证一下。</p><h4 id="相关文章"><span id="相关文章">相关文章：</span></h4><ol><li><a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast" target="_blank" rel="noopener">使 Go 变快的 5 件事</a></li><li><a href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite" target="_blank" rel="noopener">为什么 Goroutine 的栈空间会无限增长？</a></li><li><a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go" target="_blank" rel="noopener">Go 中怎么写基准测试</a></li><li><a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas" target="_blank" rel="noopener">Go 中隐藏的编译指令</a></li></ol><hr><p>via: <a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go" target="_blank" rel="noopener">https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go</a></p><p>作者：<a href="https://dave.cheney.net/author/davecheney" target="_blank" rel="noopener">Dave Cheney</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派做BT下载器</title>
      <link href="/fb1d9193/"/>
      <url>/fb1d9193/</url>
      
        <content type="html"><![CDATA[<p>可以用 <a href="https://www.transmissionbt.com/" target="_blank" rel="noopener">transmission</a>，它提供了 Web 界面</p><h4 id="1-安装-transmission"><span id="1-安装-transmission">1. 安装 transmission：</span></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install transmission-daemon</span><br></pre></td></tr></table></figure><h4 id="2-创建下载目录一个是下载完成的目录一个是未完成的目录"><span id="2-创建下载目录一个是下载完成的目录一个是未完成的目录">2. 创建下载目录，一个是下载完成的目录，一个是未完成的目录</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Public/bt_complete</span><br><span class="line">mkdir Public/bt_incomplete</span><br></pre></td></tr></table></figure><h3 id="3-配置目录权限"><span id="3-配置目录权限">3. 配置目录权限</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G debian-transmission pi</span><br><span class="line">sudo chgrp debian-transmission bt_complete</span><br><span class="line">sudo chgrp debian-transmission bt_incomplete</span><br><span class="line">sudo chmod 770 bt_complete</span><br><span class="line">sudo chmod 770 bt_incomplete</span><br></pre></td></tr></table></figure><h4 id="4-修改配置文件-etctransmission-daemonsettingsjson"><span id="4-修改配置文件-etctransmission-daemonsettingsjson">4. 修改配置文件 /etc/transmission-daemon/settings.json</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;download-dir&quot;:&quot;/home/pi/Public/bt_complete&quot;</span><br><span class="line">&quot;incomplete-dir&quot;:&quot;/home/pi/Public/bt_incomplete&quot;</span><br><span class="line">&quot;rpc-host-whitelist&quot;: &quot;192.168.1.*&quot;,</span><br></pre></td></tr></table></figure><h4 id="5-重启-transmission"><span id="5-重启-transmission">5. 重启 transmission</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service transmission-daemon reload</span><br><span class="line">sudo service transmission-daemon restart</span><br></pre></td></tr></table></figure><p>两个命令按顺序执行，单独 restart 的话配置不会保存：</p><p>浏览器中输入 <code>http://192.168.1.8:9091/</code>，默认用户名密码：<code>transmission</code></p><p><strong>修改 transmission 用户名和密码的方法：</strong></p><ol><li>先停止服务： <code>sudo service transmission-daemon stop</code></li><li>修改配置文件，看到这个是加密的密码，直接把密码改为密码明文就可以：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“rpc-username”: “明文”,</span><br><span class="line">“rpc-password”: “密文”,</span><br></pre></td></tr></table></figure><ol start="3"><li>再此启动服务 ：<code>sudo service transmission-daemon start</code><br>  启动的时候 transmission 会自动把新密码加密。</li></ol><p><strong>transmission 默认监听 51413 端口，最好在路由器上做个端口转发，把这个端口转到它的 IP 地址</strong></p>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> torrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派搭建GitHub镜像服务</title>
      <link href="/2073ae8b/"/>
      <url>/2073ae8b/</url>
      
        <content type="html"><![CDATA[<h3 id="1-树莓派上创建-git-账号创建用于存放代码的目录"><span id="1-树莓派上创建-git-账号创建用于存放代码的目录">1.  树莓派上创建 git 账号，创建用于存放代码的目录</span></h3><p><code>/srv/</code></p><h3 id="2-github-库-clone-到树莓派"><span id="2-github-库-clone-到树莓派">2. GitHub 库 clone 到树莓派</span></h3><p><code>git clone git@github.com:user/XXXX.git /srv/</code></p><h3 id="3-添加-remote"><span id="3-添加-remote">3. 添加 remote</span></h3><p><code>git remote add upstream https://github.com/abcd/XXXX</code></p><h3 id="4-修改-hook"><span id="4-修改-hook">4. 修改 hook</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.git/hooks/post-update</span></span><br><span class="line">param=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">push_branch=<span class="variable">$&#123;param##refs/heads/&#125;</span> <span class="comment">#获取到更新的分支名</span></span><br><span class="line">git push origin <span class="variable">$push_branch</span></span><br></pre></td></tr></table></figure><h3 id="5-添加定时任务"><span id="5-添加定时任务">5. 添加定时任务</span></h3><p><code>5,35 * * * * cd /srv/XXXX &amp;&amp; git pull upstream master</code></p><h3 id="6-在本地代码添加-remote"><span id="6-在本地代码添加-remote">6. 在本地代码添加 remote</span></h3><h4 id="61-有多个项目时为避免修改每个项目的-remote直接添加-host"><span id="61-有多个项目时为避免修改每个项目的-remote直接添加-host">6.1 有多个项目时，为避免修改每个项目的 remote，直接添加 host</span></h4><p><code>192.168.1.8 gitsrv</code></p><h4 id="62-在每个项目在添加一次-remote"><span id="62-在每个项目在添加一次-remote">6.2 在每个项目在添加一次 remote</span></h4><p><code>git remote add pi git@192.168.1.8:/srv/XXXX</code></p><p>这样即使以后地址改变，只需要改一次 host 就可以了</p><h3 id="7-推拉代码时从-pi-推拉"><span id="7-推拉代码时从-pi-推拉">7. 推拉代码时，从 pi 推拉</span></h3><p><code>git pull pi branch</code></p><p><code>git push pi branch</code></p>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非实时信号表</title>
      <link href="/c77ce28f/"/>
      <url>/c77ce28f/</url>
      
        <content type="html"><![CDATA[<h1 id="信号类型"><span id="信号类型">信号类型</span></h1><p>Linux系统共定义了64种信号，分为两大类：可靠信号与不可靠信号，前32种信号为不可靠信号，后32种为可靠信号。</p><h3 id="概念"><span id="概念">概念</span></h3><p>不可靠信号： 也称为非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为<code>1~31</code>；<br>可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为<code>32~64</code></p><h3 id="信号表"><span id="信号表">信号表</span></h3><p>在终端，可通过kill -l查看所有的signal信号</p><table><thead><tr><th align="left">取值</th><th align="left">名称</th><th align="left">解释</th><th align="left">默认动作</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIGHUP</td><td align="left">挂起</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">SIGINT</td><td align="left">中断</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">SIGQUIT</td><td align="left">退出</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">SIGILL</td><td align="left">非法指令</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">SIGTRAP</td><td align="left">断点或陷阱指令</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">SIGABRT</td><td align="left">abort发出的信号</td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">SIGBUS</td><td align="left">非法内存访问</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">SIGFPE</td><td align="left">浮点异常</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">SIGKILL</td><td align="left">kill信号</td><td align="left">不能被忽略、处理和阻塞</td></tr><tr><td align="left">10</td><td align="left">SIGUSR1</td><td align="left">用户信号1</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">SIGSEGV</td><td align="left">无效内存访问</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">SIGUSR2</td><td align="left">用户信号2</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">SIGPIPE</td><td align="left">管道破损，没有读端的管道写数据</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">SIGALRM</td><td align="left">alarm发出的信号</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">SIGTERM</td><td align="left">终止信号</td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">SIGSTKFLT</td><td align="left">栈溢出</td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">SIGCHLD</td><td align="left">子进程退出</td><td align="left">默认忽略</td></tr><tr><td align="left">18</td><td align="left">SIGCONT</td><td align="left">进程继续</td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">SIGSTOP</td><td align="left">进程停止</td><td align="left">不能被忽略、处理和阻塞</td></tr><tr><td align="left">20</td><td align="left">SIGTSTP</td><td align="left">进程停止</td><td align="left"></td></tr><tr><td align="left">21</td><td align="left">SIGTTIN</td><td align="left">进程停止，后台进程从终端读数据时</td><td align="left"></td></tr><tr><td align="left">22</td><td align="left">SIGTTOU</td><td align="left">进程停止，后台进程想终端写数据时</td><td align="left"></td></tr><tr><td align="left">23</td><td align="left">SIGURG</td><td align="left">I/O有紧急数据到达当前进程</td><td align="left">默认忽略</td></tr><tr><td align="left">24</td><td align="left">SIGXCPU</td><td align="left">进程的CPU时间片到期</td><td align="left"></td></tr><tr><td align="left">25</td><td align="left">SIGXFSZ</td><td align="left">文件大小的超出上限</td><td align="left"></td></tr><tr><td align="left">26</td><td align="left">SIGVTALRM</td><td align="left">虚拟时钟超时</td><td align="left"></td></tr><tr><td align="left">27</td><td align="left">SIGPROF</td><td align="left">profile时钟超时</td><td align="left"></td></tr><tr><td align="left">28</td><td align="left">SIGWINCH</td><td align="left">窗口大小改变</td><td align="left">默认忽略</td></tr><tr><td align="left">29</td><td align="left">SIGIO</td><td align="left">I/O相关</td><td align="left"></td></tr><tr><td align="left">30</td><td align="left">SIGPWR</td><td align="left">关机</td><td align="left">默认忽略</td></tr><tr><td align="left">31</td><td align="left">SIGSYS</td><td align="left">系统调用异常</td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 CGo 的字符串函数的解释</title>
      <link href="/8c45788a/"/>
      <url>/8c45788a/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="noopener">cgo</a> 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。在 CGo 的文档中有简洁的解释，但我认为解释得太简洁了，因为文档只涉及了定义中的某些特定字符串，而忽略了两个很重要的注意事项。我曾经踩过这里的坑，现在我要详细解释一下。</p><p>四个函数分别是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">CString</span><span class="params">(<span class="keyword">string</span>)</span> *<span class="title">C</span>.<span class="title">char</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoString</span><span class="params">(*C.char)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoStringN</span><span class="params">(*C.char, C.<span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">C</span>.<span class="title">GoBytes</span><span class="params">(unsafe.Pointer, C.<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure><p><code>C.CString()</code> 等价于 C 的 <code>strdup()</code>，像文档中提到的那样，把 Go 的字符串复制为可以传递给 C 函数的 C 的 <code>char *</code>。很讨厌的一件事是，由于 Go 和 CGo 类型的定义方式，调用 <code>C.free</code> 时需要做一个转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cs := C.CString(<span class="string">"a string"</span>)</span><br><span class="line">C.free(unsafe.Pointer(cs))</span><br></pre></td></tr></table></figure><p>请留意，Go 字符串中可能嵌入了 <code>\0</code> 字符，而 C 字符串不会。如果你的 Go 字符串中有 <code>\0</code> 字符，当你调用 <code>C.CString()</code> 时，C 代码会从 <code>\0</code> 字符处截断你的字符串。这往往不会被注意到，但<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString" target="_blank" rel="noopener">有时文本并不保证不含 null 字符</a>。</p><p><code>C.GoString()</code> 也等价于 <code>strdup()</code>，但与 <code>C.CString()</code> 相反，是把 C 字符串转换为 Go 字符串。你可以用它定义结构体的字段，或者是声明为 C 的 <code>char *</code>（在 Go 中叫 <code>*C.cahr</code>） 的其他变量，抑或其他的一些变量（我们后面会看到）。</p><p><code>C.GoStringN()</code> 等价于 C 的 <code>memmove()</code>，与 C 中普通的字符串函数不同。<strong>它把整个 N 长度的 C buffer 复制为一个 Go 字符串，不单独处理 null 字符。</strong>再详细点，它也通过复制来实现。如果你有一个定义为 <code>char feild[64]</code> 的结构体的字段，然后调用了 <code>C.GoStringN(&amp;field, 64)</code>，那么你得到的 Go 字符串一定是 64 个字符，字符串的末尾有可能是一串 <code>\0</code> 字符。</p><p>(我认为这是 cgo 文档中的一个 bug。它宣称 GoStringN 的入参是一个 C 的字符串，但实际上很明显不是，因为 C 的字符串不能以 null 字符结束，而 GoStringN 不会在 null 字符处结束处理。)</p><p><code>C.GoBytes()</code> 是 <code>C.GoStringN()</code> 的另一个版本，不返回 <code>string</code> 而是返回 <code>[]byte</code>。它没有宣称以 C 字符串作为入参，它仅仅是对整个 buffer 做了内存拷贝。</p><p>如果你要拷贝的东西不是以 null 字符结尾的 C 字符串，而是固定长度的 memory buffer，那么 <code>C.GoString()</code> 正好能满足需求；它避开了 C 中传统的问题<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString" target="_blank" rel="noopener">处理不是 C 字符串的 ’string‘</a>。然而，如果你要处理定义为 <code>char field[N]</code> 的结构体字段这种限定长度的 C 字符串时，这些函数<em>都不能</em>满足需求。</p><p>传统语义的结构体中固定长度的字符串变量，定义为 <code>char field[N]</code> 的字段，以及“包含一个字符串”等描述，都表示当且仅当字符串有足够空间时以 null 字符结尾，换句话说，字符串最多有 N-1 个字符。如果字符串正好有 N 个字符，那么它不会以 null 字符结尾。这是 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/UnixAPIMistake" target="_blank" rel="noopener">C 代码中诸多 bug 的根源</a>，也不是一个好的 API，但我们却摆脱不了这个 API。每次我们遇到这样的字段，文档不会明确告诉你字段的内容并不一定是 null 字符结尾的，你需要自己假设你有这种 API。</p><p><code>C.GoString()</code> 或 <code>C.GoStringN()</code> 都不能正确处理这些字段。使用 <code>GoStringN()</code> 相对来说出错更少；它仅仅返回一个末尾有一串 <code>\0</code> 字符长度为 N 的 Go 字符串（如果你仅仅是把这些字段打印出来，那么你可能不会留意到；我经常干这种事）。使用有诱惑力的 <code>GoString()</code> 更是引狼入室，因为它内部会对入参做 <code>strlen()</code>；如果字符末尾没有 null 字符，<code>strlen()</code> 会访问越界的内存地址。如果你走运，你得到的 Go 字符串末尾会有大量的垃圾。如果你不走运，你的 Go 程序出现段错误，因为 <code>strlen()</code> 访问了未映射的内存地址。</p><p>（总的来说，如果字符串末尾出现了大量垃圾，通常意味着在某处有不含结束符的 C 字符串。）</p><p>你需要的是与 C 的 <code>strndup()</code> 等价的 Go 函数，以此来确保复制不超过 N 个字符且在 null 字符处终止。下面是我写的版本，不保证无错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   s := C.GoStringN(cs, C.<span class="keyword">int</span>(<span class="built_in">len</span>))</span><br><span class="line">   i := strings.IndexByte(s, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> C.GoString(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于有 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding" target="_blank" rel="noopener">Go 的字符串怎样占用内存</a>的问题，这段代码做了些额外的工作来最小化额外的内存占用。你可能想用另一种方法，返回一个 <code>GoStringN()</code> 字符串的切片。你也可以写复杂的代码，根据 i 和 len 的不同来决定选用哪种方法。</p><p>更新：<a href="https://github.com/golang/go/issues/12428#issuecomment-136581154" target="_blank" rel="noopener">Ian Lance Taylor 给我展示了份更好的代码</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> C.GoStringN(cs, C.<span class="keyword">int</span>(C.strnlen(cs, C.size_t(<span class="built_in">len</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，这里有大量的转换。这篇文章就是你看到的 Go 和 Gco 类型的结合。</p><hr><p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions" target="_blank" rel="noopener">https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions</a></p><p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann" target="_blank" rel="noopener">ChrisSiebenmann</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 字符串中的潜在问题</title>
      <link href="/10e5e8ba/"/>
      <url>/10e5e8ba/</url>
      
        <content type="html"><![CDATA[<p>在我之前的文章 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike" target="_blank" rel="noopener">Go 中我喜欢的东西</a>中提到过，我喜欢的 <a href="https://golang.org/" target="_blank" rel="noopener">Go</a> 的东西其中之一就是它的字符串（通常还有切片）。从一个 Python 开发者的角度看，它们之所以伟大，是因为创建它们时开销很少，因为它们通常不需要复制。在 Python 中，任何时候操作字符串都需要复制一部分或全部字符串，而 <a href="https://utcc.utoronto.ca/~cks/space/blog/python/StringSpeedSurprises" target="_blank" rel="noopener">这很容易对性能造成影响</a>。想要写高性能的 Python 代码需要谨慎考虑复制的问题。在 Go 中，几乎所有的字符串操作都是不复制的，仅仅是从原字符串取一个子集（例如去除字符串首尾的空白字符），因此你可以更自由地操作字符串。这个机制可以非常直接地解决你的问题，并且非常高效。</p><p>（当然，不是所有的字符串操作都不复制。例如，把一个字符串转换成大写需要复制，尽管 Go 中的实现已经足够智能，在不需要改变原字符串时 — 例如由于它已经是一个全大写的字符串 — 可以规避掉复制。）</p><p>但是这个优势也带来了潜在的坏处，那些没有开销的子字符串使原来的整个字符串一直存在于内存中。Go 中的字符串（和切片）操作之所以内存开销很少，是因为它们只是底层存储（字符串或切片底层的数组的真实数据）的一些部分的引用；创建一个字符串做的操作就是创建了一个新的引用。但是 Go（目前）不会对字符串数据或数组进行部分的垃圾回收，所以即使它一个很小的 bit 被其它元素引用，整个对象也会一直保持在内存中。换句话说，一个单字符的字符串（目前）足够让一个巨大的字符串不被 GC 回收。</p><p>当然，不会有很多人遇到这个问题。为了遇到它，你需要处理一个非常庞大的原字符串，或造成大量的内存消耗（或者两者都做），在这个基础上，你必须创建那些不持久的字符串的持久的小子字符串（好吧，你是多么希望它是非持久的）。很多使用场景不会复现这个问题；要么你的原字符串不够大，要么你的子集获取了大部分原字符串（例如你把原字符串进行了分词处理），要么子字符串生命周期不够长。简而言之，如果你是一个普通的 Go 开发者，你可以忽略这个问题。处理长字符串并且长时间维持原字符串的很小部分的人才会关注这个问题。</p><p>（我之所以关注到这个问题，是因为一次我花了大量精力用尽可能少的内存写 Python 程序，尽管它是从一个大的配置文件解析结果然后分块储存。这让我联想到了一些其他的事，如字符串的生命周期、限制字符串只复制一次，等等。然后我用 Go 语言写了一个解析器，这让我由重新考虑了一下这些问题，我意识到由于我的解析器截取出和维持的 bit 一直存在于内存中，从输入文件解析出的庞大字符串也会一直存在与内存中。）</p><p>顺便说一下，我认为这是 Go 做了权衡之后的正确结果。大部分使用字符串的开发者不会遇到这个问题，而且截取子字符串开销很小对于开发者来说用处很大。这种低开销的截取操作也减轻了 GC 的负担；当代码使用大量的子字符串截取（像 Python 中那样）时，你只需要处理固定长度的字符串引用就可以了，而不是需要处理长度变化的字符串。</p><p>当你的代码遇到这个问题时，当然有明显的解决方法：创建一个函数，通过把字符串转换成 <code>[]byte</code> 来 ”最小化“ 字符串，然后返回。这种方法生成了一个最小化的字符串，内存开销是理论上最完美实现的只复制一次，而 Go 现在很容易就可以实现。</p><h2 id="附加问题stringstoupper-等怎样规避没有必要的复制"><span id="附加问题stringstoupper-等怎样规避没有必要的复制">附加问题：<code>strings.ToUpper()</code> 等怎样规避没有必要的复制</span></h2><p>所有的主动转换函数像 <code>ToUpper()</code> 和 <code>ToTitle()</code> 是用 <code>strings.Map()</code> 和 <a href="http://golang.org/pkg/unicode/" target="_blank" rel="noopener">unicode 包</a> 中的函数实现的。<code>Map()</code> 足够智能，在映射的函数返回一个与已存在的 <code>rune</code> 不同的结果之前不会创建新的字符串。因此，你代码中所有类似的直接使用 <code>Map()</code> 的地方都不会有内存开销。</p><hr><p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding" target="_blank" rel="noopener">https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding</a></p><p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann" target="_blank" rel="noopener">Chris Siebenmann</a><br>译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a><br>校对：<a href="https://github.com/校对者ID" target="_blank" rel="noopener">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go GC 怎么标记内存</title>
      <link href="/b3baee92/"/>
      <url>/b3baee92/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p><p>ℹ️ 本文基于 <em>Go 1.13</em>。关于内存管理的概念的讨论在我的文章 <a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44" target="_blank" rel="noopener">Go 中的内存管理和分配</a> 中有详细的解释。</p><p>Go GC 的作用是回收不再使用的内存。实现的算法是并发的三色标记和清除回收法。本中文，我们研究三色标记法，以及各个颜色的不同用处。</p><p>你可以在 Ken Fox 的 <a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/" target="_blank" rel="noopener">解读垃圾回收算法</a> 中了解更多关于不同垃圾回收机制的信息。</p><h2 id="标记阶段"><span id="标记阶段">标记阶段</span></h2><p>这个阶段浏览内存来了解哪些块儿是在被我们的代码使用和哪些块儿应该被回收。</p><p>然而，因为 GC 和我们的 Go 程序并行，GC 扫描期间内存中某些对象的状态可能被改变，所以需要一个检测这种可能的变化的方法。为了解决这个潜在的问题，实现了 <a href="https://en.wikipedia.org/wiki/Write_barrier" target="_blank" rel="noopener">写屏障</a> 算法，GC 可以追踪到任何的指针修改。使写屏障生效的唯一条件是短暂终止程序，又名 “Stop the World”。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/01.png" alt></p><p>在进程启动时，Go 也在每个 processor 起了一个标记 worker 来辅助标记内存。</p><p>然后，当 root 被加入到处理队列中后，标记阶段就开始遍历和用颜色标记内存。</p><p>为了了解在标记阶段的每一步，我们来看一个简单的程序示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct1 <span class="keyword">struct</span> &#123;</span><br><span class="line">a, b <span class="keyword">int64</span></span><br><span class="line">c, d <span class="keyword">float64</span></span><br><span class="line">e *struct2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> struct2 <span class="keyword">struct</span> &#123;</span><br><span class="line">f, g <span class="keyword">int64</span></span><br><span class="line">h, i <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := allocStruct1()</span><br><span class="line">s2 := allocStruct2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">_ = allocStruct2()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"s1 = %X, s2 = %X\n"</span>, &amp;s1, &amp;s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct1</span><span class="params">()</span> *<span class="title">struct1</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;struct1&#123;</span><br><span class="line">e: allocStruct2(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct2</span><span class="params">()</span> *<span class="title">struct2</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;struct2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct2</code> 不包含指针，因此它被储存在一个专门存放不被其他对象引用的对象的 span 中。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/02.png" alt="不包含指针的结构体储存在专有的 span 中"></p><p>这减少了 GC 的工作，因为标记内存时不需要扫描这个 span。</p><p>分配工作结束后，我们的程序强迫 GC 重复前面的步骤。下面是流程图：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/03.png" alt="扫描内存"></p><p>GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。扫描到被标记为 <code>no scan</code> 的 span 时，停止扫描。然而，这个工作是在多个协程中完成的，每个指针被加入到一个 work pool 中的队列。然后，后台运行的标记 worker 从这个 work pool 中拿到前面出列的 work，扫描这个对象然后把在这个对象里找到的指针加入到队列。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/04.png" alt="garbage collector work pool"></p><h2 id="颜色标记"><span id="颜色标记">颜色标记</span></h2><p>worker 需要一种记录哪些内存需要扫描的方法。GC 使用一种 <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking" target="_blank" rel="noopener">三色标记算法</a>，工作流程如下：</p><ul><li>开始时，所有对象都被认为是<strong>白色</strong></li><li>root 对象（栈，堆，全局变量）被标记为<strong>灰色</strong></li></ul><p>这个初始步骤完成后，GC 会：</p><ul><li>选择一个<strong>灰色</strong>的对象，标记为<strong>黑色</strong></li><li>追踪这个对象的所有指针，把所有引用的对象标记为<strong>灰色</strong></li></ul><p>然后，GC 重复以上两步，直到没有对象可被标记。在这一时刻，对象非黑即白，没有灰色。白色的对象表示没有其他对象引用，可以被回收。</p><p>下面是前面例子的图示：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/05.png" alt></p><p>初始状态下，所有的对象被认为是白色的。然后，遍历到的且被其他对象引用的对象，被标记为灰色。如果一个对象在被标记为 <code>no scan</code> 的 span 中，因为它不需要被扫描，所以可以标记为黑色。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/06.png" alt></p><p>现在灰色的对象被加入到扫描队列并被标记为黑色：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/07.png" alt></p><p>对加入到扫描队列的所有对象重复做相同的操作，直到没有对象需要被处理：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/08.png" alt></p><p>处理结束时，黑色对象表示内存中在使用的对象，白色对象是要被回收的对象。我们可以看到，由于 <code>struct2</code> 的实例是在一个匿名函数中创建的且不再存在于栈上，因此它是白色的且可以被回收。</p><p>归功于每一个 span 中的名为 <code>gcmarkBits</code> 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 scan。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/09.png" alt></p><p>我们可以看到，黑色和灰色表示的意义相同。处理的不同之处在于，标记为灰色时是把对象加入到扫描队列，而标记为黑色时，不再扫描。</p><p>GC 最终 STW，清除每一次写屏障对 work pool 做的改变，继续后续的标记。</p><p><em>你可以在我的文章 <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35" target="_blank" rel="noopener">Go GC 怎样监控你的应用</a> 中找到关于并发处理和 GC 的标记阶段更详细的描述</em>。</p><h2 id="runtime-分析器"><span id="runtime-分析器">runtime 分析器</span></h2><p>Go 提供的工具使我们可以对每一步进行可视化，观察 GC 在我们的程序中的影响。开启 tracing 运行我们的代码，可以看到前面所有步骤的一个概览。下面是追踪结果：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/10.png" alt="traces of the garbage collector"></p><p>标记 worker 的生命周期也可以在追踪结果中以协程等级可视化。下面是在启动之前先在后台等待标记内存的 goroutine #33 的例子。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/11.png" alt="marking worker"></p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/校对者ID" target="_blank" rel="noopener">校对者ID</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/" target="_blank" rel="noopener">Go 中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务中的熔断器和重试</title>
      <link href="/c9399f4/"/>
      <url>/c9399f4/</url>
      
        <content type="html"><![CDATA[<p>今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。</p><h2 id="熔断器"><span id="熔断器">熔断器</span></h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/01.png" alt="01"></p><p>想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。</p><p>后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/02.png" alt="02"></p><p>熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/03.png" alt="03"></p><p>通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 <a href="https://en.wikipedia.org/wiki/Happy_path" target="_blank" rel="noopener">wikipedia</a>）可能不会遇到这种网络模式。</p><h2 id="状态"><span id="状态">状态</span></h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/04.png" alt="04"></p><p>熔断器有三个主要的状态：</p><ul><li>Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 <strong>Max Concurrency</strong>（最大并发数）和 <strong>Timeout</strong>（超时）。</li><li>Open：所有的请求都会返回 <strong>Circuit Open</strong> 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。</li><li>Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。</li></ul><h2 id="熔断器原理"><span id="熔断器原理">熔断器原理</span></h2><p>控制熔断的设置共有 5 个主要参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommandConfig is used to tune circuit settings at runtime</span></span><br><span class="line"><span class="keyword">type</span> CommandConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Timeout                <span class="keyword">int</span> <span class="string">`json:"timeout"`</span></span><br><span class="line">MaxConcurrentRequests  <span class="keyword">int</span> <span class="string">`json:"max_concurrent_requests"`</span></span><br><span class="line">RequestVolumeThreshold <span class="keyword">int</span> <span class="string">`json:"request_volume_threshold"`</span></span><br><span class="line">SleepWindow            <span class="keyword">int</span> <span class="string">`json:"sleep_window"`</span></span><br><span class="line">ErrorPercentThreshold  <span class="keyword">int</span> <span class="string">`json:"error_percent_threshold"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go" target="_blank" rel="noopener">查看源码</a></p><p>可以通过根据两个服务的 SLA（‎ Service Level Agreement，<a href="https://zh.wikipedia.org/zh-hans/服务级别协议" target="_blank" rel="noopener">服务级别协议</a>）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。</p><p>一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。</p><h2 id="生产上的熔断器"><span id="生产上的熔断器">生产上的熔断器</span></h2><p>熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。</p><h2 id="demo"><span id="demo">Demo</span></h2><p>这段实例代码用的是 <a href="http://github.com/afex/hystrix-go/hystrix" target="_blank" rel="noopener">hystrix-go</a> 库，hystrix Netflix 库在 Golang 的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/afex/hystrix-go/hystrix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandName = <span class="string">"producer_api"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">hystrix.ConfigureCommand(commandName, hystrix.CommandConfig&#123;</span><br><span class="line">Timeout:                <span class="number">500</span>,</span><br><span class="line">MaxConcurrentRequests:  <span class="number">100</span>,</span><br><span class="line">ErrorPercentThreshold:  <span class="number">50</span>,</span><br><span class="line">RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">SleepWindow:            <span class="number">1000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, logger(handle))</span><br><span class="line">log.Println(<span class="string">"listening on :8080"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">errors := hystrix.Go(commandName, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// talk to other services</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="comment">// err := callWithRetryV1()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">output &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out := &lt;-output:</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">log.Printf(<span class="string">"success %v"</span>, out)</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errors:</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line">log.Printf(<span class="string">"failed %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger is Handler wrapper function for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(fn http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(r.URL.Path, r.Method)</span><br><span class="line">fn(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callChargeProducerAPI</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(os.Getenv(<span class="string">"SERVER_ERROR"</span>))</span><br><span class="line"><span class="keyword">if</span> os.Getenv(<span class="string">"SERVER_ERROR"</span>) == <span class="string">"1"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"503 error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 中分别测试了请求调用链 closed 和 open 两种情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Experiment 1: success path */</span><br><span class="line">// server</span><br><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">/* Experiment 2: circuit open */</span><br><span class="line">// server</span><br><span class="line">SERVER_ERROR=1 Go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 10); <span class="keyword">do</span> curl -x <span class="string">''</span> localhost:8080 ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试问题"><span id="重试问题">重试问题</span></h2><p>在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。</p><p>一段简单的重试代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callWithRetryV1</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">3</span>; index++ &#123;</span><br><span class="line"><span class="comment">// call producer API</span></span><br><span class="line">err := callChargeProducerAPI()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding backoff</span></span><br><span class="line"><span class="comment">// adding jitter</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go" target="_blank" rel="noopener">查看源码</a></p><h2 id="重试模式"><span id="重试模式">重试模式</span></h2><p>为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。</p><p>一起来看下列算法：</p><ul><li>Exponential: bash * 2<sup>attemp</sup></li><li>Full Jitter: sleep = rand(0, base * 2<sup>attempt</sup>)</li><li>Equal Jitter: temp = base * 2<sup>attemp</sup>; sleep = temp/2+rand(0, temp/2)</li><li>De-corredlated Jitter: sleep = rand(base, sleep*3)</li></ul><p>【译注】关于这几个算法，可以参考<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a> 。<strong>Full Jitter</strong>、 <strong>Equal Jitter</strong>、 <strong>De-corredlated</strong> 等都是原作者自己定义的名词。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/05.png" alt="05"></p><p>客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">这篇文章</a>中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。</p><h2 id="两者结合"><span id="两者结合">两者结合</span></h2><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/circuit-breaker-and-retry/06.png" alt="Example configuration of both tools"></p><p>熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。</p><h2 id="参考文章"><span id="参考文章">参考文章</span></h2><ol><li><a href="https://github.com/afex/hystrix-go/" target="_blank" rel="noopener">https://github.com/afex/hystrix-go/</a></li><li><a href="https://github.com/eapache/go-resiliency" target="_blank" rel="noopener">https://github.com/eapache/go-resiliency</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></li><li><a href="https://www.awsarchitectureblog.com/2015/03/backoff.html" target="_blank" rel="noopener">https://www.awsarchitectureblog.com/2015/03/backoff.html</a></li><li><a href="https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience" target="_blank" rel="noopener">https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience</a></li></ol><hr><p>via: <a href="https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/" target="_blank" rel="noopener">https://scene-si.org/2019/12/01/introduction-to-protobuf-messages/</a></p><p>作者：<a href="http://github.com/titpetric" target="_blank" rel="noopener">Tit Petric</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25295" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程，操作系统线程和 CPU 管理</title>
      <link href="/4e717bb5/"/>
      <url>/4e717bb5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French."></p><p>ℹ️ <em>本文运行环境为 Go 1.13</em></p><p>对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。</p><h2 id="m-p-g-编排"><span id="m-p-g-编排">M, P, G 编排</span></h2><p>为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The main concepts are:</span><br><span class="line">G - goroutine.</span><br><span class="line">M - worker thread, or machine.</span><br><span class="line">P - processor, a resource that is required to execute Go code.</span><br><span class="line">    M must have an associated P to execute Go code[...].</span><br></pre></td></tr></table></figure><p><code>P</code>, <code>M</code>, <code>G</code> 模型图解：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/01.png" alt="P, M, G diagram"></p><p>每个协程（<code>G</code>）运行在与一个逻辑 CPU（<code>P</code>）相关联的 OS 线程（<code>M</code>）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`hello`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`world`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Go 根据机器逻辑 CPU 的个数来创建不同的 <code>P</code>，并且把它们保存在一个空闲 <code>P</code> 的 list 里。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/02.png" alt="P initialization"></p><p>然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 <code>P</code>。这个 <code>P</code> 通过与之相关联的 OS 线程来创建一个 <code>M</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/03.png" alt="OS thread creation"></p><p>然而，像 <code>P</code> 那样，系统调用返回的甚至被 gc 强行停止的空闲的 <code>M</code> — 比如没有协程在等待运行 — 也会被加到一个空闲 list：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/04.png" alt="M and P idle list"></p><p>在程序启动阶段，Go 就已经创建了一些 OS 线程并与 <code>M</code> 想关联了。在我们的例子中，打印 <code>hello</code> 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 <code>M</code> 和 <code>P</code>：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/05.png" alt="M and P pulled from the idle list"></p><p>现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 <code>P</code> 多的 <code>M</code>，在系统调用时怎么管理协程。</p><h2 id="系统调用"><span id="系统调用">系统调用</span></h2><p>Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 <code>P</code> 和线程 <code>M</code> 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   fd, _ := os.Open(<span class="string">"number.txt"</span>)</span><br><span class="line">   fd.Read(buf)</span><br><span class="line">   fd.Close()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="keyword">string</span>(buf)) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读取的流程如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/06.png" alt="Syscall handoffs P"></p><p><code>P0</code> 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。</p><ul><li>尝试去捕获相同的 <code>P</code>，在我们的例子中就是 <code>P0</code>，然后 resume 执行过程</li><li>尝试从空闲 list 中捕获一个 <code>P</code>，然后 resume 执行过程</li><li>把协程放到全局队列里，把与之相关联的 <code>M</code> 放回空闲 list 去</li></ul><p>然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 <code>M</code> 不会阻塞：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/07.png" alt="Network poller waiting for the resource"></p><p>在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/08.png" alt></p><p>如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。</p><h2 id="os-线程方面的限制"><span id="os-线程方面的限制">OS 线程方面的限制</span></h2><p>在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：</p><blockquote><p><em>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</em></p></blockquote><p>译注：<strong>GOMAXPROCS</strong> 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 <strong>GOMAXPROCS</strong> 没有影响。这个包的 <strong><em>GOMAXPROCS</em></strong> 函数查询和修改这个最大数限制。</p><p>对这种情形举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++  &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         http.Get(<span class="string">`https://httpstat.us/200?sleep=10000`</span>)</span><br><span class="line"></span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用追踪工具得到的线程数如下：</p><p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/go-goroutines-os-thread-and-cpu-management/09.png" alt></p><p>由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。</p><hr><p>via: <a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a</a></p><p>作者：<a href="https://medium.com/@blanchon.vincent" target="_blank" rel="noopener">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf" target="_blank" rel="noopener">lxbwolf</a> 校对：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">polaris1119</a></p><p>本文由 <a href="https://github.com/studygolang/GCTT" target="_blank" rel="noopener">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25292" target="_blank" rel="noopener">Go语言中文网</a> 荣誉推出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol Names of Keyboard</title>
      <link href="/2d9f52fc/"/>
      <url>/2d9f52fc/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">符号英文名中文名</span><br><span class="line">~tilde or swung dash波浪字符或代字号</span><br><span class="line">!exclamation mark惊叹号</span><br><span class="line">@at sign or commercial at爱特或小老鼠</span><br><span class="line"><span class="comment">#number sign井号</span></span><br><span class="line">$dollar sign美元符</span><br><span class="line">%percent sign百分号</span><br><span class="line">^caret脱字符</span><br><span class="line">&amp;ampersand与和符</span><br><span class="line">*asterisk星号</span><br><span class="line">()parentheses, round brackets, soft brackets, </span><br><span class="line">or circle brackets 小括号，圆括号</span><br><span class="line">[]brackets (US), square brackets, </span><br><span class="line">closed brackets or hard brackets中括号，方括号</span><br><span class="line">&#123;&#125;braces (UK and US), French brackets, </span><br><span class="line">curly brackets大括号，花括号</span><br><span class="line">&lt;&gt; angle brackets or chevrons尖括号</span><br><span class="line">_underscore下划线</span><br><span class="line">+plus sign加号</span><br><span class="line">−minus sign减号</span><br><span class="line">=equals sign等号</span><br><span class="line">&lt; less-than sign小于号</span><br><span class="line">&gt; greater-than sign大于号</span><br><span class="line">.period, full stop or dot句号，点</span><br><span class="line">,comma逗号</span><br><span class="line">:colon 冒号</span><br><span class="line">;semicolon分号</span><br><span class="line">?question mark问号</span><br><span class="line">-hyphen连字符</span><br><span class="line">...ellipsis省略号</span><br><span class="line">–dash破折号</span><br><span class="line">/slash, forward slash斜线</span><br><span class="line">\backslash反斜线</span><br><span class="line">|vertical bar竖线</span><br><span class="line">“quotation mark双引号</span><br><span class="line">‘apostrophe单引号，省略符号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> symbol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go匿名函数和闭包</title>
      <link href="/e2c91def/"/>
      <url>/e2c91def/</url>
      
        <content type="html"><![CDATA[<h3 id="函数变量函数值"><span id="函数变量函数值">函数变量(函数值)</span></h3><p>在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func square(x int) &#123;</span><br><span class="line">println(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接调用：square(1)</li><li>把函数当成变量一样赋值：<code>s := square</code>；接着可以调用这个函数变量：s(1)。 注意：这里 square 后面没有圆括号，调用才有。</li></ol><ul><li>调用 <code>nil</code> 的函数变量会导致 panic。</li><li>函数变量的零值是 nil，这意味着它可以跟 nil 比较，但两个函数变量之间不能比较。</li></ul><h3 id="匿名函数"><span id="匿名函数">匿名函数</span></h3><p>作用: 在go语言中目前了解的作用就是用于构成闭包</p><h3 id="闭包"><span id="闭包">闭包</span></h3><p>闭包通过引用的方式使用外部函数的变量<br>函数与 与其(直接)相关的环境形成闭包</p><p>简单来说: 因为把返回的函数赋给了一个变量, 虽然函数在执行完一瞬间会销毁其执行环境, 但是如果有闭包的话, 闭包会保存外部函数的活动对象(变量), 所以如果不对闭包的引用消除掉, 闭包会一直存在内存中, 垃圾收集器不会销毁闭包占用的内存</p><h4 id="实例1"><span id="实例1">实例1</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//函数A是一个不带参数，返回值是一个匿名函数，且该函数</span><br><span class="line">//带有一个int类型参数，返回值为一个int类型</span><br><span class="line">func A() func(int) int &#123;</span><br><span class="line">sum := 0</span><br><span class="line">return func(bb int) int &#123;</span><br><span class="line">sum += bb</span><br><span class="line">fmt.Println(&quot;bb=&quot;, bb, &quot;\tsum=&quot;, sum)</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()//定义变量a,并将函数A的返回值赋给a // 这个时候, 虽然有小括号, 但是func A()还未真正执行, 只是赋值给了变量a</span><br><span class="line">b := a(4) //真正执行func A()</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：   </span><br><span class="line">**    bb= 4   sum= 4</span><br><span class="line">**    4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>调用2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()</span><br><span class="line">a(0)</span><br><span class="line">a(1)</span><br><span class="line">a(5)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 sum= 0</span><br><span class="line">**　　bb= 1 sum= 1</span><br><span class="line">**　　bb= 5 sum= 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>以上调用通过闭包实现了sum的累加</p><p>调用3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a := A()</span><br><span class="line">c := A()</span><br><span class="line">a(0)</span><br><span class="line">a(5)</span><br><span class="line">c(10)</span><br><span class="line">c(20)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 sum= 0</span><br><span class="line">**　　bb= 5 sum= 5</span><br><span class="line">**　　bb= 10 sum= 10</span><br><span class="line">**　　bb= 20 sum= 30   </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>　可以看出，上例中调用了两次函数A，构成了两个闭包，这两个闭包维护的变量sum不是同一个变量。　　</p><h4 id="实例2"><span id="实例2">实例2</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = func() &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := B() // 这个时候并未真正执行函数, 只是定义, 所以不会print</span><br><span class="line">c[0]() // 这个时候真正执行, 但是由于闭包, c[0] 中拿的i的引用</span><br><span class="line">c[1]()</span><br><span class="line">c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>闭包通过引用的方式使用外部函数的变量。</p><p>　　上例中只调用了一次函数B,构成一个闭包(<code>func() {fmt.Println(i)}</code> 与它的环境<code>func B() []func(){}</code> 构成闭包)，i 在外部函数B中定义，所以闭包维护该变量 i ，c[0]、c[1]、c[2]中的 i 都是闭包中 i 的引用。</p><p>　　因此执行<code>c:=B()</code>后，i 的值已经变为3，故再调用c<a href>0</a>时的输出是3而不是0。<br>　　<br>可作如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = (func(j int) func() &#123;</span><br><span class="line">return func() &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i) // 这个地方的小括号是真正执行了</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := B()</span><br><span class="line">c[0]()</span><br><span class="line">c[1]()</span><br><span class="line">c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：</span><br><span class="line">**        0</span><br><span class="line">**        1</span><br><span class="line">**        2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>函数<code>func() {fmt.Println(j)}</code> 与它的环境<code>func(j int) func() {}</code> 构成闭包, 变量<code>i</code>(实参) 并没有在它的环境范围内, 且 <code>j</code>是形参<br>以上修改可能没有什么实际意义，此处仅为说明问题使用。</p><p>在使用defer的时候可能出现类似问题，需要注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 2; j++ &#123;</span><br><span class="line">defer (func() &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;)()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：    </span><br><span class="line">**    2    </span><br><span class="line">**    2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="实例3"><span id="实例3">实例3:</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func incr() func() int &#123;</span><br><span class="line">var x int</span><br><span class="line">return func() int &#123;</span><br><span class="line">x++</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个函数会返回一个函数变量。<br><code>i := incr()</code> : 通过把这个函数变量赋值给<code>i</code>, <code>i</code> 就成为了一个闭包<br>所以<code>i</code> 保存着对<code>x</code> 的引用, 可以想象<code>i</code> 中有着一个指针指向<code>x</code> 或者 <code>i</code> 中有<code>x</code> 的地址</p><p>由于<code>i</code> 有着指向<code>x</code> 的指针, 所以可以修改<code>x</code> , 且保持着状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(i()) // 1</span><br><span class="line">println(i()) // 2</span><br><span class="line">println(i()) // 3</span><br></pre></td></tr></table></figure><p>也就是说, <code>x</code> 逃逸了, 它的声明周期没有随着它的作用域结束而结束<br>但是这段代码却不会递增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br></pre></td></tr></table></figure><p>这是因为这里调用了三次 <code>incr()</code>，返回了三个闭包，这三个闭包引用着三个不同的 <code>x</code>，它们的状态是各自独立的。</p><h4 id="实例4-闭包引用产生的问题"><span id="实例4-闭包引用产生的问题">实例4: 闭包引用产生的问题</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">f := func() &#123;</span><br><span class="line">println(x)</span><br><span class="line">&#125;</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br><span class="line">f() // 3</span><br></pre></td></tr></table></figure><p>因为闭包对外层词法域变量是引用的，所以这段代码会输出 3。<br>可以想象 f 中保存着 x 的地址，它使用 x 时会直接解引用，所以 x 的值改变了会导致 f 解引用得到的值也会改变。<br>但是，这段代码却会输出 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">println(x) // 1</span><br><span class="line">&#125;()</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br></pre></td></tr></table></figure><p>这是因为 f 调用时就已经解引用取值了，这之后的修改就与它无关了。</p><p>不过如果再次调用 f 还是会输出 3，这也再一次证明了 f 中保存着 x 的地址。<br>可以通过在闭包内外打印所引用变量的地址来证明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br><span class="line">&#125;()</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br></pre></td></tr></table></figure><p>可以看到引用的是同一个地址。</p><h4 id="实例51-循环闭包引用"><span id="实例51-循环闭包引用">实例5.1: 循环闭包引用</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">func() &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">f := func() &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次迭代后都对 i 进行了解引用并使用得到的值且不再使用，所以这段代码会正常输出。</p><h4 id="实例52"><span id="实例52">实例5.2</span></h4><p>正常代码：输出 0, 1, 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这段代码会输出 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">var f func()</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">f = func() &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() // 3 这个地方i最后的值是3, 而不是2, 因为只有i的值是3时, 才会跳出循环</span><br></pre></td></tr></table></figure><h4 id="实例53"><span id="实例53">实例5.3</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">funcSlice[j]() // 3, 3, 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上面这种情况, 可以声明新的匿名函数并传参:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">func(k int) &#123;</span><br><span class="line">funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">println(k)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">funcSlice[j]() // 0, 1, 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>println(k)</code> 使用的 <code>k</code> 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。(把<code>k</code>换成<code>i</code>也没有问题, 即使它与for条件的中的<code>i</code> 和func的入参<code>i</code> 重名也能正常运行)</p><p>所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p><p>这里的解决方法可以用在大多数跟闭包引用有关的问题上，不局限于第三个例子。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并区间56</title>
      <link href="/a2b71d73/"/>
      <url>/a2b71d73/</url>
      
        <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>思路: </p><ol start="0"><li>怎么判断重叠: 两区间的最小的右边界 大于或等于 两区间最大的左边界. 如<code>[1,5]</code>和<code>[2,8]</code></li><li>入参是切片的切片(intervals), 拿<code>intervals[0]</code>与它后面的所有区间对比, 从<code>intervals[1]</code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给<code>intervals[0]</code>, 并删除参与合并的那个旧区间</li><li><code>intervals[0]</code>完成后, 拿``intervals[1]<code>与它后边的所有区间对比, 从</code>intervals[2]<code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给</code>intervals[1]`, 并删除参与合并的那个就区间</li><li>拿<code>intervals[i]</code> 与它后边的所有区间对比, 从<code>intervals[i+1]</code> 开始, 如果有与之重叠的区间intervals[j]   , 就把合并后的新区间赋给 <code>intervals[i]</code> , 并删除参与合并的intervals[j]</li><li>如果第3步出现了有重叠的区间<code>intervals[j]</code>, 那么合并后<code>i</code>  的值变了, 就有可能由原来 在<code>i</code> 到<code>j</code> 之间没有重叠的区间 变成 有重叠的区间, 所以需要从头(<code>i+1</code>) 再遍历一次, 直到再也没有重叠的区间</li><li>重复, 一直到切片末尾</li></ol><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intervals); &#123;</span><br><span class="line">merged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(intervals); j++ &#123;</span><br><span class="line">x, y := intervals[i], intervals[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min(x[<span class="number">1</span>], y[<span class="number">1</span>]) &gt;= max(x[<span class="number">0</span>], y[<span class="number">0</span>]) &#123;</span><br><span class="line">merged = <span class="literal">true</span></span><br><span class="line"><span class="comment">//重新赋值</span></span><br><span class="line">intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] = min(x[<span class="number">0</span>], y[<span class="number">0</span>]), max(x[<span class="number">1</span>], y[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除j</span></span><br><span class="line">intervals[j] = intervals[<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">intervals = intervals[:<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merged &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的反射</title>
      <link href="/1d3c1f0e/"/>
      <url>/1d3c1f0e/</url>
      
        <content type="html"><![CDATA[<h4 id="编程语言中反射的概念"><span id="编程语言中反射的概念">编程语言中反射的概念</span></h4><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p><p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p><p>Golang的gRPC也是通过反射实现的。</p><h4 id="interface-和反射"><span id="interface-和反射">interface 和反射</span></h4><p>先来看看Golang关于类型设计的一些原则</p><ul><li>变量包括（value, type）两部分<ul><li>理解这一点就知道为什么nil != nil了</li></ul></li><li>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</li><li>类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</li></ul><p>反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><p><code>(value, type)</code></p><p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p><p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)</span><br><span class="line"></span><br><span class="line">var r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure><p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p><p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p><h4 id="reflect-基本功能typeof和valueof"><span id="reflect-基本功能typeof和valueof">reflect 基本功能TypeOf和ValueOf</span></h4><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="line">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="line">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></pre></td></tr></table></figure><p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type: &quot;, reflect.TypeOf(num))</span><br><span class="line">fmt.Println(&quot;value: &quot;, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">type:  float64</span><br><span class="line">value:  1.2345</span><br></pre></td></tr></table></figure><h4 id="说明"><span id="说明">说明</span></h4><ol><li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li><li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li><li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li></ol><h4 id="从relfectvalue中获取接口interface的信息"><span id="从relfectvalue中获取接口interface的信息">从relfect.Value中获取接口interface的信息</span></h4><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p><p><strong>已知原有类型【进行“强制转换”】</strong></p><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br><span class="line">// Golang 对类型要求非常严格，类型一定要完全符合</span><br><span class="line">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br><span class="line">convertPointer := pointer.Interface().(*float64)</span><br><span class="line">convertValue := value.Interface().(float64)</span><br><span class="line"></span><br><span class="line">fmt.Println(convertPointer)</span><br><span class="line">fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">0xc42000e238</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure><h5 id="说明"><span id="说明">说明</span></h5><ol><li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li><li>转换的时候，要区分是指针还是指</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li></ol><p><strong>未知原有类型【遍历探测其Filed】</strong></p><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFunc() &#123;</span><br><span class="line">fmt.Println(&quot;Allen.Wu ReflectCallFunc&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="line">func DoFiledAndMethod(input interface&#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">getType := reflect.TypeOf(input)</span><br><span class="line">fmt.Println(&quot;get Type is :&quot;, getType.Name())</span><br><span class="line"></span><br><span class="line">getValue := reflect.ValueOf(input)</span><br><span class="line">fmt.Println(&quot;get all Fields is:&quot;, getValue)</span><br><span class="line"></span><br><span class="line">// 获取方法字段</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="line">// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="line">// 3. 最后通过Field的Interface()得到对应的value</span><br><span class="line">for i := 0; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">field := getType.Field(i)</span><br><span class="line">value := getValue.Field(i).Interface()</span><br><span class="line">fmt.Printf(&quot;%s: %v = %v\n&quot;, field.Name, field.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br><span class="line">for i := 0; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">m := getType.Method(i)</span><br><span class="line">fmt.Printf(&quot;%s: %v\n&quot;, m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">get Type is : User</span><br><span class="line">get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="line">Id: int = 1</span><br><span class="line">Name: string = Allen.Wu</span><br><span class="line">Age: int = 25</span><br><span class="line">ReflectCallFunc: func(main.User)</span><br></pre></td></tr></table></figure><h5 id="说明"><span id="说明">说明</span></h5><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.Value设置实际变量的值</strong></p><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var num float64 = 1.2345</span><br><span class="line">fmt.Println(&quot;old value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br><span class="line">pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;type of pointer:&quot;, newValue.Type())</span><br><span class="line">fmt.Println(&quot;settability of pointer:&quot;, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">// 重新赋值</span><br><span class="line">newValue.SetFloat(77)</span><br><span class="line">fmt.Println(&quot;new value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">////////////////////</span><br><span class="line">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br><span class="line">pointer = reflect.ValueOf(num)</span><br><span class="line">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: 1.2345</span><br><span class="line">type of pointer: float64</span><br><span class="line">settability of pointer: true</span><br><span class="line">new value of pointer: 77</span><br></pre></td></tr></table></figure><h4 id="说明"><span id="说明">说明</span></h4><ol><li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li><li>如果传入的参数不是指针，而是变量，那么<ul><li>通过Elem获取原始值对应的对象则直接panic</li><li>通过CanSet方法查询是否可以设置返回false</li></ul></li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><p><strong>通过reflect.ValueOf来进行方法的调用</strong></p><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncHasArgs(name string, age int) &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncHasArgs name: &quot;, name, &quot;, age:&quot;, age, &quot;and origal User.Name:&quot;, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncNoArgs() &#123;</span><br><span class="line">fmt.Println(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何通过反射来进行方法的调用？</span><br><span class="line">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br><span class="line">getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 2. 先看看带有参数的调用方法</span><br><span class="line">methodValue := getValue.MethodByName(&quot;ReflectCallFuncHasArgs&quot;)</span><br><span class="line">args := []reflect.Value&#123;reflect.ValueOf(&quot;wudebao&quot;), reflect.ValueOf(30)&#125;</span><br><span class="line">methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">// 一定要指定参数为正确的方法名</span><br><span class="line">// 3. 再看看无参数的调用方法</span><br><span class="line">methodValue = getValue.MethodByName(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">args = make([]reflect.Value, 0)</span><br><span class="line">methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="line">ReflectCallFuncNoArgs</span><br></pre></td></tr></table></figure><h4 id="说明"><span id="说明">说明</span></h4><ol><li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li><li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li><li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li><li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li><li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li></ol><p><strong>golang的反射reflect性能</strong></p><p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = clazz.getField(&quot;hello&quot;);</span><br><span class="line">field.get(obj1);</span><br><span class="line">field.get(obj2);</span><br></pre></td></tr></table></figure><p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。</p><p>但是Golang的反射不是这样设计的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.TypeOf(obj)</span><br><span class="line">field, _ := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_ := reflect.ValueOf(obj)</span><br><span class="line">fieldValue := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p><p>Golang reflect慢主要有两个原因</p><ol><li>涉及到内存分配以及后续的GC；</li><li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li></ol><h4 id="总结"><span id="总结">总结</span></h4><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ul><li>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地<ul><li>反射必须结合interface才玩得转</li><li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li></ul></li><li>反射可以将“接口类型变量”转换为“反射类型对象”<ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul></li><li>反射可以将“反射类型对象”转换为“接口类型变量<ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历reflect.Type的Field获取其Field</li></ul></li><li>反射可以修改反射类型对象，但是其值必须是“addressable”<ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul></li><li>通过反射可以“动态”调用方法</li><li>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表142</title>
      <link href="/fb68a62c/"/>
      <url>/fb68a62c/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p>解题关键是理解 <code>非环部分的长度</code>与<code>相遇点到环起点那部分环的长度</code> 是相等的 这个数学关系</p><p>假设非环部分长度为<code>x</code>, 从环起点到相遇点的长度为<code>y</code> , 环的长度为<code>c</code></p><p>慢指针(slow)走过的长度可以表示为``ds = x + n1 * c + y<code>, 快指针(fast) 的速度是慢指针的两倍, 意味着 快指针走过的长度为</code>df = 2(x + n1 * c + y)`</p><p>还有一个约束是, fast 走过的路程一定比slow走的路程多出环长度的整数倍(记为<code>n2 * c</code>)</p><p>所以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df - ds = n2 * c</span><br><span class="line">2(x + n1 * c + y) - (x + n1 * c + y) = n2 * c</span><br><span class="line">x + n1 * c + y = n2 * c</span><br></pre></td></tr></table></figure><p>解读下第三步的等式: 非环部分的长度 + 环起点到相遇点之间的长度 就是环的整数倍</p><p>意味着, 当以环的起点为原点时, 已经走过y(即前面<code>从环起点到相遇点的长度</code>)的前提下, 如果再走x , 就刚好走了很多圈(<code>n2 * c</code>). *”很多圈” 的意思, 就是从原点再到原点, 终点的位置和起点的位置重合.* </p><p>怎么才能再走x呢? 让一个指针从<code>head</code> 开始走, 另一个指针从相遇点开始走, 等这两个指针相遇, 就是走了x. 如果不能理解为何相遇恰好就在上面说的<strong>原点</strong>处, 应该反复琢磨斜体”很多圈”那句话</p><p>code</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">fast, slow := head, head</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line"><span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用GitHub搜索</title>
      <link href="/a813d59a/"/>
      <url>/a813d59a/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 明确搜索仓库标题、仓库描述、README</strong></p><p><code>in:name 关键词</code></p><p>如果想查找描述的内容，可以使用这样的方式：</p><p><code>in:descripton 关键词</code></p><p>这里就是搜索上面项目描述的内容。</p><p>一般项目，都会有个README文件，如果要查该文件包含特定关键词的话</p><p><code>in:readme 关键词</code></p><p><strong>2. 明确搜索 star、fork 数大于多少的</strong></p><p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。</p><p><code>stars:&gt; 数字 关键字</code></p><p>比如要找 star 数大于 3000 的Spring Cloud 仓库，就可以这样</p><p><code>stars:&gt;3000 spring cloud</code></p><p>如果不加 &gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。</p><p>如果要找在指定数字区间的话，使用</p><p><code>stars: 10..20 关键词</code></p><p>fork 数同理，将上面的 stars 换成 <strong>fork</strong>，其它语法相同</p><p><strong>3. 明确搜索仓库大小的</strong></p><p>比如只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 <strong>size</strong> 。</p><p>使用方式：</p><p><code>size:&gt;=5000 关键词</code></p><p>这里注意下，这个数字代表K, 5000代表着5M。</p><p><strong>4. 明确仓库是否还在更新维护</strong></p><p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。</p><p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定<strong>更新时间</strong>在哪个时间前或后的</p><p>通过这样一条搜索 <code>pushed:&gt;2019-01-03 spring cloud</code></p><p>就找到了1月3号之后，还在更新的项目</p><p>想找指定时间之前或之后创建的仓库也是可以的，把 <strong>pushed</strong> 改成 <strong>created</strong> 就行。</p><p><strong>5. 明确搜索仓库的 LICENSE</strong></p><p>经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的<strong>LICENSE</strong>。开源不等于一切免费，不同的许可证要求也大不相同。 2018年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。</p><p>例如要找协议是最为宽松的 Apache License 2 的代码，可以这样</p><p><code>license:apache-2.0 spring cloud</code></p><p>其它协议就把 apache-2.0 替换一下即可，比如换成 <strong>mit</strong> 之类的。</p><p><strong>6. 明确搜索仓库的语言</strong></p><p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：</p><p><code>language:java 关键词</code></p><p><strong>7.明确搜索某个人或组织的仓库</strong></p><p><code>user:joshlong</code></p><p>组合使用一下，把 Java 项目过滤出来，多个查询之间「空格」分隔即可。</p><p><code>user:joshlong language:java</code></p><p>找某个组织的代码话，可以这样：</p><p><code>org:spring-cloud</code></p><p>就可以列出具体org 的仓库。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="/6a0b412d/"/>
      <url>/6a0b412d/</url>
      
        <content type="html"><![CDATA[<p>leetcode-26</p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>理解题意:</p><pre><code>1. 当给定数组为空时, 返回0 2. 不能引入其他数组空间, 即不能再使用一个新的数组来存放结果 3. 最终结果不重复, 整体思路是把数组后面的几个元素挪到前面去, 用后面的元素覆盖掉前面重复了的元素, 保持数组的长度始终不变. 数组中超出新长度(去重后的长度) 后的元素无视</code></pre><p>用快慢指针的思路解答:</p><ol><li>给定两个游标 left和right</li><li>当给定数组的下标为left和right的值相等时,  就不管</li><li>当不相等时, 做一个操作: 把当前right的值赋给left的下一个坐标</li></ol><p>code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">    //如果是空切片，那就返回0</span><br><span class="line">    if len(nums) == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    //用两个标记来比较相邻位置的值</span><br><span class="line">    //当一样的话，那就不管继续</span><br><span class="line">    //当不一样的时候，就把right指向的值赋值给left下一位</span><br><span class="line">    left, right := 0, 1</span><br><span class="line">    for ; right &lt; len(nums); right++ &#123;</span><br><span class="line">        if nums[left] == nums[right] &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums[:left+1])</span><br><span class="line">    return left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang编译器漏洞和标准库设计失误</title>
      <link href="/4fe063a2/"/>
      <url>/4fe063a2/</url>
      
        <content type="html"><![CDATA[<p>字节切片（byte slice）相关的编译器漏洞和标准库设计失误</p><p>假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  x = []byte(y) // error: 非法的转换</span><br><span class="line">  y = []MyByte(x) // error: 非法的转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，在Go中，这两个类型的值之间的类型转换是非法的。因为Go规定两个切片只有在它们的类型的底层类型（underlying type）相同的情况下才能转换到对方的类型。而一个非定义类型（undefined type）的底层类型为此非定义类型本身。类型[]MyByte和[]byte均为非定义类型，所以它们的底层类型不同，从而它们的值也就不能转换到对方的类型。</p><p>难道真没有办法实现它们之间的转换了？有，而且有好几种。第一种方法是使用类型非安全指针来实现双向转换，另外两种方法只能实现单向转换。另外的这两种方法要么利用了编译器的漏洞，要么利用了reflect标准库包的设计失误。</p><p><strong>使用类型非安全指针的实现。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  p := unsafe.Pointer(&amp;y)</span><br><span class="line">  x = *(*[]byte)(p)</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用类型非安全指针的实现中，转换结果和原切片共享底层元素。</p><p><strong>利用标准编译器的bug</strong></p><p>我们可以将一个[]byte切片值转换为string, 再把string转换为类型[]MyByte。转换结果和原切片不共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go白皮书提到一个字节切片可以转换为一个字符串，反之亦然。但是什么是字节切片类型呢？底层类型为[]byte的切片类型还是元素类型的底层类型为byte的切片类型？如果字节切片类型定义为<strong>元素类型的底层类型为byte的切片类型</strong>，则[]MyByte和[]byte都可称为字节切片类型。如果字节切片类型定义为<strong>底层类型为[]byte的切片类型</strong>，则只有[]byte可以被称为字节切片类型。我们认为标准编译器采纳了<strong>底层类型为[]byte的切片类型才称为字节切片</strong>这一定义，因为下面这个程序使用标准编译器是编译不过的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">  _ = string(y) // error: 非法转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，标准编译器（v1.12）却认为转换[]MyByte(“abc”)是合法的。这显然是一个漏洞。</p><p>对于码点切片（rune slice）和字符串之间的转换，同样的情况也存在。</p><p>对于gccgo编译器来说，此漏洞是对称的，因而更严重。此更严重的漏洞使得上述两种类型的值之间的转换是双向有效的。比如，下面这段代码使用gccgo（v8.0）编译是没问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  x = []byte(string(y))</span><br><span class="line">  x[0] = 127</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，gccgo编译器在内置copy和append函数的实现中也存在着同样的漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  copy(y, string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = append([]MyByte(nil), string(x)...)</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法利用了<code>reflect</code>标准库包的设计失误。此失误导致将<code>[]MyByte</code>值单向转换为类型<code>[]byte</code>是可行的，虽然这违反了Go类型系统确定的规则。使用第三种方法得到的结果切片和原切片共享底层元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  v := reflect.ValueOf(y)</span><br><span class="line">  x = v.Bytes()</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁高并发优化</title>
      <link href="/7db296fb/"/>
      <url>/7db296fb/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#问题场景">问题场景:</a></li><li><a href="#库存超卖现象是怎么产生的">库存超卖现象是怎么产生的？</a></li><li><a href="#用分布式锁如何解决库存超卖问题">用分布式锁如何解决库存超卖问题？</a></li><li><a href="#分布式锁的方案在高并发场景下">分布式锁的方案在高并发场景下</a></li><li><a href="#如何对分布式锁进行高并发优化">如何对分布式锁进行高并发优化？</a></li><li><a href="#分布式锁并发优化方案有没有什么不足">分布式锁并发优化方案有没有什么不足？</a></li></ul><!-- tocstop --><h4 id="问题场景"><span id="问题场景">问题场景:</span></h4><p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？</p><h4 id="库存超卖现象是怎么产生的"><span id="库存超卖现象是怎么产生的">库存超卖现象是怎么产生的？</span></h4><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004321.png" alt="库存超卖"></p><p>假设订单系统部署两台机器上，不同的用户都要同时买10台iphone，分别发了一个请求给订单系统。<br>接着每个订单系统实例都去数据库里查了一下，当前iphone库存是12台<br>于是乎，每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台</p><h4 id="用分布式锁如何解决库存超卖问题"><span id="用分布式锁如何解决库存超卖问题">用分布式锁如何解决库存超卖问题？</span></h4><p>分布式锁的实现原理:<br>同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004449.png" alt="分布式锁代码"></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004607.png" alt="fenbushisuo_yuanli"></p><p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</p><p>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的</p><h4 id="分布式锁的方案在高并发场景下"><span id="分布式锁的方案在高并发场景下">分布式锁的方案在高并发场景下</span></h4><p>分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。</p><p>比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。</p><p>假设加锁之后，释放锁之前，查库存 -&gt; 创建订单 -&gt; 扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。</p><p>那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。</p><p>比如一秒钟来50个请求，都是对iphone下单的，那么每个请求处理20毫秒，一个一个来，最后1000毫秒正好处理完50个请求。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004059.png" alt="分布式锁串行"></p><p>所以, 能看出来简单的使用分布式锁来处理库存超卖问题，存在的缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p><p>这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p><p>因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在一秒内瞬间下1000个订单，因为小电商系统没那场景。</p><h4 id="如何对分布式锁进行高并发优化"><span id="如何对分布式锁进行高并发优化">如何对分布式锁进行高并发优化？</span></h4><p>现在按照刚才的计算，你一秒钟只能处理针对iphone的50个订单。</p><p>其实说出来也很简单，相信很多人看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁！</p><p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。</p><p>另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p><p>LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p><p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p><p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004652.png" alt="分段加锁"></p><p>其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。</p><p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p><p>接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p><p>这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&gt; 判断库存是否充足 -&gt; 扣减库存。</p><p>这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。</p><p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？</p><p>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现</p><h4 id="分布式锁并发优化方案有没有什么不足"><span id="分布式锁并发优化方案有没有什么不足">分布式锁并发优化方案有没有什么不足？</span></h4>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 优化 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS释放被占用端口</title>
      <link href="/2d1cc7f9/"/>
      <url>/2d1cc7f9/</url>
      
        <content type="html"><![CDATA[<p><strong>场景:</strong><br>在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错</p><p>1.输入netstat -tln,查看系统当前所有被占用端口,主要是为了查看你的端口是否真正的被占用着,搭建可以看到我的9001,和9002端口都已经被占用了,所以我需要释放这两个端口</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003213.png" alt="listen-port"></p><p>2.根据端口查询进程,输入lsof -i :9001,切记不要忘了添加冒号,如下图,就可以看到当前被占用的端口的进程<br>的进程编号</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003347.png" alt></p><ol start="3"><li>kill 掉PID</li><li>再<code>netstat -tln</code> 确认下, 然后就可以起进程了</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云音乐破版权</title>
      <link href="/c6996379/"/>
      <url>/c6996379/</url>
      
        <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><p>源码地址: <a href="https://github.com/lxbwolf/UnblockNeteaseMusic" target="_blank" rel="noopener">https://github.com/lxbwolf/UnblockNeteaseMusic</a></p><p><strong>原理:</strong><br>使用其它音乐平台的歌曲替换网易云音乐无版权歌曲。<br>目前备用的平台有：网易云旧链 、QQ 、 虾米 、 百度 、酷狗 、酷我 、咕咪 、JOOX 音源替换变灰歌曲链接 (默认仅启用前四)。</p><p>1、打开网易云音乐客户端的时候，客户端不再直接访问网易云服务器而是访问UnblockNeteaseMusic服务。</p><p>2、UnblockNeteaseMusic收到客户端的请求后，透传给网易云音乐的服务器，并再拿到相关的数据后进行检查，如果发现其中的歌曲没有版权，那么去其它平台查询此歌曲的相关信息。</p><p>3、将查到的数据返回给网易云客户端。</p><p>4、至此完成网易云音乐的解锁。</p><p>整个流程要解决两个重要的问题。</p><p><strong>核心工作:</strong><br>1、将UnblockNeteaseMusic部署到服务器。可以是本地服务器也可以是云服务器。</p><p>2、为网易云客户端设置代理，以达到访问UnblockNeteaseMusic项目的目的。</p><p><strong>部署服务部分</strong></p><ol><li>安装node.js </li><li><code>git clone https://github.com/lxbwolf/UnblockNeteaseMusic.git</code></li><li>在<code>UnblockNeteaseMusic</code> 目录下, 执行<code>npx @nondanee/unblockneteasemusic(官方)</code> 或者 用docker 启动<code>docker run nondanee/unblockneteasemusic &amp;&amp; docker-compose up</code>, 还有另一种方式:<br>在<code>UnblockNeteaseMusic</code> 目录下, 执行<br><code>node app.js -p 8080:443 -f 59.111.160.195</code><br>其中<code>59.111.160.195</code> 这个地址是通过<br><code>ping music.163.com</code> 测出来的</li></ol><p>正常情况下, 服务端启动进程, 客户端配置好IP Port, 就可以用了, </p><p>此时服务端接收到请求会有log, 如果服务端log一直卡在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP Server running @ http://0.0.0.0:8080</span><br><span class="line">HTTPS Server running @ https://0.0.0.0:443</span><br></pre></td></tr></table></figure><p>说明客户端的请求并没有打到服务器上, 可能原因是8080和443端口还没有开启</p><p>配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ unblockneteasemusic -h</span><br><span class="line">usage: unblockneteasemusic [-v] [-p port] [-a address] [-u url] [-f host]</span><br><span class="line">                           [-o source [source ...]] [-t token] [-e url] [-s]</span><br><span class="line">                           [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -v, --version                   output the version number</span><br><span class="line">  -p port, --port port            specify server port</span><br><span class="line">  -a address, --address address   specify server host</span><br><span class="line">  -u url, --proxy-url url         request through upstream proxy</span><br><span class="line">  -f host, --force-host host      force the netease server ip</span><br><span class="line">  -o source [source ...], --match-order source [source ...]</span><br><span class="line">                                  set priority of sources</span><br><span class="line">  -t token, --token token         set up proxy authentication</span><br><span class="line">  -e url, --endpoint url          replace virtual endpoint with public host</span><br><span class="line">  -s, --strict                    enable proxy limitation</span><br><span class="line">  -h, --help                      output usage information</span><br></pre></td></tr></table></figure><p><strong>客户端配置</strong></p><p>源码中的<code>README</code> 有详细说明</p><table><thead><tr><th>平台</th><th>基础设置</th></tr></thead><tbody><tr><td>Windows</td><td>设置 &gt; 工具 &gt; 自定义代理 (客户端内)</td></tr><tr><td>UWP</td><td>Windows 设置 &gt; 网络和 Internet &gt; 代理</td></tr><tr><td>Linux</td><td>系统设置 &gt; 网络 &gt; 网络代理</td></tr><tr><td>macOS</td><td>系统偏好设置 &gt; 网络 &gt; 高级 &gt; 代理</td></tr><tr><td>Android</td><td>WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</td></tr><tr><td>iOS</td><td>无线局域网 &gt; HTTP 代理 &gt; 配置代理</td></tr></tbody></table><p><strong>Android 手机详细配置:</strong></p><p>设置 &gt; WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP: 106.13.86.198</span><br><span class="line">Port: 8080</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004732.png" alt="modify-network-android"></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004837.png" alt="ip-port-163-android"></p><p>破解前效果</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004909.png" alt="pojieqian-163"></p><p>破解后效果</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004946.png" alt="pojiehou-163"></p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005015.png" alt="tingge-163"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go闭包技术</title>
      <link href="/eb01d7dc/"/>
      <url>/eb01d7dc/</url>
      
        <content type="html"><![CDATA[<p>斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201002956.png" alt></p><p>斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和.<br>为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 0 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">// a b</span><br><span class="line">// a b</span><br><span class="line">a, b := 0, 1</span><br></pre></td></tr></table></figure><p>初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    fmt.Print(a, &quot; &quot;)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        fmt.Print(a, &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacciByNormal(t *testing.T) &#123;</span><br><span class="line">    fibonacciByNormal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacci(t *testing.T) &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Print(f(), &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为”闭包”!</p><p>闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func autoIncrease() func() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        i = i + 1</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func TestAutoIncrease(t *testing.T) &#123;</span><br><span class="line">    a := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(a(), a(), a())</span><br><span class="line">    b := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(b(), b(), b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果.</p><p>普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生.</p><p>但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会”长生不老”,并不会因为出身于函数内就和普通变量拥有一样的短暂人生.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func fightWithHorse() func() int &#123;</span><br><span class="line">    horseShowTime := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        horseShowTime++</span><br><span class="line">        fmt.Printf(&quot;(%d)祖国需要我,我就提枪上马立即战斗!\n&quot;,horseShowTime)</span><br><span class="line">        return horseShowTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFightWithHorse(t *testing.T) &#123;</span><br><span class="line">    f := fightWithHorse()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心!<br>下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosure(t *testing.T) &#123;</span><br><span class="line">    // 4 4 4</span><br><span class="line">    for _, c := range countByClosureButWrong() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c.</p><p>当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4.</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003531.png" alt></p><p>原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了!</p><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003721.png" alt></p><p>长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4.</p><p>既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛!</p><p>最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        n := i</span><br><span class="line">        fmt.Printf(&quot;for i=%d n=%d \n&quot;, i,n)</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            fmt.Printf(&quot;append i=%d n=%d\n&quot;, i, n)</span><br><span class="line">            return n</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003831.png" alt></p><p>上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级.</p><p>既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func countByClosureWithOk() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;for i=%d \n&quot;, i)</span><br><span class="line">        func(n int) &#123;</span><br><span class="line">            arr = append(arr, func() int &#123;</span><br><span class="line">                fmt.Printf(&quot;append n=%d \n&quot;, n)</span><br><span class="line">                return n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func TestCountByClosureWithOk(t *testing.T) &#123;</span><br><span class="line">    // 1 2 3</span><br><span class="line">    for _, c := range countByClosureWithOk() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模拟类和对象的关系,也可以实现封装,具备一定面向对象能力<ul><li>每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系.</li></ul></li><li>缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本.<ul><li>长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用.</li></ul></li><li>实现闭包成本较高,同时也增加了理解难度.<ul><li>普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性.</li></ul></li><li>滥用容易占用过多内存,可能造成内存泄漏.<ul><li>过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>github 博客绑定域名</title>
      <link href="/e9fbcad9/"/>
      <url>/e9fbcad9/</url>
      
        <content type="html"><![CDATA[<p>某篇文章说, CNAME 解析只支持 www 不支持@<br>所以@ 只能 解析到一个一个的 IP</p><h4 id="1-source-添加-cname-文件"><span id="1-source-添加-cname-文件">1. source 添加 CNAME 文件</span></h4><p>在源码的<code>source</code> 目录下, 添加一个<code>CNAME</code>文件<br>文件内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxb.wiki</span><br></pre></td></tr></table></figure><h4 id="2-dns-设置"><span id="2-dns-设置">2. DNS 设置</span></h4><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析路线(isp)</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>默认</td><td>lxbwolf.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.108.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.111.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.109.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改暂停删除备注</td></tr></tbody></table><h4 id="3-hexo-部署"><span id="3-hexo-部署">3. hexo 部署</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/a1751c09/"/>
      <url>/a1751c09/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><span id="quick-start">Quick Start</span></h2><h3 id="create-a-new-post"><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xargs</title>
      <link href="/38dfadad/"/>
      <url>/38dfadad/</url>
      
        <content type="html"><![CDATA[<p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p><p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p><p>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p><p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p><p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p><p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /sbin -perm 700 |ls -l       #这个命令是错误的</span><br><span class="line">find /sbin -perm 700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure><p><strong>命令格式</strong><br><code>somecommand |xargs -item command</code></p><p><strong>重要参数:</strong></p><ul><li>-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</li></ul><p><strong>其他参数:</strong></p><ul><li>-a file 从文件中读入作为sdtin</li><li>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li><li>-p 当每次执行一个argument的时候询问一次用户。</li><li>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</li><li>-t 表示先打印命令，然后再执行。</li><li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</li><li>-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li><li>-L num 从标准输入一次读取 num 行送给 command 命令。</li><li>-l 同 -L。</li><li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li><li>-x exit的意思，主要是配合-s使用。。</li><li>-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</li></ul><h4 id="实例"><span id="实例">实例:</span></h4><h5 id="1-多行变成单行"><span id="1-多行变成单行">1. 多行变成单行</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt</span><br><span class="line"></span><br><span class="line">a b c d e f g</span><br><span class="line">h i j k l m n</span><br><span class="line">o p q</span><br><span class="line">r s t</span><br><span class="line">u v w x y z</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt | xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure><h5 id="2-一次使用n个参数"><span id="2-一次使用n个参数">2. 一次使用n个参数</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cat test.txt | xargs -n3</span><br><span class="line"></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure><h5 id="3-d选项指定分隔符"><span id="3-d选项指定分隔符">3. d选项指定分隔符</span></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX</span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure><p>结合<code>-n</code> 选项使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span><br><span class="line"></span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure><h5 id="4-i选项的使用"><span id="4-i选项的使用">4. I选项的使用</span></h5><h6 id="41-获取参数并替换"><span id="41-获取参数并替换">4.1 获取参数并替换<code>{}</code></span></h6><p>假设一个命令为 <a href="http://sk.sh/" target="_blank" rel="noopener">sk.sh</a> 和一个保存参数的文件 arg.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#sk.sh命令内容，打印出所有参数。</span><br><span class="line"></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure><p>arg.txt.文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat arg.txt</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p><code>xargs</code> 的一个选项 <code>-I</code>，使用 <code>-I</code> 指定一个替换字符串 <code>{}</code>，这个字符串在 <code>xargs</code> 扩展时会被替换掉，当 <code>-I</code> 与 <code>xargs</code> 结合使用，每一个参数命令都会被执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat arg.txt | xargs -I &#123;&#125; ./sk.sh sombefore &#123;&#125; someafter</span><br><span class="line"></span><br><span class="line">sombefore aaa someafter</span><br><span class="line">sombefore bbb someafter</span><br><span class="line">sombefore ccc someafter</span><br></pre></td></tr></table></figure><h6 id="42-复制文件实例"><span id="42-复制文件实例">4.2 复制文件实例</span></h6><p>复制所有图片文件到 /data/images 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images/</span><br></pre></td></tr></table></figure><h6 id="43-xargs-结合find-使用"><span id="43-xargs-结合find-使用">4.3 xargs 结合find 使用</span></h6><p>用 rm 删除太多的文件时候，可能得到一个错误信息：<code>/bin/rm Argument list too long.</code> 用 xargs 去避免这个问题：</p><p><code>find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f</code> xargs -0 将 \0 作为定界符。</p><p>统计一个源代码目录中所有 php 文件的行数： <code>find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</code></p><p>查找所有的 jpg 文件，并且压缩它们： <code>find . -type f -name &quot;*.jpg&quot; -print | xargs tar -czvf images.tar.gz</code></p><h6 id="44-下载多个文件"><span id="44-下载多个文件">4.4 下载多个文件</span></h6><p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接： <code># cat url-list.txt | xargs wget -c</code></p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>升级https</title>
      <link href="/ddf7de45/"/>
      <url>/ddf7de45/</url>
      
        <content type="html"><![CDATA[<p><em>环境</em></p><pre><code>CentOSnginx</code></pre><h3 id="获取证书"><span id="获取证书">获取证书</span></h3><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。 我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p><h4 id="1-安装-certbot"><span id="1-安装-certbot">1. 安装 certbot</span></h4><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。</p><pre><code>yum install epel-releaseyum install certbot</code></pre><h4 id="2-生成证书"><span id="2-生成证书">2. 生成证书</span></h4><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。</p><pre><code>certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</code></pre><p>webroot-path就是项目根路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p><ul><li>cert.pem: 服务端证书</li><li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li><li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li><li>privkey.pem: 证书私钥</li></ul><h4 id="3-生成迪菲-赫尔曼密钥交换组-strong-diffie-hellman-group"><span id="3-生成迪菲-赫尔曼密钥交换组-strong-diffie-hellman-group">3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</span></h4><p>为了进一步提高安全性，也可以生成一个 Strong Diffie-Hellman Group。</p><pre><code>openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</code></pre><h3 id="配置nginx"><span id="配置nginx">配置nginx</span></h3><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。</p><pre><code>server {        listen 443 ssl;        # 启用http2        # 需要安装 Nginx Http2 Module        # listen 443 http2 ssl;        server_name my_server_name;        #证书文件        ssl_certificate /etc/letsencrypt/live/my_server_name/fullchain.pem;        #私钥文件        ssl_certificate_key /etc/letsencrypt/live/my_server_name/privkey.pem;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        # 优先采取服务器算法        ssl_prefer_server_ciphers on;        # 定义算法        ssl_ciphers &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&amp;quot;;        ssl_ecdh_curve secp384r1;        ssl_session_cache shared:SSL:10m;        ssl_session_tickets off;        ssl_stapling on;        ssl_stapling_verify on;        resolver 8.8.8.8 8.8.4.4 valid=300s;        resolver_timeout 5s;        add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;        add_header X-Frame-Options DENY;        add_header X-Content-Type-Options nosniff;        # 使用DH文件        ssl_dhparam /etc/ssl/certs/dhparam.pem;        location ~ /.well-known {            allow all;        }        location ~ \.php$ {            root           my_root;            fastcgi_pass   my_host:my_port;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            include        fastcgi_params;        }        root my_root;        index index.html index.php;        location / {            root my_root;            autoindex on;            index index.html index.php;            client_max_body_size 1024m;        }}</code></pre><p>其中的几项配置: <code>ssl_stapling on;</code> 开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。 <code>add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;</code> 启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接 <code>add_header X-Frame-Options DENY;</code> 添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少点击劫持 (clickjacking)攻击。 <code>add_header X-Content-Type-Options nosniff;</code> 添加 X-Content-Type-Options 响应头，防止 MIME 类型嗅探攻击 测试nginx.conf 是否有语法错误 <code>nginx -t</code> 重启nginx <code>nginx -s reload</code></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker挂载目录失败/权限拒绝</title>
      <link href="/498654c2/"/>
      <url>/498654c2/</url>
      
        <content type="html"><![CDATA[<p>把宿主机的一个目录挂载到容器中的一个目录，当访问容器中的这个目录时，出现如下问题：<br> <code>ls: cannot open directory .: Permission denied</code><br>无法访问目录，权限拒绝。<br>该问题通常在centos7下出现。或者一个容器启动成功后，里面的服务无法成功访问，这是因为centos7中的安全模块selinux把权限禁掉了，一般的解决方案有以下两种：<br>（1）临时关闭selinux<br>直接在centos服务器上执行以下命令即可。执行完成以后建议重新<code>docker run</code>。 <code>setenforce 0</code><br>（2）给容器加权限<br>在<code>docker run</code>时给该容器加权限，加上以下参数即可：<br> <code>--privileged=true</code><br> 一般都推荐使用这种方式。<br> 按上述方法修改后, 如果执行下面命令失败<br> <code>docker run --name rookie-nginx-test -d -p 8082:80 -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx -v ~/nginx/conf/conf.d:/etc/nginx/conf.d --link php7-fpm:php nginx</code><br>则是因为<code>~/nginx/www/</code> 目录下没有index 文件导致. 手动创建<code>index.php</code> 文件解决</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</title>
      <link href="/784beb8f/"/>
      <url>/784beb8f/</url>
      
        <content type="html"><![CDATA[<p>【报错原因】：没有utf-8这个语系（没添加语言_国名前缀），LC_ALL又没设定值。 <strong>服务端解决方法：</strong> 在远程系统上， <code>/etc/environment</code>加入以下两行，重新登陆即可。</p><pre><code>LANG=en_US.utf-8LC_ALL=en_US.utf-8</code></pre><p><strong>Mac终端解决方法：</strong> 编辑<code>~/.bashrc</code>或者<code>~/.zshrc</code>文件，添加</p><pre><code>export LC_ALL=en_US.UTF-8  export LANG=en_US.UTF-8</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级到php7.1之后wordpress 网站出现Error establishing a database connection的解决方法</title>
      <link href="/b6b408b2/"/>
      <url>/b6b408b2/</url>
      
        <content type="html"><![CDATA[<p>现在很多WordPress的插件都推荐将php版本升级到7.0或者7.1以上，于是就折腾了一下把几个blog升级到了7.1.5，升级的过程不难，无非就是额外安装一个php，然后启动自带的配套php-fpm7，然后nginx里location转发到新的php socket文件，这里就不表了。 升级完了，phpinfo()发现一切都正常，但是访问WordPress，却意外提示Error establishing a database connection，但是db的连接信息明明没有问题，经过反复搜索尝试，发现只要将 <code>/usr/share/nginx/html/wp-config.php</code> 文件里的 <code>define(&#39;DB_HOST&#39;, &#39;localhost&#39;);</code> 修改为 <code>define(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;);</code> 即可解决，猜测原因可能是php7.1中对域的resolve问题 另外, 为了 Debug, 可以把 <code>/usr/share/nginx/html/wp-config.php</code> 的 debug 改为 true <code>define(&#39;WP_DEBUG&#39;, true);</code> 改好了, 再改成 false.</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>date 命令转换时间戳</title>
      <link href="/7b4019ad/"/>
      <url>/7b4019ad/</url>
      
        <content type="html"><![CDATA[<p>给定时间戳, 转换成日期<br>网上所有的命令都是<br><code>date -d @$stamp &quot;+%Y-%m-%d&quot;</code><br> 但是一直提示<br> <code>date: invalid date</code>@stamp’<code>带上&quot;@&quot; 符号, 就参数错误 正确使用方法:</code>date -d “1970-01-01 UTC 1287331200 seconds” +%F<code>或者使用awk</code>awk ‘{print strftime(“%Y%m”, 1287331200)}’<code>调用外部命令耗时比较长, 更高效的方法:</code>printf “%(%Y%m)T\n” “$str” &gt;&gt; file<code>如果bash 版本低于4, printf 不支持打印日期格式, 因此使用 下面这个bash</code>/opt/compiler/gcc-4.8.2/bin/bash`</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大小端</title>
      <link href="/7ee0edaa/"/>
      <url>/7ee0edaa/</url>
      
        <content type="html"><![CDATA[<p>计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构而已），比如C/C++中，short类型一般是2个字节，int类型一般4个字节等。因此这里就存在着一个如何安排多个字节数据中各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。</p><h4 id="1-解释"><span id="1-解释">1. 解释</span></h4><p>假如有一个4字节的数据为 0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址 0x4000 8000中，则有：</p><p>内存地址</p><p>0x4000 8000（低地址）</p><p>0x4000 8001</p><p>0x4000 8002</p><p>0x4000 8003（高地址）</p><p>大端模式</p><p>0x12（高字节）</p><p>0x34</p><p>0x56</p><p>0x78（低字节）</p><p>小端模式</p><p>0x78（低字节）</p><p>0x56</p><p>0x34</p><p>0x12（高字节）</p><ul><li>大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</li><li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</li></ul><p>为什么截然相反的大小端存储模式能够并存至今？在标准化备受推崇的今天，为什么大小端谁都没有被另外一个所同化？我想这除了历史的惯性使然，还与它们各自的优缺点有关。 大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小 小端模式优点：1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）； 2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持（见1.3节），因此在多字节存储顺序上始终没有一个统一的标准</p><ul><li>Intel的80×86系列芯片使用小端存储模式</li><li>ARM芯片默认采用小端，但可以切换为大端</li><li>MIPS芯片采用大端，但可以在大小端之间切换</li><li>在网络上传输的数据普遍采用的都是大端</li></ul><h4 id="2-判断"><span id="2-判断">2. 判断</span></h4><p>方法一：通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测</p><pre><code>// @Ret: 大端，返回true; 小端，返回falsebool IsBigEndian_1(){    int nNum = 0x12345678;    char cLowAddressValue = *(char*)&amp;nNum;    // 低地址处是高字节，则为大端    if ( cLowAddressValue == 0x12 )    return true;    return false; }</code></pre><p>方法二：利用联合体union的存放顺序是所有成员都从低地址开始存放这一特性进行检测</p><pre><code>// @Ret: 大端，返回true; 小端，返回falsebool isBigEndian_2(){    union uendian    {       int nNum;       char cLowAddressValue;    };    uendian u;    u.nNum = 0x12345678;    if ( u.cLowAddressValue == 0x12 )     return true;    return false;}</code></pre><h4 id="3-转换"><span id="3-转换">3. 转换</span></h4><p>大小端转换</p><pre><code>// 实现16bit的数据之间的大小端转换#define BLSWITCH16(A)   (  ( ( (uint16)(A) &amp; 0xff00 ) &gt;&gt; 8  )    | \                             ( ( (uint16)(A) &amp; 0x00ff ) &lt;&lt; 8  )     )  // 实现32bit的数据之间的大小端转换#define BLSWITCH32(A)   (  ( ( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) |\         (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \         (((unit32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | \         (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 32)  )</code></pre><p>由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式发号器架构设计</title>
      <link href="/3d5a1f1d/"/>
      <url>/3d5a1f1d/</url>
      
        <content type="html"><![CDATA[<h3 id="一-需求设计"><span id="一-需求设计">一 需求设计</span></h3><ol><li><p>分布式环境下，保证每个序列号（sequence）是全系统唯一的；</p></li><li><p>序列号可排序，满足单调递增的规律；</p></li><li><p>特定场景下，能生成无规则（或者看不出规则）的序列号；</p></li><li><p>生成的序列号尽量短；</p></li><li><p>序列号可进行二次混淆，提供可扩展的interface，业务方自定义实现。</p></li></ol><h3 id="二-方案设计"><span id="二-方案设计">二 方案设计</span></h3><p>为了满足上述需求，发号器必须能够支持不同的生成策略，最好是还能支持自定义的生成策略，这就对系统本身的可扩展性提出了要求。 目前，发号器设计了两种比较通用的基础策略，各有优缺点，但结合起来，能达到优势互补的目的。</p><h4 id="1-segment"><span id="1-segment">1. segment</span></h4><p>第一种策略称之为『分段』（segment），下文将对其进行详细阐述： 整个segment发号器有两个重要的角色：Redis和MongoDB，理论上MongoDB是可以被MySQL或其他DB产品所替代的。 segment发号器所产生的号码满足单调递增的规律，短时间内产生的号码不会有过长的问题（可根据实际需要，设置初始值，比如 100）。</p><h5 id="redis数据结构hash类型"><span id="redis数据结构hash类型">Redis数据结构（Hash类型）</span></h5><pre><code>key: &lt;string&gt;，表示业务主键/名称value: {  cur: &lt;long&gt;，表示当前序列号  max: &lt;long&gt;，表示这个号段最大的可用序列号}</code></pre><p>取号的大部分操作都集中在Redis，为了保证序列号递增的原子性，取号的功能可以用Lua脚本实现。</p><pre><code>--[[  由于RedisTemplate设置的HashValueSerializer是GenericToStringSerializer，故此处的HASH结构中的  VALUE都是string类型，需要使用tonumber函数转换成数字类型。]]local max = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;max&quot;)  --获取一段序列号的maxlocal cur = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;cur&quot;)  --获取当前发号位置if tonumber(cur) &gt;= tonumber(max) then  --没有超过这段序列号的上限    local step = ARGV[1]    if (step == nil) then  --没有传入step参数        step = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;step&quot;)  --获取这段序列号的step配置参数值    end    redis.pcall(&quot;HSET&quot;, KEYS[1], &quot;max&quot;, tonumber(max) + tonumber(step))  --调整max参数值，扩展上限endreturn redis.pcall(&quot;HINCRBY&quot;, KEYS[1], &quot;cur&quot;, 1)  --触发HINCRBY操作，对cur自增，并返回自增后的值</code></pre><p>注意：在redis执行lua script期间，redis处于BUSY状态，这个时候对redis的任何形式的访问都会抛出JedisBusyException异常，所以lua script中的处理逻辑不得太复杂。 值得一提的是，即使切换到一个新的database，或者开启新线程执行lua script，都将会遇到同样的问题，毕竟redis是单进程单线程的。 如果不幸遇到上述问题，需要使用redis-cli客户端连上redis-server，向其发送SCRIPT KILL命令，即可终止脚本执行， 如果想避免上述问题，也可以直接使用Springboot提供的RedisTemplate，能支持绝大部分redis command。</p><h5 id="mongodb-数据结构"><span id="mongodb-数据结构">MongoDB 数据结构</span></h5><pre><code>{ bizTag: &lt;string&gt;,  表示业务主键/名称 max: &lt;long&gt;,  表示这个号段最大的可用序列号 step: &lt;int&gt;, 每次分段的步长 timestamp: &lt;long&gt;,  更新数据的时间戳（毫秒）}</code></pre><p>MongoDB部分主要是对号段的分配进行管理，一个号段不能多发，也可以根据发号情况，适当放缩号段步长（step）。 到此为止，segment发号器的雏形已经形成了。 一个比较突出的问题是在两个号段衔接的时间点，当一个segment派发完了后，会对MongoDB和Redis中的数据中的max扩容，I/O消耗比正常发号要稍多，会遇到“尖刺” 为了消除“尖刺”，可以使用双Buffer模型 <img src="http://lxb.wiki/wp-content/uploads/2019/06/9135a2df270662dedd513fa4258fc5ab.png" alt> 这个模型的核心思想就是“<strong>预分配</strong>”。可以设置一个阈值（threshold），比如20%，当Buffer-1里面的号段已经消耗了20%，那么立刻根据Buffer-1的max和step，开辟Buffer-2。 当Buffer-1完全消耗了，可以无缝衔接Buffer-2,。如果Buffer-2的消耗也达到阈值了，又可以开辟Buffer-1，如此往复。 接下来，我们来讨论一下<strong>异常/故障</strong>情况。 ① Redis宕机。因为大部分发号工作都是依靠Redis完成的，所以发生了这种情况是非常糟糕的。如果想有效降低此风险，最行之有效的办法是对Redis进行集群化，通常是1主2从，这样可以挺住非常高的QPS了。 当然也有退而求其次的办法，就是利用上述提到的双Buffer模型。不依赖Redis取号，直接通过程序控制，利用机器内存。所以当需要重启发号服务之前，要确保依赖的组件是运行良好的，不然号段就丢失了。 ② 要不要持久化的问题。这个问题主要是针对Redis，如果没有记录下当前的取号进度，那么随着Redis的宕机，取号现场就变得难以恢复了；如果每次都记录取号进度，那么这种I/O高密度型的作业会对服务性能 造成一定影响，并且随着取号的时间延长，恢复取号现场就变得越来越慢了，甚至到最后是无法忍受的。除了对Redis做高可用之外，引入MongoDB也是出于对Redis持久化功能辅助的考虑。 个人建议：如果Redis已经集群化了，而且还开启了双Buffer的策略，以及MongoDB的加持，可以不用再开启Redis的持久化了。 如果考虑到极端情况下，Redis还是宕机了，我们可以使用MongoDB里面存下来的max，就max+1赋值给cur（避免上个号段取完，正好宕机了）。 ③ MongoDB宕机。这个问题不是很严重，只要将step适当拉长一些（至少取号能支撑20分钟），利用Redis还在正常取号的时间来抢救MongoDB。不过，考虑到实际可能没这么快恢复mongo服务，可以在程序中采取 一些容错措施，比如号段用完了，mongo服务无法到达，直接关闭取号通道，直到MongoDB能正常使用；或者程序给一个默认的step，让MongoDB中的max延长到max+step*n（可能取了N个号段MongoDB才恢复过来）， 这样取号服务也可以继续。依靠程序本身继续服务，那么需要有相关的log，这样才有利于恢复MongoDB中的数据。 ④ 取号服务宕机。这个没什么好说的，只能尽快恢复服务运行了。 ⑤ Redis，MongoDB都宕机了。这种情况已经很极端了，只能利用双Buffer策略，以及程序默认的设置进行工作了，同样要有相关的log，以便恢复Redis和MongoDB。 ⑥ 都宕机了。我有一句mmp不知当讲不当讲……</p><h4 id="2-snowflake"><span id="2-snowflake">2、snowflake</span></h4><p>第二种策略是Twitter出品，算法思想比较巧妙，实现的难度也不大。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/91c86f2e2861b86d041ea16e874728a6.png" alt> 以上示意图描述了一个序列号的二进制组成结构。 第一位不用，恒为0，即表示正整数； 接下来的41位表示时间戳，精确到毫秒。为了节约空间，可以将此时间戳定义为距离某个时间点所经历的毫秒数（Java默认是1970-01-01 00:00:00）； 再后来的10位用来标识工作机器，如果出现了跨IDC的情况，可以将这10位一分为二，一部分用于标识IDC，一部分用于标识服务器； 最后12位是序列号，自增长。 snowflake的核心思想是64bit的合理分配，但不必要严格按照上图所示的分法。 如果在机器较少的情况下，可以适当缩短机器id的长度，留出来给序列号。 当然，snowflake的算法将会面临两个挑战： ① 机器id的指定。这个问题在分布式的环境下会比较突出，通常的解决方案是利用Redis或者Zookeeper进行机器注册，确保注册上去的机器id是唯一的。为了解决 强依赖Redis或者Zookeeper的问题，可以将机器id写入本地文件系统。 ② 机器id的生成规则。这个问题会有一些纠结，因为机器id的生成大致要满足三个条件：a. int类型(10bit)纯数字，b. 相对稳定，c. 与其他机器要有所区别。至于优雅美观，都是其次了。对于机器id的存储，可以使用HASH结构，KEY的规则是“application-name.port.ip”，其中ip是通过算法转换成了一段长整型的纯数字，VALUE则是机器id， 服务id，机房id，其中，可以通过服务id和机房id反推出机器id。 假设服务id(workerId)占8bit，机房id(rackId)占2bit，从1开始，workerId=00000001，rackId=01，machineId=00000000101 如果用Redis存储，其表现形式如下： <img src="http://lxb.wiki/wp-content/uploads/2019/06/f4da350756f1116434e6636a38888282.png" alt> 如果存储在文件中（建议properties文件），则文件名是sequence-client:8112:3232235742.properties，文件内容如下： <img src="http://lxb.wiki/wp-content/uploads/2019/06/3b1e3b6b90aaa663bb3a578bd98c1db1.png" alt> 如果发号服务上线，直接按照“application-name.port.ip”的规则取其内容。 ③ 时钟回拨。因为snowflake对系统时间是很依赖的，所以对于时钟的波动是很敏感的，尤其是时钟回拨，很有可能就会出现重复发号的情况。时钟回拨问题解决策略通常是直接拒绝发号，直到时钟正常，必要时进行告警。</p><h3 id="三-程序设计"><span id="三-程序设计">三 程序设计</span></h3><p>整个发号过程可以分成三个层次： 1、策略层(strategy layer)：这个层面决定的是发号方法/算法，涵盖了上述所讲的segment和snowflake两种方式，当然，用户也可以自己扩展实现其他发号策略。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/377252c9da3f792b50732cb650d42d8d.png" alt> 最顶上定义Sequence实际上就是发号的结果。bizType是对发号业务场景的定义，比如订单号，用户ID，邀请好友的分享码。 发号策略的init接口是发号前的初始化工作，而generate接口就是调用发号器的主入口了。 当然，考虑到各种异常情况，加入了拒绝发号的处理器（SequenceRejectedHandler），默认实现只是记录日志，用户可根据需求去实现该处理器，然后用set方法设置发号策略的拒绝处理器。 2、插件层(plugin layer)：此处的插件可以理解是一种拦截器，贯穿SequenceStrategy的发号全周期。引入插件后，无疑是丰富了整个发号的操作过程，用户可以从中干预到发号的整个流程，以便达到其他的目的，比如：记录发号历史，统计发号速率，发号二次混淆等。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/56fe2b69f67a1fc9cce3179163d76278.png" alt> 可以看出，插件被设计成『注册式』的，发号策略只有注册了相关插件之后，插件才能生效， 当然，一个插件能被多个发号策略所注册，一个发号策略也能同时注册多个插件，所以两者是多对多的关系，PluginManager的出现就是解决插件的注册管理问题。 从SequencePlugin的定义中可以发现，插件是有优先级（Order）的，通过getOrder()可以获得，在这套发号系统里，Order值越小，表示该插件越优先执行。此外，插件有三个重要的操作： before，表示发号之前的处理。若返回了false，那么该插件后面的操作都失效了，否则继续执行发号流程。 after，表示发号之后的处理。 doException，表示插件发生异常的处理方法。 3、持久层(persistence layer)：这个层面指代的是上述所提的MongoDB部分，如果不需要持久化的支持，可以不实现此接口，那么整个发号器就变成纯内存管理的了。 <img src="http://lxb.wiki/wp-content/uploads/2019/06/f65af0475f67e95a778a92d6ef681f62.png" alt> PersistRepository定义了基本的CRUD方法，其中persistId可以理解成上述提到的BizType。 一切的持久化对象都是从PersistModel开始的，上图中的Segment、PersistDocument都是为了实现分段发号器而定义的。</p><h3 id="四-总结"><span id="四-总结">四 总结</span></h3><p>这篇文章详细阐述了分布式发号器系统的设计，旨在能做出一个可扩展，易维护的发号系统。业界比较知名的发号算法似乎也不多，整个发号系统不一定就按照笔者所做的设计，还是要立足于具体的业务需求。</p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysqldump: Got error: 1044: Access denied for user</title>
      <link href="/a333bc04/"/>
      <url>/a333bc04/</url>
      
        <content type="html"><![CDATA[<p><code>mysqldump -u username -p dbname &gt; dbname.sql</code> mysqldump: Got error: 1044: Access denied for user XXX to database XXX when using LOCK TABLES 解决方法: <code>mysqldump -u dbuser -ppass db --skip-lock-tables &gt; db.sql</code></p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式数据库系统(DDBS)</title>
      <link href="/728c18a3/"/>
      <url>/728c18a3/</url>
      
        <content type="html"><![CDATA[<p>业务规模较小时，使用单机mysql作存储。但伴随业务发展，存储容量和并发能力会有瓶颈。</p><p>首先，假设单机的硬盘为1.8T，也可以挂更大容量硬盘，但仍有限。</p><p>其次，单机的读写并发能力有限，假设峰值写入qps1000，峰值读取qps3000，网卡对读取时流量也有要求，单次访问的读取量不应过大。</p><p>单机的链接数也有限。</p><p>那么，当使用单机mysql的业务发展，受到以上瓶颈时，一般的思路会是什么呢？一台机器不行，用两台呢，再不行，扩展更多台。</p><p>一台扩展为两台，磁盘容量扩大了，通过分表，将表打散在不同机器上，共同承担写入任务，并发也提高了，感觉这个思路是对的。</p><p>那么在这个过程中，我们需要做什么？</p><p>业务发展到单机无法承受，即使在单机上，很多表应该也做过分表了。一般会根据业务选择分表键。单个表的大小mysql也有一定要求，一般存储量不大于1G，单条记录小一些，一般不超过1k，条数一般不超过1000万条，最多不超过5000万条，否则表的使用和维护效率都很低。假设业务已经做了足够多的分表，满足三年的数据增长需要，第一年过后，每个分表的条数达到200万条，整机存储容量使用了一半，此时我们想拆分为两台机器。</p><p>此时我们可以将原机器上部分表数据同步到新机器上，并在model层抽象一个路由层，将对数据库的操作发到不同的机器上，上层业务仍可以认为在使用单机。此时可以将原机器上不归属自己管理范围的表删除，腾出空间。</p><p>一台变成了两台，向分布式走了一步。此时存储容量和并发都提高了，由路由层管理两台机器。如果两台或今后的多台机器，并发数高于路由层处理能力怎么办？那还要把路由层机器也扩一下，把路由规则都写进去，大家按一个格则办事。</p><p>经过上面的一番折腾，数据库机器水平扩展，解决了单机存在的一些问题。在这个扩展的过程中，是否会对业务产生中断影响呢？</p><p>会有一点影响。至少在路由层改路由表时，会中断数据库的写入，读取此时可以不中断。</p><p>ddbs中，使用到的多台机器，都叫做分片。分片提高了系统存储容量和并发能力，引入分片，也是系统的复杂度提高了，需要引入路由层机器，路由机器也可能需要扩展，复杂操作，还需要添加更多逻辑功能。但至少可以可业务逻辑区分开，业务可以把ddbs当做单机在使用。</p><p>那么ddbs有哪些不足呢？</p><p>ddbs还是要基于分表、分片实现的。那么对数据库的任何操作，首要条件是需要指明操作的分表键。没有这个维度的准确值，就不能对数据库操作，当然除非是备用库，那你随便扫表，因为备用库可以转为冗余安全，不走线上流量，可以做统计任务。</p><p>单指明分表键还不行，还要注意操作的数据可能会分布在不同分表、不同分片中，这样的操作会引发ddbs产生大量并发操作，业务的一个请求就会占用多个机器多个链接，使ddbs得并发能力大打折扣。比如 ‘where 分表键 in （）’操作，这种操作要慎重，in中个数不可太多。</p><p> 分表键最好选用整形，字符串型，可能hash后分配不均，表大小不均衡。</p><p>事物操作在ddbs中的实现，非常耗费系统性能。事务类操作需要路由控制层控制整个操作过程，期中可能涉及多个分片，多个不同的表的操作，对系统整体可用性要求高</p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跑道问题</title>
      <link href="/81be14b5/"/>
      <url>/81be14b5/</url>
      
        <content type="html"><![CDATA[<p>25个人，每5个人一个跑道，最少经过几次比赛，得到前三名</p><p><strong>初步思路</strong>: </p><ol><li><p>每5人一组, 全跑完后, 每组的后两名一定不在最终要的”前三名” 结果内, 所以每组可以排除2人, 剩下25-2*5=15人. 共经过5次比赛 </p></li><li><p>剩下的15人, 每5人一组, 跑完后, 每组淘汰2人, 剩下 15-2*3=9人. 经过3次比赛 </p></li><li><p>剩下的9个人分两组, A组5人B组4人, 跑完后, A组淘汰2人, B组淘汰1人, 剩下 9-2-1=6人. 经过2次比赛 </p></li><li><p>剩下的6人分两组, C组5人D组1人, A组跑完后, 淘汰2人, B组1人不需要跑, 剩下 6-2=4人. 经过1次比赛 </p></li><li><p>剩下的4个人, 跑一次, 得出前三名. 经过1次比赛 共经过 5+3+2+1+1=12次</p></li></ol><p><strong>思路2：</strong></p><ol><li><p>在第一步中, 5组全跑完后, 每组的第一名再跑一次, 按速度快慢分别标为A1 B1 C1 D1 E1. 则A1 为25人中的第一名. 经过5+1=6次比赛 </p></li><li><p>在第6次比赛中, 落后的两名D1 和E1, 可以被排除, 进而整个D组和E组都可以排除. C1不可能是第二名. 第二名可能的人员有A2 B1, 第三名可能的人员有 B1 A3 B2 A2 C1. 第二名的集合是第三名集合的子集. 第三名所有可能的5个人跑一次, 得出第二名和第三名.经过1次比赛 共经过7次比赛</p></li></ol><p><strong>另一种思路：</strong></p><p>5次跑完后，每组第一名再跑一次，这次跑的第1名，就是25中的第1名；跑完后，这个第1名出去，他原来所在的组的第2名补上，再与第6次中的其他4个人跑，这样决出最快的那个人，就是25中的第2名，同样过程，决出第3名。共 8 次</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>架构设计原则</title>
      <link href="/88049151/"/>
      <url>/88049151/</url>
      
        <content type="html"><![CDATA[<h4 id="grasp-通用职责分配软件模式"><span id="grasp-通用职责分配软件模式">GRASP 通用职责分配软件模式</span></h4><p>来自 Craig Larman 的软件设计书《UML 和模式应用》[附录 1]，Larman 在书中提出软件设计的关键任务是职责分配，并提炼总结出 9 种 (5 种核心 +4 种扩展) 软件职责分配模式，这些模式是比 GoF 设计模式更抽象的元模式。</p><p><strong>1. 信息专家 (Information Expert)</strong></p><p>为对象分配职责的通用原则 – 把职责分配给拥有足够信息可以履行职责的专家</p><p><strong>2. 创建者 (Creator)</strong></p><p>将创建 A 的职责赋给 B，如果至少下面一种情况为真：</p><ul><li>B“包含”或者聚合 A</li><li>B 记录 A 的实例</li><li>B 密切地使用 A</li><li>B 拥有 A 的初始化数据</li></ul><p><strong>3. 低耦合 (Low Coupling)</strong></p><p>赋予职责使得对象间的耦合度尽可能低，最小化对象间的依赖和变更影响，最大化重用。</p><p><strong>4. 高内聚 (High Cohesion)</strong></p><p>赋予职责使得每个对象的职责尽可能保持聚焦和单一，易于管理和理解。</p><p><strong>5. 控制器 (Controller)</strong></p><p>把职责赋予系统、设备或者子系统的表示类 (门面控制器)，或者某个用例的表示类 (用例控制器)，让控制器接收事件并协调整个系统的运作。</p><p><strong>6. 多态 (Polymorphism)</strong></p><p>将职责分配给多个具有同名方法的多态子类，运行时根据需要动态切换子类，让系统行为变得可插拔。</p><p><strong>7. 纯虚构 (Pure Fabrication)</strong></p><p>针对真实问题域中不存在，但是设计建模中有用的概念，设计虚构类并赋予职责。</p><p><strong>8. 间接 (Indirection)</strong></p><p>在两个或者多个对象间有交互的情况下，为避免直接耦合，提高重用性，创建中间类并赋予职责，对象的交互交由中间类协调。</p><p><strong>9. 受保护的变化 (Protected Variation)</strong></p><p>简单讲就是封装变化。识别系统中可能的不稳定或者变化，在不稳定组件上创建稳定的抽象接口，将可能的变化封装在接口之后，使得系统内部的不稳定或者变化不会对系统的其它部分产生不良影响。</p><h4 id="solid-面向对象设计原则"><span id="solid-面向对象设计原则">SOLID 面向对象设计原则</span></h4><p>S.O.L.I.D 是面向对象设计和编程 (OOD&amp;OOP) 中几个重要原则的首字母缩写，受 Robert Martin 推崇。</p><p><strong>1. 单一职责原则 (The Single Responsibility Principle)</strong></p><p>修改某个类的理由应该只有一个，如果超过一个，说明类承担不止一个职责，要视情况拆分。</p><p><strong>2. 开放封闭原则 (The Open Closed Principle)</strong></p><p>软件实体应该对扩展开放，对修改封闭。一般不要直接修改类库源码（即使你有源代码），通过继承等方式扩展。</p><p><strong>3. 里氏替代原则 (The Liskov Substitution Principle)</strong></p><p>当一个子类的实例能够被替换成任何超类的实例时，它们之间才是真正的 is-a 关系。</p><p><strong>4. 依赖倒置原则 (The Dependency Inversion Principle)</strong></p><p>高层模块不应该依赖于底层模块，二者都应该依赖于抽象。换句话说，依赖于抽象，不要依赖于具体实现。比方说，你不会把电器电源线焊死在室内电源接口处，而是用标准的插头插在标准的插座 (抽象) 上。</p><p><strong>5. 接口分离原则 (The Interface Segregation Principle)</strong></p><p>不要强迫用户去依赖它们不使用的接口。换句话说，使用多个专门的接口比使用单一的大而全接口要好。</p><p><strong>备注</strong></p><ol><li>高内聚 + 低耦合，就像道中的一阴一阳，是所有其它 OO 设计原则的原则 (元原则)，其它设计原则都是在这两个基础上泛化衍生出来的。</li><li>上述原则虽然是针对 OO 设计和编程提出，但是对于大规模系统架构仍然适用。比如，微服务架构就体现了：</li><li><ul><li>单一职责：一个微服务尽可能要职责单一，提供的接口也尽可能单一 (接口分离原则)，安全 / 路由 / 限流等跨横切面的关注点 (Cross-Cutting Concerns) 由独立网关负责，体现关注分离 (Separation of Concerns)。</li></ul></li></ol><ul><li>信息专家：当不确定哪个团队应该负责某个微服务时，一般原则也是谁拥有数据谁负责，基于有界上下文 Bounded Context（一般是边界比较清晰的领域数据源）构建微服务。</li><li>松散耦合：服务之间通过 HTTP/JSON 等轻量机制通信，服务之间不强耦合。</li><li>受保护的变化和依赖倒置：服务之间只依赖抽象接口，实现可能随时变化。</li><li>间接：网关在外面的客户端和内部的服务之间增加了一层间接，使两者不强耦合，可以相互独立演化。</li></ul><ol><li>作为架构师或者设计师，有两个设计能力是需要重点培养的，也是最难和最能体现架构设计水平的：</li><li><ul><li>合理的职责分配能力，也就是每个类 / 组件 / 子系统应该承担什么职责，如何保证职责单一，它们之间如何协作；</li></ul></li></ol><ul><li>系统抽象和核心领域建模能力，需要深入一线业务域。</li></ul><h3 id="分布式系统架构设计原则和理论"><span id="分布式系统架构设计原则和理论">分布式系统架构设计原则和理论</span></h3><h4 id="akf-架构原则"><span id="akf-架构原则">AKF 架构原则</span></h4><p>这 15 个架构原则来自《架构即未来 (The Art of Scalability)》[附录 2] 一书，作者马丁 L. 阿伯特和迈克尔 T. 费舍尔分别是 eBay 和 PayPal 的前 CTO，他们经历过 eBay 和 PayPal 大规模分布式电商平台的架构演进，在一线实战经验的基础上总结并提炼出 15 条架构原则：</p><p><strong>1.N + 1 设计</strong></p><p>永远不要少于两个，通常为三个。比方说无状态的 Web/API 一般部署至少&gt;=2 个。</p><p><strong>2. 回滚设计</strong></p><p>确保系统可以回滚到以前发布过的任何版本。可以通过发布系统保留历史版本，或者代码中引入动态开关切换机制 (Feature Switch)。</p><p><strong>3. 禁用设计</strong></p><p>能够关闭任何发布的功能。新功能隐藏在动态开关机制 (Feature Switch) 后面，可以按需一键打开，如发现问题随时关闭禁用。</p><p><strong>4. 监控设计</strong></p><p>在设计阶段就必须考虑监控，而不是在实施完毕之后补充。例如在需求阶段就要考虑关键指标监控项，这就是度量驱动开发 (Metrics Driven Development) 的理念。</p><p><strong>5. 设计多活数据中心</strong></p><p>不要被一个数据中心的解决方案把自己限制住。当然也要考虑成本和公司规模发展阶段。</p><p><strong>6. 使用成熟的技术</strong></p><p>只用确实好用的技术。商业组织毕竟不是研究机构，技术要落地实用，成熟的技术一般坑都被踩平了，新技术在完全成熟前一般需要踩坑躺坑。</p><p><strong>7. 异步设计</strong></p><p>能异步尽量用异步，只有当绝对必要或者无法异步时，才使用同步调用。</p><p><strong>8. 无状态系统</strong></p><p>尽可能无状态，只有当业务确实需要，才使用状态。无状态系统易于扩展，有状态系统不易扩展且状态复杂时更易出错。</p><p><strong>9. 水平扩展而非垂直升级</strong></p><p>永远不要依赖更大、更快的系统。一般公司成长到一定阶段普遍经历过买更大、更快系统的阶段，即使淘宝当年也买小型机扛流量，后来扛不住才体会这样做不 scalable，所以才有后来的去 IOE 行动。</p><p><strong>10. 设计时至少要有两步前瞻性</strong></p><p>在扩展性问题发生前考虑好下一步的行动计划。架构师的价值就体现在这里，架构设计对于流量的增长要有提前量。</p><p><strong>11. 非核心则购买</strong></p><p>如果不是你最擅长，也提供不了差异化的竞争优势则直接购买。避免 Not Invented Here 症状，避免凡事都要重造轮子，毕竟达成业务目标才是重点。</p><p><strong>12. 使用商品化硬件</strong></p><p>在大多数情况下，便宜的就是最好的。这点和第 9 点是一致的，通过商品化硬件水平扩展，而不是买更大、更快的系统。</p><p><strong>13. 小构建、小发布和快试错</strong></p><p>全部研发要小构建，不断迭代，让系统不断成长。这个和微服务理念一致。</p><p><strong>14. 隔离故障</strong></p><p>实现故障隔离设计，通过断路保护避免故障传播和交叉影响。通过舱壁泳道等机制隔离失败单元 (Failure Unit)，一个单元的失败不至影响其它单元的正常工作。</p><p><strong>15. 自动化</strong></p><p>设计和构建自动化的过程。如果机器可以做，就不要依赖于人。自动化是 DevOps 的基础。</p><p><strong>备注</strong></p><ol><li>这 15 条架构原则基本上是 eBay 在发展，经历过流量数量级增长冲击过程中，通过不断踩坑踩出来的，是干货中的干货。消化吸收这 15 条原则，基本可保系统架构不会有原则性问题。</li><li>这 15 条原则同样适用于现在的微服务架构。eBay 发展较早，它内部其实很早 (差不多 2010 年前) 就已形成完善的微服务生态，只是没有提出微服务这个概念。</li><li>这 15 条原则可根据 TTM(Time To Market)，可用性 / 可扩展性 / 质量，成本 / 效率分布在三个环内，如下图所示。</li></ol><h4 id="12-要素应用"><span id="12-要素应用">12 要素应用</span></h4><p>基于上百万应用的托管和运营经验，创始人 Adam Wiggins 提出了 12 要素应用宣言 。简单讲，满足这 12 个要素的应用是比较容易云化并居住在 Heroku 平台上的。</p><p><strong>1. 基准代码</strong></p><p>一份基准代码，多份部署。如果用镜像部署方式，则一个镜像可以部署到多个环境 (测试，预发，生产)，而不是给每个环境制作一个不同镜像。</p><p><strong>2. 依赖</strong></p><p>显式声明依赖。如果用镜像部署，则一般依赖被直接打在镜像中，或者声明在 docker file 中。</p><p><strong>3. 配置</strong></p><p>在环境中存储配置。在 Heroku 或者类似的 PaaS 平台上，配置一般是推荐注入到环境变量中的。现在采用集中式配置中心也是一种流行方式。</p><p><strong>4. 后端服务</strong></p><p>把后端服务 (例如缓存，数据库，MQ 等) 当作附加资源，相关配置和连接字符串通过环境变量注入，或者采用配置中心。</p><p><strong>5. 构建、发布和运行</strong></p><p>严格分离构建和运行。如果使用镜像部署，则构建、发布 / 运行是通过镜像这种中间格式严格分离的。</p><p><strong>6. 进程</strong></p><p>一个或者多个无状态的进程运行应用。容器运行时相当于进程，适用于无状态 Web/API。</p><p><strong>7. 端口绑定</strong></p><p>通过端口绑定提供服务。容器也是通过端口绑定对外提供服务。</p><p><strong>8. 并发</strong></p><p>通过进程模型进行扩展。容器运行时相当于进程，通过起多个容器可以任意扩展并发数量。</p><p><strong>9. 易处理</strong></p><p>快速启动和优雅终止可最大化健壮性。docker 容器支持秒级启动和关闭。</p><p><strong>10. 开发环境和线上环境等价</strong></p><p>尽可能保持开发、测试、预发和线上环境相同。容器可以保证容器内运行时环境的一致性，还需要保证不同环境的一致性，例如不同环境内的操作系统，负载均衡，服务发现，后台服务，监控告警等要尽可能一致。</p><p><strong>11. 日志</strong></p><p>把日志当作数据流。Heroku 不支持本地文件，所以必须以流方式把日志输送到后台日志服务。除了日志以外还要补充考虑 metrics 流的采集和输送。</p><p><strong>12. 管理进程</strong></p><p>后台管理任务当作一次性的进程。其实相当于在 Heroku 上以独立进程方式运行任务 Job。</p><p><strong>备注</strong></p><ol><li>12 要素应用也是当前云原生应用 (Cloud Native App) 的参考标准，也称为云应用迁移原则。满足这 12 个要素的应用，可以比较顺利迁移到各种云平台 (Kubernetes, Marathon, Cloud Foundry 等) 上。</li><li>对于面临企业遗留应用改造和云化迁移的架构师，可以重点参考这 12 条迁移原则。</li><li>Docker 容器技术可以认为是为云迁移量身定制的技术。容器化是后续云迁移的捷径，所以遗留应用改造可以先想办法做到容器化。</li></ol><h4 id="cap-定理"><span id="cap-定理">CAP 定理</span></h4><p>2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。</p><p>CAP 认为：一个分布式系统最多同时满足一致性 (Consistency)，可用性 (Availability) 和分区容忍性 (Partition Tolerance) 这三项中的两项。</p><p><strong>1.一致性 (Consistency)</strong></p><p>一致性指“all nodes see the same data at the same time”，即更新操作成功，所有节点在同一时间的数据完全一致。</p><p><strong>2.可用性 (Availability)</strong></p><p>可用性指“Reads and writes always succeed”，即服务一直可用，而且响应时间正常。</p><p><strong>3.分区容忍性 (Partition tolerance)</strong></p><p>分区容忍性指“the system continue to operate despite arbitrary message loss or failure of part of the system.”，即分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。</p><h4 id="base-理论"><span id="base-理论">BASE 理论</span></h4><p>eBay 架构师 Dan Pritchett 基于对大规模分布式系统的实践总结，在 ACM 上发表文章提出了 BASE 理论，BASE 理论是对于 CAP 理论的延伸，核心思想是即使无法做到强一致性 (Strong Consistency，CAP 中的一致性指强一致性)，但是可以采用适当的方式达到最终一致性 (Eventual Consistency)。</p><p>BASE 指基本可用 (Basically Available)、软状态 (Soft State) 和最终一致性 (Eventual Consistency)。</p><p><strong>1.基本可用 (Basically Available)</strong></p><p>基本可用是指分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。比如服务降级。</p><p><strong>2.软状态 (Soft State)</strong></p><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。分布式存储中一般一份数据至少存三个副本，允许不同节点间副本同步的延迟就是软状态的体现。</p><p><strong>3.最终一致性 (Eventual Consistency)</strong></p><p>最终一致性是指系统中的所有数据副本经过一段时间后，最终能够达成一致状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p><p><strong>备注</strong></p><ol><li>CAP 和 BASE 理论可以抠得很深，背后甚至有很复杂的数学证明。我理解得相对简单浅显：性能、高可用、不丢数据和数据一致性对分布式系统来说一般是强需求，随着流量的增长，复制和分区在所难免：</li><li><ul><li>复制 (replication)：数据在多个节点上存多份保证不丢和高可用；</li></ul></li></ol><ul><li>分区 (partition)：数据按某个纬度切分分布在不同节点上分摊流量压力保证高性能，同时也是为了降低每个节点的复杂性。例如数据库的分库分表，系统拆分微服务化也是一种分区。这两者都会带来一致性问题，一致性在时间上有一点妥协的余地 - 即是最终一致性；时间上要求强一致的话，只有可用性可以适当折中。系统架构的游戏很大部分是和状态一致性作斗争的游戏。</li></ul><ol><li>选择使用分布式产品时，比如 NoSQL 数据库，你需要了解它在 CAP 环中所在的位置，确保它满足你的场景需要。</li></ol><h3 id="组织和系统改进原则"><span id="组织和系统改进原则">组织和系统改进原则</span></h3><h4 id="康威法则"><span id="康威法则">康威法则</span></h4><p>Melvin Conway 在 1967 年提出所谓康威法则 ，指出组织架构和系统架构之间有一种隐含的映射关系：</p><p>Organization which design system […] are constrained to produce designs which are copies of the communication structures of these organization. 设计系统的组织其产生的设计等价于组织间的沟通结构。</p><p>康威法则也可以倒过来阐述：</p><p>Conway’s law reversed：You won’t be able to successfully establish an efficient organization structure that is not supported by your system design(architecture)。 如果系统架构不支持，你无法建立一个高效的组织；同样，如果你的组织架构不支持，你也无法建立一个高效的系统架构。</p><h4 id="系统改进三原则"><span id="系统改进三原则">系统改进三原则</span></h4><p>IT 运维管理畅销书《凤凰项目》[附录 8] 的作者 Gene Kim 在调研了众多高效能 IT 组织后总结出支撑 DevOps 运作的三个原理 (The Three Ways: The Principles Underpinning DevOps)[附录 9]，我认为也是系统改进提升的一般性原理 [附录 7]，见下图：</p><p><strong>原理一：系统思考 (System Thinking)</strong></p><p>开发驱动的组织，其能力不是制作软件，而是持续的交付客户价值。价值从业务需求开始，经过研发测试，到部署运维，依次流动，并最终以服务形式交付到客户手中。整个价值链流速并不依赖单个部分 (团队或个人) 的杰出工作，而是受整个价值链最薄弱环节 (瓶颈) 的限制。所以局部优化通常无效，反而招致全局受损。</p><p>Gene Kim 特别指出：Any improvements made anywhere besides the bottleneck are an illusion. 在瓶颈之外的任何优化提升都只是幻象。</p><p><strong>原理二：强化反馈环 (Amplify Feedback Loops)</strong></p><p>过程改进常常通过加强反馈环来达成。原理二强调企业和客户之间、组织团队间、流程上和系统内的反馈环。没有测量就没有提升，反馈要以测量数据为准，通过反馈数据优化改进系统。</p><p><strong>原理三：持续试验和学习的文化 (Culture of Continual Experimentation And Learning)</strong></p><p>在企业管理文化层面强调勇于试错和持续试验、学习和改进的文化。</p><p><strong>备注</strong></p><ol><li>康威法则给我们的启示：系统架构和组织架构之间有隐含的映射关系，你不能单方面改变一方的结构，调整时必须两边联动。系统架构如果是耦合的，就很难组织分散式的团队结构，两边映射不起来，团队之间容易摩擦导致生产率下降。所以一般先按业务边界对单块应用进行解耦拆分，同时做相应的团队拆分，使两边可以映射，每个团队可以独立开发、测试和部署各自的微服务，进而提升生产率。这就是近年流行的微服务架构背后的组织原则。详见我之前发表的文章《企业的组织架构是如何影响技术架构的》[附录 6]。</li><li>系统思考要求我们加强团队合作，培养流式思维和瓶颈约束思维，找出瓶颈并针对性地优化。在研发型组织中，常见的系统瓶颈如运维机器资源提供 (Provisioning) 缓慢，发布流程繁琐容易出错，开发 / 测试／UAT 环境缺失或不完善，遗留系统耦合历史负担重，基础研发平台薄弱等等。这些瓶颈点特别需要关注优化。</li><li>反馈原理要求我们关注基于数据的反馈，技术上的手段包括大数据分析和系统各个层次的测量监控。没有测量就没有反馈，没有反馈就没有提升。</li><li>在管理文化层面：</li><li><ul><li>管理层要承认企业内部近 50% 的创新或流程改进项目是有可能失败的，即使失败，员工不会受到责罚，鼓励持续的试验和从中学习；</li></ul></li></ol><ul><li>管理层要有技术偿债意识，勿追求 100% 员工利用率，要预留 20%~30% 的时间给员工做创新和系统改进提升项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秒杀系统优化思路</title>
      <link href="/bcca3074/"/>
      <url>/bcca3074/</url>
      
        <content type="html"><![CDATA[<h3 id="一-秒杀业务为什么难做"><span id="一-秒杀业务为什么难做">一、秒杀业务为什么难做</span></h3><p>1）im系统，例如qq或者微博，每个人都读自己的数据（好友列表、群列表、个人信息）； 2）微博系统，每个人读你关注的人的数据，一个人读多个人的数据； 3）秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据。</p><p>例如：小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。 又例如：12306抢票，票是有限的，库存一份，瞬时流量非常多，都读相同的库存。读写冲突，锁非常严重，这是秒杀业务难的地方。那我们怎么优化秒杀业务的架构呢？</p><h3 id="二-优化方向"><span id="二-优化方向">二、优化方向</span></h3><p>优化方向有两个（今天就讲这两个点）： （1）将请求尽量拦截在系统上游（不要让锁冲突落到数据库上去）。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小。以12306为例，一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0。</p><p>（2）充分利用缓存，秒杀买票，这是一个典型的读多写少的应用场景，大部分请求是车次查询，票查询，下单和支付才是写请求。一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。好，后续讲讲怎么个“将请求尽量拦截在系统上游”法，以及怎么个“缓存”法，讲讲细节。</p><h3 id="三-常见秒杀架构"><span id="三-常见秒杀架构">三、常见秒杀架构</span></h3><p>（1）浏览器端，最上层，会执行到一些JS代码 （2）站点层，这一层会访问后端数据，拼html页面返回给浏览器 （3）服务层，向上游屏蔽底层数据细节，提供数据访问 （4）数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）</p><h3 id="四-各层次优化细节"><span id="四-各层次优化细节">四、各层次优化细节</span></h3><h4 id="第一层客户端怎么优化浏览器层app层"><span id="第一层客户端怎么优化浏览器层app层">第一层，客户端怎么优化（浏览器层，APP层）</span></h4><p>微信的摇一摇抢红包，每次摇一摇，就会往后端发送请求么？下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？</p><p>（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求； （b）JS层面，限制用户在x秒之内只能提交一次请求；</p><p>APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？</p><h4 id="第二层站点层面的请求拦截"><span id="第二层站点层面的请求拦截">第二层，站点层面的请求拦截</span></h4><p>怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</p><p>5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。</p><p>页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。</p><p>好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p><h4 id="第三层-服务层来拦截反正就是不要让请求落到数据库上去"><span id="第三层-服务层来拦截反正就是不要让请求落到数据库上去">第三层 服务层来拦截（反正就是不要让请求落到数据库上去）</span></h4><p>服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！</p><p>对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）</p><p>1w部手机，只透1w个下单请求去db</p><p>3k张火车票，只透3k个下单请求去db</p><p>如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。</p><p>对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。</p><p>当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，…每隔半个小时放出一批：将流量摊匀。</p><p>其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。</p><p>第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。</p><h4 id="第四层-最后是数据库层"><span id="第四层-最后是数据库层">第四层 最后是数据库层</span></h4><p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。</p><p>全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。</p><h3 id="五-总结"><span id="五-总结">五、总结</span></h3><p>上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路： （1）尽量将请求拦截在系统上游（越上游越好）； （2）读多写少的常用多使用缓存（缓存抗读压力）；</p><p>浏览器和APP：做限速</p><p>站点层：按照uid做限速，做页面缓存</p><p>服务层：按照业务做写请求队列控制流量，做数据缓存</p><p>数据层：闲庭信步</p><p>并且：结合业务做优化</p>]]></content>
      
      
      <categories>
          
          <category> Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作种子</title>
      <link href="/7592d71b/"/>
      <url>/7592d71b/</url>
      
        <content type="html"><![CDATA[<p>1.下载mktorrent<br><code>git clone https://github.com/lxbwolf/mktorrent.git</code><br>2.下载完成后进入到文件夹里面<br>例如：<code>cd mktorrent</code>（如果是根目录的话）<br>3. <code>make</code><br>4. <code>make install</code><br>5. 默认安装目录位于<code>/usr/local/bin</code>，使用cd命令，从默认的/root路径切换到要制作成种子的文件上一级。<br> 例如<code>cd /Downloads</code><br>6. 制作种子命令为： <code>mktorrent -v -p -l 22 -a tracker_address -o name.torrent file_name</code><br>参数说明： tracker_address为你要发布的网站的tracker。 name.torrent为对生成torrent种子文件的命名，规则为：xxx.torrent。 file_name为你要做种的文件或文件夹。避免含有空格。<br>7. 等待一会儿会提示做种完成，在当前目录下即可找到。</p>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> torrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派搭建迅雷远程下载服务器</title>
      <link href="/1846a864/"/>
      <url>/1846a864/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载路由器固件"><span id="1-下载路由器固件">1. 下载路由器固件</span></h3><p>从 <a href="http://luyou.xunlei.com/forum-51-1.html" target="_blank" rel="noopener">官网</a> 或者 百度网盘</p><p>解压到指定目录如 <code>/root/xunlei</code> 进入目录 执行<code>./portal</code> 稍等片刻，会在最后输出一个激活码</p><h3 id="2-在迅雷远程下载页面绑定树莓派"><span id="2-在迅雷远程下载页面绑定树莓派">2. 在迅雷远程下载页面绑定树莓派</span></h3><p>登录<a href="http://yuancheng.xunlei.com/login.html" target="_blank" rel="noopener">迅雷远程下载</a>主页,登录之后，左侧会有一个添加按钮，点击添加按钮</p><p>不需要选择绑定设备类型, 直接将树莓派上获得的激活码填入框中，点击绑定后左侧就会出现树莓派对应的设备列表了，但是，如果我们此时就在右侧点击新建之后会发现,弹出的新建页面中会提示找不到挂载磁盘</p><h3 id="3-自定义迅雷的下载目录"><span id="3-自定义迅雷的下载目录">3. 自定义迅雷的下载目录</span></h3><p>进入/mnt目录，创建目录TDDOWNLOAD(名字随意) 执行<code>mount --bind /data/TDDOWNLOAD /mnt/TDDOWNLOAD</code></p><p>其中/data/TDDOWNLOAD就是自定义的下载目录，你可以指定为其他任何目录。</p><p>然后再刚刚迅雷固件的解压目录下创建目录etc,同时在etc下创建文件thunder_mounts.cfg,编辑此文件, 写入内容</p><pre><code>avaliable_mount_path_pattern{/mnt/TDDOWNLOAD}</code></pre><p>重启路由器固件 <code>./root/xunlei/portal</code> 再进入远程下载界面新建下载就没有了没挂载磁盘的提示了</p><h3 id="4-迅雷路由器固件开机启动"><span id="4-迅雷路由器固件开机启动">4. 迅雷路由器固件开机启动</span></h3><p>在/etc/init.d/下新建xunlei脚本，写入:</p><pre><code>#!/bin/sh## Xunlei initscript#### BEGIN INIT INFO# Provides:          xunlei# Required-Start:    $network $local_fs $remote_fs# Required-Stop::    $network $local_fs $remote_fs# Should-Start:      $all# Should-Stop:       $all# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: Start xunlei at boot time# Description:       A downloader### END INIT INFOdo_start(){./root/xunlei/portal}do_stop(){./root/xunlei/portal -s}case &quot;$1&quot; instart)do_start;;stop)do_stop;;esac</code></pre><p>然后将该脚本加入默认自启动中 <code>update-rc.d xunlei defaults</code></p>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thunder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派基础环境</title>
      <link href="/5976aace/"/>
      <url>/5976aace/</url>
      
        <content type="html"><![CDATA[<h3 id="修改软件源"><span id="修改软件源">修改软件源</span></h3><pre><code>sudo -secho -e &quot;deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \n deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi&quot; &amp;gt; /etc/apt/sources.listecho -e &quot;deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui&quot; &amp;gt; /etc/apt/sources.list.d/raspi.listexitsudo apt update &amp;amp;&amp;amp; sudo apt -y upgrade</code></pre><h3 id="中文输入法"><span id="中文输入法">中文输入法</span></h3><pre><code>sudo apt-get install -y ttf-wqy-zenheisudo apt-get install -y scim-pinyin</code></pre><h3 id="看门狗防止树莓派死机的监控"><span id="看门狗防止树莓派死机的监控">看门狗(防止树莓派死机的监控)</span></h3><p>当利用树莓派来做一些需要长期待机的应用时，如下载机、云储存、家庭影院等应用，我们往往会遇到的一个问题就是树莓派会因为过热而死机，需要我们重新启动树莓派，然后再次开启树莓派上的应用。这会给我们的日常操作带来许多麻烦。 Watchdog（看门狗）就能让树莓派永不死机。</p><pre><code>//树莓派自带看门狗模块，我们需要添加进去就好。sudo modprobe bcm2708_wdogecho -e &quot;\nbcm2708_wdog&quot; &amp;gt; sudo tee -a /etc/modules// 安装看门狗软件sudo apt-get install -y chkconfig watchdog// 配置sudo vim /etc/watchdog.conf// 去掉&quot;watchdog-device=/dev/watchdog&quot;这一行的#注释// 其它配置参考如下:# 用于设定CPU温度重启条件temperature-device = /sys/class/thermal/thermal_zone0/temp# 最大温度为100度，超过立即重启max-temperature = 100000# 1分钟最多进程为24个，超过即重启max-load-15=12# 5分钟最多进程为18个，超过即重启max-load-15=12# 15分钟最多进程为12个，超过即重启max-load-15=12// 完成配置后，启动看门狗sudo /etc/init.d/watchdog start// 设置为开机自启chkconfig watchdog on</code></pre><h3 id="screen让树莓派永不失联"><span id="screen让树莓派永不失联">Screen(让树莓派永不失联)</span></h3><p>利用SSH（Serare Shell，安全外壳协议）来远程控制树莓派应该是我们最常用的 操作树莓派的方式，但在用SSH连接时，我们常常会遇到连接突然断开的问题。连 接一旦断开，原米我们进行的操作也就中断了，若再使用，就得从头再来了。相信你肯定因为电脑待机而中断树莓派的任务而苦恼过。 Screen来让树莓派永不失联的方法。此方法下，就算连接断开了，当我们重新连接后依旧进行原来的操作，而不需要从头再来。</p><pre><code>// 直接安装Screensudo apt-get install -y screen// 开启一个后台view（后台的终端，不会因为断开连接而终止）screen -S 终端名// 然后就可以继续你的操作了</code></pre>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派3B+ 安装系统</title>
      <link href="/cfbe6b0a/"/>
      <url>/cfbe6b0a/</url>
      
        <content type="html"><![CDATA[<p>安装步骤: <code>官网下载系统 -- 刷入TF卡 -- 设置开启显示器和SSH -- 通电 -- 进入系统</code></p><h3 id="0-很重要"><span id="0-很重要">0. 很重要</span></h3><p>装完系统，写完 <code>wpa_supplicant.conf</code> 配置文件后，无论如何不要 <code>reboot</code>，不要 <code>reboot</code>， 不要 <code>reboot</code> ！！！<br>3B+ 有极大的概率，<code>reboot</code> 后无法正常连接 WIFI，只能重新烧录系统。</p><h3 id="1-进入官方网站下载系统镜像"><span id="1-进入官方网站下载系统镜像">1. 进入官方网站下载系统镜像</span></h3><p>官方系统 raspbian地址 <a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">https://www.raspberrypi.org/downloads/</a></p><h3 id="2-windows系统下的安装"><span id="2-windows系统下的安装">2. Windows系统下的安装</span></h3><h4 id="21-下载sd格式化工具"><span id="21-下载sd格式化工具">2.1 下载SD格式化工具</span></h4><p>SDFormatter 地址 <a href="https://www.sdcard.org/downloads/formatter\_4/eula\_windows/" target="_blank" rel="noopener">https://www.sdcard.org/downloads/formatter\_4/eula\_windows/</a></p><p>安装后直接用默认选项 格式化SD卡</p><h4 id="22-下载写镜像工具"><span id="22-下载写镜像工具">2.2 下载写镜像工具</span></h4><p>Win32 DiskImager 地址 <a href="http://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">http://sourceforge.net/projects/win32diskimager/</a></p><h3 id="3-mac系统下的安装"><span id="3-mac系统下的安装">3. MAC系统下的安装</span></h3><h4 id="31-查看当前已挂载的卷"><span id="31-查看当前已挂载的卷">3.1 查看当前已挂载的卷</span></h4><pre><code>[liuxb@liuxb-mac]$ df -hFilesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on/dev/disk1     112Gi   81Gi   30Gi    73% 1014786 4293952493    0%   /devfs          188Ki  188Ki    0Bi   100%     654          0  100%   /devmap -hosts       0Bi    0Bi    0Bi   100%       0          0  100%   /netmap auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /home/dev/disk2s3    92Gi   51Gi   41Gi    56%  336662   42525054    1%   /Volumes/系统/dev/disk2s4    20Gi   15Gi  4.4Gi    78%   92859    4579733    2%   /Volumes/数据/dev/disk3s1    29Gi  2.3Mi   29Gi     1%  107876    8373436    2%   /Volumes/未命名</code></pre><p><code>对比Size和Name可以找到SD卡的分区在系统里对应的设备文件（这里是/dev/disk3s1），如果你有多个分区，可能还会有disk3s2之类的</code></p><h4 id="32-使用diskutil-unmount将分区卸载"><span id="32-使用diskutil-unmount将分区卸载">3.2 使用diskutil unmount将分区卸载</span></h4><pre><code>[liuxb@liuxb-mac]$ diskutil unmount /dev/disk3s1Volume 未命名 on disk3s1 unmounted</code></pre><h4 id="33-先对下载的zip压缩包进行解压然后使用dd命令将系统镜像写入需要特别特别注意disk后的数字不能搞错"><span id="33-先对下载的zip压缩包进行解压然后使用dd命令将系统镜像写入需要特别特别注意disk后的数字不能搞错">3.3 先对下载的zip压缩包进行解压，然后使用dd命令将系统镜像写入，需要特别特别注意disk后的数字，不能搞错</span></h4><p>说明：/dev/disk3s1是分区，/dev/disk3是块设备，/dev/rdisk3是原始字符设备</p><pre><code>[liuxb@liuxb-mac]$ unzip 2017-09-07-raspbian-stretch.zip[liuxb@liuxb-mac]$ sudo dd bs=16m if=2017-09-07-raspbian-stretch.img of=/dev/rdisk3_输入用户密码</code></pre><p>经过几分钟的等待，出现下面的提示，说明TF卡刷好了：</p><pre><code>1172+1 records in1172+1 records out4916019200 bytes transferred in 127.253638 secs (9691442 bytes/sec)</code></pre><h3 id="4-开启ssh"><span id="4-开启ssh">4. 开启SSH</span></h3><p>在TF卡分区里创建一个名为”ssh”的不带后缀的空文件</p><h3 id="5-开启强制hdmi输出"><span id="5-开启强制hdmi输出">5. 开启强制HDMI输出</span></h3><p>在TF卡分区，打开config.txt文件(开机后位置： /boot/config.txt)，修改如下：</p><pre><code>hdmi_safe=1config_hdmi_boost=4hdmi_ignore_edid=0xa5000080hdmi_group=2hdmi_mode=82</code></pre><p>参数介绍:</p><p>项</p><p>解释</p><p>hdmi_safe=1</p><p>安全启动HDMI</p><p>config_hdmi_boost=4</p><p>开启热插拔</p><p>hdmi_group=1</p><p>CEA电视显示器</p><p>hdmi_group=2</p><p>DMT电脑显示器</p><p>hdmi_ignore_edid=0xa5000080</p><p>忽略自动探测的分辨率</p><p>输出分辨率：</p><p>hdmi_mode=4</p><p>640x480 60Hz</p><p>hdmi_mode=9</p><p>800x600 60Hz</p><p>hdmi_mode=16</p><p>1024x768 60Hz</p><p>hdmi_mode=82</p><p>1080p 60Hz</p><h3 id="6设置无线wi-fi连接假设没有网线而且没能连接显示器"><span id="6设置无线wi-fi连接假设没有网线而且没能连接显示器">6.设置无线WI-FI连接：（假设没有网线，而且没能连接显示器）</span></h3><p>在TF卡的boot分区，创建wpa_supplicant.conf文件，加入如下内容：</p><pre><code>country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ssid=&quot;lxb-wifi&quot;psk=&quot;123456789&quot;priority=1}</code></pre><p>在树莓派通电后会自动添加到<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>文件里面，进行自动连接。</p><pre><code>// 详细介绍：#ssid:网络的ssid#psk:密码#priority:连接优先级，数字越大优先级越高（不可以是负数）#scan_ssid:连接隐藏WiFi时需要指定该值为1// 如果WiFi 没有密码network={ssid=&quot;无线网络名称（ssid）&quot;key_mgmt=NONE}// 如果WiFi 使用WEP加密network={ssid=&quot;无线网络名称（ssid）&quot;key_mgmt=NONEwep_key0=&quot;wifi密码&quot;}// 如果你的 WiFi 使用WPA/WPA2加密network={ssid=&quot;无线网络名称（ssid）&quot;key_mgmt=WPA-PSKpsk=&quot;wifi密码&quot;}</code></pre><p>以上设置完成后, TF卡可以插入树莓派了, 通电. 默认登录账号:<code>pi</code> 密码: <code>raspberry</code></p>]]></content>
      
      
      <categories>
          
          <category> RPI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 发送邮件</title>
      <link href="/c296dcc8/"/>
      <url>/c296dcc8/</url>
      
        <content type="html"><![CDATA[<p>需要引入 smtp包 mail.go</p><pre><code>package mainimport (    &quot;bytes&quot;    &quot;encoding/base64&quot;    &quot;fmt&quot;    &quot;io/ioutil&quot;    &quot;net/smtp&quot;    &quot;strings&quot;)const const_smtp_server = &quot;server-ip:port&quot;//const const_email_content_type = &quot;Content-Type: text/plain; charset=UTF-8&quot;const const_email_content_type = &quot;Content-Type: text/html; charset=UTF-8&quot;const const_boundary = &quot;THIS_IS_THE_BOUNDARY_FOR_EMAIL_BY_LXB&quot;func SendEmail(sender string, receivers []string, subject string, content string, attach_files []string) error {    var buf bytes.Buffer    buf.WriteString(&quot;To: &quot;)    buf.WriteString(strings.Join(receivers, &quot;,&quot;))    buf.WriteString(&quot;\r\nFrom: &quot;)    //nickname := strings.Split(sender,&quot;@&quot;)[0]    //buf.WriteString(nickname)    buf.WriteString(&quot;&lt;&quot;)    buf.WriteString(sender)    buf.WriteString(&quot;&gt;&quot;)    buf.WriteString(&quot;\r\nSubject: &quot;)    buf.WriteString(subject)    buf.WriteString(&quot;\r\nContent-Type: multipart/mixed; boundary=&quot;)    buf.WriteString(const_boundary)    buf.WriteString(&quot;\r\n--&quot;)    buf.WriteString(const_boundary)    buf.WriteString(&quot;\r\n&quot;)    buf.WriteString(const_email_content_type)    buf.WriteString(&quot;\r\n\r\n&quot;)    buf.WriteString(content)    buf.WriteString(&quot;\r\n\r\n--&quot;)    buf.WriteString(const_boundary)    buf.WriteString(&quot;\r\n&quot;)    for _, filepath := range attach_files {        // 第一个附件        filedepts := strings.Split(filepath, &quot;/&quot;)        filename := filedepts[len(filedepts)-1]        buf.WriteString(&quot;Content-Type: application/octet-stream\r\n&quot;)        buf.WriteString(&quot;Content-Description: 附件\r\n&quot;)        buf.WriteString(&quot;Content-Transfer-Encoding: base64\r\n&quot;)        buf.WriteString(&quot;Content-Disposition: attachment; filename=\&quot;&quot; + filename + &quot;\&quot;\r\n\r\n&quot;)        //读取并编码文件内容        attaData, err := ioutil.ReadFile(filepath)        if err != nil {            print(err)            return err        }        b := make([]byte, base64.StdEncoding.EncodedLen(len(attaData)))        base64.StdEncoding.Encode(b, attaData)        buf.Write(b)        buf.WriteString(fmt.Sprintf(&quot;\r\n--%s\r\n&quot;, const_boundary))    }    fmt.Println(buf.String())    err := smtp.SendMail(const_smtp_server, nil, sender, receivers, buf.Bytes())    fmt.Println(&quot;send mail err:&quot;, err)    return err}</code></pre><p>main.go</p><pre><code>package mainimport (    //&quot;flag&quot;    //&quot;fmt&quot;    &quot;os&quot;)func main() {    //var task string    //flag.StringVar(&amp;task, &quot;t&quot;, &quot;&quot;, &quot;task id&quot;)    //flag.Parse()    //if task == &quot;&quot; {    //  fmt.Println(&quot;task is required.&quot;)    //  flag.Usage()    //  os.Exit(2)    //}    testStr := os.Args[1]    cont := &quot;&lt;html&gt;&lt;body&gt;&lt;p align=\&quot;center\&quot;&gt;表: 1&lt;/p&gt;&lt;table align=\&quot;center\&quot; border=\&quot;1\&quot; cellpadding=\&quot;10\&quot;&gt;&lt;tr&gt;&lt;td&gt;任务ID&lt;/td&gt;&lt;td&gt;列1&lt;/td&gt;&lt;td&gt;列2&lt;/td&gt;&lt;td&gt;列3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;    sender := &quot;&quot;    rcvs := []string{}    sbj := &quot;test email&quot;    //  cont := &quot;This is content&quot;    file := []string{}    SendEmail(sender, rcvs, sbj, cont, file)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell数组笔记</title>
      <link href="/21c4d609/"/>
      <url>/21c4d609/</url>
      
        <content type="html"><![CDATA[<p>Bash shell 只支持一维数组. 初始化时不需要定义数组大小(与 PHP 类似). 数组元素的下标由0开始</p><p>shell 数组用括号来表示, 元素用”空格”符号分隔开, 语法: <code>array_name=(value1 value2 ...valuen)</code></p><h3 id="实例"><span id="实例">实例</span></h3><pre><code>#!/bin/bashmy_array=(A B &quot;C&quot; D)</code></pre><p>也可以用下标来定义数组</p><pre><code>array_name[0]=value0array_name[1]=value1array_name[2]=value2</code></pre><h3 id="读取数组"><span id="读取数组">读取数组</span></h3><p><code>${array_name[index]}</code></p><h3 id="实例"><span id="实例">实例</span></h3><pre><code>#!/bin/bashmy_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: ${my_array[0]}&quot;echo &quot;第二个元素为: ${my_array[1]}&quot;echo &quot;第三个元素为: ${my_array[2]}&quot;echo &quot;第四个元素为: ${my_array[3]}&quot;</code></pre><h3 id="获取数组中的所有元素"><span id="获取数组中的所有元素">获取数组中的所有元素</span></h3><p>使用<code>@</code> 或 <code>*</code> 可以后去数组中的所有元素</p><pre><code>#!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho &quot;数组的元素为: ${my_array[*]}&quot;echo &quot;数组的元素为: ${my_array[@]}&quot;</code></pre><h3 id="获取数组的长度"><span id="获取数组的长度">获取数组的长度</span></h3><p>获取数组长度的方法与获取字符串长度的方法相同</p><pre><code>#!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho &quot;数组元素个数为: ${#my_array[*]}&quot;echo &quot;数组元素个数为: ${#my_array[@]}&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>split命令</title>
      <link href="/aa4c47b6/"/>
      <url>/aa4c47b6/</url>
      
        <content type="html"><![CDATA[<h3 id="选项"><span id="选项">选项</span></h3><pre><code>-b 值为每一个输出档案的大小, 单位为byte-C 每一个输出档中, 单行的最大byte 数-d 使用数字作为后缀-l 值为每一个输出档的行数大小</code></pre><h3 id="实例"><span id="实例">实例</span></h3><p>生成一个大小为100KB 的测试文件</p><pre><code>dd if=/dev/zero bs=100k count=1 of=date.file1+0 records in1+0 records out102400 bytes (102 kB) copied, 0.00043 seconds, 238 MB/s</code></pre><p>使用split 命令将上面创建的date.file文件分割成大小为10KB 的小文件</p><pre><code>$ split -b 10k date.file$ lsdate.file  xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj</code></pre><p>文件被分割成带有字母的后缀文件, 如果想用数字后缀可使用<code>-d</code>参数, 同时可以使用<code>-a length</code>指定后缀的长度</p><pre><code>[root@localhost split]# split -b 10k date.file -d -a 3[root@localhost split]# lsdate.file  x000  x001  x002  x003  x004  x005  x006  x007  x008  x009</code></pre><p>为分割后的文件指定文件名的前缀</p><pre><code>[root@localhost split]# split -b 10k date.file -d -a 3 split_file[root@localhost split]# lsdate.file  split_file000  split_file001  split_file002  split_file003  split_file004  split_file005  split_file006  split_file007  split_file008  split_file009</code></pre><p>使用<code>-l</code>选项根据文件的行数来分割文件,如把文件分割成每个包含10行的小文件</p><pre><code>split -l 10 date.file</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql启动时 &amp;quot;No space left on device&amp;quot;</title>
      <link href="/77f38978/"/>
      <url>/77f38978/</url>
      
        <content type="html"><![CDATA[<p>先用<code>free</code> 命令查看剩余空间</p><pre><code>[root@tokyo mysqld]# free              total        used        free      shared  buff/cache   availableMem:        1016108      632132      205776       66344      178200      180496Swap:             0           0           0</code></pre><p>发现swap 为零了</p><p>执行</p><pre><code>dd if=/dev/zero of=/swapfile bs=1M count=1024mkswap /swapfilewapon /swapfileswapon /swapfile</code></pre><p>再用<code>free</code>查看</p><pre><code>[root@tokyo ~]# free              total        used        free      shared  buff/cache   availableMem:        1016108      732148       63984       51400      219976       71132Swap:       1048572      209240      839332</code></pre><p>启动mysql, 解决</p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 后台执行命令</title>
      <link href="/be78f922/"/>
      <url>/be78f922/</url>
      
        <content type="html"><![CDATA[<p>当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用</p><ul><li>&amp;</li><li>nohup</li><li>ctrl + z</li><li>ctrl + c</li><li>jobs</li><li>bg</li><li>fg</li></ul><h4 id="amp"><span id="amp">&amp;</span></h4><p>当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh test.sh &amp; 适合在后台运行的命令有f i n d、费时的排序及一些s h e l l脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：</p><pre><code>command  &gt;  out.file  2&gt;&amp;1  &amp; </code></pre><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。(<code>ps -ef | grep 进程号</code> 或者 <code>kill -9 进程号</code>）</p><h4 id="nohup"><span id="nohup">nohup</span></h4><p>使用<code>&amp;</code>命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p><pre><code>nohup command &amp;</code></pre><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p><pre><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></pre><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，<strong>需要使用exit正常退出当前账户</strong>，这样才能保证命令一直在后台运行</p><h4 id="ctrl-z"><span id="ctrl-z">ctrl + z</span></h4><p>可以将一个正在前台执行的命令放到后台，并且处于暂停状态</p><h4 id="ctrl-c"><span id="ctrl-c">ctrl + c</span></h4><p>终止前台命令</p><h4 id="jobs"><span id="jobs">jobs</span></h4><p>查看当前有多少在后台运行的命令。 <code>jobs -l</code>选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识</p><h4 id="bg"><span id="bg">bg</span></h4><p>将一个在后台暂停的命令，变成继续执行 （在后台执行） 如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid) 将任务转移到后台运行： 先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。</p><h4 id="fg"><span id="fg">fg</span></h4><p>将后台中的命令调至前台继续运行 如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang select 的用法</title>
      <link href="/e353ee8e/"/>
      <url>/e353ee8e/</url>
      
        <content type="html"><![CDATA[<h4 id="基本使用"><span id="基本使用">基本使用</span></h4><p>select 是 Go 中的一个控制结构, 类似于switch 语句, 用于处理异步 IO 操作. select 语句会监听 case语句中channel 的读写操作, 当case 中 channel 读写操作为非阻塞状态(即能读写)时, 将会触发相应的动作.</p><pre><code>select 中的 case 语句必须是一个 channel 操作select 中的 default 子句总是可运行的</code></pre><ol><li>如果有多个 case 都可以运行, select 会随机公平地选出一个执行, 其他不会执行</li><li>如果没有可运行的 case 语句, 且有 default 语句, 则会执行 default 的动作</li><li>如果没有可运行的 case 语句, 且没有 default 语句, select 将阻塞, 知道某个 case 通信可以运行</li></ol><p><strong>例</strong></p><pre><code>package mainimport &quot;fmt&quot;func main() {   var c1, c2, c3 chan int   var i1, i2 int   select {      case i1 = &lt;-c1:         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)      case c2 &lt;- i2:         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3         if ok {            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)         } else {            fmt.Printf(&quot;c3 is closed\n&quot;)         }      default:         fmt.Printf(&quot;no communication\n&quot;)   }    }//输出：no communication</code></pre><h4 id="典型用法"><span id="典型用法">典型用法</span></h4><h5 id="1-超时判断"><span id="1-超时判断">1. 超时判断</span></h5><pre><code>//比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行var resChan = make(chan int)// do requestfunc test() {    select {    case data := &lt;-resChan:        doData(data)    case &lt;-time.After(time.Second * 3):        fmt.Println(&quot;request time out&quot;)    }}func doData(data int) {    //...}</code></pre><h5 id="2-退出"><span id="2-退出">2. 退出</span></h5><pre><code>//主线程（协程）中如下：var shouldQuit=make(chan struct{})fun main(){    {        //loop    }    //...out of the loop    select {        case &lt;-c.shouldQuit:            cleanUp()            return        default:        }    //...}//再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行close(shouldQuit)</code></pre><h5 id="3-判断-channel-是否阻塞"><span id="3-判断-channel-是否阻塞">3. 判断 channel 是否阻塞</span></h5><pre><code>//在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断ch := make (chan int, 5)//...data：=0select {case ch &lt;- data:default:    //做相应操作，比如丢弃data。视需求而定}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 笔记</title>
      <link href="/9f188831/"/>
      <url>/9f188831/</url>
      
        <content type="html"><![CDATA[<h4 id="数据类型"><span id="数据类型">数据类型</span></h4><p>Redis 支持5中数据类型</p><h5 id="字符串string"><span id="字符串string">字符串(string)</span></h5><p>Redis 中字符串是一个字节序列. Redis 中的字符串是二进制安全的, 这意味着它们的长度不由任何特殊的终止字符决定。因此，可以在一个字符串中存储高达512兆字节的任何内容 <strong>例</strong></p><pre><code>redis 127.0.0.1:6379&gt; SET name &quot;value&quot;OKredis 127.0.0.1:6379&gt; GET name&quot;value&quot;Redis命令不区分大小写.字符串的最大长度为512M</code></pre><h5 id="散列哈希hash"><span id="散列哈希hash">散列/哈希(Hash)</span></h5><p>Redis散列/哈希(Hashes)是键值对的集合。Redis散列/哈希是字符串字段和字符串值之间的映射。因此，它们用于表示对象。 <strong>例</strong></p><pre><code>redis 127.0.0.1:6379&gt; HMSET ukey username &quot;yiibai&quot; password &quot;passswd123&quot; points 200</code></pre><p>散列/哈希数据类型用于存储包含用户的基本信息的用户对象。这里HMSET，HGETALL是Redis的命令，而ukey是键的名称。</p><p>每个散列/哈希可以存储多达2^32 - 1个健-值对(超过40亿个)。</p><h5 id="列表list"><span id="列表list">列表(List)</span></h5><p>Redis列表只是字符串列表，按插入顺序排序。可以向Redis列表的头部或尾部添加元素。 <strong>例</strong></p><pre><code>redis 127.0.0.1:6379&gt; lpush alist redis (integer) 1 redis 127.0.0.1:6379&gt; lpush alist mongodb (integer) 2 redis 127.0.0.1:6379&gt; lpush alist sqlite (integer) 3 redis 127.0.0.1:6379&gt; lrange alist 0 10  1) &quot;sqlite&quot; 2) &quot;mongodb&quot; 3) &quot;redis&quot;</code></pre><h5 id="集合set"><span id="集合set">集合(Set)</span></h5><p>Redis集合是字符串的无序集合。在Redis中，可以添加，删除和测试成员存在的时间O(1)复杂性 <strong>例</strong></p><pre><code>redis 127.0.0.1:6379&gt; sadd yiibailist redis (integer) 1 redis 127.0.0.1:6379&gt; sadd yiibailist mongodb (integer) 1 redis 127.0.0.1:6379&gt; sadd yiibailist sqlite (integer) 1 redis 127.0.0.1:6379&gt; sadd yiibailist sqlite (integer) 0 redis 127.0.0.1:6379&gt; smembers yiibailist  1) &quot;sqlite&quot; 2) &quot;mongodb&quot; 3) &quot;redis&quot;注意 - 在上面的示例中，sqlite被添加了两次，但是由于集合的唯一属性，所以它只算添加一次</code></pre><h5 id="可排序集合zset"><span id="可排序集合zset">可排序集合(ZSET)</span></h5><p>Redis可排序集合类似于Redis集合，是不重复的字符集合。 不同之处在于，排序集合的每个成员都与分数相关联，这个分数用于按最小分数到最大分数来排序的排序集合。虽然成员是唯一的，但分数值可以重复 <strong>例</strong></p><pre><code>redis 127.0.0.1:6379&gt; zadd yiibaiset 0 redis(integer) 1 redis 127.0.0.1:6379&gt; zadd yiibaiset 0 mongodb(integer) 1 redis 127.0.0.1:6379&gt; zadd yiibaiset 1 sqlite(integer) 1 redis 127.0.0.1:6379&gt; zadd yiibaiset 1 sqlite(integer) 0 redis 127.0.0.1:6379&gt; ZRANGEBYSCORE yiibaiset 0 1000  1) &quot;mongodb&quot; 2) &quot;redis&quot; 3) &quot;sqlite&quot;因为 ‘sqlite‘ 的排序值是 1 ，其它两个元素的排序值是 0 ，所以 ‘sqlite‘ 排在最后一个位置上</code></pre>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 环境变量</title>
      <link href="/2ddd6919/"/>
      <url>/2ddd6919/</url>
      
        <content type="html"><![CDATA[<h5 id="goroot"><span id="goroot">GOROOT</span></h5><p>，在Linux系统中一般安装在<code>/usr/go</code>或者<code>/usr/local/go</code>，这样Linux系统中的PATH变量一般都包含了这两个目录，所以就可以直接运行go命令，而Windows系统中一般默认安装在<code>C:\go</code>中</p><p>自定义 GO安装路径, 可修改环境变量配置文件 <code>export GOROOT=$HOME/go</code></p><h5 id="gopath"><span id="gopath">GOPATH</span></h5><p>go的工作目录，这个目录指定了需要从哪个地方寻找GO的包、可执行程序等，这个目录可以是多个目录表示，go编译或者运行时会从这个环境变量中去对应查找，工作目录或者如官方文档中说的workspace 在这个目录进行编译、链接最后生成所需要的库、可执行文件，我们对比C程序的目录，也许更能方便理解，一般在C的工程项目中包含三个文件，一个include目录、src目录、Makefile文件。 <code>include</code>目录存放了所有的头文件可供其他地方包含 <code>src</code>目录则存放所有的.c后缀的源文件 <code>Makefile</code>则是该项目的编译，在编译整个工程时需要执行make命令，这里就发现GO就不需要去写什么Makefile了，执行<code>go build xxx.go</code>命令就可以编译</p><p>GOPATH 下的目录下, 一般有三个 目录 <code>bin</code> <code>pkg</code> <code>src</code> <code>bin</code>目录包含了可执行程序，注意是可执行的，不需要解释执行。 <code>pkg</code>目录包含了使用的包或者说库。 <code>src</code>里面包含了go的代码源文件，其中仍按包的不同进行组织</p><p>包名一般和目录名相同, 编译时, 可以在某个包下, 执行<code>go build</code> , 也可以在包上层直接编译包名<code>go build pkg_name</code></p><p><code>go install &lt;pkg_name/exe_name/all&gt;</code> 先编译后把编译生成的可执行文件复制到<code>bin</code> 下</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装bashmarks</title>
      <link href="/472d58f/"/>
      <url>/472d58f/</url>
      
        <content type="html"><![CDATA[<h6 id="下载源码"><span id="下载源码">下载源码</span></h6><p><code>git clone https://github.com/lxbwolf/bashmarks.git</code> 把<code>bashmarks.sh</code>复制到<code>~/bin/</code></p><h6 id="添加环境变量"><span id="添加环境变量">添加环境变量</span></h6><p>在环境变量文件里, 添加 <code>. ~/bin/bashmarks.sh</code></p><h6 id="相关命令"><span id="相关命令">相关命令</span></h6><pre><code>s &lt;bookmark_name&gt; - Saves the current directory as &quot;bookmark_name&quot;g &lt;bookmark_name&gt; - Goes (cd) to the directory associated with &quot;bookmark_name&quot;p &lt;bookmark_name&gt; - Prints the directory associated with &quot;bookmark_name&quot;d &lt;bookmark_name&gt; - Deletes the bookmarkl                 - Lists all available bookmarks</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装thefuck</title>
      <link href="/42c1114f/"/>
      <url>/42c1114f/</url>
      
        <content type="html"><![CDATA[<h6 id="下载源码"><span id="下载源码">下载源码</span></h6><p><code>git clone https://github.com/lxbwolf/thefuck.git</code></p><h6 id="配置环境变量"><span id="配置环境变量">配置环境变量</span></h6><ol><li>把<code>thefuck/**/libexec/bin</code> 添加进环境变量</li><li><code>eval $(thefuck --alias fuck)</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装samba</title>
      <link href="/8f5b70d0/"/>
      <url>/8f5b70d0/</url>
      
        <content type="html"><![CDATA[<h5 id="开发机安装-samba"><span id="开发机安装-samba">开发机安装 samba</span></h5><p><code>yum install samba samba-client samba-swat</code></p><h5 id="添加账号"><span id="添加账号">添加账号</span></h5><p><code>sampasswd -a 用户名</code> 用户名只能为已经存在的账号</p><h5 id="配置共享文件夹"><span id="配置共享文件夹">配置共享文件夹</span></h5><p>编辑<code>etc/samba/smb.conf</code>, 追加内容:</p><pre><code>[samba_share_dir]comment = samba_sharepath = /home/lxb/samba_sharecreate mask = 0664directory mask = 0775writable = yesvalid users = lxbbrowseable = yes</code></pre><h5 id="配置环境变量"><span id="配置环境变量">配置环境变量</span></h5><p>环境变量文件添加:</p><p><code>export LD_LIBRARY_PATH=/usr/local/samba/lib:$LD_LIBRARY_PATH</code></p><h5 id="samba-重启"><span id="samba-重启">samba 重启</span></h5><p><code>sudo /etc/init.d/smb restart</code></p><h5 id="mac客户端连接"><span id="mac客户端连接">MAC客户端连接</span></h5><p>Finder -&gt; 前往 -&gt; 连接服务器 -&gt; 输入smb地址</p><p><code>smb://user_name@IP/samba_share_dir</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx 配置中的rewrite</title>
      <link href="/389c639/"/>
      <url>/389c639/</url>
      
        <content type="html"><![CDATA[<p><strong>语法</strong> <code>rewrite regex replacement flag</code> flag有如下: - last - break 中止 rewrite, 不再继续匹配 - redirect 返回临时重定向的 HTTP 状态302 - permanet 返回永久重定向的 HTTP 状态301 last 和 break 的不同:<br>break 是终止当前location 的 rewrite 检测, 且不再进行 location 匹配;<br>last是终止当前location的rewrite检测,但会继续重试location匹配并处理区块中的rewrite规则</p><ol><li><p>下面是可以用来判断的表达式: <code>-f</code> 和<code>!-f</code> 判断是否存在文件 <code>-d</code> 和<code>!-d</code> 判断是否存在目录 <code>-e</code> 和<code>!-e</code> 判断是否存在文件或目录 <code>-x</code> 和<code>!-x</code> 判断文件是否可执行</p></li><li><p>下面是可以用作判断的全局变量</p><ul><li>$args 等于请求行中的参数</li><li>$content_length 请求头中的<code>Content-length</code> 字段</li><li>$content_type 请求头中的<code>Content-Type</code> 字段</li><li>$document_root 当前请求在<code>root</code> 指令中指定的值</li><li>$host 请求主机头字段, 否则为服务器名称</li><li>$http_user_agent 客户端<code>agent</code> 信息</li><li>$http_cookie 客户端<code>cookie</code> 信息</li><li>$limit_rate 这个变量可以限制连接速率</li><li>$request_body_file 客户端请求主题信息的临时文件名</li><li>$request_method #客户端请求的动作，通常为GET或POST。</li><li>$remote_addr #客户端的IP地址。</li><li>$remote_port #客户端的端口。</li><li>$remote_user #已经经过Auth Basic Module验证的用户名。</li><li>$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。</li><li><code>$query_string</code> #与$args相同。</li><li>$scheme #HTTP方法（如http，https）。</li><li>$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</li><li>$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。</li><li>$server_name #服务器名称。</li><li>$server_port #请求到达服务器的端口号。</li><li>$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li><li><code>$uri</code> 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</li><li><code>$document_uri</code> #与<code>$uri</code>相同</li></ul></li></ol><p>例:</p><pre><code>http://localhost:88/test1/test2/test.php$host: localhost$server_post: 88$request_uri: http://localhost:88/test1/test2/test.php$document_uri: /test1/test2/test.php$document_root: /usr/share/nginx/html (在nginx.conf里配置的)$request_filename: /usr/share/nginx/html/test1/test2/test.php (在nginx.conf里配置的)</code></pre><p><strong>详例:</strong><br><em>多目录转成参数</em><br><code>abc.domain.com/sort/2</code> =&gt; <code>abc.domain.com/index.php?act=sort&amp;name=abc&amp;id=2</code></p><pre><code>if ($host ~* (.*)\.domain\.com) {    set $sub_name $1;    rewrite ^/sort\/(\d+)\/?$ /index.php?act=sort&amp;cid=$sub_name&amp;id=$1 last;}</code></pre><p><em>目录对换</em><br><code>/123456/xxxx</code> =&gt; <code>/xxxx?id=123456</code></p><pre><code>rewrite ^/(\d+)\/(.+)/ /$2?id=$1 last;// rewrite ^/\/(\d+)\/(\w+)\/? /$2?id=$1 last;</code></pre><p><em>如果使用IE浏览器, 则重定向到/nginx-ie 目录下</em></p><pre><code>if ($http_user_agent ~ MSIE) {    rewrite ^(.*)$ /nginx-ie/$1 break;}</code></pre><p>*目录自动加 / *</p><pre><code>1.     if (-d $request_filename){2.     rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;3.     }</code></pre><p><em>禁止htaccess</em></p><pre><code>1.     location ~/\.ht {2.              deny all;3.          }</code></pre><p><em>禁止多个目录</em></p><pre><code>1.     location ~ ^/(cron|templates)/ {2.              deny all;3.     break;4.          }</code></pre><p><em>禁止以/data开头的文件</em></p><pre><code>可以禁止/data/下多级目录下.log.txt等请求;1.     location ~ ^/data {2.              deny all;3.          }</code></pre><p><em>禁止单个目录</em></p><pre><code>不能禁止.log.txt能请求1.     location /searchword/cron/ {2.              deny all;3.          }</code></pre><p><em>禁止单个文件</em></p><pre><code>1.     location ~ /data/sql/data.sql {2.              deny all;3.          }</code></pre><p><em>给favicon.ico和robots.txt设置过期时间;</em><br>这里为favicon.ico为99 天,robots.txt为7天并不记录404错误日志</p><pre><code>1.     location ~(favicon.ico) {2.                      log_not_found off;3.     expires 99d;4.     break;5.          }6.      7.          location ~(robots.txt) {8.                      log_not_found off;9.     expires 7d;10. break;11.      }</code></pre><p><em>设定某个文件的过期时间;这里为600秒，并不记录访问日志</em></p><pre><code>1.     location ^~ /html/scripts/loadhead_1.js {2.                      access_log   off;3.                      root /opt/lampp/htdocs/web;4.     expires 600;5.     break;6.            }</code></pre><p><em>文件反盗链并设置过期时间</em><br>这里的return 412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求<br>“rewrite ^/ <a href="http://leech.c1gstudio.com/leech.gif;”显示一张防盗链图片" target="_blank" rel="noopener">http://leech.c1gstudio.com/leech.gif;”显示一张防盗链图片</a><br>“access_log off;”不记录访问日志，减轻压力<br>“expires 3d”所有文件3天的浏览器缓存</p><pre><code>1.     location ~* ^.+\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {2.     valid_referers none blocked *.c1gstudio.com *.c1gstudio.net localhost 208.97.167.194;3.     if ($invalid_referer) {4.         rewrite ^/ http://leech.c1gstudio.com/leech.gif;5.         return 412;6.         break;7.     }8.                      access_log   off;9.                      root /opt/lampp/htdocs/web;10. expires 3d;11. break;12.      }</code></pre><p><em>只充许固定ip访问网站，并加上密码</em></p><pre><code>1.     root  /opt/htdocs/www;2.     allow   208.97.167.194;3.     allow   222.33.1.2;4.     allow   231.152.49.4;5.     deny    all;6.     auth_basic &quot;C1G_ADMIN&quot;;7.     auth_basic_user_file htpasswd;</code></pre><p><em>将多级目录下的文件转成一个文件，增强seo效果</em><br><code>/job-123-456-789.html</code> 指向 <code>/job/123/456/789.html</code></p><pre><code>1.     rewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;</code></pre><p><em>将根目录下某个文件夹指向2级目录</em><br>如<code>/shanghaijob/</code> 指向 <code>/area/shanghai/</code> 如果你将last改成permanent，那么浏览器地址栏显是 <code>/location/shanghai/</code></p><pre><code>1.     rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;</code></pre><p>上面例子有个问题是访问/shanghai 时将不会匹配</p><pre><code>1.     rewrite ^/([0-9a-z]+)job$ /area/$1/ last;2.     rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;</code></pre><p>这样/shanghai 也可以访问了，但页面中的相对链接无法使用， 如<code>./list_1.html</code>真实地址是<code>/area /shanghia/list_1.html</code>会变成<code>/list_1.html</code>,导至无法访问。<br>那我加上自动跳转也是不行咯 <code>(-d $request_filename)</code>它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果</p><pre><code>1.     if (-d $request_filename){2.     rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;3.     }</code></pre><p>知道原因后就好办了，让我手动跳转吧</p><pre><code>1.     rewrite ^/([0-9a-z]+)job$ /$1job/ permanent;2.     rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;</code></pre><p><em>文件和目录不存在的时候重定向：</em></p><pre><code>1.     if (!-e $request_filename) {2.     proxy_pass http://127.0.0.1;3.     }</code></pre><p><em>域名跳转</em></p><pre><code>1.     server2.          {3.                  listen       80;4.                  server_name  jump.c1gstudio.com;5.                  index index.html index.htm index.php;6.                  root  /opt/lampp/htdocs/www;7.                  rewrite ^/ http://www.c1gstudio.com/;8.                  access_log  off;9.          }</code></pre><p><em>多域名转向</em></p><pre><code>1.     server_name  www.c1gstudio.com www.c1gstudio.net;2.                  index index.html index.htm index.php;3.                  root  /opt/lampp/htdocs;4.     if ($host ~ &quot;c1gstudio\.net&quot;) {5.     rewrite ^(.*) http://www.c1gstudio.com$1 permanent;6.     }</code></pre><p><em>三级域名跳转</em></p><pre><code>1.     if ($http_host ~* &quot;^(.*)\.i\.c1gstudio\.com$&quot;) {2.     rewrite ^(.*) http://top.yingjiesheng.com$1;3.     break;4.     }</code></pre><p><em>域名镜向</em></p><pre><code>1.     server2.          {3.                  listen       80;4.                  server_name  mirror.c1gstudio.com;5.                  index index.html index.htm index.php;6.                  root  /opt/lampp/htdocs/www;7.                  rewrite ^/(.*) http://www.c1gstudio.com/$1 last;8.                  access_log  off;9.          }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置中的location</title>
      <link href="/a209000e/"/>
      <url>/a209000e/</url>
      
        <content type="html"><![CDATA[<p><strong>语法</strong><br><code>location [=|~|~*|^~] /uri/ {...}</code> 上下文: <code>server</code> 此命令随URL 不同而接受不同的结构. 可以配置使用常规字符串和正则表达式. 若使用正则表达式, 则必须使用<code>~*</code>前缀(选择不区分大小写的匹配) 或<code>~</code>前缀(区分大小写的匹配)</p><ol><li><code>=</code> 表示<code>uri</code> 以某个常规字符串开头, 理解为匹配url 路径即可. nginx 不对url 做编码, 因此请求为<code>/static/%20%/aa</code> 可以被规则<code>^~ /static/ /aa</code> (有空格) 匹配到.</li><li><code>~</code> 表示区分大小写的正则匹配</li><li><code>~*</code> 表示不区分大小写的正则匹配</li><li><code>!~</code> 和 <code>!~*</code> 分别为区分大小写不匹配 和 不区分大小写不匹配 的正则</li><li><code>/</code> 通用匹配, 任何请求都会匹配到</li></ol><p>多个<code>location</code> 配置的情况下, 匹配顺序为: 先匹配<code>=</code>, 其次匹配<code>^~</code>, 再匹配按文件中顺序的正则匹配, 最后匹配<code>/</code>. 当有匹配成功的时候, 停止匹配, 按当前匹配规则处理请求. <strong>例1:</strong></p><pre><code>location = / {    # 规则A}location = /login {    # 规则B}location ^~ /static {    # 规则C}location ~ \.(gif|jpg|png|js|css)$ {    # 规则D}location ~* \.png$ {    # 规则E}location !~ \.xhtml$ {    # 规则F}location !~* \.xhtml$ {    # 规则G}location / {    # 规则H}</code></pre><p>产生效果如下: 1. 访问<code>/</code> 根目录, 如<code>http://localhost/</code> 将匹配规则A 2. 访问<code>http://localhost/login</code> 将匹配规则B; <code>http://localhost/register</code> 将匹配规则H 3. 访问<code>http://localhost/static/a.html</code> 将匹配规则C 4. 访问<code>http://localhost/a.png</code> 讲匹配规则D 和规则E, 但规则D 顺序优先, 规则E 不起作用 5. 访问<code>http://localhost/static/c.png</code> 优先匹配到规则C 6. 访问<code>http://localhost/a.PNG</code> 将匹配规则E 7. 访问<code>http://localhost/a.xhtml</code> 不会匹配到规则F 和规则G, <code>http://localhost/a.XHTML</code> 不会匹配到规则G 8. 访问<code>http://localhost/category/id/1111</code> 匹配到规则H, 因为以上规则都不匹配, 这个时候应该是nginx 转发给后端应用服务器, 如FastCGI(php), tomcat(jsp), nginx 作为反向代理服务器存在. 所以实际使用中, 通常有至少三个匹配规则定义, 如下:</p><pre><code># 第一个必选规则 直接匹配网站根, 通过域名访问网站首页比较频繁, 使用这个会加速处理; 这里直接转发给后端应用服务器了, 也可以是一个静态首页location = / {    proxy_pass http://tomcat:8080/index}# 第二个必选规则 处理静态文件请求, 这是nginx 作为http 服务器的强项. 有如下两种配置模式, 目录匹配或后缀匹配, 任选其一或搭配使用location ^~ /static/ {    root /webroot/static/;}location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ {    root /webroot/res/;}# 第三个必选规则 通用规则, 用来转发动态请求到后端应用服务器. 非静态文件请求就默认是动态请求. location / {    proxy_pass http://tomcat:8080/}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx 寻找index 原理</title>
      <link href="/ab14d5fa/"/>
      <url>/ab14d5fa/</url>
      
        <content type="html"><![CDATA[<p><strong>1. nginx 是怎么找index.php 文件的</strong><br>当nginx发现需要<code>/web/echo/index.php</code> 文件时, 就会向内核发起 IO 系统调用(因为要跟硬件打交道, 这里的硬件是指硬盘, 通常需要靠内核来操作, 而内核提供的这些功能是通过系统调用来实现的), 告诉内核, 我需要这个文件, 内核从<code>/</code> 开始找到<code>web</code> 目录, 再在<code>web</code> 目录下找到<code>echo</code> 目录, 最后在<code>echo</code> 目录下找到<code>index.php</code> 文件, 于是把这个<code>index.php</code> 从硬盘上读取到内核自身的内存空间, 然后再把这个文件复制到nginx进程所在的内存空间, 于是 nginx就得到了自己想要的文件了 <strong>2. 寻找文件在文件系统层面是怎么操作的</strong><br>如, nginx 需要得到<code>/web/echo/index.php</code> 这个文件 每个分区(像ext3 等文件系统, block块是文件存储的最小单元, 默认是4096字节) 都是包含元数据区和数据区, 每个文件在元数据区都有元数据条目(一般是128字节大小), 每个条目都有一个编号, 称之为 inode(index node), 这个inode 里包含 文件类型, 权限, 连接次数, 属主和数组的 ID&amp;时间戳, 这个文件占据了哪些磁盘块也就是块的编号(block, 每个文件可以占用多个 block, 且 block 不一定是连续的, 每个 block 都有编号), 如下图:<img src="https://img-blog.csdn.net/20180616013228714?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4YndvbGY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> 目录其实也是普通文件, 也需要占用磁盘块, 目录不是一个容器. 默认创建的目录大小为4096字节, 即只需要占用一个磁盘块, 但这是不确定的. 所以要找到目录也是需要到元数据区里找到对应的条目, 只要找到对应的inode就可以找到目录所占用的磁盘块. 目录里存着一张表(映射表), 里面放着 目录或文件的名称和对应的inode号, 如下:</p><p>-</p><p>-</p><p>文件名称(只是字符串)</p><p>inode 号</p><p>test.txt</p><p>100</p><p>假如</p><pre><code>/           在数据区占据1, 2号 block, `/` 其实也是一个目录, 里面有两个目录, web 和 111web         占据5号 block, 是目录, 里面有2个目录 echo 和 dataecho        占据11号 block, 是目录, 里面有一个文件 index.phpindex.php   占据15, 16号 block, 是文件</code></pre><p>其在文件系统中分布如下图: <img src="https://img-blog.csdn.net/2018061601462786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4YndvbGY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> 那么内核究竟是怎么找到<code>index.php</code> 这个文件的呢? 内核拿到 nginx 的 IO 系统调用要获取<code>/web/echo/index.php</code> 这个文件请求之后,</p><pre><code>1. 内核读取元数据区 / 的inode, 从 inode 里读取 / 所对应的数据块的编号, 然后在数据区找到其对应的块(1, 2号块), 读取1号块上的映射表找到 web 这个名称在元数据区对应的 inode 号2. 内核读取 web 对应的 inode(3号), 从中得到 web 在数据区对应的块是5号块, 于是到数据区找到5号块, 从中读取映射表, 知道 echo 对应的 inode 是5号, 于是到元数据区找到5号 inode3. 内核读取5号 inode, 得到 echo 在数据区对应的事11号块, 于是到数据区读取11号块得到映射表, 得到index.php 对应的 inode 事9号4. 内核到元数据区读取9号 inode, 得到 index.php 对应的事15号和16号数据块, 于是就到数据区域找到15 16号块, 读取其中的内容, 得到 index.php 的完整内容</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议笔记</title>
      <link href="/4e7c79/"/>
      <url>/4e7c79/</url>
      
        <content type="html"><![CDATA[<p>HTTP协议的特点: 1. 支持客户端/服务器模式 2. 简单快速: 客户端向服务器请求服务时, 只需传送请求方法和路径. 请求方法常用的有GET, HEAD, POST. 每种方法规定了客户端与服务器联系的类型. 由于HTTP协议简单, 使得HTTP服务器的程序规模小, 因而通信速度很快. 3. 灵活: HTTP 允许传输任意类型的数据对象. 正在传输的类型由Content-Type加以标记. 4. 无连接: 限制每次连接只处理一个请求. 服务器处理完客户端的请求, 并收到客户端的应答后, 即断开连接. 采用着用方式可以节省传输时间. 5. 无状态: 无状态是指协议对于事务处理没有记忆能力. 缺少状态意味着如果后续处理需要前面的信息, 则它必须重传, 这样可能导致每次传送的数据量增大. 另一方面, 在服务器不需要先前信息时, 它的应答就较快.</p><h5 id="url"><span id="url">URL</span></h5><p>HTTP是一种基于请求与响应模式的, 无状态的, 应用层的协议, 常基于TCP的连接方式, HTTP1.1版本中给出一种持续连接的机制, 绝大多数的web开发, 都是构建在HTTP协议之上的web应用.</p><p>HTTP URL(URL是一种特殊类型的URI, 包含了用于查找某个资源的足够的信息)的格式如下: <code>http://host[:port][abs_path]</code></p><ul><li>http 表示要通过HTTP协议来定位网络资源</li><li>host 表示合法的Internet主机域名或者IP地址</li><li>port 指定端口号, 缺省端口为80</li><li>abs_path 指定请求资源的URI</li><li>若URI 中没有给出abs_path, 那当它作为请求URI时, 必须以”/“ 的形式给出, 通常这个工作浏览器会自动完成</li></ul><h5 id="请求"><span id="请求">请求</span></h5><p>HTTP请求由三部分组成: 请求行, 消息报头, 请求正文</p><h6 id="请求行"><span id="请求行">请求行</span></h6><p>以一个方法符号开头, 以空格分开, 后面跟请求的URI和协议的版本, 格式如下: <code>Method Request-URI HTTP-Version CRLF</code></p><p>请求方法有以下几种 - GET 请求获取Request-URI 所标识的资源 - POST 在Request-URI 表标识的资源后附加新的数据 - HEAD 请求获取由Request-URI 所标识的资源的响应消息报头 - PUT 请求服务器存储一个资源, 并用Request-URI 作为其标识 - DELETE 请求服务器删除Request-URI 所标识的资源 - TRACE 请求服务器会送收到的请求信息, 主要用于测试或诊断 - CONNECT 保留将来使用 - OPTIONS 请求查询服务器的性能, 或查询与资源相关的选项和需求</p><h5 id="响应"><span id="响应">响应</span></h5><p>HTTP响应由三部分组成: 状态行, 消息报头, 响应正文</p><h6 id="状态行"><span id="状态行">状态行</span></h6><p>格式: <code>HTTP-Version Status-Code Reason-Phrase CRLF</code></p><p>状态码由三位数字组成, 第一个数字定义了响应的类别: - 1xx: 指示信息 – 表示请求已接受, 继续处理 - 2xx: 成功 – 表示请求已被成功接收, 理解, 接受 - 3xx: 重定向 – 要完成请求必须进行更进一步的操作 - 4xx: 客户端错误 – 请求有语法错误或请求无法实现 - 5xx: 服务器端错误 – 服务器未能实现合法的请求</p><h5 id="报头"><span id="报头">报头</span></h5><p>HTTP 消息由客户端到服务器的请求和服务器到客户端的响应组成. 请求消息和相应消息都是由开始行(对于请求消息, 开始行就是请求行, 对于响应消息, 开始行就是状态行), 消息报头(可选), 空行(只有CRLF的行), 消息正文(可选) 组成</p><p>HTTP 消息报头包括 普通报头, 请求报头, 响应报头, 实体报头 每一个报头域都是由<code>名字 + &quot;:&quot; + 空格 + 值</code> 组成, 消息报头域的名字是大小写无关的.</p><h6 id="普通报头"><span id="普通报头">普通报头</span></h6><p>在普通报头中, 有少数报头域用于所有的请求和响应消息, 但并用于被传输的实体, 只用于传输的消息 <strong>例:</strong> Cache-Control 用于指定缓存指令, 缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现), 且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制), HTTP1.0使用类似的报头域为Pragma. 请求时的缓存指令包括: no-cache(用于指示请求或相应消息不能缓存), no-store, max-age, max-stale, min-fresh, only-if-cached; 响应时的缓存指令包括: public, private, no-cache, no-store, no-transform, must-revalidate, proxy-revalidate, max-age, s-maxage <strong>eg:</strong> 为了指示IE浏览器(客户端)不要缓存页面, 服务器端的JSP程序可以编写如下: <code>response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</code> 或 <code>response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</code> 两者作用相同, 在发送的响应消息中设置普通报头域: Cache-Control: no-cache.</p><h6 id="请求报头"><span id="请求报头">请求报头</span></h6><p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息.</p><p>常用的请求报头域: <em>Accept</em> Accept 请求报头域用于指定客户端接收哪些类型的信息. 如: <code>Accept:image/gif</code>, 表明客户端希望接收GIF图像格式的资源; <code>Accept:text/html</code>, 表明客户端希望接受html 文本</p><p><em>Accept-Charset</em> 指定客户端接受的字符集. 如: <code>Accept-Charset:iso-8859-1,GB2312</code>. 如果请求消息中没有设置这个域, 缺省是任何字符集都可以接受.</p><p><em>Accept-Encoding</em> 指定可接受的内容编码. 如<code>Accept-Encoding:gzip.deflate</code> 缺省是任何内容编码都可以接受</p><p><em>Accept-Language</em> 指定一种自然语言. 如 <code>Accept-Language:zh-cn</code> 缺省是任何语言都可以接受</p><p><em>Authorization</em> 用于证明客户端有权查看某个资源. 当浏览器访问一个页面时, 如果收到服务器的响应代码为401, 可以发送一个包含Authorization请求报头域的请求, 要求服务器对其进行验证</p><p><em>Host</em>(发送请求时, 该报头域是必需的) 指定被请求资源的Internet主机和端口号, 通常从HTTP URL中提取出来</p><p><em>User-Agent</em> 允许客户端将它的操作系统, 浏览器和其他属性告诉服务器. 不过这个报头域不是必需的, 如果我们自己写一个浏览器, 不使用User-Agent 请求报头域, 那么服务器端就无法得知我们的信息了.</p><p><em>请求报头示例</em></p><pre><code>GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbigmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)Accept-Language:zh-cn (CRLF)Acdept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:Mozilla/4.0(compatible;MSIE6.0,Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF)</code></pre><h6 id="响应报头"><span id="响应报头">响应报头</span></h6><p>响应报头允许服务器传递不能放在状态行中的附加响应信息, 以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息</p><p><em>Location</em> 重定向接受者到一个新的位置. Location响应报头域常用在更换域名的时候</p><p><em>Server</em> 包含了服务器用来处理请求的软件信息. 与<code>User-Agent</code> 请求报头域是相对应的 例: <code>Server:Apache-Coyote/1.1</code></p><p><em>WWW-Authenticate</em> WWW-Authenticate 响应报头域必须包含在401响应消息中, 客户端收到401响应消息的时候, 并发送Authorization报头域请求服务器对其进行验证时, 服务端响应报头就包含该报头域 例: <code>WWW-Authenticate:Basic realm=&quot;Basic Auth Test!</code></p><h6 id="实体报头"><span id="实体报头">实体报头</span></h6><p>请求和响应消息都可以传送一个实体. 一个实体由实体报头域和实体正文组成, 但并不是实体报头域和实体正文要在一起发送, 可以只发送实体报头域. 实体报头定义了关于实体正文(如: 有无实体正文) 和请求所标识的资源的元信息.</p><p><em>Content-Encoding</em> 被用作媒体类型的修饰符, 它的值指示了已经被应用到实体正文的附加内容的编码, 因而要获得Content-Type 报头域中所引用的媒体类型, 必须采用相应的解码机制.</p><p><em>Content-Language</em> 描述了资源所用的自然语言. 没有设置该域则认为实体内容将提供给所有的语言阅读</p><p><em>Content-Length</em> 指明实体正文的长度, 以字节方式存储的十进制数字来表示</p><p><em>Content-Type</em> 指明发送给接受者的实体正文的媒体类型 例: <code>Content-Type:text/html;charset=ISO-8859-1</code> <code>Content-Type:text/html;charset=GB2312</code></p><p><em>Last-Modified</em> 指示资源的最后修改日期和时间</p><p><em>Expires</em> 给出响应国企的日期和时间. 为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时, 直接从缓存中加载, 缩短响应时间和降低服务器负载) 的页面, 我们可以使用Expires 实体报头域指定页面过期的时间. 例: <code>Expires:Thu, 15 Sep 2006 16:23:12 GMT</code></p><p>HTTP1.1 的客户端和缓存必须将其他非法的日期格式(包括0) 看作已经过期 为了让浏览器不要缓存页面, 我们也可以利用Expires 实体报头域设置为0, jsp中程序如下: <code>response.setDateHeader(&quot;Expires&quot;, &quot;0&quot;);</code></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt 同步方式发送post 请求</title>
      <link href="/c57f4e3b/"/>
      <url>/c57f4e3b/</url>
      
        <content type="html"><![CDATA[<p>不成功的方式: 1. QNetworkReply的isFinished()函数, 通过while循环判断reply是否已经结束, 结束后再调用readAll()读取响应信息, 结果与判断isRunning() 方式结果一样, 都会进入死循环, 没有响应. 2. QNetworkReply继承自QIODevice, 尝试调用QIODevice的waitForReadyRead()方法, 结果不阻塞, 直接返回</p><p>成功的方式: 使用QEventLoop来阻塞运行, 知道信号发出</p><pre><code>QNetworkReply *reply = _manager-&gt;post(QNetworkRequest(QUrl(SERVER_URL)), data);QByteArray responseData;QEventLoop eventLoop;connect(_manager, SIGNAL(finished(QNetworkReply*)), &amp;eventLoop, SLOT(quit()));eventLoop.exec();       //block until finishresponseData = reply-&gt;readAll();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qt 程序打包</title>
      <link href="/7e8574d1/"/>
      <url>/7e8574d1/</url>
      
        <content type="html"><![CDATA[<h6 id="设置程序图标"><span id="设置程序图标">设置程序图标</span></h6><ol><li>把ico文件放到源文件目录下, 命名为”test.ico”</li><li>创建一个<code>myico.rc</code> 文件, 输入如下内容 <code>IDI_ICON1 ICON DISCARDABLE &quot;test.ico&quot;</code></li><li>在pro文件写入 <code>RC_FILE = myico.rc</code></li><li>执行qmake, 编译</li></ol><h6 id="编译-打包"><span id="编译-打包">编译, 打包</span></h6><ol><li>选择release编译运行</li><li>将生成的exe文件放到某个路径下, 如 <code>Desktop/Test</code></li><li>在cmd里, 进入到exe存放路径, 使用wendeployqt工具拷贝exe运行需要的dll</li><li>使用Inno Setup Compiler生成安装文件</li></ol><h6 id="inno-setup-工具使用注意事项"><span id="inno-setup-工具使用注意事项">Inno Setup 工具使用注意事项</span></h6><ul><li>添加主执行文件外的其他应用程序文件夹下的文件时, 需要编辑一次, 重新指定目标子文件夹</li><li>编译脚本为<code>*.iss</code> 文件, 编译后默认在源exe的Base 目录下生成Output文件夹, 指定的setup.exe文件生成在Output 文件夹下</li><li>Inno Setup 工具基础版不支持中文. 如需显示中文, 需要找汉化版</li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gerrit + apache 安装</title>
      <link href="/2eb2e06d/"/>
      <url>/2eb2e06d/</url>
      
        <content type="html"><![CDATA[<p>使用gerrit自带的数据库h2, 验证方式为HTTP, SMTP 服务器未配置</p><h6 id="git-安装"><span id="git-安装">git 安装</span></h6><p>可直接从yum 源安装</p><h6 id="gerrit-安装"><span id="gerrit-安装">gerrit 安装</span></h6><p>先添加gerrit 用户. gerrit 从2.10开始, 换成了新版界面. 几乎国内所有的镜像都会下载失败, 需要翻墙下载. 下载完成后, 初始化命令为: <code>java -jar gerrrit-war init -d /home/gerrit/repository</code></p><p>初始化启动时, “Authentication method” 设为”http” ,其他默认 “Listen on port [8080]“ 可用默认, 如端口被占用, 初始化后也可在配置文件修改</p><h6 id="apache-安装"><span id="apache-安装">apache 安装</span></h6><p>直接从yum源安装 apache名字为httpd, 服务名也是httpd. 服务启动后, 默认以apache用户运行. 如需访问其他用户的文件, 如<code>/home/gerrit/repository/htpasswd</code>, 需要确保apache 用户有足够的权限</p><h6 id="配置-apache"><span id="配置-apache">配置 apache</span></h6><p>修改 apache 的conf 文件, 一般路径为<code>/etc/httpd/conf/httpd.conf</code> windows 下的配置文件路径为 <code>INSTALL_DIR/conf/httpd.conf</code></p><p>去掉下面几行的注释</p><pre><code>LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_connect_module modules/mod_proxy_connect.soLoadModule proxy_http_module modules/mod_proxy_http.soLoadModule proxy_ftp_module modules/mod_proxy_ftp.soLoadModule negotiation_module modules/mod_negotiation.so</code></pre><p>在最后追加下面配置</p><pre><code>&lt;VirtualHost *:8080&gt;    ServerName v3server  ProxyRequests Off    ProxyVia Off    ProxyPreserveHost On    &lt;Proxy *:8080&gt;          Order deny,allow          Allow from all    &lt;/Proxy&gt;      &lt;Location /login/&gt;      AuthType Basic      AuthName &quot;Gerrit Code Review&quot;      Require valid-user     AuthUserFile D:/git/htpasswd    &lt;/Location&gt;  ProxyPass / http://10.14.132.179:9080/  ProxyPassReverse / http://10.14.132.179:9080/&lt;/VirtualHost&gt;</code></pre><p>如端口被占用, 修改conf文件的”Listen 8080” 字段, 换成其他的端口 查看某个端口是否被占用 : <code>netstat -lnp | grep 8080</code> <code>ProxyPass</code> 和 <code>proxyPassReverse</code> 的端口需与gerrit的conf文件里端口一致</p><h6 id="配置-gerrit"><span id="配置-gerrit">配置 gerrit</span></h6><p>修改<code>GERRIT_DIR/etc/gerrit.config</code> 文件</p><pre><code>[gerrit]basePath = gitcanonicalWebUrl = http://10.14.132.179:9080/[database]type = H2database = db/ReviewDB[auth]type = HTTPlogoutUrl = http://aa:aa@10.14.132.179:8080/[sendemail]smtpServer = smtp.163.comsmtpUser = useremail@163.com  smtpPass = userpass  from = useremail@163.com[container]user = adminjavaHome = C:\\Program Files\\Java\\jdk1.6.0_27\\jre[sshd]listenAddress = *:29418[httpd]listenUrl = http://10.14.132.179:9080/[cache]directory = cache</code></pre><p>需要修改的内容: - canonicalWebUrl - auth/type</p><p>需要注意: canonicalWebUrl 和 listenAddress 不是8080. apache 的端口和 gerrit 的端口是不同的, 用户访问地址为 apache 的地址</p><h6 id="启动-gerrit"><span id="启动-gerrit">启动 gerrit</span></h6><p><code>GERRIT_DIR/bin/gerrit.sh start</code></p><h6 id="启动-apache"><span id="启动-apache">启动 apache</span></h6><p><code>service httpd start</code></p><h6 id="添加账号和密码"><span id="添加账号和密码">添加账号和密码</span></h6><p><code>htpasswd -cm /home/gerrit/repository/htpasswd USER_NAME</code></p><ul><li>htpasswd 为apache 的命令工具</li><li>参数c 意为新建文件, 即 <code>/home/gerrit/repository/htpasswd</code> 文件不存在时, 新建名为htpasswd的文件</li><li>参数m 为使用md5 加密</li><li>当htpasswd文件存在时, 可以使用<code>htpasswd -m /PATH_TO_HTPASSWD USER_NAME</code> 添加账号</li><li>保存账号密码信息的文件(htpasswd), 名字为自定义的, 但需要与apache 的conf 配置文件里 <code>AuthUserFile</code> 一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 工程的几种文件</title>
      <link href="/924904f6/"/>
      <url>/924904f6/</url>
      
        <content type="html"><![CDATA[<h4 id="pro"><span id="pro"><code>*.pro</code></span></h4><p>qmake的工程(project)文件 例子:</p><pre><code>TEMPLATE = appCONFIG += QTQT += core guiTARGET = somenameSOURCES += main.cpp \          widget.cppHEADERS += widget.hFORMS += widget.ui</code></pre><ul><li>前三行是qmake的默认值, 都可以省略</li><li>TARGET 行指定工程名, 也可以省略</li></ul><h4 id="pri"><span id="pri"><code>*.pri</code></span></h4><p>include 文件 接上面的例子, 我们可以将源文件的设置独立处理, 放到somename.pri文件内:</p><pre><code>SOURCES += main.cpp \          widget.cppHEADERS += widget.hFORMS += widget.ui</code></pre><p>这时, pro 文件就可以简化为:</p><pre><code>TEMPLATE = appCONFIG += QTQT += core guiTARGET = somenameinclude(somename.pri)</code></pre><h4 id="prf"><span id="prf"><code>*.prf</code></span></h4><p>特性(feature) 文件 和pri文件类似, prf文件也是要被包含进pro文件. 只是它更隐蔽.</p><p>在上面的例子中, 其实已经用到了prf, 就是 <code>CONFIG += QT</code></p><p>当在CONFIG 中指定一个值时, qmake就会尝试去加载相应的feature文件: - Qt安装目录下的<code>mkspecs/features/qt.prf</code> - features 文件的文件名必须小写</p><p>例子:</p><pre><code>win32:CONFIG += console // 为win32程序添加控制台</code></pre><p>把该文件命名为<code>a.prf</code>, 放到前面提到的目录中, 然后在pro文件内添加 <code>CONFIG += a</code></p><p>也可以使用load命令来加载prf文件 <code>load(a)</code></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt UI 编码规范</title>
      <link href="/9c64b54d/"/>
      <url>/9c64b54d/</url>
      
        <content type="html"><![CDATA[<h5 id="变量声明"><span id="变量声明">变量声明</span></h5><ul><li><p>每行只声明一个变量</p></li><li><p>避免使用短的/无意义的命名</p></li><li><p>当一个变量被用到时再声明</p><pre><code>// Wrongint a, b;char* c, * d;// Correctint height;int width;char* nameOfOne;char* nameOfOther;</code></pre></li></ul><h5 id="变量命名"><span id="变量命名">变量命名</span></h5><ul><li><p>变量名/函数名采用驼峰命名法(lowerCaseCamel), 首字母缩写词出现的命名中, 缩写也用驼峰命名</p><pre><code>// Wrong short Cntr;char ITEM_DELIM = &apos;&apos;;void myXMLStreamReader();// Correctshort counter;char itemDelimiter = &apos;&apos;;void myXmlStreamReader();</code></pre></li></ul><h5 id="空行空格"><span id="空行空格">空行/空格</span></h5><ul><li><p>用一个且仅用一个空行在适当的地方划分代码块</p></li><li><p>在关键词和小括号之间总是只用一个空格符</p><pre><code>// Wrongif(foo){}// Correctif (foo){}</code></pre></li></ul><h5 id="指针引用"><span id="指针引用">指针/引用</span></h5><ul><li><p>在类型名和<code>*</code>或<code>&amp;</code>之间没有空格, 在<code>*</code>或<code>&amp;</code>与变量名之间有一个空格</p><pre><code>char* someValue;const QString&amp; myString;const char* const WOR = &quot;hello&quot;;</code></pre></li></ul><h5 id="符号与空格"><span id="符号与空格">符号与空格</span></h5><ul><li>二元操作符左右两边都有一个空格</li><li>一元操作符与变量之间不留空格</li><li>逗号左右没有空格, 右边一个空格</li><li>分号左边没有空格; 分号作为语句的结束符, 右边一般不再有内容</li><li><code>#</code>号右边没有空格</li><li>左引号的左边和右引号的各一个空格, 左引号的右边和右引号的左边没有空格</li><li>如果右引号右边是右括号, 它们之间没有空格</li></ul><h5 id="cast"><span id="cast">cast</span></h5><ul><li><p>避免C语言的cast, 尽量用C++的cast(static_cast, const_cast, reinterpret_cast). reinterpret_cast 和 C风格的cast用起来都是危险的，但至少 reinterpret_cast 不会把const修饰符去掉</p></li><li><p>涉及到QObjects或重构自己的代码时，不要使用dynamic_cast,而是用qobject_cast，例如在引进一个类型的方法时</p></li><li><p>用构造函数去cast简单类型,例如：用int(myFloat)代替(int)myFloat</p><pre><code>// Wrongchar* blockOfMemory = (char* ) malloc(data.size());// Correctchar *blockOfMemory = reinterpret_cast&lt;char *&gt;(malloc(data.size()));</code></pre></li></ul><h5 id="语句"><span id="语句">语句</span></h5><ul><li>不要在一行写多条语句</li></ul><h5 id="括号"><span id="括号">括号</span></h5><ul><li><p>每个大括号单独一行</p></li><li><p>不论条件语句的执行部分有几行, 必须使用大括号</p></li><li><p>小括号用来给语句分组</p><p> // Wrong<br> if (address.isEmpty()) {</p><pre><code>return false;</code></pre><p> }</p><p> for (int i = 0; i &lt; 10; +’’i) {</p><pre><code>qDebug(&quot;%i&quot;, i);</code></pre><p> }</p><p> // Correct<br> if (address.isEmpty())<br> {</p><pre><code>return false;</code></pre><p> }<br> else<br> {</p><pre><code>return true;</code></pre><p> }</p><p> for (int i = 0; i &lt; 10;i)<br> {</p><pre><code>qDebug(&quot;%i&quot;, i);</code></pre><p> }</p></li></ul><pre><code>// Wrongif (a &amp;&amp; b || c)// Correctif ((a &amp;&amp; b) || c)// Wronga + b &amp; c// Correct(a + b) &amp; c</code></pre><h5 id="switch语句"><span id="switch语句">switch语句</span></h5><ul><li><p>case缩进</p></li><li><p>除enum外, 每组case最后都要加default;</p><p> switch (myEnum)<br> {</p><pre><code>case Value1:    doSomething();break;case Value2:case Value3:    doSomethingElse();    // fall throughbreak;default:    defaultHandling();break;</code></pre><p> }</p></li></ul><h5 id="goto"><span id="goto">goto</span></h5><ul><li>禁止使用goto</li></ul><h5 id="换行"><span id="换行">换行</span></h5><ul><li><p>每行代码不多于120字符</p></li><li><p>逗号在行尾. 操作符在新行的开头位置</p></li><li><p>换行时尽量避免行与行之间看起来参差不齐</p><p> // Wrong<br> if (longExpression +</p><pre><code>otherLongExpression +otherOtherLongExpression) {</code></pre><p> }</p><p> // Correct<br> if (longExpression</p><pre><code>+ otherLongExpression+ otherOtherLongExpression) {</code></pre><p> }</p></li></ul><h5 id="c特性"><span id="c特性"><code>C++</code>特性</span></h5><ul><li>不要使用异常处理</li><li>不要使用运行时类型识别</li><li>理智地使用模板</li></ul><h5 id="qt源码中的规范"><span id="qt源码中的规范">Qt源码中的规范</span></h5><ul><li>所有代码都是ascii，使用者如果不确定的话，只可能是7字节</li><li>每一个QObject的子类都必须有Q_OBJECT宏，即使这个类没用到信号或槽。否则qobject_cast将不能使用</li><li>在connect语句中，使信号和槽的参数规范化（参看 QMetaObject::normalizedSignature），可以加快信号/槽的查找速度。可以使用qtrepotools/util/normalize规范已有代码</li></ul><h5 id="包含头文件顺序"><span id="包含头文件顺序">包含头文件顺序</span></h5><ol><li>源文件对应的头文件</li><li>&lt;分隔&gt;</li><li>C系统文件</li><li>&lt;分隔&gt;</li><li>C++系统文件</li><li>&lt;分隔&gt;</li><li>Qt库文件</li><li>&lt;分隔&gt;</li><li>其他目录</li></ol><p>每组文件按字母升序排列</p><h5 id="编译器平台"><span id="编译器平台">编译器/平台</span></h5><ol><li><p>使用三目运算符 ？时要特别小心，如果每次的返回值的类型可能不一样的话，一些编译器会在运行时生成冲突的代码（此时编译器甚至不会报错） <code>QString s; return condition ? s : &quot;nothing&quot;; // crash at runtime - QString vs. const char *</code></p></li><li><p>要特别小心对齐问题。无论何时，当一个指针被cast后的对齐数是增加的时候，它都可能会崩溃。例如一个const char 被cast成了cons int，当cast之后的数字不得不在2或4个字节之间对齐时，指针就会在机器上崩溃</p></li><li><p>任何需要需要执行构造函数或相关代码进行初始化的实例，都不能用作库代码中的全局实例。因为当构造函数或代码将要运行的时候，该实例还没有被定义（在第一次调用该实例时，在加载库时，在执行main()之前） <code>// global scope static const QString x; // Wrong - default constructor needs to be run to initialize x static const QString y = &quot;Hello&quot;; // Wrong - constructor that takes a const char * has to be run QString z; // super wrong static const int i = foo(); // wrong - call time of foo() undefined, might not be called at all</code> 可以使用下面方法: <code>// global scope static const char x[] = &quot;someText&quot;; // Works - no constructor must be run, x set at compile time static int y = 7; // Works - y will be set at compile time static MyStruct s = {1, 2, 3}; // Works - will be initialized statically, no code being run static QString *ptr = 0; // Pointers to objects are ok - no code needed to be run to initialize ptr</code></p></li><li><p>用Q_GLOBAL_STATIC定义全局实例</p><pre><code> Q_GLOBAL_STATIC(QString, s)void foo(){ s()-&gt;append(&quot;moo&quot;);}</code></pre></li></ol><ol start="5"><li>char型变量是有符号的还是无符号的取决于它运行环境的架构。如果你明确地想使用一个signed或unsinged char，就使用signed char或unsigned char。以下代码运行在把char默认为无符号的平台上时，其条件判断恒为真 <code>char c; // c can&#39;t be negative if it is unsigned /********/ /*******/ if (c &gt; 0) { … } // WRONG - condition is always true on platforms where the default is unsigned</code></li><li>避免64位的枚举值<ul><li>嵌入式应用系统二进制接口将所有的枚举类型的值硬编码成32位int值</li><li>微软的编译器不支持64位的枚举值</li></ul></li></ol><h5 id="编程偏好"><span id="编程偏好">编程偏好</span></h5><ul><li>用枚举值定义常量而非用const int或defines<ul><li>枚举值会在编译时被编译器用实际值替换掉，因而运行时得出结果的速度更快</li><li>defines不是命名空间安全的（并且看起来很丑）</li></ul></li><li>当重新实现一个虚方法时，在Qt5中，用 Q_DECL_OVERRIDE宏在函数声明之后，分号之前注解它</li><li>不要把const-iterator和none-const iterator搞混 <code>for (Container::const_iterator it = c.begin(); it != c.end(); ++it) // Wrong for (Container::const_iterator it = c.cbegin(); it != c.cend(); ++it) // Right</code></li></ul><h5 id="命名空间"><span id="命名空间">命名空间</span></h5><ul><li>除跟UI直接交互的类外, 其他类必须处在命名空间内</li></ul><h5 id="float值"><span id="float值">float值</span></h5><ul><li>用qFuzzyCompare去和delta比较其值</li><li>用qIsNull去判断float值是不是二进制0，而不是和0.0比较 <code>[static] bool qFuzzyCompare(double p1, double p2) // Instead of comparing with 0.0 qFuzzyCompare(0.0,1.0e-200); // This will return false // Compare adding 1 to both values will fix the problem qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true</code></li></ul><h5 id="类的成员命名"><span id="类的成员命名">类的成员命名</span></h5><ul><li><p>成员变量一般为名词</p></li><li><p>函数成员一般为动词/动词+名词，但是当动词为get时，get常常省略。当返回值为Bool型变量时，函数名一般以前缀’is’开头</p><pre><code>public:    void setColor(const QColor&amp; c);    QColor color() const;    void setDirty(bool b);    bool isDirty() const;private Q_SLOTS:    void onParentChanged();</code></pre></li></ul><h5 id="构造函数"><span id="构造函数">构造函数</span></h5><ul><li>为了使构造函数被错误使用的可能性降到最小，每一个构造函数（除了拷贝构函数）都应该检查自己是否需要加上explicit 符号</li></ul><h5 id="注意代码陷阱"><span id="注意代码陷阱">注意代码陷阱</span></h5><ul><li>不要为了图方便少些一些代码。因为代码是一次书写，后期不止一次地要去理解。例如 <code>QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, &quot;volume&quot;);</code></li><li>改成下面的方式会更容易理解 <code>QSlider *slider = new QSlider(Qt::Vertical); slider-&gt;setRange(12, 18); slider-&gt;setPageStep(3); slider-&gt;setValue(13); slider-&gt;setObjectName(&quot;volume&quot;);</code></li></ul><h5 id="参考资料"><span id="参考资料">参考资料</span></h5><ol><li><a href="https://wiki.qt.io/Qt\_Contribution\_Guidelines" target="_blank" rel="noopener">https://wiki.qt.io/Qt\_Contribution\_Guidelines</a></li><li><a href="https://wiki.qt.io/Qt\_Coding\_Style" target="_blank" rel="noopener">https://wiki.qt.io/Qt\_Coding\_Style</a></li><li><a href="https://wiki.qt.io/Coding_Conventions" target="_blank" rel="noopener">https://wiki.qt.io/Coding_Conventions</a></li><li><a href="https://community.kde.org/Policies/Library\_Code\_Policy" target="_blank" rel="noopener">https://community.kde.org/Policies/Library\_Code\_Policy</a></li><li><a href="https://wiki.qt.io/UI\_Text\_Conventions" target="_blank" rel="noopener">https://wiki.qt.io/UI\_Text\_Conventions</a></li><li><a href="https://wiki.qt.io/API\_Design\_Principles" target="_blank" rel="noopener">https://wiki.qt.io/API\_Design\_Principles</a></li><li><a href="http://doc.qt.io/qt-5/qml-codingconventions.html" target="_blank" rel="noopener">http://doc.qt.io/qt-5/qml-codingconventions.html</a></li><li><a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">https://google.github.io/styleguide/cppguide.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7升级gcc 和gdb</title>
      <link href="/ec9feff6/"/>
      <url>/ec9feff6/</url>
      
        <content type="html"><![CDATA[<p>升级后版本: gcc-5.4.0 gdb-7.11.1</p><h4 id="安装开发必备环境"><span id="安装开发必备环境">安装开发必备环境</span></h4><pre><code>yum groupinstall &quot;Development Tools&quot;yum install glibc-static libstdc++-static</code></pre><h4 id="编译安装gcc-540"><span id="编译安装gcc-540">编译安装gcc-5.4.0</span></h4><p><a href="http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/" target="_blank" rel="noopener">gcc下载地址</a></p><pre><code>tar -xvf gcc-5.4.0.tar.bz2cd gcc-5.4.0./contrib/download_prerequisitsmkdir buildcd build../configure --enable-checking=release --enable-languages=c,c++ --disable-multilibmake（建议不要使用make -j来编译，虽然可以缩短编译时间，但极大可能会编译失败）make install</code></pre><p>其中执行<code>./contrib/download_prerequisits</code>将自动下载以下几个文件，这个几个文件在gcc编译时需要： - mpfr-2.4.2.tar.bz2 - gmp-4.3.2.tar.bz2 - mpc-0.8.1.tar.gz - isl-0.15.tar.bz2</p><p><code>make install</code> 时, 自动安装到<code>/usr/local/gcc-5.40</code></p><h4 id="解决运行程序时-gcc-报错glibcxx_3421-not-found"><span id="解决运行程序时-gcc-报错glibcxx_3421-not-found">解决运行程序时, gcc 报错’GLIBCXX_3.4.21’ not found</span></h4><p>这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决，运行以下命令检查动态库： <code>strings /lib64/libstdc++.so.6 | grep GLIBC</code></p><p>以下是输出结果：</p><pre><code>GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_3.4.14GLIBCXX_3.4.15GLIBCXX_3.4.16GLIBCXX_3.4.17GLIBCXX_3.4.18GLIBCXX_3.4.19GLIBC_2.3GLIBC_2.2.5GLIBC_2.14GLIBC_2.4GLIBC_2.3.2GLIBCXX_DEBUG_MESSAGE_LENGTH</code></pre><p>从输出结果可以看到并没有“GLIBCXX_3.4.21“,所以可以断定我们的程序运行时动态加载的是老的动态库，解决这个问题需要将当前链接文件的链接指向改成最新的动态库地址：</p><pre><code>cp /usr/local/lib64/libstdc++.so.6.0.21 /lib64cd /lib64rm -rf libstdc++.so.6ln -s libstdc++.so.6.0.21 libstdc++.so.6</code></pre><p>然后你可以执行以下命令来查看’GLIBCXX_3.4.21’已经可以找到了: <code>strings /lib64/libstdc++.so.6 | grep GLIBC</code></p><p>解决了这个问题终于可以执行程序了，然后又测试了-g选项来编译程序，编译好程序调试程序时并不能够设置断点以及print变量的值，gdb调试中出现：Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.e17_2.6.x86_4 libgcc-4.8.5-4.e17.x86_64的问题，通过上网查阅资料，是因为gcc版本和gdb版本并不匹配，或者说gdb版本过低</p><h4 id="编译安装gdb-7111"><span id="编译安装gdb-7111">编译安装gdb-7.11.1</span></h4><p><a href="http://ftp.gnu.org/gnu/gdb/" target="_blank" rel="noopener">gdb下载地址</a></p><pre><code>tar -xvf gdb-7.11.1.tar.gzcd gdb-7.11.1./configuremakemake install</code></pre><p>当执行make install时gdb安装出现了错误：<code>WARNING: &#39;makeinfo&#39; is missing on your sysem</code>，则需安装相关依赖程序: <code>yum install texinfo libncurses5-dev</code></p><p>如果调试程序时出现下面信息时：</p><pre><code>warning: File &quot;/usr/local/lib64/libstdc++.so.6.0.21-gdb.py&quot; auto-loading has been declined by your `auto-load safe-path&apos; set to &quot;$debugdir:$datadir/auto-load&quot;.To enable execution of this file add    add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.pyline to your configuration file &quot;/root/.gdbinit&quot;.To completely disable this security protection add    set auto-load safe-path /line to your configuration file &quot;/root/.gdbinit&quot;.</code></pre><p>解决方法: 将以下信息放入<code>~/.gdbinit</code></p><pre><code>add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.pyset auto-load safe-path /</code></pre><p>若想通过gdb来调试STL容器，则还需要做一些配置，可以通过<code>GDB Python pretty printers</code>来解决这个问题：</p><pre><code>svn checkout svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python stlPrettyPrintermv stlPrettyPrinter /usr/local</code></pre><p>然后将下面的配置信息放入<code>~/.gdbinit</code></p><pre><code>pythonimport syssys.path.insert(0, &apos;/usr/local/stlPrettyPrinter&apos;)from libstdcxx.v6.printers import register_libstdcxx_printersregister_libstdcxx_printers (None)end</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 视音频同步</title>
      <link href="/aeb01c06/"/>
      <url>/aeb01c06/</url>
      
        <content type="html"><![CDATA[<p>原文地址: <a href="https://blog.csdn.net/nonmarking/article/details/50522413" target="_blank" rel="noopener">https://blog.csdn.net/nonmarking/article/details/50522413</a></p><p>对于直播流来说, 只考虑发送端的同步问题, 原理如下: 1. 解析视音频, 讲视频流和音频流的时间戳用同样的时间基准表示 2. 比较转换后的两个时间戳, 找出较小值, 对应发送偏慢的流 3. 读取, 转码, 发送相应的流, 同时, 若该流的转码时间很快, 超前于wall clock, 则还需要进行相应的延时 4. 重复以上过程</p><p>下文包括两部分, 一是音频转码部分, 二是视音频同步</p><h6 id="音频转码基本流程"><span id="音频转码基本流程">音频转码基本流程</span></h6><p>首先是一些音频输入输出的基本设置</p><pre><code>//Set own audio device&apos;s name    if (avformat_open_input(&amp;ifmt_ctx_a, device_name_a, ifmt, &amp;device_param) != 0){        printf(&quot;Couldn&apos;t open input audio stream.（无法打开输入流）\n&quot;);        return -1;    }……//input audio initialize    if (avformat_find_stream_info(ifmt_ctx_a, NULL) &lt; 0)    {        printf(&quot;Couldn&apos;t find audio stream information.（无法获取流信息）\n&quot;);        return -1;    }    audioindex = -1;    for (i = 0; i &lt; ifmt_ctx_a-&gt;nb_streams; i++)    if (ifmt_ctx_a-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO)    {        audioindex = i;        break;    }    if (audioindex == -1)    {        printf(&quot;Couldn&apos;t find a audio stream.（没有找到视频流）\n&quot;);        return -1;    }    if (avcodec_open2(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec, avcodec_find_decoder(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;codec_id), NULL) &lt; 0)    {        printf(&quot;Could not open audio codec.（无法打开解码器）\n&quot;);        return -1;    }…… //output audio encoder initialize    pCodec_a = avcodec_find_encoder(AV_CODEC_ID_AAC);    if (!pCodec_a){        printf(&quot;Can not find output audio encoder! (没有找到合适的编码器！)\n&quot;);        return -1;    }    pCodecCtx_a = avcodec_alloc_context3(pCodec_a);    pCodecCtx_a-&gt;channels = 2;    pCodecCtx_a-&gt;channel_layout = av_get_default_channel_layout(2);    pCodecCtx_a-&gt;sample_rate = ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate;    pCodecCtx_a-&gt;sample_fmt = pCodec_a-&gt;sample_fmts[0];    pCodecCtx_a-&gt;bit_rate = 32000;    pCodecCtx_a-&gt;time_base.num = 1;    pCodecCtx_a-&gt;time_base.den = pCodecCtx_a-&gt;sample_rate;    /** Allow the use of the experimental AAC encoder */    pCodecCtx_a-&gt;strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;    /* Some formats want stream headers to be separate. */    if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)        pCodecCtx_a-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;    if (avcodec_open2(pCodecCtx_a, pCodec_a, NULL) &lt; 0){        printf(&quot;Failed to open ouput audio encoder! (编码器打开失败！)\n&quot;);        return -1;    }    //Add a new stream to output,should be called by the user before avformat_write_header() for muxing    audio_st = avformat_new_stream(ofmt_ctx, pCodec_a);    if (audio_st == NULL){        return -1;    }    audio_st-&gt;time_base.num = 1;    audio_st-&gt;time_base.den = pCodecCtx_a-&gt;sample_rate;    audio_st-&gt;codec = pCodecCtx_a;</code></pre><p>接下来, 考虑到输入音频的sample format 可能需要进行转换, 需要用到swresample库的功能 先做好相应的初始化</p><pre><code>// Initialize the resampler to be able to convert audio sample formats    aud_convert_ctx = swr_alloc_set_opts(NULL,        av_get_default_channel_layout(pCodecCtx_a-&gt;channels),        pCodecCtx_a-&gt;sample_fmt,        pCodecCtx_a-&gt;sample_rate,        av_get_default_channel_layout(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;channels),        ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_fmt,        ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate,        0, NULL);swr_init(aud_convert_ctx);</code></pre><p>此外, 参照transcode_aac.c的做法, 使用FIFO buffer存储从输入端解码得到的音频采样数据, 这些数据在后续将转换sample format并进行编码, 由此即完成了一个音频转码功.</p><p>此外, 还需要另外的一个buffer来存储转换合适之后的音频数据</p><pre><code>//Initialize the FIFO buffer to store audio samples to be encoded.     AVAudioFifo *fifo = NULL;    fifo = av_audio_fifo_alloc(pCodecCtx_a-&gt;sample_fmt, pCodecCtx_a-&gt;channels, 1);    //Initialize the buffer to store converted samples to be encoded.    uint8_t **converted_input_samples = NULL;    /**    * Allocate as many pointers as there are audio channels.    * Each pointer will later point to the audio samples of the corresponding    * channels (although it may be NULL for interleaved formats).    */    if (!(converted_input_samples = (uint8_t**)calloc(pCodecCtx_a-&gt;channels,        sizeof(**converted_input_samples)))) {        printf(&quot;Could not allocate converted input sample pointers\n&quot;);        return AVERROR(ENOMEM);    }</code></pre><p>至此, 一些基本的初始化工作完成.</p><p>音频计算pts的方法和视频类似. 即先通过sample rate算出每两个音频sample之间的时间间隔, 再通过计数当前已编码的音频sample总数(nb_samples变量的作用) 来算出当前编码音频帧的时间戳. 如果和视频的流程做类比, 大概为: framerate 相当于sample rate, framecnt相当于nb_samples.</p><pre><code>//audio trancoding here        const int output_frame_size = pCodecCtx_a-&gt;frame_size;        /**        * Make sure that there is one frame worth of samples in the FIFO        * buffer so that the encoder can do its work.        * Since the decoder&apos;s and the encoder&apos;s frame size may differ, we        * need to FIFO buffer to store as many frames worth of input samples        * that they make up at least one frame worth of output samples.        */        while (av_audio_fifo_size(fifo) &lt; output_frame_size) {            /**            * Decode one frame worth of audio samples, convert it to the            * output sample format and put it into the FIFO buffer.            */            AVFrame *input_frame = av_frame_alloc();            if (!input_frame)            {                ret = AVERROR(ENOMEM);                return ret;            }                       /** Decode one frame worth of audio samples. */            /** Packet used for temporary storage. */            AVPacket input_packet;            av_init_packet(&amp;input_packet);            input_packet.data = NULL;            input_packet.size = 0;            /** Read one audio frame from the input file into a temporary packet. */            if ((ret = av_read_frame(ifmt_ctx_a, &amp;input_packet)) &lt; 0) {                /** If we are at the end of the file, flush the decoder below. */                if (ret == AVERROR_EOF)                {                    encode_audio = 0;                }                else                {                    printf(&quot;Could not read audio frame\n&quot;);                    return ret;                }                               }            /**            * Decode the audio frame stored in the temporary packet.            * The input audio stream decoder is used to do this.            * If we are at the end of the file, pass an empty packet to the decoder            * to flush it.            */            if ((ret = avcodec_decode_audio4(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec, input_frame,                &amp;dec_got_frame_a, &amp;input_packet)) &lt; 0) {                printf(&quot;Could not decode audio frame\n&quot;);                return ret;            }            av_packet_unref(&amp;input_packet);            /** If there is decoded data, convert and store it */            if (dec_got_frame_a) {                /**                * Allocate memory for the samples of all channels in one consecutive                * block for convenience.                */                if ((ret = av_samples_alloc(converted_input_samples, NULL,                    pCodecCtx_a-&gt;channels,                    input_frame-&gt;nb_samples,                    pCodecCtx_a-&gt;sample_fmt, 0)) &lt; 0) {                    printf(&quot;Could not allocate converted input samples\n&quot;);                    av_freep(&amp;(*converted_input_samples)[0]);                    free(*converted_input_samples);                    return ret;                }                /**                * Convert the input samples to the desired output sample format.                * This requires a temporary storage provided by converted_input_samples.                */                /** Convert the samples using the resampler. */                if ((ret = swr_convert(aud_convert_ctx,                    converted_input_samples, input_frame-&gt;nb_samples,                    (const uint8_t**)input_frame-&gt;extended_data, input_frame-&gt;nb_samples)) &lt; 0) {                    printf(&quot;Could not convert input samples\n&quot;);                    return ret;                }                /** Add the converted input samples to the FIFO buffer for later processing. */                /**                * Make the FIFO as large as it needs to be to hold both,                * the old and the new samples.                */                if ((ret = av_audio_fifo_realloc(fifo, av_audio_fifo_size(fifo) + input_frame-&gt;nb_samples)) &lt; 0) {                    printf(&quot;Could not reallocate FIFO\n&quot;);                    return ret;                }                /** Store the new samples in the FIFO buffer. */                if (av_audio_fifo_write(fifo, (void **)converted_input_samples,                    input_frame-&gt;nb_samples) &lt; input_frame-&gt;nb_samples) {                    printf(&quot;Could not write data to FIFO\n&quot;);                    return AVERROR_EXIT;                }                           }        }        /**        * If we have enough samples for the encoder, we encode them.        * At the end of the file, we pass the remaining samples to        * the encoder.        */        if (av_audio_fifo_size(fifo) &gt;= output_frame_size)            /**            * Take one frame worth of audio samples from the FIFO buffer,            * encode it and write it to the output file.            */        {            /** Temporary storage of the output samples of the frame written to the file. */            AVFrame *output_frame=av_frame_alloc();            if (!output_frame)            {                ret = AVERROR(ENOMEM);                return ret;            }            /**            * Use the maximum number of possible samples per frame.            * If there is less than the maximum possible frame size in the FIFO            * buffer use this number. Otherwise, use the maximum possible frame size            */            const int frame_size = FFMIN(av_audio_fifo_size(fifo),                pCodecCtx_a-&gt;frame_size);            /** Initialize temporary storage for one output frame. */            /**            * Set the frame&apos;s parameters, especially its size and format.            * av_frame_get_buffer needs this to allocate memory for the            * audio samples of the frame.            * Default channel layouts based on the number of channels            * are assumed for simplicity.            */            output_frame-&gt;nb_samples = frame_size;            output_frame-&gt;channel_layout = pCodecCtx_a-&gt;channel_layout;            output_frame-&gt;format = pCodecCtx_a-&gt;sample_fmt;            output_frame-&gt;sample_rate = pCodecCtx_a-&gt;sample_rate;            /**            * Allocate the samples of the created frame. This call will make            * sure that the audio frame can hold as many samples as specified.            */            if ((ret = av_frame_get_buffer(output_frame, 0)) &lt; 0) {                printf(&quot;Could not allocate output frame samples\n&quot;);                av_frame_free(&amp;output_frame);                return ret;            }            /**            * Read as many samples from the FIFO buffer as required to fill the frame.            * The samples are stored in the frame temporarily.            */            if (av_audio_fifo_read(fifo, (void **)output_frame-&gt;data, frame_size) &lt; frame_size) {                printf(&quot;Could not read data from FIFO\n&quot;);                return AVERROR_EXIT;            }            /** Encode one frame worth of audio samples. */            /** Packet used for temporary storage. */            AVPacket output_packet;            av_init_packet(&amp;output_packet);            output_packet.data = NULL;            output_packet.size = 0;            /** Set a timestamp based on the sample rate for the container. */            if (output_frame) {                nb_samples += output_frame-&gt;nb_samples;            }            /**            * Encode the audio frame and store it in the temporary packet.            * The output audio stream encoder is used to do this.            */            if ((ret = avcodec_encode_audio2(pCodecCtx_a, &amp;output_packet,                output_frame, &amp;enc_got_frame_a)) &lt; 0) {                printf(&quot;Could not encode frame\n&quot;);                av_packet_unref(&amp;output_packet);                return ret;            }            /** Write one audio frame from the temporary packet to the output file. */            if (enc_got_frame_a) {                output_packet.stream_index = 1;                AVRational time_base = ofmt_ctx-&gt;streams[1]-&gt;time_base;                AVRational r_framerate1 = { ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate, 1 };// { 44100, 1};                  int64_t calc_duration = (double)(AV_TIME_BASE)*(1 / av_q2d(r_framerate1));  //内部时间戳                  output_packet.pts = av_rescale_q(nb_samples*calc_duration, time_base_q, time_base);                output_packet.dts = output_packet.pts;                output_packet.duration = output_frame-&gt;nb_samples;                //printf(&quot;audio pts : %d\n&quot;, output_packet.pts);                aud_next_pts = nb_samples*calc_duration;                int64_t pts_time = av_rescale_q(output_packet.pts, time_base, time_base_q);                int64_t now_time = av_gettime() - start_time;                if ((pts_time &gt; now_time) &amp;&amp; ((aud_next_pts + pts_time - now_time)&lt;vid_next_pts))                    av_usleep(pts_time - now_time);                if ((ret = av_interleaved_write_frame(ofmt_ctx, &amp;output_packet)) &lt; 0) {                    printf(&quot;Could not write frame\n&quot;);                    av_packet_unref(&amp;output_packet);                    return ret;                }                av_packet_unref(&amp;output_packet);            }                       av_frame_free(&amp;output_frame);               }     </code></pre><h6 id="视音频同步"><span id="视音频同步">视音频同步</span></h6><p>首先定义几个变量</p><pre><code>int aud_next_pts = 0;//视频流目前的pts,可以理解为目前的进度int vid_next_pts = 0;//音频流目前的ptsint encode_video = 1, encode_audio = 1;//是否要编码视频、音频</code></pre><p>则相应的视音频同步方法如下: 1. 确定视频, 音频二者中至少有一个是需要进行转码的 2. 比较两个流的进度, 使用av_compare_ts函数, 注意：此时的vid_next_pts和aud_next_pts的time base都是ffmpeg内部基准，即<code>AVRational time_base_q = { 1, AV_TIME_BASE };</code> 3. 对进度落后的流进行转码, 并相应地对进度进行更新. 对于视频，有 vid_next_pts=framecnt_calc_duration;，对于音频，有 aud_next_pts = nb_samples_calc_duration;这里framecnt和nb_samples都相当于计数器，而calc_duration是对应流每两个frame或sample之间的时间间隔，也是以ffmpeg内部时间基准为单位的 4. 若转码进度很快完成, 则不能急于写入输出流, 而是需要先进行延时, 但是也要保证延时后的时间不会超过另一个流的进度</p><p>综上, 流程如下:</p><pre><code> //start decode and encode    int64_t start_time = av_gettime();    while (encode_video || encode_audio)    {        if (encode_video &amp;&amp;            (!encode_audio || av_compare_ts(vid_next_pts, time_base_q,            aud_next_pts, time_base_q) &lt;= 0))        {              进行视频转码；              转码完成后；              vid_next_pts=framecnt*calc_duration; //general timebase                        //Delay                        int64_t pts_time = av_rescale_q(enc_pkt.pts, time_base, time_base_q);                        int64_t now_time = av_gettime() - start_time;                                               if ((pts_time &gt; now_time) &amp;&amp; ((vid_next_pts + pts_time - now_time)&lt;aud_next_pts))                            av_usleep(pts_time - now_time);              写入流；}else{              进行音频转码；              转码完成后；          aud_next_pts = nb_samples*calc_duration;                int64_t pts_time = av_rescale_q(output_packet.pts, time_base, time_base_q);                int64_t now_time = av_gettime() - start_time;                if ((pts_time &gt; now_time) &amp;&amp; ((aud_next_pts + pts_time - now_time)&lt;vid_next_pts))                    av_usleep(pts_time - now_time);              写入流；}</code></pre><p>至此, 视音频同步完成. 最后再完成一些flush_encoder的工作即可.</p>]]></content>
      
      
      <categories>
          
          <category> A&amp;amp;V </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 推流报错</title>
      <link href="/eaddfbfe/"/>
      <url>/eaddfbfe/</url>
      
        <content type="html"><![CDATA[<p>在使用dshow设备推流时，经常会报出real time buffer too full dropping frames的错误信息，其原因在<a href="https://trac.ffmpeg.org/wiki/DirectShow" target="_blank" rel="noopener">这篇文章</a>里有写到，可以通过添加rtbufsize参数来解决，码率越高对应的rtbufsize就需要越高，但过高的rtbufsize会带来视频的延时，若要保持同步，可能就需要对音频人为增加一定的延时。而根据我的测试，即使不添加rtbufszie参数，虽然会报出错误信息，但并不影响直播流的观看或录制，而且可以保持同步。这就是一个trade off的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> A&amp;amp;V </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>protocol buffer</title>
      <link href="/66065582/"/>
      <url>/66065582/</url>
      
        <content type="html"><![CDATA[<h5 id="developer-guide"><span id="developer-guide">Developer Guide</span></h5><p><code>.proto</code> 文件</p><pre><code>message Person {  required string name = 1;  required int32 id = 2;  optional string email = 3;  enum PhoneType {    MOBILE = 0;    HOME = 1;    WORK = 2;  }  message PhoneNumber {    required string number = 1;    optional PhoneType type = 2 [default = HOME];  }  repeated PhoneNumber phone = 4;}</code></pre><p>Once you’ve defined your messages, you run the protocol buffer compiler for your application’s language on your .proto file to generate data access classes. These provide simple accessors for each field (like name() and set_name()) as well as methods to serialize/parse the whole structure to/from raw bytes</p><p>You can add new fields to your message formats without breaking backwards-compatibility; old binaries simply ignore the new field when parsing. So if you have a communications protocol that uses protocol buffers as its data format, you can extend your protocol without having to worry about breaking existing code.</p><h5 id="language-guide"><span id="language-guide">Language Guide</span></h5><h6 id="defining-a-message-type"><span id="defining-a-message-type">Defining A Message Type</span></h6><pre><code>syntax = &quot;proto3&quot;; // First non-empty; first non-comment linemessage SearchRequest {  string query = 1; // unique numbered tag  int32 page_number = 2;  int32 result_per_page = 3;}</code></pre><h6 id="specifying-field-types"><span id="specifying-field-types">Specifying Field Types</span></h6><h6 id="assigning-tags"><span id="assigning-tags">Assigning Tags</span></h6><p>1-15 one byte 16-2047 two bytes you should reserve the tags 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.</p><p>range: 1 to 536,870,911 You also cannot use the numbers 19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber)</p><h6 id="specifying-field-rules"><span id="specifying-field-rules">Specifying Field Rules</span></h6><ul><li>singular zero or one of this field</li><li>repeated any number of times</li></ul><h6 id="adding-more-message-types"><span id="adding-more-message-types">Adding More Message Types</span></h6><h6 id="reserved-fields"><span id="reserved-fields">Reserved Fields</span></h6><pre><code>message Foo {  reserved 2, 15, 9 to 11;  reserved &quot;foo&quot;, &quot;bar&quot;;}</code></pre><p>Note that you can’t mix field names and tag numbers in the same reserved statement.</p><h6 id="whats-generated-from-your-proto"><span id="whats-generated-from-your-proto">What’s Generated From Your .proto?</span></h6><h6 id="default-values"><span id="default-values">Default Values</span></h6><p>sigular: - string - byte - bool - numeric type - enum - message field</p><p>repeated: - repeated filed</p><h6 id="enumerations"><span id="enumerations">Enumerations</span></h6><pre><code>message SearchRequest {  string query = 1;  int32 page_number = 2;  int32 result_per_page = 3;  enum Corpus {    UNIVERSAL = 0;    WEB = 1;    IMAGES = 2;    LOCAL = 3;    NEWS = 4;    PRODUCTS = 5;    VIDEO = 6;  }  Corpus corpus = 4;}</code></pre><p>You can define aliases by assigning the same value to different enum constants</p><pre><code>enum EnumAllowingAlias {  option allow_alias = true;  UNKNOWN = 0;  STARTED = 1;  RUNNING = 1;}enum EnumNotAllowingAlias {  UNKNOWN = 0;  STARTED = 1;  // RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.}</code></pre><h6 id="reserved-values"><span id="reserved-values">Reserved Values</span></h6><pre><code>enum Foo {  reserved 2, 15, 9 to 11, 40 to max;  reserved &quot;FOO&quot;, &quot;BAR&quot;;}</code></pre><p>Note that you can’t mix field names and numeric values in the same reserved statement.</p><h6 id="using-other-message-types"><span id="using-other-message-types">Using Other Message Types</span></h6><p>Define a message in the same <code>.proto</code> file.</p><pre><code>message SearchResponse {  repeated Result results = 1;}message Result {  string url = 1;  string title = 2;  repeated string snippets = 3;}</code></pre><h6 id="importing-definitions"><span id="importing-definitions">Importing Definitions</span></h6><p>By default you can only use definitions from directly imported .proto files. <code>import &quot;myproject/other_protos.proto&quot;;</code></p><pre><code>// new.proto// All definitions are moved here======================================================// old.proto// This is the proto that all clients are importing.import public &quot;new.proto&quot;;import &quot;other.proto&quot;;======================================================// client.protoimport &quot;old.proto&quot;;// You use definitions from old.proto and new.proto, but not other.proto</code></pre><p>The protocol compiler searches for imported files in a set of directories specified on the protocol compiler command line using the -I/–proto_path flag. If no flag was given, it looks in the directory in which the compiler was invoked. In general you should set the –proto_path flag to the root of your project and use fully qualified names for all imports.</p><h6 id="using-proto2-message-types"><span id="using-proto2-message-types">Using proto2 Message Types</span></h6><p>It’s possible to import proto2 message types and use them in your proto3 messages, and vice versa. However, proto2 enums cannot be used directly in proto3 syntax (it’s okay if an imported proto2 message uses them).</p><h6 id="nested-types"><span id="nested-types">Nested Types</span></h6><pre><code>message SearchResponse {  message Result {    string url = 1;    string title = 2;    repeated string snippets = 3;  }  repeated Result results = 1;}</code></pre><p>If you want to reuse this message type outside its parent message type, you refer to it as <code>Parent.Type</code>:</p><pre><code>message SomeOtherMessage {  SearchResponse.Result result = 1;}</code></pre><p>You can nest messages as deeply as you like</p><pre><code>message Outer {                  // Level 0  message MiddleAA {  // Level 1    message Inner {   // Level 2      int64 ival = 1;      bool  booly = 2;    }  }  message MiddleBB {  // Level 1    message Inner {   // Level 2      int32 ival = 1;      bool  booly = 2;    }  }}</code></pre><h6 id="updating-a-message-type"><span id="updating-a-message-type">Updating A Message Type</span></h6><ul><li>Don’t change the numeric tags for any existing fields</li><li>If you add new fields, any messages serialized by code using your “old” message format can still be parsed by your new generated code</li><li>Fields can be removed, as long as the tag number is not used again in your updated message type<ul><li>You may want to rename the field instead, perhaps adding the prefix “OBSOLETE_”, or make the tag reserved, so that future users of your .proto can’t accidentally reuse the number.</li></ul></li><li>Compatibility<ul><li>int32, uint32, int64, uint64, and bool are all compatible</li><li>sint32 and sint64 are compatible with each other but are not compatible with the other integer types</li><li>string and bytes are compatible as long as the bytes are valid UTF-8</li><li>Embedded messages are compatible with bytes if the bytes contain an encoded version of the message</li><li>fixed32 is compatible with sfixed32, and fixed64 with sfixed64</li><li>enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit)</li></ul></li><li>Moving any fields into an existing oneof is not safe</li></ul><h6 id="any"><span id="any">Any</span></h6><pre><code>import &quot;google/protobuf/any.proto&quot;;message ErrorStatus {  string message = 1;  repeated google.protobuf.Any details = 2;}</code></pre><h6 id="oneof"><span id="oneof">Oneof</span></h6><p>You can add fields of any type, but cannot use <code>repeated</code> fields</p><p>Features: - Setting a oneof field will automatically clear all other members of the oneof - If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message - If you’re using C++, make sure your code doesn’t cause memory crashes - Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case</p><h6 id="maps"><span id="maps">Maps</span></h6><p><code>map&lt;key_type, value_type&gt; map_field = N</code> The <code>key_type</code> can be any integral or string type. The <code>value_type</code> can be any type except another map.</p><ul><li>Map fields cannot be <code>repeated</code></li><li>Wire format ordering and map iteration ordering of map values is undefined</li><li>When generating text format for a <code>.proto</code>, maps are sorted by key</li><li>When parsing from the wire or when merging, if there are duplicate map keys the last key seen is used. When parsing a map from text format, parsing may fail if there are duplicate keys</li></ul><p>backwords compatibility:</p><pre><code>message MapFieldEntry {  key_type key = 1;  value_type value = 2;}repeated MapFieldEntry map_field = N;</code></pre><h6 id="packages"><span id="packages">Packages</span></h6><h6 id="json-mapping"><span id="json-mapping">JSON Mapping</span></h6>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qt 的 pro 文件</title>
      <link href="/8304997e/"/>
      <url>/8304997e/</url>
      
        <content type="html"><![CDATA[<h4 id="注释"><span id="注释">注释</span></h4><p>使用<code>#</code> 进行行注释</p><h4 id="模板"><span id="模板">模板</span></h4><p><code>TEMPLATE = app</code> 告诉<code>qmake</code>为这个应用程序生成哪种<code>makefile</code>. - app 默认值. 生成app的makefile - lib 生成一个库的makefile - vcapp 生成一个应用程序的<code>VisualStudio</code>项目文件 - vclib 生成一个库的<code>VisualStudio</code> 项目文件 - subdirs 生成<code>makefile</code>文件编译<code>subdirs</code>指定的子文件夹</p><h4 id="应用程序目录"><span id="应用程序目录">应用程序目录</span></h4><p>指定生成的应用程序放置的目录 <code>DESTDIR += ../bin</code></p><h4 id="配置信息"><span id="配置信息">配置信息</span></h4><p><code>COFNIG</code> 用来告诉<code>qmake</code> 关于应用程序的配置信息 <code>CONFIG += qt warn_on release</code></p><h4 id="ui目录"><span id="ui目录">ui目录</span></h4><p>指定uic命令将<code>.ui</code>文件转化成的<code>ui_*.h</code>文件的存放目录 <code>UI_DIR += forms</code></p><h4 id="rcc目录"><span id="rcc目录">rcc目录</span></h4><p>指定rcc命令将<code>.qrc</code>文件转换成的<code>qrc_*.h</code>文件的存放目录 <code>RCC_DIR += ../tmp</code></p><h4 id="moc目录"><span id="moc目录">moc目录</span></h4><p>指定moc命令将<strong>含Q_OBJECT的头文件转换成标准<code>.h</code>文件的存放目录</strong> <code>MOC_DIR += ../tmp</code></p><h4 id="目标文件目录"><span id="目标文件目录">目标文件目录</span></h4><p>指定目标文件(obj)的存放目录 <code>OBJECTS_DIR += ../tmp</code></p><h4 id="依赖相关路径"><span id="依赖相关路径">依赖相关路径</span></h4><p>程序编译时依赖的相关路径 <code>DEPENDPATH += . forms include qrc sources</code></p><h4 id="头文件包含路径"><span id="头文件包含路径">头文件包含路径</span></h4><p><code>INCLUDEPATH += .</code></p><h4 id="qmake时产生的信息"><span id="qmake时产生的信息">qmake时产生的信息</span></h4><p><code>message($$(PATH))</code></p><h4 id="源文件编码方式"><span id="源文件编码方式">源文件编码方式</span></h4><p><code>CODECFORSRC = GBK</code></p><h4 id="工程中包含的头文件"><span id="工程中包含的头文件">工程中包含的头文件</span></h4><p><code>HEADERS += include/aa.h</code></p><h4 id="工程中包含的ui文件"><span id="工程中包含的ui文件">工程中包含的<code>.ui</code>文件</span></h4><p><code>FORMS += forms/aa.ui</code></p><h4 id="工程中包含的源文件"><span id="工程中包含的源文件">工程中包含的源文件</span></h4><p><code>SOURCES += sources/main.cpp sources/aa.cpp</code></p><h4 id="工程中包含的资源文件"><span id="工程中包含的资源文件">工程中包含的资源文件</span></h4><pre><code>RESOURCES += qrc/aa.qrcLIBS += -LfolderPathRelease: LIBS += -LfolderReleasePathDebug: LIBS += -LfolderDebugPathDEFINES += XX_XX_XXX // 定义编译选项, 在.h文件中就可以用 #ifdefine XX_XX_XXXRC_FIELS = xxx.icns</code></pre><h4 id="平台相关性处理"><span id="平台相关性处理">平台相关性处理</span></h4><p>根据qmake所运行的平台来使用相应的作用域来进行处理.</p><p>为Windows平台添加的依赖平台的文件示例:</p><pre><code>win32{SOURCES += hello_win.cpp}</code></pre><h4 id="生成makefile"><span id="生成makefile">生成Makefile</span></h4><p><code>qmake -oMakefile hello.pro</code></p><p>对于VisualStudio用户, qmake也可以生成<code>.dsp</code>文件 <code>qmake -tvcapp -o hello.dsp hello.pro</code></p><h6 id="pro文件实例"><span id="pro文件实例">pro文件实例</span></h6><pre><code>TEMPLATE = app #模块配置LANGUAGE = C++ #C++语言CONFIG += qt warn_on debug release#引入的lib文件,用于引入动态链接库LIBS += qaxcontainer.lib#头文件包含路径INCLUDEPATH += ../../qtcompnent/qtchklisten/inc ../../qtcompnent/qtclearfile/inc ../../validator/inc/validerrcode ../../qtcompnent/qtdir/inc ../inc ../../utillib/inc/xmlapi ../../utillib/inc/util ../../xercesc ../../qtcompnent/qteditor/inc ../../qtcompnent/qtfunreview/inc ../../qtcompnent/qttable/inc ../../qtcompnent/qtversion/inc ../../qtcompnent/qtini/inc ../../icdtool/icdservices/inc ../../icdtool/dataset/inc ../../icdtool/doi/inc ../../icdtool/reportcontrol/inc ../../icdtool/GSEconctrol/inc ../../icdtool/inputs/inc ../../icdtool/SMVconctrol/inc ../../icdtool/logcontrol/inc ../../scdpreview/inc/scdpreviewtoollib ../../scdpreview/form ../../icdtool/sclcontrol/inc ../../icdtool/log/inc ../../icdtool/settingcontrol/inc ../../qtcompnent/qteditor/inc ../../qtcompnent/qttreeview/inc ../../qtcompnent/qttabwidget/inc ../../communication/inc ../../qtcompnent/qtabout/inc ../iedmanage/inc ../ldmanage/inc ../foriecrun/inc ../../qtcompnent/validset/inc#工程中包含的头文件HEADERS += ../inc/exportstable.h /../inc/maintabwidget.h /../inc/outputtab.h /../inc/strutil.h /../inc/treeeditview.h /../inc/MainForm.h /../inc/recenfileini.h /../inc/ExportCIDFunction.h#工程中包含的源文件SOURCES += ../src/main.cpp /../src/exportstable.cpp /../src/maintabwidget.cpp /../src/outputtab.cpp /../src/treeeditview.cpp /../src/MainForm.cpp /../src/recenfileini.cpp /../src/ExportCIDFunction.cpp#工程中包含的.ui设计文件FORMS = ../form/scdmainform.ui /../form/exportiedform.ui /../form/Exportsedform.ui /../form/Importsedform.ui /../form/formiminputs.ui#图像文件IMAGES = images/substation.png /images/communication.png /images/autocom.png /images/reportcfg.png /images/comcfg.png /images/filetrans.png /images/review.png /images/setting.png#工程中包含的资源文件RESOURCES = Scintilla.qrc#CONFIG -= releaseCONFIG -= debugRC_FILE = scdtool.rcBINLIB = ../../bin ../../xercesc/libUI_HEADERS_DIR = ../inc # .ui文件转会为**.h 存放的目录UI_SOURCES_DIR = ../src # .ui文件转会为**.cpp 存放的目录QMAKE_LIBDIR = $${BINLIB}release {TARGET = scdtool #指定生成的应用程序名OBJECTS_DIR = ../../obj/scdtool/release #指定目标文件(obj)的存放目录}debug {TARGET = scdtool_d #指定生成的应用程序名OBJECTS_DIR = ../../obj/scdtool/debug #指定目标文件(obj)的存放目录}MOC_DIR = $${OBJECTS_DIR}DESTDIR = ../../bin #指定生成的应用程序放置的目录</code></pre><p>补充: <a href="https://www.cnblogs.com/Braveliu/p/5107550.html" target="_blank" rel="noopener">cnblogs</a></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于FFmpeg的摄像头直播(推流)</title>
      <link href="/ae1aac27/"/>
      <url>/ae1aac27/</url>
      
        <content type="html"><![CDATA[<p>原文地址: <a href="http://blog.csdn.net/wh8_2011/article/details/73506154" target="_blank" rel="noopener">http://blog.csdn.net/wh8_2011/article/details/73506154</a></p><p>本文实现: 读取PC摄像头视频数据并以RTMP协议发送为直播流. 示例包含 1. FFmpeg的libavdevice的使用 2. 视频编码, 解码, 推流的基本流程</p><p>要使用libavdevice的相关函数, 首先需要注册相关组件 <code>avdevice_register_all()</code></p><p>列出电脑中可用的DShow设备</p><pre><code>AVFormatContext *pFmtCtx = avformat_alloc_context();      AVDeviceInfoList *device_info = NULL;      AVDictionary* options = NULL;      av_dict_set(&amp;options, &quot;list_devices&quot;, &quot;true&quot;, 0);      AVInputFormat *iformat = av_find_input_format(&quot;dshow&quot;);      printf(&quot;Device Info=============\n&quot;);      avformat_open_input(&amp;pFmtCtx, &quot;video=dummy&quot;, iformat, &amp;options);      printf(&quot;========================\n&quot;); </code></pre><p>也可以直接使用FFmpeg的工具 <code>ffmpeg -list_devices true -f dshow -i dummy</code></p><p>PS: avdevice有一个avdevice_list_devices函数可以枚举系统的采集设备, 包括设备名和设备描述, 可以让用户选择要使用的设备, 但是不支持DShow设备.</p><p>像打开普通文件一样将上面的具体设备名作为输入打开, 并进行相应的初始化设置</p><pre><code>av_register_all();      //Register Device      avdevice_register_all();      avformat_network_init();      //Show Dshow Device        show_dshow_device();      printf(&quot;\nChoose capture device: &quot;);      if (gets(capture_name) == 0)      {          printf(&quot;Error in gets()\n&quot;);          return -1;      }      sprintf(device_name, &quot;video=%s&quot;, capture_name);      ifmt=av_find_input_format(&quot;dshow&quot;);      //Set own video device&apos;s name      if (avformat_open_input(&amp;ifmt_ctx, device_name, ifmt, NULL) != 0){          printf(&quot;Couldn&apos;t open input stream.（无法打开输入流）\n&quot;);          return -1;      }      //input initialize      if (avformat_find_stream_info(ifmt_ctx, NULL)&lt;0)      {          printf(&quot;Couldn&apos;t find stream information.（无法获取流信息）\n&quot;);          return -1;      }      videoindex = -1;      for (i = 0; i&lt;ifmt_ctx-&gt;nb_streams; i++)          if (ifmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)          {              videoindex = i;              break;          }      if (videoindex == -1)      {          printf(&quot;Couldn&apos;t find a video stream.（没有找到视频流）\n&quot;);          return -1;      }      if (avcodec_open2(ifmt_ctx-&gt;streams[videoindex]-&gt;codec, avcodec_find_decoder(ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;codec_id), NULL)&lt;0)      {          printf(&quot;Could not open codec.（无法打开解码器）\n&quot;);          return -1;      }</code></pre><p>输入设备初始化后, 需要对输出做相应的初始化. FFmpeg将网络协议和文件同等看待, 同时因为使用RTMP协议进行传输, 因此制定输出为flv格式, 编码器使用H.264</p><pre><code>//output initialize      avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;flv&quot;, out_path);      //output encoder initialize      pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);      if (!pCodec){          printf(&quot;Can not find encoder! (没有找到合适的编码器！)\n&quot;);          return -1;      }      pCodecCtx=avcodec_alloc_context3(pCodec);      pCodecCtx-&gt;pix_fmt = PIX_FMT_YUV420P;      pCodecCtx-&gt;width = ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;width;      pCodecCtx-&gt;height = ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;height;      pCodecCtx-&gt;time_base.num = 1;      pCodecCtx-&gt;time_base.den = 25;      pCodecCtx-&gt;bit_rate = 400000;      pCodecCtx-&gt;gop_size = 250;      /* Some formats,for example,flv, want stream headers to be separate. */      if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)          pCodecCtx-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;      //H264 codec param      //pCodecCtx-&gt;me_range = 16;      //pCodecCtx-&gt;max_qdiff = 4;      //pCodecCtx-&gt;qcompress = 0.6;      pCodecCtx-&gt;qmin = 10;      pCodecCtx-&gt;qmax = 51;      //Optional Param      pCodecCtx-&gt;max_b_frames = 3;      // Set H264 preset and tune      AVDictionary *param = 0;      av_dict_set(&amp;param, &quot;preset&quot;, &quot;fast&quot;, 0);      av_dict_set(&amp;param, &quot;tune&quot;, &quot;zerolatency&quot;, 0);      if (avcodec_open2(pCodecCtx, pCodec,&amp;param) &lt; 0){          printf(&quot;Failed to open encoder! (编码器打开失败！)\n&quot;);          return -1;      }      //Add a new stream to output,should be called by the user before avformat_write_header() for muxing      video_st = avformat_new_stream(ofmt_ctx, pCodec);      if (video_st == NULL){          return -1;      }      video_st-&gt;time_base.num = 1;      video_st-&gt;time_base.den = 25;      video_st-&gt;codec = pCodecCtx;      //Open output URL,set before avformat_write_header() for muxing      if (avio_open(&amp;ofmt_ctx-&gt;pb,out_path, AVIO_FLAG_READ_WRITE) &lt; 0){      printf(&quot;Failed to open output file! (输出文件打开失败！)\n&quot;);      return -1;      }      //Show some Information      av_dump_format(ofmt_ctx, 0, out_path, 1);      //Write File Header      avformat_write_header(ofmt_ctx,NULL); </code></pre><p>完成输入和输出的初始化后, 就可以正式开始解码和编码并推流的流程了. 需要注意的是, 摄像头数据往往是RGB格式的, 需要将其转换为YUV420P格式, 才能推流, 因此要先做如下的准备工作</p><pre><code>//prepare before decode and encode      dec_pkt = (AVPacket *)av_malloc(sizeof(AVPacket));      //enc_pkt = (AVPacket *)av_malloc(sizeof(AVPacket));      //camera data has a pix fmt of RGB,convert it to YUV420      img_convert_ctx = sws_getContext(ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;width, ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;height,           ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);      pFrameYUV = avcodec_alloc_frame();      uint8_t *out_buffer = (uint8_t *)av_malloc(avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));      avpicture_fill((AVPicture *)pFrameYUV, out_buffer, PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);  </code></pre><p>现在, 就可以正式开始解码, 编码 和推流了</p><pre><code>//start decode and encode      int64_t start_time=av_gettime();      while (av_read_frame(ifmt_ctx, dec_pkt) &gt;= 0){             if (exit_thread)              break;          av_log(NULL, AV_LOG_DEBUG, &quot;Going to reencode the frame\n&quot;);          pframe = av_frame_alloc();          if (!pframe) {              ret = AVERROR(ENOMEM);              return -1;          }          //av_packet_rescale_ts(dec_pkt, ifmt_ctx-&gt;streams[dec_pkt-&gt;stream_index]-&gt;time_base,          //  ifmt_ctx-&gt;streams[dec_pkt-&gt;stream_index]-&gt;codec-&gt;time_base);          ret = avcodec_decode_video2(ifmt_ctx-&gt;streams[dec_pkt-&gt;stream_index]-&gt;codec, pframe,              &amp;dec_got_frame, dec_pkt);          if (ret &lt; 0) {              av_frame_free(&amp;pframe);              av_log(NULL, AV_LOG_ERROR, &quot;Decoding failed\n&quot;);              break;          }          if (dec_got_frame){              sws_scale(img_convert_ctx, (const uint8_t* const*)pframe-&gt;data, pframe-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);                 enc_pkt.data = NULL;              enc_pkt.size = 0;              av_init_packet(&amp;enc_pkt);              ret = avcodec_encode_video2(pCodecCtx, &amp;enc_pkt, pFrameYUV, &amp;enc_got_frame);              av_frame_free(&amp;pframe);              if (enc_got_frame == 1){                  //printf(&quot;Succeed to encode frame: %5d\tsize:%5d\n&quot;, framecnt, enc_pkt.size);                  framecnt++;                   enc_pkt.stream_index = video_st-&gt;index;                  //Write PTS                  AVRational time_base = ofmt_ctx-&gt;streams[videoindex]-&gt;time_base;//{ 1, 1000 };                  AVRational r_framerate1 = ifmt_ctx-&gt;streams[videoindex]-&gt;r_frame_rate;// { 50, 2 };                  AVRational time_base_q = { 1, AV_TIME_BASE };                  //Duration between 2 frames (us)                  int64_t calc_duration = (double)(AV_TIME_BASE)*(1 / av_q2d(r_framerate1));  //内部时间戳                  //Parameters                  //enc_pkt.pts = (double)(framecnt*calc_duration)*(double)(av_q2d(time_base_q)) / (double)(av_q2d(time_base));                  enc_pkt.pts = av_rescale_q(framecnt*calc_duration, time_base_q, time_base);                  enc_pkt.dts = enc_pkt.pts;                  enc_pkt.duration = av_rescale_q(calc_duration, time_base_q, time_base); //(double)(calc_duration)*(double)(av_q2d(time_base_q)) / (double)(av_q2d(time_base));                  enc_pkt.pos = -1;                  //Delay                  int64_t pts_time = av_rescale_q(enc_pkt.dts, time_base, time_base_q);                  int64_t now_time = av_gettime() - start_time;                  if (pts_time &gt; now_time)                      av_usleep(pts_time - now_time);                  ret = av_interleaved_write_frame(ofmt_ctx, &amp;enc_pkt);                  av_free_packet(&amp;enc_pkt);              }          }          else {              av_frame_free(&amp;pframe);          }          av_free_packet(dec_pkt);      }  </code></pre><p>解码比较简单, 编码部分需要自己计算PTS, DTS, 比较复杂 这里通过帧率计算PTS和DTS, 首先通过帧率计算两帧之间的时间间隔, 但是要换算</p>]]></content>
      
      
      <categories>
          
          <category> A&amp;amp;V </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于FFmpeg的推送文件到RTMP服务器</title>
      <link href="/5722b57a/"/>
      <url>/5722b57a/</url>
      
        <content type="html"><![CDATA[<p>原文地址: <a href="http://blog.csdn.net/leixiaohua1020/article/details/39803457" target="_blank" rel="noopener">http://blog.csdn.net/leixiaohua1020/article/details/39803457</a></p><p>将本地的MOV/AVI/MKV/MP4/FLV等格式的媒体文件， 通过流媒体协议(RTMP, HTTP, UDP, TCP, RTP等)以直播流的形式推送出去.</p><p>在这个推流器的基础上, 可以进行以下几种方式的修改, 实现各式各样的推流器. 例如: * 将输入文件改为网络流URL, 可以显示转流器 * 将输入文件改为回调函数(内存读取)的形式, 可以推送内存中的视频数据 * 将输入文件改为系统设备(通过libavdevice), 同时加上编码的功能, 可以实现实时推流器(现场直播)</p><h3 id="需要注意的地方"><span id="需要注意的地方">需要注意的地方</span></h3><h4 id="封装格式"><span id="封装格式">封装格式</span></h4><p>RTMP采用的封装格式FLV, 因此在指定输出流媒体的时候需要制定其封装格式为”flv”. 同理, 其他流媒体协议也需要指定其封装格式. 例如采用UDP推送流媒体的时候, 可以指定其封装格式为”mpegts”.</p><h4 id="延时"><span id="延时">延时</span></h4><p>发送流媒体的数据的时候需要延时. 否则, FFmpeg处理数据速度很快, 瞬间就能把所有的数据发送出去, 流媒体服务器是承受不了的. 因此需要按照视频实际的帧率发送数据. 本文的推流器在视频帧与帧之间采用av_usleep()函数休眠的方式来延迟发送. 这样就可以按照视频的帧率发送数据了, 代码如下</p><pre><code>//…  int64_t start_time=av_gettime();  while (1) {  //…      //Important:Delay      if(pkt.stream_index==videoindex){          AVRational time_base=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;          AVRational time_base_q={1,AV_TIME_BASE};          int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q);          int64_t now_time = av_gettime() - start_time;          if (pts_time &gt; now_time)              av_usleep(pts_time - now_time);      }  //…  }  //… </code></pre><h4 id="ptsdts问题"><span id="ptsdts问题">PTS/DTS问题</span></h4><p>没有封装格式的裸流(例如H.264裸流)是不包含PTS, DTS这些参数的. 在发送这种数据的时候, 需要自己计算并写入AVPacket的PTS, DTS, duration等参数.</p><pre><code>//FIX：No PTS (Example: Raw H.264)  //Simple Write PTS  if(pkt.pts==AV_NOPTS_VALUE){      //Write PTS      AVRational time_base1=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;      //Duration between 2 frames (us)      int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(ifmt_ctx-&gt;streams[videoindex]-&gt;r_frame_rate);      //Parameters      pkt.pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE);      pkt.dts=pkt.pts;      pkt.duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE);  } </code></pre><h4 id="sequence"><span id="sequence">sequence</span></h4><p><img src="http://img.blog.csdn.net/20180113202019583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>代码</p><pre><code>/**  * 最简单的基于FFmpeg的推流器（推送RTMP）  * Simplest FFmpeg Streamer (Send RTMP)  *   * 雷霄骅 Lei Xiaohua  * leixiaohua1020@126.com  * 中国传媒大学/数字电视技术  * Communication University of China / Digital TV Technology  * http://blog.csdn.net/leixiaohua1020  *   * 本例子实现了推送本地视频至流媒体服务器（以RTMP为例）。  * 是使用FFmpeg进行流媒体推送最简单的教程。  *  * This example stream local media files to streaming media   * server (Use RTMP as example).   * It&apos;s the simplest FFmpeg streamer.  *   */  #include &lt;stdio.h&gt;  #define __STDC_CONSTANT_MACROS  #ifdef _WIN32  //Windows  extern &quot;C&quot;  {  #include &quot;libavformat/avformat.h&quot;  #include &quot;libavutil/mathematics.h&quot;  #include &quot;libavutil/time.h&quot;  };  #else  //Linux...  #ifdef __cplusplus  extern &quot;C&quot;  {  #endif  #include &lt;libavformat/avformat.h&gt;  #include &lt;libavutil/mathematics.h&gt;  #include &lt;libavutil/time.h&gt;  #ifdef __cplusplus  };  #endif  #endif  int main(int argc, char* argv[])  {      AVOutputFormat *ofmt = NULL;      //输入对应一个AVFormatContext，输出对应一个AVFormatContext      //（Input AVFormatContext and Output AVFormatContext）      AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL;      AVPacket pkt;      const char *in_filename, *out_filename;      int ret, i;      int videoindex=-1;      int frame_index=0;      int64_t start_time=0;      //in_filename  = &quot;cuc_ieschool.mov&quot;;      //in_filename  = &quot;cuc_ieschool.mkv&quot;;      //in_filename  = &quot;cuc_ieschool.ts&quot;;      //in_filename  = &quot;cuc_ieschool.mp4&quot;;      //in_filename  = &quot;cuc_ieschool.h264&quot;;      in_filename  = &quot;cuc_ieschool.flv&quot;;//输入URL（Input file URL）      //in_filename  = &quot;shanghai03_p.h264&quot;;      out_filename = &quot;rtmp://localhost/publishlive/livestream&quot;;//输出 URL（Output URL）[RTMP]      //out_filename = &quot;rtp://233.233.233.233:6666&quot;;//输出 URL（Output URL）[UDP]      av_register_all();      //Network      avformat_network_init();      //输入（Input）      if ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0)) &lt; 0) {          printf( &quot;Could not open input file.&quot;);          goto end;      }      if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &lt; 0) {          printf( &quot;Failed to retrieve input stream information&quot;);          goto end;      }      for(i=0; i&lt;ifmt_ctx-&gt;nb_streams; i++)           if(ifmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO){              videoindex=i;              break;          }      av_dump_format(ifmt_ctx, 0, in_filename, 0);      //输出（Output）      avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;flv&quot;, out_filename); //RTMP      //avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;mpegts&quot;, out_filename);//UDP      if (!ofmt_ctx) {          printf( &quot;Could not create output context\n&quot;);          ret = AVERROR_UNKNOWN;          goto end;      }      ofmt = ofmt_ctx-&gt;oformat;      for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) {          //根据输入流创建输出流（Create output AVStream according to input AVStream）          AVStream *in_stream = ifmt_ctx-&gt;streams[i];          AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec);          if (!out_stream) {              printf( &quot;Failed allocating output stream\n&quot;);              ret = AVERROR_UNKNOWN;              goto end;          }          //复制AVCodecContext的设置（Copy the settings of AVCodecContext）          ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec);          if (ret &lt; 0) {              printf( &quot;Failed to copy context from input to output stream codec context\n&quot;);              goto end;          }          out_stream-&gt;codec-&gt;codec_tag = 0;          if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)              out_stream-&gt;codec-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;      }      //Dump Format------------------      av_dump_format(ofmt_ctx, 0, out_filename, 1);      //打开输出URL（Open output URL）      if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) {          ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);          if (ret &lt; 0) {              printf( &quot;Could not open output URL &apos;%s&apos;&quot;, out_filename);              goto end;          }      }      //写文件头（Write file header）      ret = avformat_write_header(ofmt_ctx, NULL);      if (ret &lt; 0) {          printf( &quot;Error occurred when opening output URL\n&quot;);          goto end;      }      start_time=av_gettime();      while (1) {          AVStream *in_stream, *out_stream;          //获取一个AVPacket（Get an AVPacket）          ret = av_read_frame(ifmt_ctx, &amp;pkt);          if (ret &lt; 0)              break;          //FIX：No PTS (Example: Raw H.264)          //Simple Write PTS          if(pkt.pts==AV_NOPTS_VALUE){              //Write PTS              AVRational time_base1=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;              //Duration between 2 frames (us)              int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(ifmt_ctx-&gt;streams[videoindex]-&gt;r_frame_rate);              //Parameters              pkt.pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE);              pkt.dts=pkt.pts;              pkt.duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE);          }          //Important:Delay          if(pkt.stream_index==videoindex){              AVRational time_base=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;              AVRational time_base_q={1,AV_TIME_BASE};              int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q);              int64_t now_time = av_gettime() - start_time;              if (pts_time &gt; now_time)                  av_usleep(pts_time - now_time);          }          in_stream  = ifmt_ctx-&gt;streams[pkt.stream_index];          out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];          /* copy packet */          //转换PTS/DTS（Convert PTS/DTS）          pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));          pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));          pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);          pkt.pos = -1;          //Print to Screen          if(pkt.stream_index==videoindex){              printf(&quot;Send %8d video frames to output URL\n&quot;,frame_index);              frame_index++;          }          //ret = av_write_frame(ofmt_ctx, &amp;pkt);          ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);          if (ret &lt; 0) {              printf( &quot;Error muxing packet\n&quot;);              break;          }          av_free_packet(&amp;pkt);      }      //写文件尾（Write file trailer）      av_write_trailer(ofmt_ctx);  end:      avformat_close_input(&amp;ifmt_ctx);      /* close output */      if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE))          avio_close(ofmt_ctx-&gt;pb);      avformat_free_context(ofmt_ctx);      if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) {          printf( &quot;Error occurred.\n&quot;);          return -1;      }      return 0;  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> A&amp;amp;V </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 推流工具</title>
      <link href="/b3ed22dc/"/>
      <url>/b3ed22dc/</url>
      
        <content type="html"><![CDATA[<p>SRR测试网址 <code>http://www.ossrs.net/srs.release/trunk/research/players/srs_player.html</code> 获取 <code>git clone https://github.com/ossrs/srs.git</code></p><p>configure make <code>cd srs/trunk</code> <code>./configure &amp;&amp; make</code></p><p>开启服务器 <code>./objs/srs -c conf/srs.conf</code></p><p>列出设备 <code>./ffmpeg.exe -list_devices true -f dshow -i dummy</code> ffmpeg采集摄像头推流 <code>ffmpeg.exe -f dshow -i video=&quot;EasyCamera&quot; -q 4 -s 640*480 -aspect 4:3 -r 10 -vcodec flv -ar 22050 -ab 64k -ac 1 -acodec libmp3lame -threads 4 -f flv rtmp://192.168.1.102/RTMP/RtmpVideo</code></p><p>ffmpeg采集摄像头和麦克风推流 <code>ffmpeg -f dshow -i video=&quot;USB2.0 PC CAMERA&quot; -f dshow -i audio=&quot;麦克风 (2- USB2.0 MIC)&quot; -b:a 600k -ab 128k -f flv rtmp://192.168.1.102/RTMP/RtmpVideo</code></p>]]></content>
      
      
      <categories>
          
          <category> A&amp;amp;V </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令组和代码块</title>
      <link href="/8cb7d3c0/"/>
      <url>/8cb7d3c0/</url>
      
        <content type="html"><![CDATA[<h1 id="命令组-和-代码块"><span id="命令组-和-代码块">命令组 和 代码块</span></h1><p>() 命令组. 如 <code>(a=hello,echo $a)</code> 在()中的命令列表, 将作为一个子Shell来运行 在()中的变量, 由于是在子Shell总运行的, 因此对脚本剩下的部分是不可见的</p><p>如</p><pre><code>a=123(a=321;)echo &quot;a=$a&quot; # a=123# 在()中的a变量, 更像是一个局部变量</code></pre><p>{} 代码块, 又称内部组. 这个结构创建了一个匿名的函数, 与函数不同的是, 在{}中声明的变量, 对于脚本剩余的代码是可见的, 如</p><pre><code>{    local a;    a=123;}# bash中的local申请的变量只能用在函数中a=123;{a=321;}echo &quot;a=$a&quot; # a=321</code></pre><p>()也可用作初始化数组 array=(element1,element2,element3)</p><p>{xxx,yyy,zzz} 大括号扩展, 例</p><pre><code>cat {file1,file2,file3} &gt; combined_file# 把file1 file2 file3连接在一起, 重定向到combined_filecp file1.{txt,bak}# 把file1.txt 复制到file1.bak</code></pre><p>一个命令会对大括号中以逗号分隔的文件列表起作用, file globbing会对大括号中的文件名作扩展</p><pre><code># 大括号中不允许有空白, 除非这个空白是有意义的echo {file1,file2}\ :{\ A,&quot; B&quot;,&apos; C&apos;}# file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell 中的冒号</title>
      <link href="/9aa135a6/"/>
      <url>/9aa135a6/</url>
      
        <content type="html"><![CDATA[<p>冒号(:) 是一个空命令. 作用与true相同. “:”是一个bash内建命令, 返回值为0, 即与true相同. 例:</p><pre><code>:echo $?  # 0</code></pre><p>死循环</p><pre><code>while :do    list_1    list_2done</code></pre><p>if/then 中的占位符</p><pre><code>if listthen : # 什么都不做, 引出分支else    take-some-actionfi</code></pre><p>在一个2元命令中, 提供一个占位符, 表明后面的表达式, 不是一个命令, 如</p><pre><code>:$((n=$n+1)</code></pre><p>如果没有:, bash会尝试把”$((n=$n+1))” 解释成一个命令</p><p>使用”参数替换” 来评估字符串变量</p><pre><code>:${HOSTNAME?}${USER?}${MAIL?}# 如果一个或多个环境变量没有设置, 则打印错误信息</code></pre><p>在和&gt;(重定向符号)结合使用时, 把一个文件截断到0长度, 不修改它的权限. 如果文件不存在, 则创建它</p><pre><code>: &gt; data.xxx # 文件&quot;data.xxx&quot; 被清空# 与 cat /dev/null &gt; data.xxx 作用相同, 但是不会产生一个新的进程, 因为:是一个内建命令.</code></pre><p>只适用于普通文件, 不适用于管道, 符号链接, 和其他特殊文件.</p><p>也可以用作注释, :与#不同的是, :不会关闭剩余行的错误检查.</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程中select用法</title>
      <link href="/53b3b0c1/"/>
      <url>/53b3b0c1/</url>
      
        <content type="html"><![CDATA[<p>select提供了一个构建交互式菜单程序的方式, 语法结构: <code>select name [ in word ] ; do list ; done</code></p><p>例:</p><pre><code>#!/bin/bashselect i in a b c ddo    echo $idone</code></pre><p>执行结果</p><pre><code>$ ./select.sh 1) a2) b3) c4) d#? </code></pre><p>选择索引</p><pre><code>$ ./select.sh 1) a2) b3) c4) d#? 1a#? 2b#? 3c#? 4d#? 6#? 1) a2) b3) c4) d#? 1) a2) b3) c4) d#? </code></pre><p>如果输入的不是菜单描述的范围就会echo一个空行，如果直接输入回车，就会再显示一遍菜单本身。当然我们会发现这样一个菜单程序似乎没有什么意义，实际程序中，select大多数情况是跟case配合使用的。</p><pre><code>#!/bin/bashselect i in a b c ddo    case $i in         a)            echo &quot;Your choice is a&quot;        ;;        b)            echo &quot;Your choice is b&quot;        ;;        c)            echo &quot;Your choice is c&quot;        ;;        d)            echo &quot;Your choice is d&quot;        ;;        *)            echo &quot;Wrong choice! exit!&quot;        ;;    esacdone</code></pre><p>执行结果</p><pre><code>$ ./select.sh 1) a2) b3) c4) d#? 1Your choice is a#? 2Your choice is b#? 3Your choice is c#? 4Your choice is d#? 5Wrong choice! exit!</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在shell脚本中使用ls命令的注意事项</title>
      <link href="/12994d1/"/>
      <url>/12994d1/</url>
      
        <content type="html"><![CDATA[<p>请对比如下两个测试：</p><pre><code>$ for i in `ls /etc`;do echo $i;doneadjtimeadobeappstream.confarch-releaseasound.confavahibash.bash_logoutbash.bashrcbind.keysbinfmt.d......$ for i in /etc/*;do echo $i;done/etc/adjtime/etc/adobe/etc/appstream.conf/etc/arch-release/etc/asound.conf/etc/avahi/etc/bash.bash_logout/etc/bash.bashrc/etc/bind.keys/etc/binfmt.d......</code></pre><p>像ls这样的命令很多时候是设计给人用的，它的很多显示是有特殊设定的，可能并不是纯文本。 比如可能包含一些格式化字符，也可能包含可以让终端显示出颜色的标记字符等等。 当我们在程序里面使用类似这样的命令的时候要格外小心，说不定什么时候在什么不同环境配置的系统上， 你的程序就会有意想不到的异常出现，到时候排查起来非常麻烦。 所以这里我们应该尽量避免使用ls这样的命令来做类似的行为，用通配符可能更好。</p><p>当然，如果你要操作的是多层目录文件的话，那么ls就更不能帮你的忙了，它遇到目录之后显示成这样：</p><pre><code>$ ls /etc/*/etc/adobe:mms.cfg/etc/avahi:avahi-autoipd.action  avahi-daemon.conf  avahi-dnsconfd.action  hosts  services/etc/binfmt.d:/etc/bluetooth:main.conf/etc/ca-certificates:extracted  trust-source</code></pre><p>所以遍历一个目录还是要用两个连续的<code>**</code>，如果不是bash 4.0之后的版本的话，可以使用find。 我推荐用find，因为它更通用。 有时候你会发现，使用find之后，绝大多数原来需要写脚本解决的问题可能都用不着了，一个find命令解决很多问题</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件发送原理</title>
      <link href="/b0248f59/"/>
      <url>/b0248f59/</url>
      
        <content type="html"><![CDATA[<p>SMTP(Simple Mail Transfer Protocol)是电子邮件从客户机传输到服务器或从某一个服务器传输到另一个服务器使用的传输协议。SMTP 是请求/响应协议，命令和响应都是基于 ASCII 文本，并以 CR 和 LF 符结束。响应包括一个表示返回状态的三位数字代码。在 TCP 协议 25 端口监听连接请求。其命令如下：</p><p>SMTP命令</p><p>命令说明</p><p>HELO ＜domain＞＜CRLF＞</p><p>识别发送方到接收SMTP的一个HELO命令</p><p>AUTH LOGIN</p><p>登陆服务器的命令。在这条命令之后，要发送用Base64编码后的用户名与密码进行登陆</p><p>MAIL FROM:＜reverse-path＞＜CRLF＞</p><p>＜reverse-path＞为发送者地址。此命令告诉接收方一个新邮件发送的开始，并对所有的状态和缓冲区进行初始化。此命令开始一个邮件传输处理，最终完成将邮件数据传送到一个或多个邮箱中</p><p>RCPT TO:＜forward-path＞＜CRLF＞</p><p>＜forward-path＞标识各个邮件接收者的地址</p><p>DATA ＜CRLF＞</p><p>接收SMTP将把其后的行为看作邮件数据去处理，以＜CRLF＞.＜CRLF＞标识数据的结尾</p><p>REST ＜CRLF＞</p><p>退出/复位当前的邮件传输</p><p>NOOP ＜CRLF＞</p><p>要求接收SMTP仅做OK应答。（用于测试）</p><p>QUIT ＜CRLF＞</p><p>要求接收SMTP返回一个OK应答并关闭传输。</p><p>VRFY ＜string＞ ＜CRLF＞</p><p>验证指定的邮箱是否存在，由于安全因素，服务器多禁止此命令。</p><p>EXPN ＜string＞ ＜CRLF＞</p><p>验证给定的邮箱列表是否存在，扩充邮箱列表，也常禁止使用。</p><p>HELP ＜CRLF＞</p><p>查询服务器支持什么命令</p><hr><p>邮件交互图</p><pre><code>A-&gt;B: 1. 建立TCP连接(host:port, 默认port为25)B-&gt;A: 220. Anti-spam GT for Coremail SystemNote over A: A-&gt;B: 2. 向服务器标识用户身份(HELO host\r\/n)B-&gt;A: 250 OKNote over A: A-&gt;B: 3. 登录服务器(AUTH LOGIN\r\/n)B-&gt;A: 334. username: (这里是解密后的信息)A-&gt;B: &lt;my_username&gt;(要用Base64加密)B-&gt;A: 334. password: (这里是解密后的信息)A-&gt;B: &lt;my_password&gt;(要用Base64加密)B-&gt;A: 235. Authentication successfulNote over A: A-&gt;B: 4. 指定发信者(MAIL FROM: &lt;my_sender@gmail.com&gt;\r\/n)B-&gt;A: 250. Mail OKNote over A: A-&gt;B: 5. 指定收信者(RCPT TO: &lt;my_receiver@gmail.com&gt;\r\/n)B-&gt;A: 250. Mail OKNote over A: A-&gt;B: 6. 发送数据(DATA\r\/n)B-&gt;A: 354. End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;Note over A: A-&gt;B: 7. to: &lt;my_receiver@gmail.com\r\/nsubject:&lt;my_subject&gt;\r\/nSome Context\r\/n.\r\/n&gt;B-&gt;A: 250. Mail OKNote over A: A-&gt;B: 8. QUIT\r\/nB-&gt;A: 221. Bye</code></pre><p><strong>因markdown里不能打出”\n”, 因此使用”\/n” 代替”\n”</strong></p><hr><p>SMTP发信操作及返回码</p><pre><code>[crazywill@localhost crazywill]$ telnet smtp.163.com 25 #telnet登录25端口Trying 202.108.5.81...Connected to smtp.163.com.Escape character is &apos;^]&apos;.220 163.com Coremail SMTP(Anti Spam) SystemEHLO smtp.163.com # 握手 :)250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250 8BITMIMEAUTH LOGIN # 开始认证登录334 dXNlcm5hbWU6crazywill334 UGFzc3dvcmQ6mypassword535 Error: authentication failed # 直接用户名密码不能登录AUTH LOGIN334 dXNlcm5hbWU6Y3Jhenl3aWxs334 UGFzc3dvcmQ6bXlwYXNzd29yZA==235 Authentication successful # 使用Base64编码则成功登录MAIL FROM:&lt;test@163.com&gt; # 邮件发送方553 You are not authorized to send mail, authentication is required # 不可伪造发送邮件 MAIL FROM:&lt;crazywill@163.com&gt; # 邮件发送方250 Mail OKRCPT TO:&lt;crazywill@163.com&gt; # 邮件的接收方，若有多个收件人，则重复这一语句多次。250 Mail OKDATA # 邮件体内容354 Please start mail input.TO: crazywill@163.com # 此处的TO，FROM，等内容，可以随便造假 :) 可以骗人但骗不了懂得查看邮件源码的。FROM: cccc@163.comSUBJECT: test by telnet/smtp test, just a test. # 邮件正文内容，与Header部分空一行开始写. # 邮件写完，以一个句点加回车结果。250 Mail OK queued as smtp10,wKjADQ2ApxRnnqBE0CWaEw==.38326S3 # 返回250 表示发送成功。NOOP # 空语句，不执行任何操作，一般用来保持和服务器连接，不要掉线250 OKQUIT # 退出221 Closing connection. Good bye.Connection closed by foreign host.[crazywill@localhost crazywill]$</code></pre><hr><p>参考资料: <a href="http://www.cnblogs.com/FengYan/archive/2013/01/01/2840982.html" target="_blank" rel="noopener">用c++发邮件</a> <a href="http://blog.csdn.net/lishuhuakai/article/details/27503503" target="_blank" rel="noopener">电子邮件发送的原理以及简易实现</a> <a href="http://blog.csdn.net/lishuhuakai/article/details/27852009" target="_blank" rel="noopener">邮件正文及其附件的发送的C++实现</a> <a href="http://blog.csdn.net/zbird1988/article/details/11592137" target="_blank" rel="noopener">C++通过SMTP发送邮件总结</a> <a href="http://blog.csdn.net/zbird1988/article/details/11592137" target="_blank" rel="noopener">C++实现向多人发送邮件</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]How to split a string in C++</title>
      <link href="/9747854a/"/>
      <url>/9747854a/</url>
      
        <content type="html"><![CDATA[<p>这个问题是说, 怎么得到组成一句话的各个单词, 或者得到CSV中的各个数据片段. 这在C++中是个很简单的问题, 却有很多种答案.</p><p>有3种方案, 每种有利有弊. 使用时请自己选择最佳方案. 这篇文章的目的是说明 迭代器的接口是如何优胜于简单的容器的, 并且阐明 <a href="http://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/" target="_blank" rel="noopener">design of the STL</a> 是何等强大.</p><p>方案1使用的标准组件(虽然方案1.2 做了微调). 方案2相对好点但使用了<code>boost</code>. 而方案3 更好但使用了<code>ranges</code>. 所以到底应该用哪个, 取决于你需要什么和你能使用什么.</p><h3 id="solution-1-iterating-on-a-stream"><span id="solution-1-iterating-on-a-stream">Solution 1: Iterating on a stream</span></h3><h4 id="stepping-into-the-world-of-streams"><span id="stepping-into-the-world-of-streams">Stepping into the world of streams</span></h4><p>“流” 是一个 能生成 与源或希望连接的目标 的联系 的对象. 流可以从源中获取信息(<code>std::istream</code>), 或为目标提供信息(<code>std::ostream</code>), 或者两者皆可(<code>std::iostream</code>).</p><p>源和目标可以是标准输入(<code>std::cin</code>), 标准输出(<code>std::cout</code>), 一个文件, 或者一个字符串, 前提是方式得当. 对流的主要操作包括: - 对于输入流: 使用操作符<code>&gt;&gt;</code> 从里面读取信息 - 对于输出流: 使用操作符<code>&lt;&lt;</code>, 向它推入信息</p><p>一个指向字符串的输入流, <code>std::istringstream</code>, 有个有趣的特性: 它的操作符<code>&gt;&gt;</code> 在源字符串中制造出去向下一个空格的字符串.</p><h4 id="istream_iterator"><span id="istream_iterator">istream_iterator</span></h4><p><code>std::istream_iterator</code> 是连接输入流的迭代器. 它代表了输入迭代器的普遍接口, 但它的操作符<code>++</code> 更像是输入流.</p><p><code>istream_iterator</code> 以它从流里读取的类型为模板. 我们现在使用<code>istream_iterator&lt;std::string&gt;</code>, 它从流里读取字符串, 分离时为我们提供一个字符串.</p><p>当到达流的终点时, 流向它的迭代器发送信号, 然后迭代器被标记为结束.</p><h3 id="solution-11"><span id="solution-11">Solution 1.1</span></h3><p>现在, 我们可以借迭代器的接口使用算法, 这真切地证明了<code>STL</code> 设计的灵活性. 为了使用<code>STL</code>, 我们需要一个<code>begin</code> 和一个<code>end</code> (请参考<a href="http://www.fluentcpp.com/2017/03/28/inserting-several-elements-into-an-stl-container/" target="_blank" rel="noopener">Inserting several elements into an STL container efficiently</a>). <code>begin</code> 是一个 还没开始着手分割的字符串的<code>istreamstream</code> 的迭代器: <code>std::istream_iterator&lt;std::string&gt;(iss)</code> . 按照惯例, <code>end</code> 的默认值也是个<code>istream_iterator</code> : <code>std::istream_iterator&lt;string&gt;()</code>.</p><p>代码如下:</p><pre><code>std::string text = &quot;Let me split this into words&quot;;std::istringstream iss(text);std::vector&lt;std::string&gt; results((std::istream_iterator&lt;std::string&gt;(iss)), std::istream_iterator&lt;std::string&gt;());</code></pre><p><strong>第一个参数的额外的括号是为了避免与一个函数调用的歧义–请参考Scott Meyers的著作Effective STL 条目6 “most vexing parse”</strong></p><p>优: - 仅使用标准组件 - 除字符串外, 对所有流都适用 劣: - 只能以空格为分隔符进行分割, 而且这在解析CSV时会是个至关重要的问题 - 在性能方面有待优化(但如果这不是影响你整个程序的瓶颈, 这也不是个大问题) - 很多人认为仅为了分割一个字符串, 写了太多代码</p><h3 id="solution12-pimp-my-operatorgtgt"><span id="solution12-pimp-my-operatorgtgt">Solution1.2: Pimp my operator&gt;&gt;</span></h3><p>导致上面两条劣势的原因是同一个: <code>istream_iterator</code> 从流里读取字符串时调用的操作符<code>&gt;&gt;</code>. 这个操作符做了很多事: 在下一个空格处停止(这是我们的最初的需求, 但这个不能自定义), 格式化, 读取然后设置一些标志位, 构造对象, 等等. 而以上这些, 大部分我们是不需要的. 所以我们希望自己实现下面的函数:</p><pre><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; is, std::string&amp; output){    // ...does lots of things...}</code></pre><p>实际上, 我们无法改变这些, 因为这是在标注库里的. 我们可以用另一个类型重载它, 但是这个类型需要是<code>string</code> 的一种.</p><p>所以现在的需求就是, 用另一种类型伪装成<code>string</code>. 有两种方案: 继承<code>std::string</code> 和 用显式转换封装<code>string</code>. 这里我们选择继承.</p><p>假如我们希望以逗号为分割符分割一个字符串:</p><pre><code>class WordDelimitedByCommas: pulic std::string{};</code></pre><p>我必须承认这是有争议的. 有人会说:”<code>std::string</code> 没有虚析构函数, 所以你不应该继承它!” 这可能, 大概, 也许是有一点点点点武断. 这里我要说的是, 继承本身不会产生问题. 诚然, 当一个指向<code>WordDelimitedByCommas</code> 的指针以<code>std::string</code> 的形式被<code>delete</code> 掉时, 会产生问题. 继续读, 你会发现, 我们不会这么做. 现在我们可以阻止写代码的人借<code>WordDelimitedByCommas</code> 突发冷箭破坏程序吗? 我们不能. 但是这个险值得我们冒吗? 请继续读, 然后你自己判断.</p><p>现在为了仅实现我们需要的功能, 我们可以重载操作符<code>&gt;&gt;</code> : 获取下一个逗号之前的所有字符. 这个可以借用<code>getline</code> 函数实现:</p><pre><code>std::istream&amp; operator&gt;&gt;(std::istream* is, std::WordDelimitedByCommas&amp;){    std::getline(is, output, &apos;,&apos;);    return is;}</code></pre><p><strong>返回值<code>is</code> 保证了可以连续调用操作符<code>&gt;&gt;</code></strong></p><p>现在我们可以写初级代码了:</p><pre><code>std::string text = &quot;Let,me,split,this,into,words&quot;;std::istringstream iss(text);std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedByCommas&gt;(iss)), std::istream_iterator&lt;WordDelimitedByCommas&gt;());</code></pre><p>我们可以通过模板化<code>WordDelimitedByCommas</code> 泛华所有的分隔符:</p><pre><code>template&lt;char delemiter&gt;class WordDelimitedBy: pulic std::string{};</code></pre><p>现在以分号举例:</p><pre><code>std::string text = &quot;Let;me;split;this;into;words&quot;;std::istringstream iss(text);std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedBy&lt;&apos;;&apos;&gt;&gt;(iss)), std::istream_iterator&lt;WordDelimitedBy&lt;&apos;;&apos;&gt;&gt;());</code></pre><p>优: - 编译时允许任何分隔符 - 不仅是字符串, 对任何流都可以操作 - 比方案1更快(快20%到30%) 劣: - 虽然可以很方便的复用, 但仍不是标准 - 仅仅为了分割一个字符串, 这个方案仍然使用了大量代码</p><h3 id="solution2-using-boostsplit"><span id="solution2-using-boostsplit">Solution2: Using <code>boost::split</code></span></h3><p>这个方案比方案1高级, 除非你需要对所有的流都进行操作.</p><pre><code>#include &lt;boost/algorithm/string.hpp&gt;std::string text = &quot;Let me split this into words&quot;;std::vector&lt;std::string&gt; result;boost::split&lt;results, text, [](char c){return &apos; &apos; == c;});</code></pre><p>传给<code>boost::split</code> 的第三个参数是一个函数或函数对象, 确定一个字符是不是分隔符. 上面的例子是使用<code>lambda</code> 表达式, 传入一个<code>char</code>, 返回这个<code>char</code> 是否是空格.</p><p><code>boost::split</code> 的实现很简单: 在到达字符串的结束位置之前, 重复地调用<code>find_if</code> .</p><p>优: - 非常直观的接口 - 允许任何分隔符, 甚至是多个 - 高效: 比方案1.1 快 60% 劣: - 暂不是标准: 需要用到<code>boost</code></p><h3 id="solution-3未来-usingranges"><span id="solution-3未来-usingranges">Solution 3(未来): Using<code>ranges</code></span></h3><p>虽然它们现在还没有像标准库甚至<code>boost</code> 里的组件一样被广泛使用, <code>ranges</code> 是<a href="http://www.fluentcpp.com/2017/01/12/ranges-stl-to-the-next-level/" target="_blank" rel="noopener">future of the STL</a> . 在未来几年, 会大量面世.</p><p>Eric Neiber 的 <a href="https://github.com/ericniebler/range-v3/blob/master/test/view/split.cpp" target="_blank" rel="noopener">range-v3</a> 库 提供了非常友好的接口. 为了生成一个字符串的分割<code>view</code>, 代码如下:</p><pre><code>std::string text = &quot;Let me split this into words&quot;;auto splitText = text | view::split(&apos; &apos;);</code></pre><p>它有很多有趣的特性, 诸如 使用一个子字符串作为分隔符. <code>ranges</code> 会被<code>C++20</code> 引入, 所以我们应该能在几年之内就可以使用这个功能了.</p><h3 id="so-how-do-i-split-my-string"><span id="so-how-do-i-split-my-string">So, how do I split my string?</span></h3><p>如果你能使用<code>boost</code>, 务必使用方案2. 或者你可以自己写算法, 像<code>boost</code> 那样基于<code>find_if</code> 分割字符串.</p><p>如果你不想这么做, 你可以使用标准, 即方案1.1, 如果你需要自定义分隔符, 或者发现1.1是个瓶颈, 那么你可以选择方案1.2 .</p><p>如果你可以使用<code>ranges</code> , 那么就应该选择方案3.</p><p>翻译原文: <a href="http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/" target="_blank" rel="noopener">http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>strict weak ordering</title>
      <link href="/22f34ac7/"/>
      <url>/22f34ac7/</url>
      
        <content type="html"><![CDATA[<p>A strict weak ordering is a <em>binary relation</em> &lt; on a set S that is a strict partial order (a transitive relation that is irreflexive, or equivalently, that is asymmetric) in which the relation <code>neither a &lt; b nor b &lt; a</code> is transitive. Therefore, a strict weak ordering has the following properties:</p><ul><li>For all x in S, it is not the case that x &lt; x (irreflexivity).</li><li>For all x, y in S, if x &lt; y then it is not the case that y &lt; x (asymmetry).</li><li>For all x, y, z in S, if x &lt; y and y &lt; z then x &lt; z (transitivity).</li><li>For all x, y, z in S, if x is incomparable with y (neither x &lt; y nor y &lt; x hold), and y is incomparable with z, then x is incomparable with z (transitivity of incomparability).</li></ul><p>This list of properties is somewhat redundant, as asymmetry follows readily from irreflexivity and transitivity.</p><p><strong>离散数学中的relation:</strong> Given a function f (which models a binary relation) over a domain D, and a, b ∈ D:</p><ul><li>Reflexivity: f (a, a) is true.</li><li>Asymmetry: For a ≠ b, if f(a, b) is true, f(b,a) is false</li><li>Anti-symmetry: If f(a, b) and f(b, a) are both true iff a ≡ b</li><li>Transitivity: If f(a, b) and f(b, c) are true, then f(a, c) is true</li><li>Incomparability: Neither f(a, b) nor f(b, a) is true</li><li>Transitivity of incomparability: If a and b are incomparable, and so are b and c, then a and c are incomparable.</li></ul><p>摘自WikiPedia</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 禁止普通用户su切换root</title>
      <link href="/e5131675/"/>
      <url>/e5131675/</url>
      
        <content type="html"><![CDATA[<p>一般情况下, 普通用户执行”su -“命令, 可以登录为root. 为了加强系统的安全性, 有必要建立一个管理员的组, 只允许这个组的用户执行”su -“ 命令登录为root, 而让其他组的用户即使执行”su -“ 输入了正确的密码, 也无法登录为root用户. 在Unix 和Linux 下, 这个组的名称通常为”wheel”.</p><p>1 添加一个用户, 把这个用户加入wheel组 2 修改/etc/pam.d/su <code>#auth required pam_wheel.so use_uid</code> 这行注释打开 3 修改/etc/login.defs 在文件末添加一行 <code>SU_WHEEL_ONLY yes</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>禁止root用户ssh登录机器</title>
      <link href="/d29ba5b9/"/>
      <url>/d29ba5b9/</url>
      
        <content type="html"><![CDATA[<p>1 修改 /etc/ssh/sshd_config <code>#PermitRootLogin yes</code> 取消注释并改为 <code>PermitRootLogin no</code></p><p>2 重启ssh <code>/etc/init.d/sshd restart</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Move semantics of RapidJSON</title>
      <link href="/e5a4892c/"/>
      <url>/e5a4892c/</url>
      
        <content type="html"><![CDATA[<p>RapidJSON 的设计有一个特性, 进行赋值操作时, 不是把源value复制(copy)到目的 value, 而是转移(move)到目的value. 例如</p><pre><code>Value a(123);Value b(456);b = a; // a becomes a Null value, b becomes number 123.</code></pre><p><img src="http://img.blog.csdn.net/20170510091639158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这样的设计的目的是 为了提高性能. 对于固定大小的JSON类型(Number, True, False, Null), 复制很简单快捷. 而对于可变大小的类型(String, Array, Object), 复制时会产生大量不容易被察觉的开销. 尤其是当我们需要创建一个临时的值, 把它复制给另一个变量, 然后析构它. 若使用正常的<strong>复制</strong> 语义:</p><pre><code>Document d;Value o(kObjectType);{    Value contacts(kArrayType);    // Adding elements to contacts array.    // ...    o.AddMember(&quot;contacts&quot;, contacts, d.GetAllocator(); // deep clone contacts(may be with lots of allocations)    // destruct contact}</code></pre><p><img src="http://img.blog.csdn.net/20170510092703640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><code>o</code> 需要分配跟<code>contacts</code> 大小一样的缓冲区, 做深度复制, 然后析构<code>contacts</code> . 这样会产生大量不必要的内存分配/释放 和内存复制. 有一些方案可以避免实质的复制这些数据, 如引用计数, 垃圾回收等等. 为了使RapidJSON简单和快速, 我们选择使用转移语义来进行赋值. 这与<code>std::auto_ptr</code>类似, 都是在赋值时转移拥有权. 转移比复制简捷地多, 它只需 析构原来的值, 把源值<code>memcpy()</code> 到目的值, 最后再把源值 设为Null类型.</p><p>使用转移语义, 上面的例子变成:</p><pre><code>Document d;Value o(kObjectType);{    Value contacts(kArraryType);    // Adding elements to contacts array.    o.AddMember(&quot;contacts&quot;, contacts, d.GetAllocator()); // Just memcpy() of contacts itself to the value of new member(16 bytes)    // contacts became Null here. Its destructiong is trivial.}</code></pre><p><img src="http://img.blog.csdn.net/20170510094606202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>转移语义和临时值</strong> 有时, 我们想直接构造一个临时变量传给”转移”函数, 如<code>PushBack()</code> , <code>AddMember()</code> . 由于临时对象不能直接转化成正常的值引用, 我们可以调用<code>Move()</code> 函数</p><pre><code>Value a(kArrayType);Document::AllocatorType&amp; allocator = document.GetAllocator();// a.PushBack(Value(42), allocator); // Compiling errora.PushBack(Value().SetInt(42), allocator); // fluent APIa.PushBack(Value(42).Move(), allocator); // same as above</code></pre><p>翻译原文: <a href="http://rapidjson.org/md\_doc\_tutorial.html#MoveSemantics" target="_blank" rel="noopener">http://rapidjson.org/md\_doc\_tutorial.html#MoveSemantics</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[译]C++11 sort using function objects</title>
      <link href="/e754bcbe/"/>
      <url>/e754bcbe/</url>
      
        <content type="html"><![CDATA[<p>如果你用C++编码， 需要对容器内的元素进行排序， 这个容器提供任意访问的迭代器， 比如<code>std::vector</code>， 那么简单快捷的方法是使用里的<code>std::sort</code> 函数.</p><p><strong>Basic sorting</strong> <code>std::sort</code> 函数需要两个参数, 这两个参数分别指向你要排序的序列容器的开始(initial)和终点(final). 这个序列容易内除final指向的那个元素外 所有元素都会被排序. 下面是一个简单的排序例子:</p><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;&lt;/vector&gt;&lt;/algorithm&gt;const int array[] {10, 20, 5, 15, 0};std::vector&lt;int&gt; vec(array, array + 5);&lt;/int&gt;std::sort(vec.begin(), vec.end());</code></pre><p>输出: <code>0 5 10 15 20</code></p><p><strong>More complex sorting</strong> 在某些时候, 根据数值升序排序已经足够解决问题了, 但是当我们需要按某个特定的参数进行排序, 或者降序排列时, 就需要一些其他的东西了. 对于这种需求, <code>std::sort</code> 需要引入第三个参数: 比较函数. 这个比较函数有两个参数, 分别是序列容器的两个元素, 返回值可以隐式地转为bool. 如果第一个参数应该排在第二个参数前面, 则返回true.</p><p>例:</p><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;&lt;/vector&gt;&lt;/algorithm&gt;bool DescOrderInt(int a, int b);...const int array[] = {10, 20, 5, 15, 0};std::vector&lt;int&gt; vec(array, array + 5);&lt;/int&gt;std::sort(vec.begin(), vec.end(), DescOrderInt);</code></pre><p>DescOrderInt的实现:</p><pre><code>bool DescOrderInt(int a, int b){return a &amp;gt; b;}</code></pre><p>输出: <code>20 15 10 5 0</code></p><p><strong>C++11 sort using function objects</strong> 网上很多例子说, 为了排列元素, 可以使用<code>std::binary_function</code> 定义比较函数, 但不幸的是, <code>std::binary_function</code> 在C++11 中已经被标为 “将被弃用的”, 在C++17中会被完全移除, 所以写新的C++代码时, 最好不要用这个.</p><p>我们可以使用C++11中引入的<code>std::function</code> 来定义这个函数指针. 例:</p><pre><code>#include &lt;algorithm&gt;#include &lt;function&gt;#include &lt;vector&gt;&lt;/vector&gt;&lt;/function&gt;&lt;/algorithm&gt;struct StrDescOrderInt{bool operator()(int a, int b) const{return a &amp;gt; b;}};...const int array[] = {10, 20, 5, 15, 0};std::vector&lt;int&gt; vec(array, array + 5);&lt;/int&gt;std::function&lt;bool(int, int)=&quot;&quot;&gt; sorter = StrDescOrderInt();&lt;/bool(int,&gt;std::sort(vec.begin(), vec.end(), sorter);</code></pre><p>输出: <code>20 15 10 5 0</code></p><p><strong>A real-life example: providing multiple sorting options</strong> 我们假设有一队足球运动员, 我们想让用户按他们自己的意愿去排列这些运动员. 有一个图表的UI, 上面有几个按钮, 每个按钮对应不用的排序规则.</p><p>Plaer 类的代码:</p><pre><code>// -- Player.h --#include &lt;string&gt;&lt;/string&gt;class Player{public:Player(const char * name, int caps, int goals);const std::string &amp;amp; GetName() const;int GetCaps() const;int GetGoals() const;private:std::string mName;int mCaps;int mGoals;};</code></pre><p>现在我们新写一个类或结构体来列出所有的比较函数. 比较函数是一个结构体并实现操作符<code>()</code>, 操作符<code>()</code> 带有两个参数, 分别为两个指向Player的指针, 返回bool值.</p><pre><code>class Player;struct PlayerSorting{// namestruct SortPlayerByNameAsc (bool operator()(Player* p1, Player* p2) const;);struct SortPlayerByNameDes (bool operator()(Player* p1, Player* p2) const;);// capsstruct SortPlayerByCapsAsc (bool operator()(Player* p1, Player* p2) const;);struct SortPlayerByCapsDes (bool operator()(Player* p1, Player* p2) const;);// goalsstruct SortPlayerByGoalsAsc (bool operator()(Player* p1, Player* p2) const;);struct SortPlayerByGoalsDes (bool operator()(Player* p1, Player* p2) const;);}</code></pre><p>然后, 在调用它的地方, 我们可以先把所有的<code>std::function</code> 存在一个<code>std::vector</code> 里, 使用的时候, 用索引访问vector的元素.</p><pre><code>std::vector&amp;lt; std::function&lt;bool(player *,=&quot;&quot; player=&quot;&quot; *)=&quot;&quot;&gt; &amp;gt; sorters;sorters.push_back(PlayerSorting::SortPlayerByNameAsc());sorters.push_back(PlayerSorting::SortPlayerByCapsAsc());sorters.push_back(PlayerSorting::SortPlayerByGoalsAsc());sorters.push_back(PlayerSorting::SortPlayerByNameDes());sorters.push_back(PlayerSorting::SortPlayerByCapsDes());sorters.push_back(PlayerSorting::SortPlayerByGoalsDes());&lt;/bool(player&gt;</code></pre><p>例如, 根据得分降序排列:</p><pre><code>std::vector&lt;player *=&quot;&quot;&gt; players;&lt;/player&gt;// ...init players...std::sort(players.begin(), players.end(), sorters[5]);</code></pre><p>输出:</p><pre><code>NAME                     CAPS  GOALSLionel Messi             21    20David Villa              13    16Asamoah Gyan             22    15Arjen Robben             11    12Mesut Oezil              19    10Diego Forlan             20    10Andres Iniesta           15    9Wesley Sneijder          24    6Xavi                     17    5Bastian Schweinsteiger   23    4</code></pre><p>假如需要实现一种新的排序方式, 我们只需要在PlayerSorting类中添加一个新的仿函数即可.</p><p>原文地址: <a href="http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/" target="_blank" rel="noopener">http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>core文件被截断问题的解决办法</title>
      <link href="/d12416f0/"/>
      <url>/d12416f0/</url>
      
        <content type="html"><![CDATA[<p><strong>现象</strong><br>通过gdb打开core，但看不到core的内容，信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ gdb XXX core.XXX</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux ( 7.0.1-32.el5)</span><br><span class="line">Copyright (C) 2009 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /home/XXX/XXX...done.</span><br><span class="line">BFD: Warning: /home/XXX/core.XXX is truncated: expected core file size &gt;= 747175936, found: 1236992.</span><br><span class="line"> </span><br><span class="line">warning: core file may not match specified executable file.</span><br><span class="line">Cannot access memory at address 0x344201cc88</span><br></pre></td></tr></table></figure><p><strong>调查</strong><br>ulimit -a的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 1000</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 40960</span><br><span class="line">max locked memory       (kbytes, -l) 32</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65000</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 536870912</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 1024000</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 40960</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>经别人指点，说是“core file size”的值太小了。</p><p><strong>修改core file size的方法</strong><br>1 使用root用户登录，在<code>/etc/security/limits.conf</code>文件中，添加了“* hard core   unlimited”行，添加后此文件的内容大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># /etc/security/limits.conf</span><br><span class="line">#</span><br><span class="line"># Each line describes a limit for a user in the form:</span><br><span class="line">#</span><br><span class="line"># &lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;</span><br><span class="line">#</span><br><span class="line">* - msgqueue 536870912</span><br><span class="line">* soft nofile 65000</span><br><span class="line">* hard nofile 65000</span><br><span class="line">* soft core   unlimited</span><br><span class="line">* hard core   unlimited</span><br></pre></td></tr></table></figure><p>2 修改这个文件后，退出root用户<br>3 退出自己的账户的全部登录的终端，然后关闭telnet工具，重新使用自己的账户登录系统，键入下面的命令，都会返回unlimited</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -S -c</span><br><span class="line">unlimited</span><br><span class="line">$ ulimit -H -c</span><br><span class="line">unlimited</span><br></pre></td></tr></table></figure><p>此时core文件就不会被截断了。</p><p><strong>参考资料</strong><br>How do I enable core dumps for everybody<br><a href="http://www.akadia.com/services/ora_enable_core.html" target="_blank" rel="noopener">http://www.akadia.com/services/ora_enable_core.html</a></p><p>原文地址: <a href="http://blog.sina.com.cn/s/blog_537f4d9b0100wi88.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_537f4d9b0100wi88.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> core </tag>
            
            <tag> 解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]String&amp;#039;s interface</title>
      <link href="/4c3249cd/"/>
      <url>/4c3249cd/</url>
      
        <content type="html"><![CDATA[<p>考虑以下代码:</p><pre><code>bool fun(const string&amp;amp; code){assert(code.length() &amp;gt;= 2);if (code.substr(0, 2) == string(&quot;XX&quot;)){// ...}// ...}</code></pre><p>有没有发现什么问题? 不要纠结于assert(), 它只是为了保证 string “code” 长度大于2而已.</p><p>很显然, 这段代码用来检查string是否以”XX”开头. 基于它长度大于2 的前提, 这段代码能正常运行. 我们的关心的问题是, 表达式能否达到正确的结果.</p><p>绝大多数情况下, 我们之所以使用C++, 是希望能使我们的程序达到最优的性能. 基于这个目标, 上面的代码看起来就不是很正确了. 为了检查”code”是否以”XX”开头, 我们生成了两个临时的string, 每个string都可能潜在地申请堆上的内存. 有人可能会为此辩解: std::string应该能为一个 2字母的序列实现 短字符串最优化(SSO). 就算这个辩解是正确的, 这段代码也已经 耗费了 一些不能被优化掉的开销, 更何况, 并不是所有的都会实现SSO. 例如, 我使用的GCC 4.4.7 就不会为string实现SSO.</p><p>类模板<code>std::basic_string</code> 的接口很复杂. 它提供了大量的成员函数, 似乎不用它们显得不领情, 同时开发者也不会有自己一遍遍重新解析的冲动.</p><p>因为开发者模糊地记得应用于NTBS(null-terminated byte strings)(可以被隐式地转为<code>const char*</code> )的 操作符 <code>==</code> 会使结果出错, 所以他通过 确保参与比较的两个值都是<code>std::string</code> 类型来避开这个错误. 他可能在想, 在运行操作符<code>==</code> 前文本”XX” 已经被显式地转成了<code>std::string</code>, 那么这么做也没有坏处. <strong>但是</strong>, 这是错误的, 因为对于操作符<code>==</code>, 标准提供了两种版本:</p><pre><code>bool operator==(const std::string&amp;amp; lhs, const char* rhs);bool operator==(const char* lhs, const std::string&amp;amp; rhs);</code></pre><p>当然实际上他们是带有多个参数的函数模板, 远比这个复杂. <code>std::string</code> 可以直接跟NTBS比较, 没有必要生成临时的<code>std::string</code>. 我们开头的例子, 可以通过去除显式生成的临时副本 进行优化: <code>if (code.substr(0, 2) == &quot;XX&quot;)</code></p><p>更进一步, 不可否认, 在有些地方使用操作符<code>==</code> 看起来很高雅, 但是仅仅为了检查一个<code>string</code> 本身的一部分而去新申请一部分资源(生成一个新的<code>string</code>) 这种做法是错误的. 开发者的初衷, 并不是要是程序看起来高雅. 实际上, 如果我们深入研究<code>std::basic_string</code> 的官方文档, 就会发现, <code>std::basic_string</code>提供了一种比较它的子字符串和NTBS的方法: <code>if(code.compare(0, 2, &quot;XX&quot;) == 0)</code> 这个比较是三方比较, 结果等于0表示相等. 它可以达到目的, 并且不需要生成任何临时的<code>string</code>.</p><p>尽管这个<code>compare()</code> 使性能达到了很大的优化, 但我并不满足于此. 虽然它做了正确的事情, 但如果我们是第一次遇到他, 很难抓住他的精髓. 如果你可以使用boost库, 我的建议性的解决方案是使用<code>Boost String Algorithms Library</code> 中的算法:</p><pre><code>#include &lt;boost algorithm=&quot;&quot; string=&quot;&quot; predicate.hpp=&quot;&quot;&gt;&lt;/boost&gt;bool func(const string&amp;amp; code){if (boost::algorithm::starts_with(code, &quot;XX&quot;))}</code></pre><p>这段代码很好地体现了我想说的意思, 没有任何多余的开销.</p><p>原文地址: <a href="https://akrzemi1.wordpress.com/2015/04/15/strings-interface/" target="_blank" rel="noopener">https://akrzemi1.wordpress.com/2015/04/15/strings-interface/</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++返回内部静态成员的陷阱</title>
      <link href="/d66df6b4/"/>
      <url>/d66df6b4/</url>
      
        <content type="html"><![CDATA[<p>在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多开发人员。如果你的内存是在函数内栈上分配的，那么这个内存会随着函数的返回而被弹栈释放，所以，你一定要返回一块函数外部还有效的内存。</p><p>这是一个让无数人困扰的问题。如果你一不小心，你就很有可能在这个上面犯错误。当然目前有很多解决方法，如果你熟悉一些标准库的话，你可以看到许多各式各样的解决方法。大体来说有下面几种：</p><p>1）在函数内部通过malloc或new在堆上分配内存，然后把这块内存返回（因为在堆上分配的内存是全局可见的）。这样带来的问题就是潜在的内存问题。因为，如果返回出去的内存不释放，那么就是memory Leak。或者是被多次释放，从而造成程序的crash。这两个问题都相当的严重，所以这种设计方法并不推荐。（在一些Windows API中，当你调用了一些API后，你必需也要调用他的某些API来释放这块内存）</p><p>2）让用户传入一块他自己的内存地址，而在函数中把要返回的内存放到这块内存中。这是一个目前普遍使用的方式。很多Windows API函数或是标准C函数都需要你传入一个buffer和这个buffer的长度。这种方式对我们来说应该是屡见不鲜了。这种方式的好处就是由函数外部的程序来维护这块内存，比较简显直观。但问题就是在使用上稍许有些麻烦。不过这种方式把犯错误的机率减到了最低。</p><p>3）第三种方式显得比较另类，他利用了static的特性，static的栈内存一旦分配，那这块内存不会随着函数的返回而释放，而且，它是全局可见的（只要你有这块内存的地址）。所以，有一些函数使用了static的这个特性，即不用使用堆上的内存，也不需要用户传入一个buffer和其长度。从而，使用得自己的函数长得很漂亮，也很容易使用。</p><p>这里，我想对第三个方法进行一些讨论。使用static内存这个方法看似不错，但是它有让你想象不到的陷阱。让我们来用一个实际发生的案例来举一个例子吧。</p><p><strong>示例</strong></p><p>有过socket编程经验的人一定知道一个函数叫：inet_ntoa，这个函数主要的功能是把一个数字型的IP地址转成字符串，这个函数的定义是这样的（注意它的返回值）：</p><p><code>char *inet_ntoa(struct in_addr in);</code></p><p>显然，这个函数不会分配堆上的内存，而他又没有让你传一下字符串的buffer进入，那么他一定使用“返回static char[]”这种方法。在我们继续我们的讨论之前，让我们先了解一下IP地址相关的知识，下面是inet_ntoa这个函数需要传入的参数：（也许你会很奇怪，只有一个member的struct还要放在struct中干什么？这应该是为了程序日后的扩展性的考虑）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span>  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> s_addr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于IPV4来说，一个IP地址由四个8位的bit组成，其放在<code>s_addr</code>中，高位在后，这是为了方便网络传输。如果你得到的一个<code>s_addr</code>的整型值是：3776385196。那么，打开你的Windows计算器吧，看看它的二进制是什么？让我们从右到左，8位为一组（如下所示）。</p><p>11100001   00010111    00010000    10101100</p><p>再把每一组转成十进制，于是我们就得到：225   23   16   172， 于是IP地址就是 172.16.23.225。</p><p>好了，言归正传。我们有这样一个程序，想记录网络包的源地址和目地地址，于是，我们有如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">src</span>, <span class="title">des</span>;</span>  </span><br><span class="line">........  </span><br><span class="line">........  </span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"源IP地址&lt;%s&gt;/t目的IP地址&lt;%s&gt;/n"</span>, inet_ntoa(src),   inet_ntoa(des));</span><br></pre></td></tr></table></figure><p>会发生什么样的结果呢？你会发现记录到文件中的源IP地址和目的IP地址完全一样。这是什么问题呢？于是你开始调试你的程序，你发现src.s_addr和des.s_addr根本不一样（如下所示）。可为什么输出到文件的源和目的都是一样的？难道说是inet_ntoa的bug？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src.s_addr = <span class="number">3776385196</span>;    <span class="comment">//对应于172.16.23.225  </span></span><br><span class="line">des.s_addr = <span class="number">1678184620</span>;  <span class="comment">//对应于172.16.7.100</span></span><br></pre></td></tr></table></figure><p>原因就是<code>inet_ntoa()</code>“自作聪明”地把内部的static char[]返回了，而我们的程序正是踩中了这个陷阱。让我们来分析一下fprintf代码。在我们fprintf时，编译器先计算<code>inet_ntoa(des)</code>，于是其返回一个字符串的地址，然后程序再去求<code>inet_ntoa(src)</code>表达式，又得到一个字符串的地址。这两个字符串的地址都是<code>inet_ntoa()</code>中那个<code>static char[]</code>，显然是同一个地址，而第二次求src的IP时，这个值的des的IP地址内容必将被src的IP覆盖。所以，这两个表达式的字符串内存都是一样的了，此时，程序会调用fprintf把这两个字符串（其实是一个）输出到文件。所以，得到相同的结果也就不奇怪。</p><p>仔细看一下inet_ntoa的man，我们可以看到这句话：<code>The string is returned in a statically allocated buffer,  which  subsequent calls will overwrite.</code>证实了我们的分析。</p><p><strong>小结</strong></p><p>让我们大家都扪心自问一下，我们在写程序的过程当中是否使用了这种方法？这是一个比较危险，容易出错的方法。这种陷阱让人防不胜防。想想，如果你有这样的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>( inet_ntoa(ip1), inet_ntoa(ip2) )==<span class="number">0</span> ) &#123;  </span><br><span class="line">…. ….  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本想判断一下两个IP地址是否一样，却不料掉入了那个陷阱——让这个条件表达式永真。</p><p>这个事情告诉我们下面几个道理：</p><p>1）慎用这种方式的设计。返回函数内部的static内存有很大的陷阱。</p><p>2）如果一定要使用这种方式的话。你就必须严肃地告诉所有使用这个函数的人，千万不要在一个表达式中多次使用这个函数。而且，还要告诉他们，不copy函数返回的内存的内容，而只是保存返回的内存地址或是引用是没用的。不然的话，后果概不负责。</p><p>3）C/C++是很危险的世界，如果你不清楚他的话。还是回火星去吧。</p><p>附：看过Efftive C++的朋友一定知道其中有一个条款（item 23）：不要试图返回对象的引用。这个条款中也对是否返回函数内部的static变量进行了讨论。结果也是持否定态度的。</p><p>原文地址: <a href="http://www.tuicool.com/articles/JNZZfiZ" target="_blank" rel="noopener">http://www.tuicool.com/articles/JNZZfiZ</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 陷阱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]Custom comparison, equality and equivalence with the STL</title>
      <link href="/55f488ad/"/>
      <url>/55f488ad/</url>
      
        <content type="html"><![CDATA[<p>从一段代码引用开始:</p><pre><code>std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; v1 = ... // v1 is filled with datastd::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; v2 = ... // v2 is filled with datastd::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; results;&lt;/int,&gt;&lt;/int,&gt;&lt;/int,&gt;std::sort(v1.begin(), v1.end());std::sort(v2.begin(), v2.end());std::set_difference(v1.begin(), v1.end(),v2.begin(), v2.end(),std::back_inserter(result),compareFirst);</code></pre><p>我们在两个排好序的vector v1 和 v2上调用<code>std::set_difference</code>. <code>std::set_difference</code> 把结果写入 <code>result</code>, <code>std::back_inserter</code> 确保输出的结果从<code>result</code> 的后面添入. 自定义的<code>compareFirst</code> 作为比较函数提供给<code>std::set_difference</code></p><p>默认地, <code>std::set_difference</code> 通过 <code>std::pair</code> 默认的比较函数来比较里面的元素(比较pair的first和second), 我们自定义了<code>compareFirst</code>, 希望只比较pair的first. <code>compareFirst</code>不是STL的函数, 需要我们自己实现.</p><p><code>std::set_difference</code> 使用的前提是input已经排好序, 倘若我们自定义比较函数C, 而通过C我们能把元素排好序, 那么我们使用这个C代替sort的默认排序也是可以的.</p><p>在此例中, 我们使用<code>std::set_difference</code> 只对pair的first进行排序, 尽管它们已经通过”first + second”的方式排序完了.</p><p>下面来实现<code>compareFirst</code>. 初版:</p><pre><code>bool compareFirst(const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp;amp; p1, const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp;amp; p2){return p1.first == p2.first; // not final code, bug lurking here!}</code></pre><p>实际上, 上面的代码不会得到我们预期的结果. 为什么? 毕竟<code>std::set_difference</code> 会检查元素跟另一个容器的元素是否相等(equal), 不是吗?&lt;/int,&gt;&lt;/int,&gt;</p><p>为了理解上面的内容, 我们把STL大概地分为两类: 操作排序元素的 和操作乱序元素的.</p><p><strong>Comparing elements</strong></p><p>C++中描述”a is the same as b” 有两种方法</p><pre><code>- the natural way: a == b. This is called equality. Equality is based on operator==.- the other way: a is not smaller than b and b is not smaller than a, so !(a&lt;b) &amp;&amp;=&quot;&quot; !(b&lt;a).=&quot;&quot; this=&quot;&quot; is=&quot;&quot; called=&quot;&quot; equivalence.=&quot;&quot; equivalence=&quot;&quot; based=&quot;&quot; on=&quot;&quot; operator&lt;.=&quot;&quot; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    对于基本类型如int, 甚至实践中大多数类型, `equivalence` 和`quality` 是相通的. 但是正如*Scott Meyers* 在&amp;lt;&amp;lt; Effective STL&amp;gt;&amp;gt;  一书条目19中指出的, 对于有一些类型, 即使&quot;并非罕见&quot;, `equivalence` 和 `equality` 是不同的, 如 大小写不敏感的string类型.</span><br><span class="line">    </span><br><span class="line">    &lt;u&gt;Why such a far-fetched way to express a simple thing?&lt;/u&gt;</span><br><span class="line">    </span><br><span class="line">    当我们使用算法对容器内元素进行排序时, 很容易理解必须有独一无二的排序方法(如有多种排序方法, 会很笨重, 并可能产生不一致的结果). 所以对于一个特定的容器, 排序时, &quot;==&quot; 和&quot;&amp;lt;&quot; 只能选一个. </span><br><span class="line">    </span><br><span class="line">    对于STL中排序的部分, 我们别无选择: 排序时必须使用&quot;&amp;lt;&quot;;</span><br><span class="line">    而乱序部分, 则没有这个约束, 我们可以使用&quot;==&quot;.</span><br><span class="line">    </span><br><span class="line">    **Implementing the comparator**</span><br><span class="line">    </span><br><span class="line">    STL的乱序部分使用&quot;==&quot;, 而排序部分使用&quot;&amp;lt;&quot;. 我们自定义的比较函数也必须遵循这种逻辑. </span><br><span class="line">    </span><br><span class="line">    现在我们可以理解怎么自定义实现`std::set_difference` 的比较函数`compareFirst` 了.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">bool compareFirst(const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp; p1, const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp; p2) &#123; return p1.first &lt; p2.first; // correct, STL-compatible code. &#125;</span><br></pre></td></tr></table></figure></code></pre><p>原文地址: <a href="http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/" target="_blank" rel="noopener">http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/</a> &lt;/int,&gt;&lt;/int,&gt;</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]How to (std::)find something efficiently with the STL</title>
      <link href="/56dc57bb/"/>
      <url>/56dc57bb/</url>
      
        <content type="html"><![CDATA[<p>本文分3部分: 1. 怎么使用STL进行高效的查找: 借用传统STL算法对元素进行范围搜索 2. 搜索STL容器: 当你有直接读取STL容器里元素的权限时, 怎么进行高效准确的搜索(与简单的范围搜索相比较) 3. STL搜索算法的秘密: 向公众展示不为人知的算法, 这些算法在已经学习过的人眼里确实是很有用的</p><p>STL根据查看方式的不同, 一共分为两种: 排序的和不排序的. * 排序集合的遍历, 通常需要对数时长, 而乱序集合的遍历, 需要线性时长 * 排序容器中比较元素大小的函数根据equivalence(comparing with &lt;), 而乱序容器中的函数根据equality(comparing with ==).</p><p>本文将展示对于在一个范围内搜索一个给定的值, C++怎么样去阐述下面3个问题: * 它存在否 * 它在哪 * 它应该在什么位置(排序容器)</p><h3 id="is-it-there"><span id="is-it-there">Is it there?</span></h3><h4 id="乱序容器的元素"><span id="乱序容器的元素">乱序容器的元素</span></h4><p>这个问题可以用std::find来表达(需要和与范围的终点值的比较相结合):</p><pre><code>vector&lt;int&gt; v = ... // v filled with valuesif (std::find(v.begin(), v.end(), 42) != v.end()){...</code></pre><p>“Is it there”这个问题也可以用std::count来表达:</p><pre><code>vector&lt;int&gt; v = ... // v filled with valuesif (std::count(v.begin(), v.end(), 42)){...</code></pre><p>std::count()的返回值会被隐式地转换成if条件里的bool值: 如果该范围里有至少一个值为42, 则返回true.</p><p>与std::find相比, std::count的优劣: 优势:</p><ul><li>std::count避免了与范围的end值相比较</li></ul><p>弊端:</p><ul><li>std::count遍历整个集合, 而std::find在第一个与要查找的值相等的位置停下</li><li>可以证明, 对于”想要查找某个值”这件事, std::find 表达得更明确 基于以上, std::find用得更多.</li></ul><p><strong>Note</strong> 若要确认某个值存在而非是与要搜索的值相等, 请使用<code>std::count_if, std::find_if, std::find_if_not</code></p><h4 id="排序容器的元素"><span id="排序容器的元素">排序容器的元素</span></h4><p>使用的算法是<code>std::binary_search</code>, 此函数返回一个bool值, 此bool值表示在集合中是否存在与搜索的值相等的元素.</p><pre><code>std::set&lt;int&gt; numbers = // sorted elementsbool is42InThere = std::binary_search(numbers.begin(), numbers.end(), 42);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    ### Where is it?</span><br><span class="line">    (当确定了要搜索的值存在后,) 我们想更进一步, 得到指向那个元素的迭代器.</span><br><span class="line">    </span><br><span class="line">    #### 乱序容器的元素</span><br><span class="line">    </span><br><span class="line">    使用std::find. 返回指向第一个与搜索的值相等的元素的迭代器, 如果找不到, 则返回集合的终点.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector numbers = ... auto searchResult = std::find(numbers.begin(), numbers.end(), 42);</span><br><span class="line"></span><br><span class="line">if (searchResult != numbers.end()) &#123; ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    #### 排序容器的元素</span><br><span class="line">    </span><br><span class="line">    对于排序集合, STL并没有像std::find一样直接的算法. std::find并不是为排序容器设计的, 因为它依据的是&quot;==&quot;而不是&quot;&amp;lt;&quot;, 消耗的时间为线性时长而不是对数时长.</span><br><span class="line">    对于一个给定的容器, 如果容器内元素的&quot;equality&quot;和&quot;equivalence&quot;是相同的, 且你能接受消耗的线性时长, 那么std::find会为你返回正确的结果, 你也能从它简单直接的接口中获益. **但是,** 不能忘记, std::find并不是为排序容器设计的.</span><br><span class="line">    </span><br><span class="line">    这里推荐使用`std::equal_range`. (并非`std::lower_bound`)</span><br><span class="line">    函数原型: </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">template&lt; class ForwardIt, class T &gt; std::pair&lt;forwardit,forwardit&gt; equal_range( ForwardIt first, ForwardIt last, const T&amp; value );</span><br><span class="line"></span><br><span class="line">    `std::equal_range` 返回与搜索值相等的元素的范围, 这个范围用一对集合内的迭代器表示. 这两个迭代器分别指向 与搜索值相等的范围里第一个元素和最后一个元素的下一个位置.&lt;/forwardit,forwardit&gt;</span><br><span class="line">    </span><br><span class="line">    然而, 它的接口有些笨重:</span><br><span class="line">    例A:</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector v = &#123;3, 7, 3, 11, 3, 3, 2&#125;; sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">// equal_range, attempt 1: natively clumsy std::pair&lt;std::vector::iterator, std::vector::iterator&gt; range1 = equal\_range(v.begin(), v.end(), 3); std::for\_each(range1.first, range1.second, doSomething);</span><br><span class="line"></span><br><span class="line">    用一个`typedef` 或者`using`让它更简洁:</span><br><span class="line">    例B:</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector v = &#123;3, 7, 3, 11, 3, 3, 2&#125;; sort(v.begin(), v.end());&lt;/std::vector</span><br><span class="line"></span><br><span class="line">using IteratorPair = std::pair&lt;std::vector::iterator, std::vector::iterator&gt;;&lt;/std::vector</span><br><span class="line"></span><br><span class="line">// equal\_range, attempt 2: with the classical typedef IteratorPair range2 = equal\_range(v.begin(), v.end(), 3); std::for_each(range2.first, range2.second, doSomething);</span><br><span class="line"></span><br><span class="line">    例B确实简洁了很多, 但是仍有一个根本问题: 没有考虑 抽象等级.</span><br><span class="line">    尽管返回的是一个范围, 但这对迭代器强迫我们在操作返回的范围时必须按照&quot;第一&quot;&quot;第二&quot;这种方式来写代码. 范围就应该用&quot;首&quot;&quot;尾&quot;这种方式来表达. 这不仅给我们在其他地方使用这个返回值时造成很大的麻烦, 而且使代码很别扭.</span><br><span class="line">    </span><br><span class="line">    为了解决这个问题, 我么可以把`std::equal_range` 返回的迭代器对封装进一个有&quot;范围&quot;这种语义的`object`</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">template</span><br><span class="line"></span><br><span class="line">class Range</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Range(std::pair range)</span><br><span class="line"></span><br><span class="line">m\_begin(range.first), m\_end(range.second) &#123;&#125; typename Container::iterator begin() &#123; return m\_begin; &#125; typename Container::iterator end() &#123; return m\_end; &#125;</span><br><span class="line"></span><br><span class="line">private: typename Container::iterator m\_begin; typename Container::iterator m\_end; &#125;;</span><br><span class="line"></span><br><span class="line">    注意: 尽管`std::equal_range` 返回的结果是一个&quot;范围&quot;, 但是`std::begin` 和 `std::end` 不能用在这个结果上. 而上面的封装解决了这个问题.</span><br><span class="line">    可以像下面这样使用:</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector v = &#123;3, 7, 3, 11, 3, 3, 2&#125;; sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">// equal_range, attempt 3: natural al last Range&lt;std::vector\&gt; range3 = equal\_range(v.begin(), v.end(), 3); std::for\_each(range3.begin(), range3.end(), doSomething);</span><br><span class="line"></span><br><span class="line">    不管你使用上面的哪种方式, `std::equal_range` 都会返回一个范围, 要确定它是否为空, 可以通过检查那两个迭代器(是否相等)或者使用`std::distance` 检查它的大小. &lt;/std::vector&lt;int&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">bool noElementFound = range3.begin() == range3.end(); size_t numberOfElementFound = std::distance(range3.begin(), range3.end())</span><br></pre></td></tr></table></figure></code></pre><h3 id="where-should-it-be"><span id="where-should-it-be">Where should it be?</span></h3><p>这个问题仅仅针对排序的范围, 因为对于乱序的范围, 某个元素可能会存在任何位置.</p><p>对于排序的范围, 这个问题可以简化为: 如果它存在, 那么它在哪儿? 如果它不存在, 那么它应该在哪儿?</p><p>这个问题可以用算法<code>std::lower_bound</code> 和<code>std::upper_bound</code> 来解释.</p><p>当你理解了<code>std::equal_range</code> 后, 上面这句话就很容易理解了: <code>std::lower_bound</code> 和<code>std::upper_bound</code> 都会返回 <code>std::equal_range</code> 返回的那个迭代器对的第一个和第二个迭代器.</p><p>要插入某个值x, 使用<code>std::lower_bound</code> 得到指向 在范围里与x相等的元素之前的位置的迭代器, 使用<code>std::upper_bound</code> 得到指向 在范围里与x相等的元素之后的位置的迭代器.</p><p>注意: 如果仅仅是搜索某个元素, 永远不要使用<code>std::lower_bound</code></p><p>与<code>std::find</code> 相反, 你不能根据 判断<code>std::lower_bound</code> 返回的迭代器是否与终点的迭代器相等 来判断要搜索的值是否存在于这个集合. 事实上, 如果这个值在集合里不存在, 则<code>std::lower_bound</code> 返回它应该在的位置, 而不是终点的迭代器. 所以, 你不仅需要确认返回的迭代器不是终点的迭代器, 还要确认它指向的元素跟要搜索的值是相等的.</p><h3 id="总结"><span id="总结">总结</span></h3><p>Question to express in C++</p><p>NOT SORTED</p><p>SORTED</p><p>Is it there?</p><p>std::find != end</p><p>std::binary_search</p><p>Where is it?</p><p>std::find</p><p>std::equal_range</p><p>Where should it be?</p><p>-</p><p>std::lower_bound / std::upper_bound</p><p>原文地址: <a href="http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm\_medium=toutiao.io&amp;utm\_source=toutiao.io" target="_blank" rel="noopener">http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm\_medium=toutiao.io&amp;utm\_source=toutiao.io</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]Effective STL 9</title>
      <link href="/978f4b48/"/>
      <url>/978f4b48/</url>
      
        <content type="html"><![CDATA[<p>条款9：在删除选项中仔细选择 假定你有一个标准STL容器，c，容纳int， <code>Container&lt;int&gt; c;</code> 而你想把c中所有值为<code>1963</code>的对象都去掉。令人吃惊的是，完成这项任务的方法因不同的容 器类型而不同：没有一种方法是通用的。</p><p>如果你有一个连续内存容器（vector、deque或string——参见条款1），最好的方法是erase-remove惯用法（参见条款32）：</p><pre><code>c.erase(remove(c.begin(), c.end(), 1963),       // 当c是vector、stringc.end());                               // 或deque时，// erase-remove惯用法// 是去除特定值的元素// 的最佳方法</code></pre><p>这方法也适合于list，但是，正如条款44解释的，list的成员函数remove更高效：</p><pre><code>c.remove(1963);     // 当c是list时，// remove成员函数是去除// 特定值的元素的最佳方法</code></pre><p>当c是标准关联容器（即，set、multiset、map或multimap）时，使用任何叫做remove的东 西都是完全错误的。这样的容器没有叫做remove的成员函数，而且使用remove算法可能覆 盖容器值（参见条款32），潜在地破坏容器。（关于这样的破坏的细节，参考条款22，那 个条款也解释了为什么试图在map和multimap上使用remove肯定不能编译，而试图在set和 multiset上使用可能不能编译。）</p><p>不，对于关联容器，解决问题的适当方法是调用erase：</p><pre><code>c.erase(1963);      // 当c是标准关联容器时// erase成员函数是去除// 特定值的元素的最佳方法</code></pre><p>这不仅是正确的，而且很高效，只花费对数时间。（序列容器的基于删除的技术需要线性 时间。）并且，关联容器的erase成员函数有基于等价而不是相等的优势，条款19解释了这 一区别的重要性。</p><p>让我们现在稍微修改一下这个问题。不是从c中除去每个有特定值的物体，让我们消除下面 判断式（参见条款39）返回真的每个对象：</p><pre><code>bool badValue(int x);   // 返回x是否是“bad”对于序列容器（vector、string、deque和list），我们要做的只是把每个remove()替换为remove_if()，然后就完成了：c.erase(remove_if(c.begin(), c.end(), badValue),    // 当c是vector、stringc.end());           // 或deque时这是去掉// badValue返回真// 的对象的最佳方法c.remove_if(badValue);              // 当c是list时这是去掉// badValue返回真// 的对象的最佳方法</code></pre><p>对于标准关联容器，它不是很直截了当。有两种方法处理该问题，一个更容易编码，另一 个更高效。“更容易但效率较低”的解决方案用<code>remove_copy_if()</code>把我们需要的值拷贝到一 个新容器中，然后把原容器的内容和新的交换：</p><pre><code>AssocContainer&lt;int&gt; c;              // c现在是一种...                                 // 标准关联容器AssocContainer&lt;int&gt; goodValues;         // 用于容纳不删除// 的值的临时容器remove_copy_if(c.begin(), c.end(),          // 从c拷贝不删除inserter(goodValues,        // 的值到goodValues.end()),          // goodValuesbadValue);c.swap(goodValues);             // 交换c和goodValues// 的内容</code></pre><p>这种方法的缺点是它拷贝了所有不删除的元素，而这样的拷贝开销可能大于我们期望的底线。</p><p>我们可以通过直接从原容器删除元素来避开拷贝的开销。不过，因为关联容器没有提供类似<code>remove_if()</code>的成员函数，所以我们必须写一个循环来迭代c中的元素，和原来一样删除元素.</p><p>看起来，这个任务很简单，而且实际上，代码也很简单。不幸的是，那些正确工作的代码 很少是跃出脑海的代码。例如，这是很多程序员首先想到的：</p><pre><code>AssocContainer&lt;int&gt; c;...for (AssocContainer&lt;int&gt;::iterator i = c.begin();   // 清晰，直截了当i!= c.end();                                // 而漏洞百出的用于++i) {                                      // 删除c中badValue返回真if (badValue(*i)) c.erase(i);                   // 的每个元素的代码}                                                   // 不要这么做！&lt;/int&gt;&lt;/int&gt;</code></pre><p>唉，这有未定义的行为。当容器的一个元素被删时，指向那个元素的所有迭代器都失效了 。当c.erase(i)返回时，i已经失效。那对于这个循环是个坏消息，因为在erase()返回后， i通过for循环的++i部分自增。</p><p>为了避免这个问题，我们必须保证在调用erase之前就得到了c中下一元素的迭代器。最容 易的方法是当我们调用时在i上使用后置递增：</p><pre><code>AssocContainer&lt;int&gt; c;...for (AssocContainer&lt;int&gt;::iterator i = c.begin();   // for循环的第三部分i != c.end();                                   // 是空的；i现在在下面/*nothing*/ ){                                 // 自增if (badValue(*i)) c.erase(i++);     // 对于坏的值，把当前的else ++i;                           // i传给erase，然后}                                       // 作为副作用增加i；// 对于好的值，// 只增加i</code></pre><p>这种调用erase()的解决方法可以工作，因为表达式i++的值是i的旧值，但作为副作用，i增 加了。因此，我们把i的旧值（没增加的）传给erase，但在erase开始执行前i已经自增了 。那正好是我们想要的。正如我所说的，代码很简单，只不过不是大多数程序员在第一次 尝试时想到的。</p><p>现在让我们进一步修改该问题。不仅删除badValue返回真的每个元素，而且每当一个元素 被删掉时，我们也想把一条消息写到日志文件中。</p><p>对于关联容器，这说多容易就有多容易，因为只需要对我们刚才开发的循环做一个微不足 道的修改就行了：</p><pre><code>ofstream logFile;                   // 要写入的日志文件AssocContainer&lt;int&gt; c;...for (AssocContainer&lt;int&gt;::iterator i = c.begin();   // 循环条件和前面一样i !=c.end();){if (badValue(*i)){logFile &amp;lt;&amp;lt; &quot;Erasing &quot; &amp;lt;&amp;lt; *i &amp;lt;&amp;lt;&apos;\n&apos;;   // 写日志文件         c.erase(i++);           // 删除元素    }    else ++i;}</code></pre><p>现在是vector、string和deque给我们带来麻烦。我们不能再使用<code>erase-remove</code>惯用法，因为没有办法让erase()或remove()写日志文件。而且，我们不能使用刚刚为关联容器开发的循环, 因为它为vector、string和deque产生未定义的行为！要记得对于那样的容器，调用erase不仅使所有指向被删元素的迭代器失效，也使被删元素之后的所有迭代器失效。在我们的情况里，那包括所有i之后的迭代器。我们写i++，++i或你能想起的其它任何东西都没有用，因为没有能导致迭代器有效的。</p><p>我们必须对vector、string和deque采用不同的战略。特别是，我们必须利用erase()的返回值。那个返回值正是我们需要的：一旦删除完成，它就是指向紧接在被删元素之后的元素的有效迭代器。换句话说，我们这么写：</p><pre><code>for (SeqContainer&lt;int&gt;::iterator i = c.begin();i != c.end();){if (badValue(*i)){logFile &amp;lt;&amp;lt; &quot;Erasing &quot; &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &apos;\n&apos;;         i = c.erase(i);         // 通过把erase的返回值    }                   // 赋给i来保持i有效    else        ++i;}</code></pre><p>这可以很好地工作，但只用于标准序列容器。由于论证一个可能的问题（条款5做了），标准关联容器的erase()的返回类型是void[1]。对于那些容器，你必须使用“后置递增你要传给erase()的迭代器”技术。（顺便说说，在为序列容器编码和为关联容器编码之间的这种差别是为什么写容器无关代码一般缺乏考虑的一个例子——参见条款2。)</p><p>为了避免你奇怪list的适当方法是什么，事实表明对于迭代和删除，你可以像vector/str ing/deque一样或像关联容器一样对待list；两种方法都可以为list工作。</p><p>如果我们观察在本条款中提到的所有东西，我们得出下列结论：</p><p>去除一个容器中有特定值的所有对象： 如果容器是vector、string或deque，使用erase-remove惯用法。</p><p>如果容器是list，使用list::remove。</p><p>如果容器是标准关联容器，使用它的erase成员函数。</p><p>去除一个容器中满足一个特定判定式的所有对象： 如果容器是vector、string或deque，使用<code>erase-remove_if</code>惯用法。</p><p>如果容器是list，使用list::remove_if。</p><p>如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素， 当你把迭代器传给erase时记得后置递增它。</p><p>在循环内做某些事情（除了删除对象之外）： 如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。 如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</p><p>如你所见，与仅仅调用erase相比，有效地删除容器元素有更多的东西。解决问题的最好方法取决于你是怎样鉴别出哪个对象是要被去掉的，储存它们的容器的类型，和当你删除它们的时候你还想要做什么（如果有的话）。只要你小心而且注意了本条款的建议，你将毫不费力。如果你不小心，你将冒着产生不必要低效的代码或未定义行为的危险。</p><h2 id="-"><span id="-">------------------------------------------------------------------------------</span></h2><p>[1] 这仅对带有迭代器实参的erase()形式是正确的。关联容器也提供一个带有一个值的实参 的erase()形式，而那种形式返回被删掉的元素个数。但这里，我们只关心通过迭代器删除东 西。</p><p><a href="https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_3%2FC%2Fnetres%2Feffstl%2Ffile10.html" target="_blank" rel="noopener">参考地址</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL 的 erase( ) 陷阱-迭代器失效总结</title>
      <link href="/b12cd95a/"/>
      <url>/b12cd95a/</url>
      
        <content type="html"><![CDATA[<p>STL中的容器按存储方式分为两类，一类是按以数组形式存储的容器（如：vector 、deque)；另一类是以不连续的节点形式存储的容器（如：list、set、map）。在使用erase方法来删除元素时，需要注意一些问题。</p><h4 id="1listsetmap容器"><span id="1listsetmap容器"><strong>1.list,set,map容器</strong></span></h4><p>在使用 list、set 或 map遍历删除某些元素时可以这样使用：</p><p><strong><del>1.1 正确写法 1</del></strong></p><pre><code>std::list&lt;int&gt; list;std::list&lt;int&gt;::iterator it_list;for (it_list = list.begin(); it_list != list.end();){if (willDelete(*it_list)){it_list = list.erase(it_list);}else{++it_list;}}</code></pre><p><strong>Note:</strong> 以上方法仅适用于standard sequence container, 因为对于standard associative container, erase()的返回类型为void. (查阅Effective STL Item 9)以下为原文:</p><pre><code>This works wonderfully, but only for the standard sequence containers. Due to reasoning one might question, erase()&apos;s return type for the standard associative containers is void. For those containers, you have to use the postincrement-the-iterator-you-pass-to-erase technique.</code></pre><p><strong>1.2 正确写法2</strong> 查阅原版Effctive STL Item 9, 证实, 下面这种写法不能用于标准序列容器, 而适用于标准关联容器, 而List也可以使用这种方法.</p><pre><code>std::list&lt;int&gt; list;std::list&lt;int&gt;::iterator it_list;for (it_list = list.begin(); it_list != list.end();){if (willDelete(*it_list)){list.erase(it_list++); // 必须使用后缀自增, 不能使用前缀自增}else{++it_list;}}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    **1.3 错误写法 1**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::list&lt; int&gt; List; std::list&lt; int&gt;::iterator itList; for( itList = List.begin(); itList != List.end(); itList++) &#123; if( WillDelete( *itList) ) &#123; List.erase( itList); &#125; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    **1.4 错误写法 2**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::list&lt; int&gt; List; std::list&lt; int&gt;::iterator itList; for( itList = List.begin(); itList != List.end(); ) &#123; if( WillDelete( *itList) ) &#123; itList = List.erase( ++itList); &#125; else itList++; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    **1.5 分析**</span><br><span class="line">    </span><br><span class="line">    正确方法1: 通过erase()方法的返回值来获取下一个元素的位置;</span><br><span class="line">    正确方法2: 在调用erase()方法之前先使用&quot;++&quot; 来获取下一个元素的位置;</span><br><span class="line">    错误使用方法1: 在调用erase()方法之后使用&quot;++&quot; 来获取下一个元素的位置, 由于在调用erase()方法之后, 该元素的位置已经被删除, 如果再根据这个旧的位置来获取下一个位置, 则会出现异常;</span><br><span class="line">    错误使用方法2: 同上</span><br><span class="line">    </span><br><span class="line">    ####**2. vector,deque 容器**</span><br><span class="line">    在使用 vector、deque遍历删除元素时，也可以通过erase的返回值来获取下一个元素的位置：</span><br><span class="line">    </span><br><span class="line">    **2.1 正确写法:**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector vec; std::vector::iterator it\_vec; for (it\_vec = vec.begin(); it\_vec != vec.end();) &#123; if (willDelete(*it\_vec)) &#123; it\_vec = vec.erase(it\_vec); &#125; else &#123; ++it_vec; &#125; &#125;</span><br></pre></td></tr></table></figure></code></pre><p><strong>2.2 注意</strong></p><p>vector, deque 不能像上面的”正确方法2” 的办法来遍历删除. 原因请参考Effective STL条款9。摘录到下面： 1) 对于关联容器(如map, set, multimap, multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。</p><pre><code>for (iter = cont.begin(); it != cont.end();){(*iter)-&amp;gt;doSomething();if (shouldDelete(*iter))cont.erase(iter++);else++iter;}</code></pre><p>因为iter传给erase方法的是一个副本，iter++会指向下一个元素。</p><p>2) 对于序列式容器(如vector, deque)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor, deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase()方法可以返回下一个有效的iterator。</p><pre><code>for (iter = cont.begin(); iter != cont.end();){(*it)-&amp;gt;doSomething();if (shouldDelete(*iter))iter = cont.erase(iter);else++iter;}</code></pre><p>3)对于list来说，它使用了不连续分配的内存，并且它的erase()方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。</p><h4 id="3-其他"><span id="3-其他"><strong>3. 其他</strong></span></h4><p><strong>set</strong> 键和值相等。 键唯一。 元素默认按升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</p><p><strong>map</strong> 键唯一。 元素默认按键的升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</p><p><a href="http://mp.weixin.qq.com/s/qonNrKKZLladvIwvurQCTA" target="_blank" rel="noopener">作成参考地址</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用GDB调试程序</title>
      <link href="/13b68d49/"/>
      <url>/13b68d49/</url>
      
        <content type="html"><![CDATA[<h3 id="使用gdb"><span id="使用gdb">使用GDB</span></h3><p>一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p><pre><code>$gcc -g -Wall hello.c -o hello$g++ -g -Wall hello.cpp -o hello</code></pre><p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 启动GDB的方法有以下几种： <code>gdb &lt;program&gt;</code> program也就是你的执行文件，一般在当前目录下。 <code>gdb &lt;program&gt; core</code> 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。 <code>gdb &lt;program&gt; &lt;pid&gt;</code> 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 以上三种都是进入gdb环境和加载被调试程序同时进行的。也可以先进入gdb环境，在加载被调试程序，方法如下：</p><pre><code>*在终端输入：gdb*在gdb环境中：file &lt;program&gt;这两步等价于：gdb &lt;program&gt;</code></pre><p>GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下面只例举一些比较常用的参数：</p><pre><code>-symbols &lt;file&gt;-s &lt;file&gt;从指定文件中读取符号表。-se file从指定文件中读取符号表信息，并把他用在可执行文件中。-core &lt;file&gt;-c &lt;file&gt;调试时core dump的core文件。-directory &lt;directory&gt;-d &lt;directory&gt;加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。```&lt;/directory&gt;&lt;/directory&gt;&lt;/file&gt;&lt;/file&gt;&lt;/file&gt;&lt;/file&gt;&lt;/program&gt;&lt;/program&gt;&lt;/pid&gt;&lt;/program&gt;&lt;/program&gt;&lt;/program&gt;###GDB的命令概貌启动gdb后，你就被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb的命令可以使用help命令来查看，如下所示：```bash$ gdbGNU gdb 6.7.1-debianCopyright (C) 2007 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http: gnu.org=&quot;&quot; licenses=&quot;&quot; gpl.html=&quot;&quot;&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;i486-linux-gnu&quot;.(gdb) helpList of classes of commands:&lt;/http:&gt;aliases -- Aliases of other commandsbreakpoints -- Making program stop at certain pointsdata -- Examining datafiles -- Specifying and examining filesinternals -- Maintenance commandsobscure -- Obscure featuresrunning -- Running the programstack -- Examining the stackstatus -- Status inquiriessupport -- Support facilitiestracepoints -- Tracing of program execution without stopping the programuser-defined -- User-defined commandsType &quot;help&quot; followed by a class name for a list of commands in that class.Type &quot;help all&quot; for the list of all commands.Type &quot;help&quot; followed by command name for full documentation.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.Command name abbreviations are allowed if unambiguous.(gdb)</code></pre><p>gdb 的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用<code>help &lt;class&gt;</code>命令，如：help breakpoints，查看设置断点的所有命令。也可以直接<code>help &lt;command&gt;&lt;/command&gt;</code>来查看命令的帮助。 gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其列出来。</p><p><strong>示例一</strong>：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func</p><pre><code>(gdb) b funcBreakpoint 1 at 0x804837a: file tst.c, line 5.</code></pre><p><strong>示例二</strong>：敲入b按两次TAB键，你会看到所有b打头的命令：</p><pre><code>(gdb) bbacktrace break bt(gdb)</code></pre><p><strong>示例三</strong>：只记得函数的前缀，可以这样：</p><pre><code>(gdb) b make_ &amp;lt;按TAB键&amp;gt;（再按下一次TAB键，你会看到:）make_a_section_from_file make_environmake_abs_section make_function_typemake_blockvector make_pointer_typemake_cleanup make_reference_typemake_command make_symbol_completion_list(gdb) b make_GDB把所有make开头的函数全部列出来给你查看。</code></pre><p><strong>示例四</strong>：调试C++的程序时，有可以函数名一样。如：</p><pre><code>(gdb) b &apos;bubble( M-?bubble(double,double) bubble(int,int)(gdb) b &apos;bubble(</code></pre><p>你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思） 要退出gdb时，只用发quit或命令简称q就行了</p><h3 id="gdb中运行unix的shell程序"><span id="gdb中运行unix的shell程序">GDB中运行UNIX的shell程序</span></h3><p>在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成： <code>shell &lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code> 调用UNIX的shell来执行<code>&lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code>，环境变量SHELL中定义的UNIX的shell将会被用来执行<code>&lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code>，如果SHELL没有定义，那就使用UNIX的标准<code>shell：/bin/sh</code>。（在Windows中使用Command.com或cmd.exe） 还有一个gdb命令是make： <code>make &lt;make-args&gt;</code> 可以在gdb中执行make命令来重新build自己的程序。这个命令等价于<code>shell make &lt;make-args&gt;</code>。</p><h3 id="在gdb中运行程序"><span id="在gdb中运行程序">在GDB中运行程序</span></h3><p>当以<code>gdb &lt;program&gt;</code>方式启动gdb后，gdb会在PATH路径和当前目录中搜索<code>&lt;program&gt;</code>的源文件。如要确认gdb是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。 在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。 <strong>1、程序运行参数。</strong> set args 可指定运行时参数。（如：set args 10 20 30 40 50） show args 命令可以查看设置好的运行参数。 <strong>2、运行环境。</strong> `path</p><p><code>可设定程序的运行路径。 show paths 查看程序的运行路径。 set environment varname [=value] 设置环境变量。如：set env USER=hchen show environment [varname] 查看环境变量。 **3、工作目录。**</code>cd</p><p>` 相当于shell的cd命令。 pwd 显示当前的所在目录。 <strong>4、程序的输入输出。</strong> info terminal 显示你程序用到的终端的模式。 使用重定向控制程序输出。如：run &gt; outfile tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb</p><h3 id="调试已运行的程序"><span id="调试已运行的程序">调试已运行的程序</span></h3><p>两种方法： 1. 在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用<code>gdb &lt;program&gt; PID</code>格式挂接正在运行的程序。 2. 先用<code>gdb &lt;program&gt;</code>关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。</p><h3 id="暂停恢复程序运行"><span id="暂停恢复程序运行">暂停/恢复程序运行</span></h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。 当进程被gdb停住时，你可以使用<code>info program</code> 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（Watch Point）、捕捉点（Catch Point）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可以使用c或是 continue命令。</p><p><strong>下面为重要的使用步骤, 只摘抄了部分必要的信息, 如设置断点, 查看栈信息, 其余操作, 可以在<a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">wiki.ubuntu</a>查看</strong></p><p><strong>设置断点（Break Points）</strong> 我们用break命令来设置断点。下面有几点设置断点的方法： <code>break &lt;function&gt;</code> 在进入指定函数时停住。C++中可以使用<code>class::function</code>或<code>function(type,type)</code>格式来指定函数名。 <code>break &lt;linenum&gt;</code> 在指定行号停住。 <code>break +offset</code> <code>break -offset</code> 在当前行号的前面或后面的offset行停住。offiset为自然数。 <code>break filename：linenum</code> 在源文件filename的linenum行处停住。 <code>break filename：function</code> 在源文件filename的function函数的入口处停住。 <code>break *address</code> 在程序运行的内存地址处停住。 <code>break</code> break命令没有参数时，表示在下一条指令处停住。 <code>break ... if &lt;condition&gt;</code> …可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置<code>break if i==100</code>，表示当i为100时停住程序。 查看断点时，可使用info命令，如下所示：（注：n表示断点号） <code>info breakpoints [n]</code> <code>info break [n]</code></p><p><strong>维护停止点</strong> 上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用<code>delete</code>、<code>clear</code>、<code>disable</code>、<code>enable</code>这几个命令来进行维护。 <code>clear</code> 清除所有的已定义的停止点。 <code>clear &lt;function&gt;</code> <code>clear &lt;filename：function&gt;</code> 清除所有设置在函数上的停止点。 <code>clear &lt;linenum&gt;</code> <code>clear &lt;filename：linenum&gt;</code> 清除所有设置在指定行上的停止点。 <code>delete [breakpoints] [range...]</code> 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。&lt;/filename：linenum&gt;&lt;/filename：function&gt;</p><p>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。 <code>disable [breakpoints] [range...]</code> disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis. <code>enable [breakpoints] [range...]</code> enable所指定的停止点，breakpoints为停止点号。 <code>enable [breakpoints] once range...</code> enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。 <code>enable [breakpoints] delete range...</code> enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p><p><strong>恢复程序运行和单步调试</strong> 当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用step或next命令单步跟踪程序。 <code>continue [ignore-count]</code> <code>c [ignore-count]</code> <code>fg [ignore-count]</code> 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。 <code>step &lt;count&gt;</code> 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 <code>next &lt;count&gt;</code> 同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 <code>set step-mode</code> <code>set step-mode on</code> 打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数很有利于查看机器码。 <code>set step-mode off</code> 关闭step-mode模式。 <code>finish</code> 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。 <code>until 或 u</code> 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 <code>stepi 或 si</code> <code>nexti 或 ni</code> 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是<code>“display/i $pc”</code> ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p><p><strong>查看栈信息</strong> 当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。 下面是一些查看函数调用栈信息的GDB命令： <code>backtrace</code> <code>bt</code> 打印当前的函数调用栈的所有信息。如：</p><pre><code>(gdb) bt#0  func (n=250) at tst.c:6#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30#2  0x400409ed in __libc_start_main () from /lib/libc.so.6</code></pre><p>从上可以看出函数的调用栈信息：<code>__libc_start_main --&amp;gt; main() --&amp;gt; func()</code></p><p><code>backtrace &lt;n&gt;</code> <code>bt &lt;n&gt;</code> n是一个正整数，表示只打印栈顶上n层的栈信息。 <code>backtrace &amp;lt;-n&amp;gt;</code> <code>bt &amp;lt;-n&amp;gt;</code> -n表一个负整数，表示只打印栈底下n层的栈信息。 如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。 <code>frame &lt;n&gt;</code> <code>f &lt;n&gt;</code> n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。 <code>up &lt;n&gt;</code> 表示向栈的上面移动n层，可以不打n，表示向上移动一层。 <code>down &lt;n&gt;</code> 表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p><p>上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令： <code>select-frame &lt;n&gt;</code> 对应于 frame 命令。 <code>up-silently &lt;n&gt;</code>对应于 up 命令。 <code>down-silently &lt;n&gt;</code> 对应于 down 命令。 查看当前栈层的信息，你可以用以下GDB命令： <code>frame</code> 或 <code>f</code> 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。 <code>info frame</code> <code>info f</code> 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如： <code>bash (gdb) info f Stack level 0, frame at 0xbffff5d4: eip = 0x804845d in func (tst.c:6); saved eip 0x8048524 called by frame at 0xbffff60c source language c. Arglist at 0xbffff5d4, args: n=250 Locals at 0xbffff5d4, Previous frame&#39;s sp is 0x0 Saved registers: ebp at 0xbffff5d4, eip at 0xbffff5d8</code></p><p><code>info args</code> 打印出当前函数的参数名及其值。 <code>info locals</code> 打印出当前函数中所有局部变量及其值。 <code>info catch</code> 打印出当前的函数中的异常处理信息。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器工作过程</title>
      <link href="/49fab9fa/"/>
      <url>/49fab9fa/</url>
      
        <content type="html"><![CDATA[<p>代码要运行，必须先转成二进制的机器码。这是编译器的任务。</p><p>比如，下面这段源码（假定文件名叫做test.c）。</p><pre><code>#include &lt;stdio.h&gt;int main(void){fputs(&quot;Hello, world!\n&quot;, stdout);return 0;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    要先用编译器处理一下，才能运行。</span><br><span class="line">    </span><br><span class="line">    ```bash</span><br><span class="line">    $ gcc test.c</span><br><span class="line">    $ ./a.out</span><br><span class="line">    Hello, world!</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">对于复杂的项目，编译过程还必须分成三步。</span><br><span class="line"></span><br><span class="line">    $ ./configure</span><br><span class="line">    $ make</span><br><span class="line">    $ make install</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。</span><br><span class="line"></span><br><span class="line">本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了Alex Smith的文章《Building C Projects》。需要声明的是，本文主要针对gcc编译器，也就是针对C和C++，不一定适用于其他语言的编译。</span><br><span class="line"></span><br><span class="line">![这里写图片描述](http://img.blog.csdn.net/20170105233325494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br><span class="line"></span><br><span class="line">#### 第一步 配置（configure）</span><br><span class="line"></span><br><span class="line">编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。</span><br><span class="line"></span><br><span class="line">这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。</span><br><span class="line"></span><br><span class="line">configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。</span><br><span class="line"></span><br><span class="line">`$ ./configure --prefix=/www --with-mysql`</span><br><span class="line"></span><br><span class="line">上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。</span><br><span class="line"></span><br><span class="line">#### 第二步 确定标准库和头文件的位置</span><br><span class="line"></span><br><span class="line">源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。</span><br><span class="line"></span><br><span class="line">编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</span><br><span class="line"></span><br><span class="line">#### 第三步 确定依赖关系</span><br><span class="line"></span><br><span class="line">对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。</span><br><span class="line"></span><br><span class="line">（1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。</span><br><span class="line"></span><br><span class="line">编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。</span><br><span class="line"></span><br><span class="line">在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</span><br><span class="line"></span><br><span class="line">#### 第四步 头文件的预编译（precompilation）</span><br><span class="line"></span><br><span class="line">不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。</span><br><span class="line"></span><br><span class="line">不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。</span><br><span class="line"></span><br><span class="line">#### 第五步 预处理（Preprocessing）</span><br><span class="line"></span><br><span class="line">预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。</span><br><span class="line"></span><br><span class="line">    extern int fputs(const char *, FILE *);</span><br><span class="line">    extern FILE *stdout;</span><br><span class="line">    int main(void)</span><br><span class="line">    &#123;</span><br><span class="line">    fputs(&quot;Hello, world!\n&quot;, stdout);</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。</span><br><span class="line"></span><br><span class="line">这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。</span><br><span class="line"></span><br><span class="line">#### 第六步 编译（Compilation）</span><br><span class="line"></span><br><span class="line">预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。</span><br><span class="line"></span><br><span class="line">下面是本文开头的那段源码转成的汇编码。</span><br><span class="line"></span><br><span class="line">```` .file &quot;test.c&quot; .section .rodata .LC0: .string &quot;Hello, world!\\n&quot; .text .globl main .type main, @function main: .LFB0: .cfi\_startproc pushq %rbp .cfi\_def\_cfa\_offset 16 .cfi\_offset 6, -16 movq %rsp, %rbp .cfi\_def\_cfa\_register 6 movq stdout(%rip), %rax movq %rax, %rcx movl $14, %edx movl $1, %esi movl $.LC0, %edi call fwrite movl $0, %eax popq %rbp .cfi\_def\_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident &quot;GCC: (Debian 4.9.1-19) 4.9.1&quot; .section .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></code></pre><p>这种转码后的文件称为对象文件（object file）。</p><h4 id="第七步-连接linking"><span id="第七步-连接linking">第七步 连接（Linking）</span></h4><p>对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。</p><p>编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。</p><p><strong>make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。</strong></p><h4 id="第八步-安装installation"><span id="第八步-安装installation">第八步 安装（Installation）</span></h4><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。</p><p>表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。</p><h4 id="第九步-操作系统连接"><span id="第九步-操作系统连接">第九步 操作系统连接</span></h4><p>可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。</p><p>这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在<code>/usr/share/applications</code>目录下的<code>.desktop</code>文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。</p><p>这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。</p><h4 id="第十步-生成安装包"><span id="第十步-生成安装包">第十步 生成安装包</span></h4><p>写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。</p><p>所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。</p><h4 id="第十一步-动态连接dynamic-linking"><span id="第十一步-动态连接dynamic-linking">第十一步 动态连接（Dynamic linking）</span></h4><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p><p>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</p><p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unordered_map笔记</title>
      <link href="/d97ca7/"/>
      <url>/d97ca7/</url>
      
        <content type="html"><![CDATA[<p>unordered_map与map的区别 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。 而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。 用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator== 或者hash_value()了。 最后，说，当不需要结果排好序时，最好用unordered_map。</p><p>linux下使用 普通的key就不说了和map一样 看一下用sockaddr_in 作为key的方法</p><pre><code>#ifndef CSESSION_H  #define CSESSION_H  #include &lt;netinet in.h=&quot;&quot;&gt;#include &lt;time.h&gt;#include &lt;/time.h&gt;&lt;/netinet&gt;&lt;map&gt;#include &lt;string.h&gt;#include &lt;tr1 unordered_map=&quot;&quot;&gt;  //头文件#include &lt;iostream&gt;using namespace std;using namespace std::tr1;struct Terminal{int             nid ; //id  the key for terminalsockaddr_in     addr; //ip  the key for Clienttime_t          tm;   //last alive timeenTerminalStat  enStat;//statusTerminal();~Terminal();Terminal &amp;amp;operator =(const Terminal&amp;amp; term);};struct hash_func  //hash 函数{size_t operator()(const sockaddr_in &amp;amp;addr) const{return addr.sin_port*9999 + addr.sin_addr.s_addr;}};struct cmp_fun //比较函数 =={bool operator()(const sockaddr_in &amp;amp;addr1, const sockaddr_in &amp;amp;addr2) const{return memcmp(&amp;amp;addr1, &amp;amp;addr2, sizeof(sockaddr_in)) == 0 ? true:false;}};//typedef unordered_map&lt;int,terminal*&gt; MapTerminal; // Terminal socket 作为key//typedef unordered_map&lt;int,terminal*&gt;::iterator MapTerminal_It; //  &lt;/int,terminal*&gt;&lt;/int,terminal*&gt;typedef unordered_map&lt;sockaddr_in, terminal*,hash_func,=&quot;&quot; cmp_fun=&quot;&quot;&gt; MapClientSession; // sockaddr_in作为keytypedef unordered_map&lt;sockaddr_in, terminal*,hash_func,=&quot;&quot; cmp_fun=&quot;&quot;&gt;::iterator MapClientSession_It; //  &lt;/sockaddr_in,&gt;&lt;/sockaddr_in,&gt;#endif // CSESSION_H</code></pre><p><code>operator==</code>有两种方式 一种是</p><pre><code>struct st{bool operator==(const st &amp;amp;s) const...}；</code></pre><p>另一种就是自定义函数体，代码中</p><pre><code>struct cmp_fun{bool operator()(...)...}</code></pre><p>必须要自定义<code>operator==</code>和<code>hash_value</code>。 重载<code>operator==</code>是因为，如果两个元素的<code>hash_value</code>的值相同，并不能断定这两个元素就相同，必须再调用<code>operator==</code>。 当然，如果<code>hash_value</code>的值不同，就不需要调用<code>operator==</code>了。</p><p>&lt;/string.h&gt;</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unordered_set笔记</title>
      <link href="/14decfad/"/>
      <url>/14decfad/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.cplusplus.com/reference/unordered\_set/unordered\_set/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/unordered\_set/unordered\_set/</a></p><p><strong>unordered_set</strong> 模板原型:</p><pre><code>[cpp]template &amp;lt; class Key,      class Hash = hash&lt;key&gt;,class Pred = equal_to&lt;key&gt;,class Alloc = allocator&lt;key&gt;&amp;gt; class unordered_set;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    当比较unordered_set中某两个元素时, 先调用`hash&lt;key&gt;`, 如果`hash&lt;key&gt;`  不相等, 说明两个元素不同, 如果`hash&lt;key&gt;` 值相等, 则调用`equal_to&lt;key&gt;`, 判断两个元素是否完全相等. (Hash函数和Compare函数都可以自定义)&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;</span><br><span class="line">    </span><br><span class="line">    C++ 11中对unordered_set描述大体如下：无序集合容器（unordered_set）是一个存储唯一(unique，即无重复）的关联容器（Associative container），容器中的元素无特别的秩序关系，该容器允许基于值的快速元素检索，同时也支持正向迭代。</span><br><span class="line">    在一个unordered_set内部，元素不会按任何顺序排序，而是通过元素值的hash值将元素分组放置到各个槽(Bucker，也可以译为“桶”），这样就能通过元素值快速访问各个对应的元素（均摊耗时为O（1））。</span><br><span class="line">    原型中的Key代表要存储的类型，而hash&lt;key&gt;也就是你的hash函数，equal_to&lt;key&gt;用来判断两个元素是否相等，allocator&lt;key&gt;是内存的分配策略。一般情况下，我们只关心hash&lt;key&gt;和equal_to&lt;key&gt;参数，下面将介绍这两部分。&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;</span><br><span class="line">    </span><br><span class="line">    **`hash&lt;key&gt;`**</span><br><span class="line">    ` hash&lt;key&gt;`通过相应的hash函数，将传入的参数转换为一个size_t类型值，然后用该值对当前hashtable的bucket取模算得其对应的hash值。而C++标准库，为我们提供了基本数据类型的hash函数：&lt;/key&gt;&lt;/key&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">\[cpp\] /// Primary class template hash. template struct hash;</span><br><span class="line"></span><br><span class="line">/// Partial specializations for pointer types. template struct hash&lt;\_Tp*&gt; : public \_\_hash\_base&lt;size\_t, \_tp*=&quot;&quot;&gt; &#123; size\_t operator()(\_Tp* \_\_p) const noexcept &#123; return reinterpret_cast(__p); &#125; &#125;; &lt;/size_t,&gt;</span><br><span class="line"></span><br><span class="line">// Explicit specializations for integer types.</span><br><span class="line"></span><br><span class="line">define \_Cxx\_hashtable\_define\_trivial\_hash(\_Tp) \</span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line">template&lt;&gt; \ struct hash&lt;\_Tp&gt; : public \_\_hash\_base&lt;size\_t, \_tp=&quot;&quot;&gt; \ &#123; \ size\_t \ operator()(\_Tp \_\_val) const noexcept \ &#123; return static_cast(__val); &#125; \ &#125;; &lt;/size_t,&gt;</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for bool. \_Cxx\_hashtable\_define\_trivial_hash(bool)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for char. \_Cxx\_hashtable\_define\_trivial_hash(char)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for signed char. \_Cxx\_hashtable\_define\_trivial_hash(signed char)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned char. \_Cxx\_hashtable\_define\_trivial_hash(unsigned char)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for wchar\_t. \_Cxx\_hashtable\_define\_trivial\_hash(wchar_t)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for char16\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char16_t)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for char32\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char32_t)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for short. \_Cxx\_hashtable\_define\_trivial_hash(short)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for int. \_Cxx\_hashtable\_define\_trivial_hash(int)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for long. \_Cxx\_hashtable\_define\_trivial_hash(long)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for long long. \_Cxx\_hashtable\_define\_trivial_hash(long long)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned short. \_Cxx\_hashtable\_define\_trivial_hash(unsigned short)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned int. \_Cxx\_hashtable\_define\_trivial_hash(unsigned int)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned long long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long long)</span><br><span class="line"></span><br><span class="line">    对于指针类型，标准库只是单一将地址转换为一个size_t值作为hash值，这里特别需要注意的是`char *`类型的指针，其标准库提供的hash函数只是将指针所指地址转换为一个sieze_t值，如果，你需要用`char *`所指的内容做hash，那么，你需要自己写hash函数或者调用系统提供的`hash&lt;string&gt;`。</span><br><span class="line">    标准库为string类型对象提供了一个hash函数，即：Murmur hash，。对于float、double、long double标准库也有相应的hash函数，这里，不做过多的解释，相应的可以参看functional_hash.h头文件。</span><br><span class="line">    上述只是介绍了基本数据类型，而在实际应用中，有时，我们需要使用自己写的hash函数，那怎么自定义hash函数？参考标准库基本数据类型的hash函数，我们会发现这些hash函数有个共同的特点：通过定义函数对象，实现相应的hash函数，这也就意味我们可以通过自定义相应的函数对象，来实现自定义hash函数。比如：已知平面上有N，每个点的x轴、y轴范围为[0，100]，现在需要统计有多少个不同点？hash函数设计为：将每个点的x、y值看成是101进制，如下所示:&lt;/string&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">\[cpp\]</span><br><span class="line"></span><br><span class="line">include&lt;bits\\stdc++.h&gt;</span><br><span class="line">=======================</span><br><span class="line"></span><br><span class="line">using namespace std; struct myHash &#123; size\_t operator()(pair&lt;int, int=&quot;&quot;&gt; \_\_val) const &#123; return static_cast(\_\_val.first * 101 + \_\_val.second); &#125; &#125;; int main() &#123; unordered\_set&lt;pair&lt;int, int=&quot;&quot;&gt;, myHash&gt; S; int x, y; while (cin &gt;&gt; x &gt;&gt; y) S.insert(make\_pair(x, y)); for (auto it = S.begin(); it != S.end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;  </span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    **`equal_to&lt;key&gt;`**</span><br><span class="line">    该参数用于实现比较两个关键字是否相等，至于为什么需要这个参数？这里做点解释，前面我们说过，当不同关键字，通过hash函数，可能会得到相同的关键字值，每当我们在unordered_set里面做数据插入、删除时，由于unordered_set关键字唯一性，所以我们得确保唯一性。标准库定义了基本类型的比较函数，而对于自定义的数据类型，我们需要自定义比较函数。这里有两种方法:重载==操作符和使用函数对象，下面是STL中实现`equal_to&lt;key&gt;`的源代码：&lt;/key&gt;&lt;/key&gt;&lt;/pair&lt;int,&gt;&lt;/size_t&gt;&lt;/int,&gt;&lt;/bits\stdc++.h&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">\[cpp\] template struct unary\_function &#123; /// @c argument\_type is the type of the argument typedef \_Arg argument\_type;</span><br><span class="line"></span><br><span class="line">/// @c result\_type is the return type typedef \_Result result_type; &#125;; template struct equal\_to : public binary\_function&lt;\_Tp, \_Tp, bool&gt; &#123; bool operator()(const \_Tp&amp; \_\_x, const \_Tp&amp; \_\_y) const &#123; return \_\_x == \_\_y; &#125; &#125;;</span><br></pre></td></tr></table></figure></code></pre><p><strong>扩容与缩容</strong> 在vector中，每当我们插入一个新元素时，如果当前的容量（capacity)已不足，需要向系统申请一个更大的空间，然后将原始数据拷贝到新空间中。这种现象在unordered_set中也存在，比如当前的表长为100，而真实存在表中的数据已经大于1000个元素，此时，每个bucker均摊有10个元素，这样就会影响到unordered_set的存取效率，而标准库通过采用某种策略来对当前空间进行扩容，以此来提高存取效率。当然，这里也存在缩容，原理和扩容类似，不过，需要注意的是，每当unordered_set内部进行一次扩容或者缩容，都需要对表中的数据重新计算，也就是说，扩容或者缩容的时间复杂度至少为。 code：</p><pre><code>[cpp]// unordered_set::find#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_set&gt;  &lt;/unordered_set&gt;&lt;/string&gt;&lt;/iostream&gt;int main (){std::unordered_set&lt;std::string&gt; myset = { &quot;red&quot;,&quot;green&quot;,&quot;blue&quot; };  &lt;/std::string&gt;std::string input;std::cout &amp;lt;&amp;lt; &quot;color? &quot;;    getline (std::cin,input);    std::unordered_set&lt;std::string&gt;::const_iterator got = myset.find (input);  &lt;/std::string&gt;if ( got == myset.end() )std::cout &amp;lt;&amp;lt; &quot;not found in myset&quot;;    else      std::cout &amp;lt;&amp;lt; *got &amp;lt;&amp;lt; &quot; is in myset&quot;;    std::cout &amp;lt;&amp;lt; std::endl;    return 0;  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++代码优化建议</title>
      <link href="/8e72ff9a/"/>
      <url>/8e72ff9a/</url>
      
        <content type="html"><![CDATA[<ol><li>记住阿姆达尔定律： Ahmdal’s rule $$Speedup =\dfrac{ time_{old}}{time_{new}} = \dfrac{1}{(1-func_{cost})+func_{cost}/func_{speedup}}$$</li></ol><ul><li>func_cost是函数func运行时间百分比，func_speedup是你优化函数的运行的系数。</li><li>所以，如果你优化了函数TriangleIntersect执行40%的运行时间，使它运行快了近两倍，而你的程序会运行快25%。</li><li>这意味着不经常使用的代码不需要做较多优化考虑（或者完全不优化）。</li><li>这里有句俗语：让经常执行的路径运行更加高效，而运行稀少的路径正确运行。</li></ul><ol><li><p>代码先保证正确，然后再考虑优化 这并不意味着用8周时间写一个全功能的射线追踪算法，然后用8周时间去优化它。 分多步来做性能优化。 先写正确的代码，当你意识到这个函数可能会被经常调用，进行明显的优化。 然后再寻找算法的瓶颈，并解决（通过优化或者改进算法）。通常，改进算法能显著地改进瓶颈——也许是采用一个你还没有预想到的方法。所有频繁调用的函数，都需要优化。</p></li><li><p>我所了解的那些写出非常高效代码的人说，他们优化代码的时间，是写代码时间的两倍。</p></li><li><p>跳转和分支执行代价高，如果可能，尽量少用。</p></li></ol><p>函数调用需要两次跳转，外加栈内存操作。 优先使用迭代而不是递归。 使用内联函数处理短小的函数来消除函数调用开销。 将循环内的函数调用移动到循环外(例如，将for(i=0;i&lt;100;i++) DoSomething();改为DoSomething() { for(i=0;i&lt;100;i++) { … }})。 if…else if…else if…else if…很长的分支链执行到最后的分支需要很多的跳转。如果可能，将其转换为一个switch声明语句，编译器有时候会将其转换为一个表查询单次跳转。如果switch声明不可行，将最常见的场景放在if分支链的最前面。 5. 仔细思考函数下标的顺序。</p><pre><code>两阶或更高阶的数组在内存中还是以一维的方式在存储在内存中，这意味着（对于C/C++数组）array[i][j] 和 array[i][j+1]是相邻的，但是array[i][j] 和array[i+1][j]可能相距很远。</code></pre><p>以适当的方式访问存储实际内存中的数据，可以显著地提升你代码的执行效率（有时候可以提升一个数量级甚至更多）。 现代处理器从主内存中加载数据到处理器cache，会加载比单个值更多的数据。该操作会获取请求数据和相邻数据（一个cache行大小）的整块数据。这意味着，一旦array[i][j]已经在处理器cache中，array[i][j+1]很大可能也已经在cache中了，而array[i+1][j]可能还在内存中。 6. 使用指令层的并行机制</p><pre><code>尽管许多程序还是依赖单线程的执行，现代处理器在单核中也提供了不少的并行性。例如：单个CPU可以同时执行4个浮点数乘，等待4个内存请求并执行一个分支预判。</code></pre><p>为了最大化利用这种并行性，代码块（在跳转之间的）需要足够的独立指令来允许处理器被充分利用。 考虑展开循环来改进这一点。 这也是使用内联函数的一个好理由。 7. 避免或减少使用本地变量。</p><pre><code>本地变量通常都存储在栈上。不过如果数量比较少，它们可以存储在CPU寄存器中。在这种情况下，函数不但得到了更快访问存储在寄存器中的数据的好处，也避免了初始化一个栈帧的开销。</code></pre><p>不要将大量数据转换为全局变量。 8. 减少函数参数的个数。</p><pre><code>和减少使用本地变量的理由一样——它们也是存放在栈上。</code></pre><p>9. 通过引用传递结构体而不是传值</p><pre><code>我在射线追踪中还找不到一个场景需要将结构体使用传值方式（包括一些简单结构如：Vector，Point和Color）。</code></pre><p>10. 如果你的函数不需要返回值，不要定义。</p><ol><li><p>尽量避免数据转换。</p><p>整数和浮点数指令通常操作不同的寄存器，所以转换需要进行一次拷贝操作。 短整型（char和short）仍然使用一整个寄存器，并且它们需要被填充为32/64位，然后在存储回内存时需要再次转换为小字节（不过，这个开销一定比一个更大的数据类型的内存开销要多一点）。</p></li><li><p>定义C++对象时需要注意。</p><p>使用类初始化而不是使用赋值（Color c(black); 比Color c; c = black;更快）</p></li><li><p>使类构造函数尽可能轻量。 尤其是常用的简单类型（比如，color，vector，point等等），这些类经常被复制。 这些默认构造函数通常都是在隐式执行的，这或许不是你所期望的。 使用类初始化列表(Use Color::Color() : r(0), g(0), b(0) {}，而不是初始化函数Color::Color() { r= g = b = 0; } .)</p></li><li><p>如果可以的话，使用位移操作&gt;&gt;和&lt;&lt;来代替整数乘除法</p></li><li><p>小心使用表查找函数</p><p>许多人都鼓励将复杂的函数（比如：三角函数）转化为使用预编译的查找表。对于射线追踪功能来说，这通常导致了不必要的内存查找，这很昂贵（并不断增长），并且这和计算一个三角函数并从内存中获取值一样快（尤其你考虑到三角查找打乱了cpu的cache存取）。 在其他情况下，查找表会很有用。对于GPU编程通常优先使用表查找而不是复杂函数。</p></li><li><p>对大多数类，优先使用+= 、 -= 、 *= 和 /=，而不是使用+ 、 – 、 * 、 和?/</p><p>这些简单操作需要创建一个匿名临时中间变量。 例如：Vector v = Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1);?创建了五个匿名临时Vector: Vector(1,0,0), Vector(0,1,0), Vector(0,0,1), Vector(1,0,0) + Vector(0,1,0), 和 Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1). 对上述代码进行简单转换：Vector v(1,0,0); v+= Vector(0,1,0); v+= Vector(0,0,1);仅仅创建了两个临时Vector: Vector(0,1,0) 和 Vector(0,0,1)。这节约了6次函数调用（3次构造函数和3次析构函数）。</p></li><li><p>对于基本数据类型，优先使用+?、?-?、?<em>?、?和?/，而不是+=?、?-=?、?</em>= 和 /=</p></li><li><p>推迟定义本地变量</p><p>定义一个对象变量通常需要调用一次函数（构造函数）。 如果一个变量只在某些情况下需要（例如在一个if声明语句内），仅在其需要的时候定义，这样，构造函数仅在其被使用的时候调用。</p></li><li><p>对于对象，使用前缀操作符（++obj），而不是后缀操作符（obj++）</p><p>这在你的射线追踪算法中可能不是一个问题 使用后缀操作符需要执行一次对象拷贝（这也导致了额外的构造和析构函数调用），而前缀的构造函数不需要一个临时的拷贝。</p></li><li><p>小心使用模板</p><p>对不同的是实例实现进行不同的优化。 标准模板库已经经过良好的优化，不过我建议你在实现一个交互式射线追踪算法时避免使用它。 使用自己的实现，你知道它如何使用算法，所以你知道如何最有效的实现它。 最重要的是，我的经历告诉我：调试STL库非常低效。通常这也不是一个问题，除非你使用debug版本做性能分析。你会发现STL的构造函数，迭代器和其他一些操作，占用了你15%的运行时间，这会导致你分析性能输出更加费劲。</p></li><li><p>避免在计算时进行动态内存分配</p><p>动态内存对于存储场景和运行期间其他数据都很有用。 但是，在许多（大多数）的系统动态内存分配需要获取控制访问分配器的锁。对于多线程应用程序，现实中使用动态内存由于额外的处理器导致了性能下降，因为需要等待分配器锁和释放内存。 即便对于单线程应用，在堆上分配内存也比在栈上分配内存开销大得多。操作系统还需要执行一些操作来计算并找到适合尺寸的内存块。</p></li><li><p>找到你系统内存cache的信息并利用它们</p><p>如果一个是数据结构正好适合一个cache行，处理整个类从内存中只需要做一次获取操作。 确保所有的数据结构都是cache行大小对齐（如果你的数据结构和一个cache行大小都是128字节，仍有可能因为你的结构体中的一个字节在一个cache行中，而其他127字节在另外一个cahce行中）。</p></li><li><p>避免不需要的数据初始化</p><p>如果你需要初始化一大段的内存，考虑使用memset。</p></li><li><p>尽早结束循环和尽早返回函数调用</p><p>考虑一个射线和三角形交叉，通常的情况是射线会越过三角，所以这里可以优化。 如果你决定将射线和三角面板交叉。如果射线和面板交叉t值是负数，你可以立即返回。这允许你跳过射线三角交叉一大半的质心坐标计算。这是一个大的节约，一旦你知道这个交叉不存在，你就应该立即返回交叉计算函数。 同样的，一些循环也应该尽早结束。例如，当设置阴影射线，对于近处的交叉通常都是不必须的，一旦有类似的的交叉，交叉计算就应该尽早返回。（这里的交叉含义不太明白，可能是专业词汇，译者注）</p></li><li><p>在稿纸上简化你的方程式</p><p>许多方程式中，通常都可以或者在某些条件中取消计算。 编译器不能发现这些简化，但是你可以。取消一个内部循环的一些昂贵操作可以抵消你在其他地方的好几天的优化工作。</p></li><li><p>整数、定点数、32位浮点数和64位双精度数字的数学运算差异，没有你想象的那么大</p><p>在现代CPU，浮点数运算和整数运算差不多拥有同样的效率。在计算密集型应用（比如射线追踪），这意味这可以忽略整数和浮点数计算的开销差异。这也就是说，你不必要对算数进行整数处理优化。 双精度浮点数运算也不比单精度浮点数运算更慢，尤其是在64位机器上。我在同一台机器测试射线追踪算法全部使用double比全部使用floats运行有时候更快，反过来测试也看到了一样的现象（这里的原文是：I have seen ray tracers run faster using all doubles than all floats on the same machine. I have also seen the reverse）。</p></li><li><p>不断改进你的数学计算，以消除昂贵的操作</p><p>sqrt()经常可以被优化掉，尤其是在比较两个值的平方根是否一致时。 如果你重复地需要处理 除x 操作，考虑计算1/x的值，乘以它。这在向量规范化（3次除法）运算中赢得了大的改进，不过我最近发现也有点难以确定的。不过，这仍然有所改进，如果你要进行三次或更多除法运算。 如果你在执行一个循环，那些在循环中执行不发生变化的部分，确保提取到循环外部。 考虑看看你的计算值是否可以在循环中修改得到（而不每次都重新开始循环计算）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>x == x</title>
      <link href="/72da8a18/"/>
      <url>/72da8a18/</url>
      
        <content type="html"><![CDATA[<p>C的表达式 x == x，何时为假呢？即下面的代码：</p><pre><code>if (x == x){printf(&quot;Equal\n&quot;);}else{printf(&quot;Not equal\n&quot;);}</code></pre><p>什么时候输出为”Not equal”呢？</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;&lt;/string.h&gt;&lt;/stdio.h&gt;&lt;/stdlib.h&gt;int main(void){float x = 0xffffffff;if (x == x){printf(&quot;Equal\n&quot;);}else{printf(&quot;Not equal\n&quot;);}if (x &amp;gt;= 0){printf(&quot;x(%f) &amp;gt;= 0\n&quot;, x);}else if (x &amp;lt; 0)     {        printf(&quot;x(%f) &amp;lt; 0\n&quot;, x);    }    int a = 0xffffffff;    memcpy(&amp;amp;x, &amp;amp;a, sizeof(x));    if (x == x)     {        printf(&quot;Equal\n&quot;);    }    else     {        printf(&quot;Not equal\n&quot;);    }    if (x &amp;gt;= 0){printf(&quot;x(%f) &amp;gt;= 0\n&quot;, x);}else if (x &amp;lt; 0)     {        printf(&quot;x(%f) &amp;lt; 0\n&quot;, x);    }    else     {        printf(&quot;Surprise x(%f)!!!\n&quot;, x);    }    return 0;}</code></pre><p>编译<code>gcc -g -Wall test.c</code>，看执行结果：</p><pre><code>$ ./a.outEqualx(4294967296.000000) &amp;gt;= 0Not equalSurprise x(-nan)!!!</code></pre><p>最后两行输出是不是有点surprise啊。</p><p>下面先简单解释一下： 1. 当<code>float x = 0xffffffff</code>：这时将整数赋给一个浮点数，由于float和int的size都是4，而浮点数的存储格式与整数不同，其需要将某些位作为小数位，所以float的范围要小于int的范围。因此这里涉及到了整数转换浮点的规定。因为这个转换其实很少用到，我也就不查了。但是总之，这个转换是合法的。但是最终的值很可能不是你想要的结果——尤其是当浮点的范围小于整数的范围时。 2. 即使整数转换成浮点，数值再不是期望值，但它也一定是一个合法的浮点数值。所以第一个<code>x == x</code>，一定为true，且x不是大于0，就是小于0。这时x存的并不是0xffffffff。 3. 当使用memcpy将0xff填充到x的地址时，这时x存的保证为0xffffffff。但是这个不是一个合法的float的值。因此奇怪的现象发生了，x并不等于x。原因则是与cpu的浮点指令相关. 4. 作为一个非法的float值，当它与其它任何数值比较时，都会返回false。这也就造成了，后面惊奇的结果，x既不大于等于0，也不小于0。</p><p>总结一下：一般来说，浮点类型很少被使用，也不应该在程序中鼓励使用。不仅其效率比整数低，且由于浮点类型特殊的存储格式，很容易造成一些意想不到的错误。如果真的无法避免时，一定要小心小心再小心。特别要注意今天的主题，这种非法的浮点值，会导致任何比较判断都失败。而判断这种浮点值的方法也很简单，如果<code>x != x</code>，那么该浮点即为非法浮点值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++在重载operator=为带模板的函数的时候的陷阱</title>
      <link href="/a25c4e07/"/>
      <url>/a25c4e07/</url>
      
        <content type="html"><![CDATA[<p>原文地址 <a href="https://segmentfault.com/a/1190000004467381" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004467381</a></p><p>最近被一个语法问题缠了半天，终于找到了原因。不仔细思考一下写的时候真的很容易忽略。先看代码：</p><p>template class A { public: const T t = 0;</p><p>template A&amp; operator=(const A&amp; a) { return *this; } };</p><p>int main() { A a, b;</p><p>b = a; // error } 这会带来一个编译错误，然而横睇掂睇都看不出问题。于是我就试了一下这样的代码：A c; b = c;居然通过了编译。F**k，这个模板居然胳膊肘往外拐。</p><p>其实我在写这个代码的时候忽略了一点，就是default assignment operator，它是你在定义类的时候编译器默认给你加上去的，行为是对所有成员变量赋值。它的声明是A&amp; operator=(const A&amp; a);，跟我们自己定义的放在一起：</p><p>template A&amp; operator=(const A&amp; a) { return *this; }</p><p>A&amp; operator=(const A&amp; a) /<em>= delete</em>/; 恰好构成了模板特化，这就糟了。一旦构成了特化，OtherT可以匹配的类型就会除去int，用A赋值时只能调用系统给我们定义的那个。然而它也不起作用，因为成员里面有常量（这样它就会被标记为= delete，留意delete并不会令OtherT可以匹配到int，反而令它匹配不到）。</p><p>知道了原因之后，解决就很方便了，只要重新定义这个默认赋值运算符就好：</p><p>A&amp; operator=(const A&amp; a) { /<em>…</em>/ }</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习笔记</title>
      <link href="/31dc5dc1/"/>
      <url>/31dc5dc1/</url>
      
        <content type="html"><![CDATA[<p>关于Makefile怎么写,参考<a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">http://blog.csdn.net/haoel/article/details/2886</a></p><p>一 关于编译和链接</p><pre><code>一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</code></pre><p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p><pre><code>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</code></pre><p>二 Makefile的规则</p><p>三条:</p><pre><code>1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。     2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。     3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。target ... : prerequisites ...             command             ...             ...target也就是一个目标文件，可以是Object File，也可以是执行文件,还可以是一个标签（Label）.prerequisites就是，要生成那个target所需要的东西(文件或是目标)。command也就是make需要执行的命令。（任意的Shell命令）这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</code></pre><p>For example:</p><pre><code>edit : main.o kbd.o command.o display.o \            insert.o search.o files.o utils.o             cc -o edit main.o kbd.o command.o display.o \                        insert.o search.o files.o utils.omain.o : main.c defs.h             cc -c main.c     kbd.o : kbd.c defs.h command.h             cc -c kbd.c     command.o : command.c defs.h command.h             cc -c command.c     display.o : display.c defs.h buffer.h             cc -c display.c     insert.o : insert.c defs.h buffer.h             cc -c insert.c     search.o : search.c defs.h buffer.h             cc -c search.c     files.o : files.c defs.h buffer.h command.h             cc -c files.c     utils.o : utils.c defs.h             cc -c utils.c     clean :             rm edit main.o kbd.o command.o display.o \                insert.o search.o files.o utils.o在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个\[Tab\]键作为开头(在Makefile中的命令，必须要以\[Tab\]键开始)。make并不管命令是怎么工作的，它只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，make就会执行后续定义的命令。clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，如果其冒号后什么也没有，那么make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</code></pre><p>三 Makefile里有什么</p><p>1 显示规则</p><p>2 隐晦规则</p><p>3 变量的定义</p><p>4 文件指示: 其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。</p><p>5 注释: Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。</p><p>四 Makefile的文件名</p><pre><code>默认情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了就解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</code></pre><p>当然，也可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，可以使用make的“-f”和“–file”参数，如：make -f Make.Linux或make –file Make.AIX。</p><p>五 引用其它的Makefile</p><p>include的语法是：</p><pre><code>include</code></pre><p>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p><pre><code>在include前面可以有一些空字符，但是绝不能是\[Tab\]键开始。include和可以用一个或多个空格隔开。例如,有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：include foo.make *.mk $(bar)等价于：include foo.make a.mk b.mk c.mk e.mk f.mk</code></pre><p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><pre><code>1、如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。     2、如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</code></pre><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p><pre><code>-include     其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</code></pre><p>六 环境变量 MAKEFILES</p><pre><code>如果当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。但是在这里还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当使用make时，所有的Makefile都会受到它的影响，这绝不是想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明.</code></pre><p>七 关于命令</p><pre><code>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：@echo 正在编译XXX模块......</code></pre><p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：</p><pre><code>echo 正在编译XXX模块......     正在编译XXX模块......</code></pre><p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于调试Makefile，看看书写的命令执行起来是什么样子的或是什么顺序的,而make参数“-s”或“–slient”则是全面禁止命令的显示。</p><pre><code>如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令。比如第一条命令是cd，希望第二条命令在cd之后的基础上运行，那么就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：示例一：         exec:                 cd /home/hchen                 pwd示例二：         exec:                 cd /home/hchen; pwd</code></pre><p>当执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p><pre><code>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。有些时候，命令的出错并不表示就是错误的。例如mkdir，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。之所以使用mkdir的意思就是一定要有这样的一个目录，只要这个目录存在了,就不希望mkdir出错而终止规则的运行。为了做到这一点，忽略命令的出错，可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</code></pre><p>   clean:             -rm -f *.o</p><p>还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p><pre><code>在一些大的工程中，会把不同模块或是不同功能的源文件放在不同的目录中，这种情况可以在每个目录中都书写一个该目录的Makefile，例如，有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么总控的Makefile可以这样书写：subsystem:             cd subdir &amp;&amp; $(MAKE)</code></pre><p>其等价于：</p><pre><code>subsystem:             $(MAKE) -C subdir</code></pre><p>这两个例子的意思都是先进入“subdir”目录，然后执行make命令。总控Makefile的变量可以传递到下级的Makefile中，但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p><p>如果要传递变量到下级Makefile中，那么可以使用这样的声明：</p><pre><code>export</code></pre><p>如果不想让某些变量传递到下级Makefile中，那么可以这样声明：</p><pre><code>unexport</code></pre><p>如：</p><pre><code>示例一：    export variable = value    其等价于：    variable = value         export variable    其等价于：    export variable := value    其等价于：    variable := value         export variable示例二：    export variable += value    其等价于：    variable += value         export variable</code></pre><p>如果要传递所有的变量，那么，只要一个export就行了,后面什么也不用跟，表示传递所有的变量。</p><p>八 变量</p><p>两种高级用法:</p><pre><code>我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</code></pre><p>示例：</p><pre><code>foo := a.o b.o c.o     bar := $(foo:.o=.c)</code></pre><p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有的“.o”字串“结尾”全部替换成“.c”，所以“$(bar)”的值就是“a.c b.c c.c”。</p><p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p><pre><code>x = y     y = z     a := $($(x))</code></pre><p>在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）</p><p>我们还可以使用更多的层次：</p><pre><code>x = y     y = z     z = u     a := $($($(x)))</code></pre><p>这里的$(a)的值是“u”.</p><pre><code>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令.定义是以endef关键字结束,其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。命令需要以\[Tab\]键开头，define定义的命令也不例外.</code></pre><p>下面的这个示例展示了define的用法：</p><p>define two-lines     echo foo     echo $(bar) endef</p><p>九 目标变量</p><pre><code>前面所有的在Makefile中定义的变量都是“全局变量”，在整个文件，都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。当然，我们同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效,而不会影响规则链以外的全局变量的值。</code></pre><p>其语法是：</p><pre><code>:: overide</code></pre><p>可以是各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p><p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p><pre><code>prog : CFLAGS = -g     prog : prog.o foo.o bar.o             $(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c             $(CC) $(CFLAGS) prog.cfoo.o : foo.c             $(CC) $(CFLAGS) foo.cbar.o : bar.c             $(CC) $(CFLAGS) bar.c</code></pre><p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”.</p><p>十 条件判断语法</p><p>条件表达式的语法为：</p><pre><code>else         endif</code></pre><p>其中表示条件关键字，如“ifeq”。这个关键字有四个。</p><p>第一个是我们前面所见过的“ifeq”</p><pre><code>ifeq (, )     ifeq &apos;&apos; &apos;&apos;     ifeq &quot;&quot; &quot;&quot;     ifeq &quot;&quot; &apos;&apos;     ifeq &apos;&apos; &quot;&quot;</code></pre><p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p><pre><code>ifeq ($(strip $(foo)),)         endif</code></pre><p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么就生效。</p><p>第二个条件关键字是“ifneq”。</p><p>第三个条件关键字是“ifdef”。语法是：</p><pre><code>ifdef</code></pre><p>如果变量的值非空，那到表达式为真。否则，表达式为假。当然，同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p><pre><code>示例一：     bar =     foo = $(bar)     ifdef foo     frobozz = yes     else     frobozz = no     endif示例二：     foo =     ifdef foo     frobozz = yes     else     frobozz = no     endif</code></pre><p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p><p>第四个条件关键字是“ifndef”。</p><pre><code>在这一行上，多余的空格是被允许的，但是不能以\[Tab\]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以\[Tab\]键开始就行了。特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</code></pre><p>十一 foreach 函数     foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，它的语法是：</p><pre><code>$(foreach ,&lt;list&gt;,&lt;text&gt;)这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。&amp;nbsp; &amp;nbsp;所以，&lt;var&gt;最好是一个变量名，&lt;/var&gt;&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举&lt;list&gt;中的单词。举个例子：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;names := a b c dfiles := $(foreach n,$(names),$(n).o) </code></pre><p>  $(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。 </p><p>十二 检查规则</p><p>有时候，我们不想让我们的makefile中的规则执行起来，只想检查一下命令，或是执行的序列。可以使用make命令的下述参数：</p><pre><code>“-n”     “--just-print”     “--dry-run”</code></pre><p>------------------   </p><pre><code>“-t”     “--touch”     这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</code></pre><hr><pre><code>“-W ”     这个参数需要指定一个文件。一般是是源文件（或依赖文件），make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。假定目标需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。</code></pre><p>十三 make的其他参数</p><p>“-B” “–always-make” 认为所有的目标都需要更新（重编译）。</p><p>“-C</p><p>” “–directory=</p><p>” 指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p><p>“-i” “–ignore-errors” 在执行时忽略所有的错误。</p><p>“-k” “–keep-going” 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。 十四 隐含规则</p><pre><code>在使用Makefile时，有一些会经常使用，而且使用频率非常高的东西，比如，编译C/C++的源程序为中间目标文件（Unix下是\[.o\]文件，Windows下是\[.obj\]文件）,这些就是早先约定了的，不需要我们再写出来的规则。“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，即使Makefile中没有书写这样的规则。例如，把\[.c\]文件编译成\[.o\]文件这一规则，根本就不用写出来，make会自动推导出这种规则，并生成需要的\[.o\]文件。“隐含规则”会使用一些系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</code></pre><p>1 使用隐含规则</p><pre><code>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：foo : foo.o bar.o             cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</code></pre><p>这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p><pre><code>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把\[.o\]的目标的依赖文件置成\[.c\]，并使用C的编译命令“cc –c $(CFLAGS) \[.c\]”来生成\[.o\]的目标。也就是说，我们完全没有必要写下下面的两条规则：foo.o : foo.c             cc –c foo.c $(CFLAGS)     bar.o : bar.c         cc –c bar.c $(CFLAGS)</code></pre><p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p><pre><code>当然，如果我们为\[.o\]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：foo.o : foo.p</code></pre><p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p><p>1 编译C程序的隐含规则 “.o”的目标的依赖目标会自动推导为“.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”</p><p>2 编译C++程序的隐含规则 “.o”的目标的依赖目标会自动推导为“.cc”或是“.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p><p>3 链接Object文件的隐含规则 “”目标依赖于“.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p><pre><code>x : y.o z.o</code></pre><p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p><pre><code>cc -c x.c -o x.o     cc -c y.c -o y.o     cc -c z.c -o z.o     cc x.o y.o z.o -o x     rm -f x.o     rm -f y.o     rm -f z.o</code></pre><p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
