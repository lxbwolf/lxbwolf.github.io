<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【译】10大静态网站生成工具</title>
    <url>/690c8418/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#静态网站是什么">静态网站是什么？</a></li>
<li><a href="#最好的开源静态网站生成工具">最好的开源静态网站生成工具</a><ul>
<li><a href="#1-jekyll">1、Jekyll</a></li>
<li><a href="#2-hugo">2、Hugo</a></li>
<li><a href="#3-hexo">3、Hexo</a></li>
<li><a href="#4-gatsby">4、Gatsby</a></li>
<li><a href="#5-vuepress">5、VuePress</a></li>
<li><a href="#6-nuxtjs">6、Nuxt.js</a></li>
<li><a href="#7-docusaurus">7、Docusaurus</a></li>
<li><a href="#8-eleventy">8、Eleventy</a></li>
<li><a href="#9-publii">9、Publii</a></li>
<li><a href="#10-primo">10、Primo</a></li>
</ul>
</li>
<li><a href="#结语">结语</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>在寻找部署静态网页的方法吗？这几个开源的静态网站生成工具可以帮你迅速部署界面优美、功能强大的静态网站，无需掌握复杂的 HTML 和 CSS 技能。</p>
</blockquote>
<h3><span id="静态网站是什么">静态网站是什么？</span></h3><p>技术上来讲，静态网站是指网页不是由服务器动态生成的。HTML、CSS 和 JavaScript 文件就静静地躺在服务器的某个路径下，它们的内容与终端用户接收到的版本是一样的。原始的源码文件已经提前编译好了，源码在每次请求后都不会变化。</p>
<p>Linux.CN 是一个依赖多个数据库的动态网站，当有浏览器的请求时，网页就会生成并提供服务。大部分网站是动态的，你与这些网站互动时，大量的内容会经常改变。</p>
<p>静态网站有一些好处，比如加载时间更短，请求的服务器资源更少、更安全（值得商榷）。</p>
<p>传统上，静态网站更适合于创建只有少量网页、内容变化不频繁的小网站。</p>
<p>然而，随着静态网站生成工具出现后，静态网站的适用范围越来越大。你还可以使用这些工具搭建博客网站。</p>
<p>我整理了几个开源的静态网站生成工具，这些工具可以帮你搭建界面优美的网站。</p>
<h3><span id="最好的开源静态网站生成工具">最好的开源静态网站生成工具</span></h3><p>请注意，静态网站不会提供很复杂的功能。如果你需要复杂的功能，那么你可以参考适用于动态网站的<a href="https://itsfoss.com/open-source-cms/">最佳开源 CMS</a>列表。</p>
<h4><span id="1-jekyll">1、Jekyll</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230847472.png" alt></p>
<p>Jekyll 是用 <a href="https://www.ruby-lang.org/en/">Ruby</a> 写的最受欢迎的开源静态生成工具之一。实际上，Jekyll 是 <a href="https://pages.github.com/">GitHub 页面</a> 的引擎，它可以让你免费用 GitHub 托管网站。</p>
<p>你可以很轻松地跨平台配置 Jekyll，包括 Ubuntu。它利用 <a href="https://github.com/Shopify/liquid/wiki">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki">Liquid</a>（模板语言）、HTML 和 CSS 来生成静态的网页文件。如果你要搭建一个没有广告或推广自己工具或服务的产品页的博客网站，它是个不错的选择。</p>
<p>它还支持从常见的 CMS（<ruby>内容管理系统<rt>Content management system</rt></ruby>）如 Ghost、WordPress、Drupal 7 迁移你的博客。你可以管理永久链接、类别、页面、文章，还可以自定义布局，这些功能都很强大。因此，即使你已经有了一个网站，如果你想转成静态网站，Jekyll 会是一个完美的解决方案。你可以参考<a href="https://jekyllrb.com/docs/">官方文档</a>或 <a href="https://github.com/jekyll/jekyll">GitHub 页面</a>了解更多内容。</p>
<ul>
<li><a href="https://jekyllrb.com/">Jekyll</a></li>
</ul>
<h4><span id="2-hugo">2、Hugo</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230848755.png" alt></p>
<p>Hugo 是另一个很受欢迎的用于搭建静态网站的开源框架。它是用 <a href="https://golang.org/">Go 语言</a>写的。</p>
<p>它运行速度快、使用简单、可靠性高。如果你需要，它也可以提供更高级的主题。它还提供了一些有用的快捷方式来帮助你轻松完成任务。无论是组合展示网站还是博客网站，Hogo 都有能力管理大量的内容类型。</p>
<p>如果你想使用 Hugo，你可以参照它的<a href="https://gohugo.io/getting-started/">官方文档</a>或它的 <a href="https://github.com/gohugoio/hugo">GitHub 页面</a>来安装以及了解更多相关的使用方法。如果需要的话，你还可以将 Hugo 部署在 GitHub 页面或任何 CDN 上。</p>
<ul>
<li><a href="https://gohugo.io/">Hugo</a></li>
</ul>
<h4><span id="3-hexo">3、Hexo</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230849836.png" alt></p>
<p>Hexo 是一个有趣的开源框架，基于 <a href="https://nodejs.org/en/">Node.js</a>。像其他的工具一样，你可以用它搭建相当快速的网站，不仅如此，它还提供了丰富的主题和插件。</p>
<p>它还根据用户的每个需求提供了强大的 API 来扩展功能。如果你已经有一个网站，你可以用它的<a href="https://hexo.io/api/migrator.html">迁移</a>扩展轻松完成迁移工作。</p>
<p>你可以参照<a href="https://hexo.io/docs/">官方文档</a>或 <a href="https://github.com/hexojs/hexo">GitHub 页面</a> 来使用 Hexo。</p>
<ul>
<li><a href="https://hexo.io/">Hexo</a></li>
</ul>
<h4><span id="4-gatsby">4、Gatsby</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230850165.png" alt></p>
<p>Gatsby 是一个越来越流行的开源网站生成框架。它使用 <a href="https://reactjs.org/">React.js</a> 来生成快速、界面优美的网站。</p>
<p>几年前在一个实验性的项目中，我曾经非常想尝试一下这个工具，它提供的成千上万的新插件和主题的能力让我印象深刻。与其他静态网站生成工具不同的是，你可以使用 Gatsby 生成一个网站，并在不损失任何功能的情况下获得静态网站的好处。</p>
<p>它提供了与很多流行的服务的整合功能。当然，你可以不使用它的复杂的功能，或将其与你选择的流行 CMS 配合使用，这也会很有趣。你可以查看他们的<a href="https://www.gatsbyjs.com/docs/">官方文档</a>或它的 <a href="https://github.com/gatsbyjs/gatsby">GitHub 页面</a>了解更多内容。</p>
<ul>
<li><a href="https://www.gatsbyjs.com/">Gatsby</a></li>
</ul>
<h4><span id="5-vuepress">5、VuePress</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230850623.png" alt></p>
<p>VuePress 是由 <a href="https://vuejs.org/">Vue.js</a> 支持的静态网站生成工具，而 Vue.js 是一个开源的渐进式 JavaScript 框架。</p>
<p>如果你了解 HTML、CSS 和 JavaScript，那么你可以无压力地使用 VuePress。你应该可以找到几个有用的插件和主题来为你的网站建设开个头。此外，看起来 Vue.js 的更新一直很活跃，很多开发者都在关注 Vue.js，这是一件好事。</p>
<p>你可以参照他们的<a href="https://vuepress.vuejs.org/guide/">官方文档</a>和 <a href="https://github.com/vuejs/vuepress">GitHub 页面</a>了解更多。</p>
<ul>
<li><a href="https://vuepress.vuejs.org/">VuePress</a></li>
</ul>
<h4><span id="6-nuxtjs">6、Nuxt.js</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230851735.png" alt></p>
<p>Nuxt.js 使用了 Vue.js 和 Node.js，但它致力于模块化，并且有能力依赖服务端而非客户端。不仅如此，它的目标是为开发者提供直观的体验，并提供描述性错误，以及详细的文档等。</p>
<p>正如它声称的那样，在你用来搭建静态网站的所有工具中，Nuxt.js 可以做到功能和灵活性两全其美。他们还提供了一个 <a href="https://template.nuxtjs.org/">Nuxt 线上沙盒</a>，让你不费吹灰之力就能直接测试它。</p>
<p>你可以查看它的 <a href="https://github.com/nuxt/nuxt.js">GitHub 页面</a>和<a href="https://nuxtjs.org/">官方网站</a>了解更多。</p>
<ul>
<li><a href="https://nuxtjs.org/">Nuxt.js</a></li>
</ul>
<h4><span id="7-docusaurus">7、Docusaurus</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230851189.png" alt></p>
<p>Docusaurus 是一个有趣的开源静态网站生成工具，为搭建文档类网站量身定制。它还是 <a href="https://opensource.facebook.com/">Facebook 开源计划</a>的一个项目。</p>
<p>Docusaurus 是用 React 构建的。你可以使用所有的基本功能，像文档版本管理、文档搜索和翻译大多是预先配置的。如果你想为你的产品或服务搭建一个文档网站，那么可以试试 Docusaurus。</p>
<p>你可以从它的 <a href="https://github.com/facebook/docusaurus">GitHub 页面</a>和它的<a href="https://docusaurus.io/">官网</a>获取更多信息。</p>
<ul>
<li><a href="https://docusaurus.io/">Docusaurus</a></li>
</ul>
<h4><span id="8-eleventy">8、Eleventy</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230852491.png" alt></p>
<p>Eleventy 自称是 Jekyll 的替代品，旨在以更简单的方法来制作更快的静态网站。</p>
<p>它似乎很容易上手，而且它还提供了适当的文档来帮助你。如果你想找一个简单的静态网站生成工具，Eleventy 似乎会是一个有趣的选择。</p>
<p>你可以参照它的 <a href="https://github.com/11ty/eleventy/">GitHub 页面</a>和<a href="https://www.11ty.dev/">官网</a>来了解更多的细节。</p>
<ul>
<li><a href="https://www.11ty.dev/">Eleventy</a></li>
</ul>
<h4><span id="9-publii">9、Publii</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230852316.png" alt></p>
<p>Publii 是一个令人印象深刻的开源 CMS，它能使生成一个静态网站变得很容易。它是用 <a href="https://www.electronjs.org">Electron</a> 和 Vue.js 构建的。如果有需要，你也可以把你的文章从 WorkPress 网站迁移过来。此外，它还提供了与 GitHub 页面、Netlify 及其它类似服务的一键同步功能。</p>
<p>如果你利用 Publii 生成一个静态网站，你还可以得到一个所见即所得的编辑器。你可以从<a href="https://getpublii.com/">官网</a>下载它，或者从它的 <a href="https://github.com/GetPublii/Publii">GitHub 页面</a>了解更多信息。</p>
<ul>
<li><a href="https://getpublii.com/">Publii</a></li>
</ul>
<h4><span id="10-primo">10、Primo</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304230852327.png" alt></p>
<p>一个有趣的开源静态网站生成工具，目前开发工作仍很活跃。虽然与其他的静态生成工具相比，它还不是一个成熟的解决方案，有些功能还不完善，但它是一个独特的项目。</p>
<p>Primo 旨在使用可视化的构建器帮你构建和搭建网站，这样你就可以轻松编辑和部署到任意主机上。</p>
<p>你可以参照<a href="https://primo.af/">官网</a>或查看它的 <a href="https://github.com/primo-app/primo-desktop">GitHub 页面</a>了解更多信息。</p>
<ul>
<li><a href="https://primo.af/">Primo</a></li>
</ul>
<h3><span id="结语">结语</span></h3><p>还有很多文章中没有列出的网站生成工具。然而，我试图提到最好的静态生成器，为您提供最快的加载时间，最好的安全性和令人印象深刻的灵活性。</p>
<p>列表中没有你最喜欢的工具？在下面的评论中告诉我。</p>
<hr>
<p>via: <a href="https://itsfoss.com/open-source-static-site-generators/">https://itsfoss.com/open-source-static-site-generators/</a></p>
<p>作者：<a href="https://itsfoss.com/author/ankush/">Ankush Das</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>APNG与 GIF</title>
    <url>/941edb97/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#关于-apng">关于 APNG</a></li>
<li><a href="#apng-简史">APNG 简史</a></li>
<li><a href="#为什么-gif-能存活29年之久">为什么 GIF 能存活29年之久？</a></li>
<li><a href="#为什么要取代它">为什么要取代它？</a></li>
<li><a href="#apng-的组成">APNG 的组成</a></li>
<li><a href="#apng-帧间优化">APNG 帧间优化</a></li>
<li><a href="#为什么没有普及">为什么没有普及？</a></li>
<li><a href="#特性检测">特性检测</a></li>
<li><a href="#apng-to-canvas">APNG to Canvas</a></li>
<li><a href="#制作工具">制作工具</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- tocstop -->

<h3><span id="关于-apng">关于 APNG</span></h3><p>APNG（Animated Portable Network Graphics）顾名思义是基于 PNG 格式扩展的一种动画格式，增加了对动画图像的支持，同时加入了 24 位图像和 8 位 Alpha 透明度的支持，这意味着动画将拥有更好的质量，其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。</p>
<h3><span id="apng-简史">APNG 简史</span></h3><p><strong>MNG</strong></p>
<p>在 APNG 之前它还有一个老冤家叫 MNG（Multiple-image Network Graphics）即多图像网络图形，1996 年 6 月提出 PNF（Portable Network Frame）草案，同年8月更名为 MNG ，2001 年 1 月 31 日发布 MNG 规范 1.0 版本，MNG 是出自 PNG 开发组之手，但由于结构复杂的 MNG 程序库，使用过程会占用大量的资源，早期只有较少的浏览器支持，Chrome、IE、Opera、Safari 则从未支持过。</p>
<p><strong>APNG</strong></p>
<p>2004 年，由 Mozilla 公司两位 Mozilla 程序员 Stuart Parmenter 和 Vladimir Vukićević 共同设计出 APNG，他们希望 Mozilla 社区能使用它，但提案未能通过。</p>
<p><strong>libpng程序库</strong></p>
<p>2006 年，Google Summer of Code 活动中，加拿大圣力嘉学院的学生为 libpng 程序库加入了对 APNG 支持，此后开发者再次推荐给 Mozilla 社区，不过仍然遭到拒绝。</p>
<p><strong>首次支持</strong></p>
<p>2007 年 3 月 23 日，Mozilla 后知后觉，在 Mozilla Firefox 3.0 中 首次支持 APNG 格式。</p>
<p><strong>标准化申请</strong></p>
<p>2007 年 4 月 20 日，Mozilla 希望 APNG 能成为官方标准，因此 PNG 组织发起投票，最终以8：10的票数否决了 APNG 进了官方标准，因为 PNG 组织决心继续推广 MNG，但这不并影响 Mozilla 继续支持 APNG。</p>
<h3><span id="为什么-gif-能存活29年之久">为什么 GIF 能存活29年之久？</span></h3><p>开头讲 APNG 时提到，APNG 的出现就是为了替代 GIF，诞生于 1987 年的 GIF 为什么能存活 29 年之久？</p>
<p>主要有四个原因：</p>
<ul>
<li>几乎所有的主流浏览器都支持 GIF</li>
<li>早期选择不多，GIF 几乎是唯一选择（GIF - 1987、JPEG - 1992、PNG - 1996、APNG - 2004、WebP - 2010）</li>
<li>实现起来简单，制作的工具多</li>
<li>采用 LZW 数据压缩算法，使得 GIF 体积小，在早期慢速的互联网易于传播</li>
</ul>
<h3><span id="为什么要取代它">为什么要取代它？</span></h3><p><strong>1、图片质量</strong></p>
<div style="width: 100%;"><img style="width: 20%;background: #000;" src="//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif"><img style="width: 20%;background: #fff;" src="//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif"><img style="width: 20%;background: #dd0041;" src="//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif"><img style="width: 20%;background: #6752b7;" src="//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif"><img style="width: 20%;background: url(//misc.aotu.io/ONE-SUNDAY/apng_checker.png);background-size: 8px 8px;" src="//misc.aotu.io/ONE-SUNDAY/gif_spinfox.gif"><p style="color: #bbb;text-align: center;">GIF</p></div>

<div style="width: 100%;"><img style="width: 20%;background: #000;" src="//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png"><img style="width: 20%;background: #fff;" src="//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png"><img style="width: 20%;background: #dd0041;" src="//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png"><img style="width: 20%;background: #6752b7;" src="//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png"><img style="width: 20%;background: url(//misc.aotu.io/ONE-SUNDAY/apng_checker.png);background-size: 8px 8px;" src="//misc.aotu.io/ONE-SUNDAY/apng_spinfox.png"><p style="color: #bbb;text-align: center;">APNG</p></div>

<p>如果你使用的是非 Firefox、Safari 浏览器，那 APNG 格式的图片会向下兼容显示为静态图，你可以更换 Firefox、Safari 浏览器或者在 Chrome 浏览器安装 <a href="https://chrome.google.com/webstore/detail/apng/ehkepjiconegkhpodgoaeamnpckdbblp">APNG Extension for Google Chrome </a>扩展来兼容，通过两者对比能总结出以下区别：</p>
<p><strong>GIF：</strong></p>
<ul>
<li>最多支持 8 位 256 色，色阶过渡糟糕，图片具有颗粒感</li>
<li>不支持 Alpha 透明通道，边缘有杂边</li>
</ul>
<p><strong>APNG：</strong></p>
<ul>
<li>支持 24 位真彩色图片</li>
<li>支持 8 位 Alpha 透明通道</li>
<li>向下兼容 PNG</li>
</ul>
<p><strong>2、图片体积</strong></p>
<p>如果你使用的浏览器不支持WebP，下面对比的 WebP 格式的图片将无法显示。</p>
<table><tbody><tr><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/SteamEngine.gif"></td><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/SteamEngine.png"></td></tr><tr><td style="text-align: center;">GIF = 43 920 bytes</td><td style="text-align: center;">APNG = 34 210 bytes</td></tr><tr><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/SteamEngine.webp" alt="SteamEngine.webp"></td><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/SteamEngine_lossy.webp" alt="SteamEngine_lossy.webp"></td></tr><tr><td style="text-align: center;">WebP = 41 064 bytes</td><td style="text-align: center;">Lossy WebP = 73 774 bytes</td></tr><tr><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/world-cup_2014_42.gif"></td><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/world_cup_2014_42.png"></td></tr><tr><td style="text-align: center;">GIF = 43 132 bytes</td><td style="text-align: center;">APNG = 30 823 bytes</td></tr><tr><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/world_cup_2014_42.webp" alt="world_cup_2014_42.webp"></td><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/world_cup_2014_42_lossy.webp" alt="world_cup_2014_42_lossy.webp"></td></tr><tr><td style="text-align: center;">WebP = 55 968 bytes</td><td style="text-align: center;">Lossy WebP = 114 518 bytes</td></tr><tr><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/BladeRunner.gif"></td><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/BladeRunner.png"></td></tr><tr><td style="text-align: center;">GIF = 200 700 bytes</td><td style="text-align: center;">APNG = 168 411 bytes</td></tr><tr><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/BladeRunner.webp" alt="BladeRunner.webp"></td><td style="text-align: center;"><img src="//misc.aotu.io/ONE-SUNDAY/BladeRunner_lossy.webp" alt="BladeRunner_lossy.webp"></td></tr><tr><td style="text-align: center;">WebP = 424 752 bytes</td><td style="text-align: center;">Lossy WebP = 394 118 bytes</td></tr></tbody></table>

<p>从几组 GIF、APNG、WebP 的对比中可以发现，无论在纯色的图片或是多彩的图片，大部分情况下 APNG 依旧能比 GIF、WebP 以及有损的 WebP 的体积小。</p>
<h3><span id="apng-的组成">APNG 的组成</span></h3><p>APNG 是基于 PNG 格式扩展的，首先需要了解一个简单的 PNG 文件组成结构：</p>
<table><tbody><tr><td>PNG Signature</td><td>IHDR</td><td>IDAT</td><td>IEND</td></tr></tbody></table>

<p>PNG 由 4 部分组成，首先以 PNG Signature（PNG签名块）开头，紧接着一个 IHDR（图像头部块），然后是一个或多个的 IDAT（图像数据块），最终以 IEND（图像结束块）结尾。</p>
<p>APNG 规范引入了三个新大块，分别是：acTL（动画控制块）、fcTL（帧控制块）、fdAT（帧数据块），下图是三个独立的 PNG 文件组成 APNG 的示意图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503115051.png" alt></p>
<ul>
<li>acTL 块必须在第一个 IDAT 块之前，用于告诉解析器这是一个动画 PNG，包含动画帧总数和循环次数的信息</li>
<li>fcTL 块是每一帧都必须的，出现在 IDAT 或 fdAT 之前，包含顺序号、宽高、帧位置、延时等信息</li>
<li>fdAT 块与 IDAT 块有着相同的结构，除了 fcTL 中的顺序号</li>
</ul>
<p>从图中可以发现第一帧与后面两帧不同，那是因为第一帧 APNG 文件存储的为一个正常的 PNG 数据块，对于不支持 APNG 的浏览器或软件，只会显示 APNG 文件的第一帧，忽略后面附加的动画块，这也是为什么 APNG 能向下兼容 PNG 的原因。</p>
<h3><span id="apng-帧间优化">APNG 帧间优化</span></h3><p>假设使用一个 4 帧图片合成 APNG</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503115139.png" alt></p>
<p>APNG 会通过算法计算帧之间的差异，只存储帧之前的差异，而不是存储全帧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503115211.png" alt></p>
<p>通过 TweakPNG 软件观察 IDAT 图像数据块和 fdAT 帧数据块的大小，可以明显的看出来存储全帧与差异帧的区别，使得 APNG 文件大小有显著的减少。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503115247.png" alt></p>
<h3><span id="为什么没有普及">为什么没有普及？</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503115312.png" alt></p>
<p>主要的原因是缺乏浏览器的支持，从 Can I use 查询可知 Firefox 从 3 到 49 版本自始自终支持着，Opera 早期只有三个版本支持过（10.1、11.5、12.1），后续版本则取消了对 APNG 的支持，而 Chrome、IE、Edge 则从未支持过 APNG，Chrome 和 Opera 都在推广自家的 WebP，而微软则一直是个不合群的家伙。</p>
<p>但是，重要的一点是 2014 年 9 月 17 号 Apple 向用户推送了 iOS 8，这意味着 Safari 8 新增了对 APNG 的支持，这能有效的推动 APNG 的发展，至少在移动端。</p>
<h3><span id="特性检测">特性检测</span></h3><p>既然存在兼容问题，那就需要通过判断应用场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> apngTest = <span class="keyword">new</span> <span class="title class_">Image</span>(),</span><br><span class="line">    ctx = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;canvas&quot;</span>).<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    apngTest.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        ctx.<span class="title function_">drawImage</span>(apngTest, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        self.<span class="property">apng_supported</span> = ctx.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).<span class="property">data</span>[<span class="number">3</span>] === <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    apngTest.<span class="property">src</span> = <span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg==&quot;</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>方法与 WebP 检测相似，同样是加载一张 1x1 像素大小的 Base64 编码图片，不同在于 WebP 加载完成后是判断图片宽高是否大于 1，而 APNG 则是将其绘制到画布中，通过 getImageData() 方法去获取该图片的像素数据，主要是获取 data[3] 的 Alpha 透明通道（值的范围：0 - 255），当返回 0（0代表透明的）时则表示支持 APNG，返回 255（255 代表完全可见的）则表示不支持 APNG。</p>
<h3><span id="apng-to-canvas">APNG to Canvas</span></h3><p>当然，目前也有用于兼容的库： <a href="https://github.com/davidmz/apng-canvas">apng-canvas</a></p>
<p>使用该库需要以下条件支持：</p>
<ul>
<li>Canvas</li>
<li>Typed Arrays</li>
<li>Blob URLs</li>
<li>requestAnimationFrame</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;example.png&quot; class=&quot;apng-image&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APNG.ifNeeded().then(function() &#123;</span><br><span class="line">    var images = document.querySelectorAll(&quot;.apng-image&quot;);</span><br><span class="line">    for (var i = 0; i &lt; images.length; i++) &#123;</span><br><span class="line">        APNG.animateImage(images[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3><span id="制作工具">制作工具</span></h3><p>在了解 APNG 后，是不是心痒痒想制作 APNG 呢？在制作工具方面，APNG 已经不像早期那样工具匮乏了， <a href="http://littlesvr.ca/apng/">APNG Software </a>网站上有大量的制作工具，有客户端版本（大部分只支持 Widnows）也有命令行版本，可以非常轻松的制作 APNG，比如下面这款软件。</p>
<p><strong>Windows客户端 - APNG Assembler</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503115617.png" alt></p>
<p><strong>Mac客户端 - APNGb</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503121205.png" alt></p>
<p><strong>功能说明：</strong></p>
<ul>
<li>Playback Settings 可设置循环的次数，0 表示无限循环，可跳过第一帧</li>
<li>Delays - All Frames 可设置所有帧播放时所停留的时间</li>
<li>Compression Settings 可设置压缩参数，有三种压缩方式（zlib、7zip、Zopfli）以及颜色类型和调色板优化</li>
<li>Delays - Selected Frames 可设置选中帧播放时所停留的时间</li>
</ul>
<p>这里演示图分别是 Windows 版本和 Mac 版本，功能基本一致，将序列帧图片拖拽到指定位置，设置一些基本的参数即可生成 APNG 图，Mac 版本比 Windows 版本多出一个将 APNG 图片 Disassembly（分解）功能，可分解为多个 PNG 图片。</p>
<p><a href="https://sourceforge.net/projects/apngasm/">下载地址戳这里</a></p>
<h3><span id="参考资料">参考资料</span></h3><p><a href="http://people.mozilla.org/~dolske/apng/demo.html">Animated PNG demos </a><a href="http://littlesvr.ca/apng/gif_apng_webp.html">GIF vs APNG vs WebP </a><a href="http://littlesvr.ca/apng/inter-frame.html">Inter-frame Optimization in APNG </a><a href="https://github.com/davidmz/apng-canvas">davidmz/apng-canvas - Github </a><a href="https://en.wikipedia.org/wiki/GIF">GIF - Wikipedia </a><a href="https://en.wikipedia.org/wiki/APNG">APNG - Wikipedia </a><a href="https://wiki.mozilla.org/APNG_Specification">APNG Specification </a><a href="http://caniuse.com/#search=APNG">Can I use - APNG </a><a href="https://zh.wikipedia.org/wiki/PNG">Portable Network Graphics - Wikipedia </a><a href="https://en.wikipedia.org/wiki/Multiple-image_Network_Graphics">Multiple-image Network Graphics - Wikipedia </a><a href="http://littlesvr.ca/apng/">APNG Software</a></p>
<p><a href="https://wiki.mozilla.org/APNG_Specification">https://wiki.mozilla.org/APNG_Specification</a></p>
<p><a href="https://philip.html5.org/tests/apng/tests.html">https://philip.html5.org/tests/apng/tests.html</a></p>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>apng</tag>
        <tag>gif</tag>
      </tags>
  </entry>
  <entry>
    <title>B树和B+树</title>
    <url>/17ced2c4/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p><strong>一 B树</strong></p>
<p><strong>1.B树的定义：</strong>B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。</p>
<p><strong>2.B树的特征：</strong></p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 ≤ k ≤ m （m为树的阶）</li>
<li>每个叶子节点都包含k-1个元素，其中 m/2 ≤ k ≤ m （m为树的阶）</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分（一个结点有k个孩子时，必有k-1个元素才能将子树中所有元素划分为k个子集）</li>
</ul>
<p><strong>3.B树的操作</strong></p>
<p><strong>3.1 B树的查找：</strong>如下图，查询元素8</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212210837.png" alt></p>
<p>第一次磁盘IO：把15所在节点读到内存中，然后与8做比较，小于15，找到下一个节点（5和9对应的节点）</p>
<p>第二次磁盘IO：把5和9所在的节点读到内存中，然后与8做比较，5&lt;8&lt;9，找到下一个节点（6和8对应的节点）</p>
<p>第三次磁盘IO：把6和8所在节点读到内存中，然后与8做比较，找到了元素8</p>
<p><strong>3.1 B树的插入：</strong> 将元素7插入下图中的B树</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212211015.png" alt></p>
<p>步骤一：自顶向下查找元素7应该在的位置，即在6和8之间</p>
<p>步骤二：三阶B树中的节点最多有两个元素，把6 7 8里面的中间元素上移（中间元素上移是插入操作的关键）</p>
<p>步骤三：上移之后，上一层节点元素也超载了，5 7 9中间元素上移，现在根节点变为了 7 15</p>
<p>步骤四：要对B树进行调整，使其满足B树的特性，最终如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212211040.png" alt></p>
<p><strong>二 B+树</strong> </p>
<p> B+树是B树的一种变形体，它与B树的差异在于：</p>
<ul>
<li><p>有K个子节点的节点必然有K个关键码</p>
</li>
<li><p>非叶节点仅具有索引作用，元素信息均存放在叶节点中</p>
</li>
<li><p>树的所有叶节点构成一个有序链表，可以按照关键码排序的次序遍历全部记录</p>
<p>B+树的优势：</p>
</li>
<li><p>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</p>
</li>
<li><p>B+树的叶子节点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212211103.png" alt></p>
<p>总结：我们知道二叉查找树的时间复杂度是Ｏ(logN)，效率已经足够高。为什么出现B树和B+树呢？当大量数据存储在磁盘上，进行查询操作时，需要先将数据加载到内存中（磁盘IO操作），而数据并不能一次性全部加载到内存中，只能逐一加载每个磁盘页（对应树的一个节点），并且磁盘IO操作很慢，平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。为了减少磁盘IO的次数，就需要降低树的深度，那么就引出了B树和B+树：每个节点存储多个元素，采用多叉树结构。这样就提高了效率，比如数据库索引，就是存储在磁盘上，采用的就是B+树的数据结构。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++在重载operator=为带模板的函数的时候的陷阱</title>
    <url>/a25c4e07/</url>
    <content><![CDATA[<p>原文地址 <a href="https://segmentfault.com/a/1190000004467381">https://segmentfault.com/a/1190000004467381</a></p>
<p>最近被一个语法问题缠了半天，终于找到了原因。不仔细思考一下写的时候真的很容易忽略。先看代码：</p>
<p>template class A { public: const T t = 0;</p>
<p>template A&amp; operator=(const A&amp; a) { return *this; } };</p>
<p>int main() { A a, b;</p>
<p>b = a; // error } 这会带来一个编译错误，然而横睇掂睇都看不出问题。于是我就试了一下这样的代码：A c; b = c;居然通过了编译。F**k，这个模板居然胳膊肘往外拐。</p>
<p>其实我在写这个代码的时候忽略了一点，就是default assignment operator，它是你在定义类的时候编译器默认给你加上去的，行为是对所有成员变量赋值。它的声明是A&amp; operator=(const A&amp; a);，跟我们自己定义的放在一起：</p>
<p>template A&amp; operator=(const A&amp; a) { return *this; }</p>
<p>A&amp; operator=(const A&amp; a) /<em>= delete</em>/; 恰好构成了模板特化，这就糟了。一旦构成了特化，OtherT可以匹配的类型就会除去int，用A赋值时只能调用系统给我们定义的那个。然而它也不起作用，因为成员里面有常量（这样它就会被标记为= delete，留意delete并不会令OtherT可以匹配到int，反而令它匹配不到）。</p>
<p>知道了原因之后，解决就很方便了，只要重新定义这个默认赋值运算符就好：</p>
<p>A&amp; operator=(const A&amp; a) { /<em>…</em>/ }</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Lambda 表达式</title>
    <url>/e4d97659/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#基础">基础</a><ul>
<li><a href="#1-值捕获">1. 值捕获</a></li>
<li><a href="#2-引用捕获">2. 引用捕获</a></li>
<li><a href="#3-隐式捕获">3. 隐式捕获</a></li>
<li><a href="#4-表达式捕获">4. 表达式捕获</a></li>
</ul>
</li>
<li><a href="#泛型-lambda">泛型 Lambda</a></li>
</ul>
<!-- tocstop -->

<p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p>
<h3><span id="基础">基础</span></h3><p>Lambda 表达式的基本语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[捕获列表](参数列表) <span class="built_in">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p>
<p>所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p>
<h4><span id="1-值捕获">1. 值捕获</span></h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，<strong>被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-引用捕获">2. 引用捕获</span></h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-隐式捕获">3. 隐式捕获</span></h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p>
<p>总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p>
<ul>
<li>[] 空捕获列表</li>
<li>[name1, name2, …] 捕获一系列变量</li>
<li>[&amp;] 引用捕获, 让编译器自行推导捕获列表</li>
<li>[=] 值捕获, 让编译器执行推导引用列表</li>
</ul>
<h4><span id="4-表达式捕获">4. 表达式捕获</span></h4><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p>
<p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>important</code> 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值， 在表达式中初始化。</p>
<h3><span id="泛型-lambda">泛型 Lambda</span></h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。 这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。</p>
<p>幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始， Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7升级gcc 和gdb</title>
    <url>/ec9feff6/</url>
    <content><![CDATA[<p>升级后版本: <code>gcc-5.4.0</code> <code>gdb-7.11.1</code></p>
<h2><span id="安装开发必备环境">安装开发必备环境</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum groupinstall <span class="string">&quot;Development Tools&quot;</span></span><br><span class="line">yum install glibc-static libstdc++-static</span><br></pre></td></tr></table></figure>


<h2><span id="编译安装gcc-540">编译安装gcc-5.4.0</span></h2><p><a href="http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/">gcc下载地址</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf gcc-5.4.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> gcc-5.4.0</span><br><span class="line">./contrib/download_prerequisits</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">make（建议不要使用make -j来编译，虽然可以缩短编译时间，但极大可能会编译失败）</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>其中执行<code>./contrib/download_prerequisits</code>将自动下载以下几个文件，这个几个文件在gcc编译时需要： <code>- mpfr-2.4.2.tar.bz2 - gmp-4.3.2.tar.bz2 - mpc-0.8.1.tar.gz - isl-0.15.tar.bz2</code></p>
<p><code>make install</code> 时, 自动安装到<code>/usr/local/gcc-5.40</code></p>
<h2><span id="解决运行程序时-gcc-报错glibcxx_3421-not-found">解决运行程序时, gcc 报错’GLIBCXX_3.4.21’ not found</span></h2><p>这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决，运行以下命令检查动态库： <code>strings /lib64/libstdc++.so.6 | grep GLIBC</code></p>
<p>以下是输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_3.4.14</span><br><span class="line">GLIBCXX_3.4.15</span><br><span class="line">GLIBCXX_3.4.16</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBC_2.3</span><br><span class="line">GLIBC_2.2.5</span><br><span class="line">GLIBC_2.14</span><br><span class="line">GLIBC_2.4</span><br><span class="line">GLIBC_2.3.2</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br></pre></td></tr></table></figure>


<p>从输出结果可以看到并没有<code>GLIBCXX_3.4.21</code>,所以可以断定我们的程序运行时动态加载的是老的动态库，解决这个问题需要将当前链接文件的链接指向改成最新的动态库地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/lib64/libstdc++.so.6.0.21 /lib64</span><br><span class="line"><span class="built_in">cd</span> /lib64</span><br><span class="line"><span class="built_in">rm</span> -rf libstdc++.so.6</span><br><span class="line"><span class="built_in">ln</span> -s libstdc++.so.6.0.21 libstdc++.so.6</span><br></pre></td></tr></table></figure>

<p>然后你可以执行以下命令来查看<code>GLIBCXX_3.4.21</code>已经可以找到了: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings /lib64/libstdc++.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure>



<p>解决了这个问题终于可以执行程序了，然后又测试了<code>-g</code>选项来编译程序，编译好程序调试程序时并不能够设置断点以及print变量的值，gdb调试中出现：</p>
<p><code>Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.e17\_2.6.x86\_4 libgcc-4.8.5-4.e17.x86_64</code> 的问题，通过上网查阅资料，是因为gcc版本和gdb版本并不匹配，或者说gdb版本过低</p>
<h2><span id="编译安装gdb-7111">编译安装gdb-7.11.1</span></h2><p><a href="http://ftp.gnu.org/gnu/gdb/">gdb下载地址</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf gdb-7.11.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gdb-7.11.1</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>当执行 <code>make install</code> 时gdb安装出现了错误：</p>
<p><code>WARNING: &#39;makeinfo&#39; is missing on your sysem</code>，</p>
<p>则需安装相关依赖程序: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install texinfo libncurses5-dev</span><br></pre></td></tr></table></figure>



<p>如果调试程序时出现下面信息时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: File <span class="string">&quot;/usr/local/lib64/libstdc++.so.6.0.21-gdb.py&quot;</span> auto-loading has been declined by your `auto-load safe-path<span class="string">&#x27; set to &quot;$debugdir:$datadir/auto-load&quot;.</span></span><br><span class="line"><span class="string">To enable execution of this file add</span></span><br><span class="line"><span class="string">    add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.py</span></span><br><span class="line"><span class="string">line to your configuration file &quot;/root/.gdbinit&quot;.</span></span><br><span class="line"><span class="string">To completely disable this security protection add</span></span><br><span class="line"><span class="string">    set auto-load safe-path /</span></span><br><span class="line"><span class="string">line to your configuration file &quot;/root/.gdbinit&quot;.</span></span><br></pre></td></tr></table></figure>


<p>解决方法: 将以下信息放入<code>~/.gdbinit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.py</span><br><span class="line"><span class="built_in">set</span> auto-load safe-path /</span><br></pre></td></tr></table></figure>


<p>若想通过gdb来调试STL容器，则还需要做一些配置，可以通过<code>GDB Python pretty printers</code>来解决这个问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">svn checkout svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python stlPrettyPrinter</span><br><span class="line"><span class="built_in">mv</span> stlPrettyPrinter /usr/local</span><br></pre></td></tr></table></figure>


<p>然后将下面的配置信息放入<code>~/.gdbinit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(0, <span class="string">&#x27;/usr/local/stlPrettyPrinter&#x27;</span>)</span><br><span class="line">from libstdcxx.v6.printers import register_libstdcxx_printers</span><br><span class="line">register_libstdcxx_printers (None)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++返回内部静态成员的陷阱</title>
    <url>/d66df6b4/</url>
    <content><![CDATA[<p>在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多开发人员。如果你的内存是在函数内栈上分配的，那么这个内存会随着函数的返回而被弹栈释放，所以，你一定要返回一块函数外部还有效的内存。</p>
<p>这是一个让无数人困扰的问题。如果你一不小心，你就很有可能在这个上面犯错误。当然目前有很多解决方法，如果你熟悉一些标准库的话，你可以看到许多各式各样的解决方法。大体来说有下面几种：</p>
<p>1）在函数内部通过malloc或new在堆上分配内存，然后把这块内存返回（因为在堆上分配的内存是全局可见的）。这样带来的问题就是潜在的内存问题。因为，如果返回出去的内存不释放，那么就是memory Leak。或者是被多次释放，从而造成程序的crash。这两个问题都相当的严重，所以这种设计方法并不推荐。（在一些Windows API中，当你调用了一些API后，你必需也要调用他的某些API来释放这块内存）</p>
<p>2）让用户传入一块他自己的内存地址，而在函数中把要返回的内存放到这块内存中。这是一个目前普遍使用的方式。很多Windows API函数或是标准C函数都需要你传入一个buffer和这个buffer的长度。这种方式对我们来说应该是屡见不鲜了。这种方式的好处就是由函数外部的程序来维护这块内存，比较简显直观。但问题就是在使用上稍许有些麻烦。不过这种方式把犯错误的机率减到了最低。</p>
<p>3）第三种方式显得比较另类，他利用了static的特性，static的栈内存一旦分配，那这块内存不会随着函数的返回而释放，而且，它是全局可见的（只要你有这块内存的地址）。所以，有一些函数使用了static的这个特性，即不用使用堆上的内存，也不需要用户传入一个buffer和其长度。从而，使用得自己的函数长得很漂亮，也很容易使用。</p>
<p>这里，我想对第三个方法进行一些讨论。使用static内存这个方法看似不错，但是它有让你想象不到的陷阱。让我们来用一个实际发生的案例来举一个例子吧。</p>
<p><strong>示例</strong></p>
<p>有过socket编程经验的人一定知道一个函数叫：inet_ntoa，这个函数主要的功能是把一个数字型的IP地址转成字符串，这个函数的定义是这样的（注意它的返回值）：</p>
<p><code>char *inet_ntoa(struct in_addr in);</code></p>
<p>显然，这个函数不会分配堆上的内存，而他又没有让你传一下字符串的buffer进入，那么他一定使用“返回static char[]”这种方法。在我们继续我们的讨论之前，让我们先了解一下IP地址相关的知识，下面是inet_ntoa这个函数需要传入的参数：（也许你会很奇怪，只有一个member的struct还要放在struct中干什么？这应该是为了程序日后的扩展性的考虑）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> s_addr;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>对于IPV4来说，一个IP地址由四个8位的bit组成，其放在<code>s_addr</code>中，高位在后，这是为了方便网络传输。如果你得到的一个<code>s_addr</code>的整型值是：3776385196。那么，打开你的Windows计算器吧，看看它的二进制是什么？让我们从右到左，8位为一组（如下所示）。</p>
<p>11100001   00010111    00010000    10101100</p>
<p>再把每一组转成十进制，于是我们就得到：225   23   16   172， 于是IP地址就是 172.16.23.225。</p>
<p>好了，言归正传。我们有这样一个程序，想记录网络包的源地址和目地地址，于是，我们有如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> src, des;  </span><br><span class="line">........  </span><br><span class="line">........  </span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;源IP地址&lt;%s&gt;/t目的IP地址&lt;%s&gt;/n&quot;</span>, <span class="built_in">inet_ntoa</span>(src),   <span class="built_in">inet_ntoa</span>(des));  </span><br></pre></td></tr></table></figure>
<p>会发生什么样的结果呢？你会发现记录到文件中的源IP地址和目的IP地址完全一样。这是什么问题呢？于是你开始调试你的程序，你发现src.s_addr和des.s_addr根本不一样（如下所示）。可为什么输出到文件的源和目的都是一样的？难道说是inet_ntoa的bug？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">src.s_addr = <span class="number">3776385196</span>;    <span class="comment">//对应于172.16.23.225  </span></span><br><span class="line">des.s_addr = <span class="number">1678184620</span>;  <span class="comment">//对应于172.16.7.100  </span></span><br></pre></td></tr></table></figure>
<p>原因就是<code>inet_ntoa()</code>“自作聪明”地把内部的static char[]返回了，而我们的程序正是踩中了这个陷阱。让我们来分析一下fprintf代码。在我们fprintf时，编译器先计算<code>inet_ntoa(des)</code>，于是其返回一个字符串的地址，然后程序再去求<code>inet_ntoa(src)</code>表达式，又得到一个字符串的地址。这两个字符串的地址都是<code>inet_ntoa()</code>中那个<code>static char[]</code>，显然是同一个地址，而第二次求src的IP时，这个值的des的IP地址内容必将被src的IP覆盖。所以，这两个表达式的字符串内存都是一样的了，此时，程序会调用fprintf把这两个字符串（其实是一个）输出到文件。所以，得到相同的结果也就不奇怪。</p>
<p>仔细看一下inet_ntoa的man，我们可以看到这句话：<code>The string is returned in a statically allocated buffer,  which  subsequent calls will overwrite.</code>证实了我们的分析。</p>
<p><strong>小结</strong></p>
<p>让我们大家都扪心自问一下，我们在写程序的过程当中是否使用了这种方法？这是一个比较危险，容易出错的方法。这种陷阱让人防不胜防。想想，如果你有这样的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>( <span class="built_in">inet_ntoa</span>(ip1), <span class="built_in">inet_ntoa</span>(ip2) )==<span class="number">0</span> ) &#123;  </span><br><span class="line">…. ….  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>本想判断一下两个IP地址是否一样，却不料掉入了那个陷阱——让这个条件表达式永真。</p>
<p>这个事情告诉我们下面几个道理：</p>
<p>1）慎用这种方式的设计。返回函数内部的static内存有很大的陷阱。</p>
<p>2）如果一定要使用这种方式的话。你就必须严肃地告诉所有使用这个函数的人，千万不要在一个表达式中多次使用这个函数。而且，还要告诉他们，不copy函数返回的内存的内容，而只是保存返回的内存地址或是引用是没用的。不然的话，后果概不负责。</p>
<p>3）C/C++是很危险的世界，如果你不清楚他的话。还是回火星去吧。</p>
<p>附：看过Efftive C++的朋友一定知道其中有一个条款（item 23）：不要试图返回对象的引用。这个条款中也对是否返回函数内部的static变量进行了讨论。结果也是持否定态度的。</p>
<p>原文地址: <a href="http://www.tuicool.com/articles/JNZZfiZ">http://www.tuicool.com/articles/JNZZfiZ</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS释放被占用端口</title>
    <url>/2d1cc7f9/</url>
    <content><![CDATA[<p><strong>场景:</strong><br>在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错</p>
<p>1.输入netstat -tln,查看系统当前所有被占用端口,主要是为了查看你的端口是否真正的被占用着,搭建可以看到我的9001,和9002端口都已经被占用了,所以我需要释放这两个端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003213.png" alt="listen-port"></p>
<p>2.根据端口查询进程,输入lsof -i :9001,切记不要忘了添加冒号,如下图,就可以看到当前被占用的端口的进程<br>的进程编号</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003347.png" alt></p>
<ol start="3">
<li>kill 掉PID</li>
<li>再<code>netstat -tln</code> 确认下, 然后就可以起进程了</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Custom comparison, equality and equivalence with the STL</title>
    <url>/55f488ad/</url>
    <content><![CDATA[<p>从一段代码引用开始:</p>
<pre><code>std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; v1 = ... // v1 is filled with data
std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; v2 = ... // v2 is filled with data
std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; results;&lt;/int,&gt;&lt;/int,&gt;&lt;/int,&gt;

std::sort(v1.begin(), v1.end());
std::sort(v2.begin(), v2.end());

std::set_difference(v1.begin(), v1.end(),
v2.begin(), v2.end(),
std::back_inserter(result),
compareFirst);</code></pre><p>我们在两个排好序的vector v1 和 v2上调用<code>std::set_difference</code>. <code>std::set_difference</code> 把结果写入 <code>result</code>, <code>std::back_inserter</code> 确保输出的结果从<code>result</code> 的后面添入. 自定义的<code>compareFirst</code> 作为比较函数提供给<code>std::set_difference</code></p>
<p>默认地, <code>std::set_difference</code> 通过 <code>std::pair</code> 默认的比较函数来比较里面的元素(比较pair的first和second), 我们自定义了<code>compareFirst</code>, 希望只比较pair的first. <code>compareFirst</code>不是STL的函数, 需要我们自己实现.</p>
<p><code>std::set_difference</code> 使用的前提是input已经排好序, 倘若我们自定义比较函数C, 而通过C我们能把元素排好序, 那么我们使用这个C代替sort的默认排序也是可以的.</p>
<p>在此例中, 我们使用<code>std::set_difference</code> 只对pair的first进行排序, 尽管它们已经通过”first + second”的方式排序完了.</p>
<p>下面来实现<code>compareFirst</code>. 初版:</p>
<pre><code>bool compareFirst(const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp;amp; p1, const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp;amp; p2)
&#123;
return p1.first == p2.first; // not final code, bug lurking here!
&#125;</code></pre><p>实际上, 上面的代码不会得到我们预期的结果. 为什么? 毕竟<code>std::set_difference</code> 会检查元素跟另一个容器的元素是否相等(equal), 不是吗?&lt;/int,&gt;&lt;/int,&gt;</p>
<p>为了理解上面的内容, 我们把STL大概地分为两类: 操作排序元素的 和操作乱序元素的.</p>
<p><strong>Comparing elements</strong></p>
<p>C++中描述”a is the same as b” 有两种方法</p>
<pre><code>- the natural way: a == b. This is called equality. Equality is based on operator==.
- the other way: a is not smaller than b and b is not smaller than a, so !(a&lt;b) &amp;&amp;=&quot;&quot; !(b&lt;a).=&quot;&quot; this=&quot;&quot; is=&quot;&quot; called=&quot;&quot; equivalence.=&quot;&quot; equivalence=&quot;&quot; based=&quot;&quot; on=&quot;&quot; operator&lt;.=&quot;&quot; ```=&quot;&quot; 这两个问题涉及到另一个名词:=&quot;&quot; `equivalence`=&quot;&quot; &lt;u=&quot;&quot;&gt;How is it different from equality?&lt;/b)&gt;

对于基本类型如int, 甚至实践中大多数类型, `equivalence` 和`quality` 是相通的. 但是正如*Scott Meyers* 在&amp;lt;&amp;lt; Effective STL&amp;gt;&amp;gt;  一书条目19中指出的, 对于有一些类型, 即使&quot;并非罕见&quot;, `equivalence` 和 `equality` 是不同的, 如 大小写不敏感的string类型.

&lt;u&gt;Why such a far-fetched way to express a simple thing?&lt;/u&gt;

当我们使用算法对容器内元素进行排序时, 很容易理解必须有独一无二的排序方法(如有多种排序方法, 会很笨重, 并可能产生不一致的结果). 所以对于一个特定的容器, 排序时, &quot;==&quot; 和&quot;&amp;lt;&quot; 只能选一个. 

对于STL中排序的部分, 我们别无选择: 排序时必须使用&quot;&amp;lt;&quot;;
而乱序部分, 则没有这个约束, 我们可以使用&quot;==&quot;.

**Implementing the comparator**

STL的乱序部分使用&quot;==&quot;, 而排序部分使用&quot;&amp;lt;&quot;. 我们自定义的比较函数也必须遵循这种逻辑. 

现在我们可以理解怎么自定义实现`std::set_difference` 的比较函数`compareFirst` 了.</code></pre><p>​    </p>
<p>bool compareFirst(const std::pair&lt;int, std::string=””&gt;&amp; p1, const std::pair&lt;int, std::string=””&gt;&amp; p2) { return p1.first &lt; p2.first; // correct, STL-compatible code. } ```</p>
<p>原文地址: <a href="http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/">http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/</a> &lt;/int,&gt;&lt;/int,&gt;</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile修改hosts</title>
    <url>/265eeb54/</url>
    <content><![CDATA[<p>[toc]</p>
<p>[toc]</p>
<blockquote>
<p>在很多场景中，比如我们需要搭建一个集群，这时候容器要识别集群内的节点，就需要添加相应的host解析。</p>
</blockquote>
<h2><span id="背景">背景</span></h2><p>hosts文件其实并不是存储在Docker镜像中的，<code>/etc/hosts</code>, <code>/etc/resolv.conf</code>和<code>/etc/hostname</code>，是存在主机上的<code>/var/lib/docker/containers/(docker_id)</code> 目录下，容器启动时是通过mount将这些文件挂载到容器内部的。因此如果在容器中修改这些文件，修改部分不会存在于容器的top layer，而是直接写入这3个文件中。容器重启后修改内容不存在的原因是Docker每次创建新容器时，会根据当前docker0下的所有节点的IP信息重新建立hosts文件。也就是说，你的修改会被Docker给自动覆盖掉。</p>
<h2><span id="解决办法">解决办法</span></h2><h3><span id="opt-1-开启时加参数">OPT 1 开启时加参数</span></h3><p>开启容器时候添加参数 <code>--add-host machine:ip</code> 可以实现hosts修改，在容器中可以识别machine主机。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name nginx nginx:latest --add-host=<span class="string">&#x27;server:127.0.0.1&#x27;</span> --add-host=<span class="string">&#x27;server2:127.0.0.2&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="opt-2-修改容器hosts查找目录">OPT 2 修改容器hosts查找目录</span></h3><p>让容器开启时候，不去找<code>/etc/hosts</code>文件，而是去找自定义的hosts文件，下面是一个Dockerfile实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">RUN <span class="built_in">cp</span> /etc/hosts /tmp/hosts <span class="comment">#路径长度最好保持一致</span></span><br><span class="line">RUN <span class="built_in">mkdir</span> -p -- /lib-override &amp;&amp; <span class="built_in">cp</span> /lib/x86_64-linux-gnu/libnss_files.so.2 /lib-override</span><br><span class="line">RUN sed -i <span class="string">&#x27;s:/etc/hosts:/tmp/hosts:g&#x27;</span> /lib-override/libnss_files.so.2</span><br><span class="line">ENV LD_LIBRARY_PATH /lib-override</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;192.168.0.1 node1&quot;</span> &gt;&gt; /tmp/hosts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="opt-3-在-一个-run-中-设置-etchosts-的同时运行需要dns服务的安装">OPT 3 在 一个 RUN 中 设置 /etc/hosts 的同时，运行需要dns服务的安装</span></h3><p>由于在不同的 RUN 层中，/etc/hosts 会被docker重写覆盖掉，所以必须在同一个 RUN 层中同时设置并使用对应的域名映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;111.8.8.111 mirror.npm.com&quot;</span> &gt;&gt; /etc/hosts &amp;&amp; npm install </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch集群原理</title>
    <url>/fe48575b/</url>
    <content><![CDATA[<h2><span id="1-集群分布式原理">1 集群分布式原理</span></h2><p>ES集群可以根据节点数， 动态调整主分片与副本数， 做到整个集群有效均衡负载。</p>
<p>单节点状态下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181548073.png" alt></p>
<p>两个节点状态下， 副本数为1：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181549769.png" alt></p>
<p>三个节点状态下， 副本数为1：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181550937.png" alt></p>
<p>三个节点状态下， 副本数为2：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181550352.png" alt></p>
<h2><span id="2-分片处理机制">2 分片处理机制</span></h2><p>设置分片大小的时候， 需预先做好容量规划， 如果节点数过多， 分片数过小， 那么新的节点将无法分片， 不能做到水平扩展， 并且单个分片数据量太大， 导致数据重新分配耗时过大。</p>
<p>假设一个集群中有一个主节点、两个数据节点。orders索引的分片分布情况如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> orders </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">		<span class="string">&quot;number_of_shards&quot;</span>:<span class="number">2</span>, ## 主分片 <span class="number">2</span></span><br><span class="line">		<span class="string">&quot;number_of_replicas&quot;</span>:<span class="number">2</span> ## 副分片总数 <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181551701.png" alt></p>
<p>整个集群中存在P0和P1两个主分片， P0对应的两个R0副本分片， P1对应的是两个R1副本分片。</p>
<h2><span id="3-新建索引处理流程">3 新建索引处理流程</span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181552857.png" alt></p>
<ol>
<li>写入的请求会进入主节点， 如果是NODE2副本接收到写请求， 会将它转发至主节点。</li>
<li>主节点接收到请求后， 根据documentId做取模运算（外部没有传递documentId，则会采用内部自增ID）， 如果取模结果为P0，则会将写请求转发至NODE3处理。</li>
<li>NODE3节点写请求处理完成之后， 采用异步方式， 将数据同步至NODE1和NODE2节点。</li>
</ol>
<h2><span id="4-读取索引处理流程">4 读取索引处理流程</span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202408181553285.png" alt></p>
<ol>
<li>读取的请求进入MASTER节点， 会根据取模结果， 将请求转发至不同的节点。</li>
<li>如果取模结果为R0，内部还会有负载均衡处理机制，如果上一次的读取请求是在NODE1的R0， 那么当前请求会转发至NODE2的R0， 保障每个节点都能够均衡的处理请求数据。</li>
<li>读取的请求如果是直接落至副本节点， 副本节点会做判断， 若有数据则返回，没有的话会转发至其他节点处理。</li>
</ol>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Effective STL 9</title>
    <url>/978f4b48/</url>
    <content><![CDATA[<p>条款9：在删除选项中仔细选择 假定你有一个标准STL容器，c，容纳int， <code>Container&lt;int&gt; c;</code> 而你想把c中所有值为<code>1963</code>的对象都去掉。令人吃惊的是，完成这项任务的方法因不同的容 器类型而不同：没有一种方法是通用的。</p>
<p>如果你有一个连续内存容器（vector、deque或string——参见条款1），最好的方法是erase-remove惯用法（参见条款32）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1963</span>),       <span class="comment">// 当c是vector、string</span></span><br><span class="line">c.<span class="built_in">end</span>());                               <span class="comment">// 或deque时，</span></span><br><span class="line"><span class="comment">// erase-remove惯用法</span></span><br><span class="line"><span class="comment">// 是去除特定值的元素</span></span><br><span class="line"><span class="comment">// 的最佳方法</span></span><br></pre></td></tr></table></figure>


<p>这方法也适合于list，但是，正如条款44解释的，list的成员函数remove更高效：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove</span>(<span class="number">1963</span>);     <span class="comment">// 当c是list时，</span></span><br><span class="line"><span class="comment">// remove成员函数是去除</span></span><br><span class="line"><span class="comment">// 特定值的元素的最佳方法</span></span><br></pre></td></tr></table></figure>


<p>当c是标准关联容器（即，set、multiset、map或multimap）时，使用任何叫做remove的东 西都是完全错误的。这样的容器没有叫做remove的成员函数，而且使用remove算法可能覆 盖容器值（参见条款32），潜在地破坏容器。（关于这样的破坏的细节，参考条款22，那 个条款也解释了为什么试图在map和multimap上使用remove肯定不能编译，而试图在set和 multiset上使用可能不能编译。）</p>
<p>不，对于关联容器，解决问题的适当方法是调用erase：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="number">1963</span>);      <span class="comment">// 当c是标准关联容器时</span></span><br><span class="line"><span class="comment">// erase成员函数是去除</span></span><br><span class="line"><span class="comment">// 特定值的元素的最佳方法</span></span><br></pre></td></tr></table></figure>


<p>这不仅是正确的，而且很高效，只花费对数时间。（序列容器的基于删除的技术需要线性 时间。）并且，关联容器的erase成员函数有基于等价而不是相等的优势，条款19解释了这 一区别的重要性。</p>
<p>让我们现在稍微修改一下这个问题。不是从c中除去每个有特定值的物体，让我们消除下面 判断式（参见条款39）返回真的每个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">badValue</span><span class="params">(<span class="type">int</span> x)</span></span>;   <span class="comment">// 返回x是否是“bad”</span></span><br><span class="line">对于序列容器（vector、string、deque和list），我们要做的只是把每个<span class="built_in">remove</span>()替换为<span class="built_in">remove_if</span>()，然后就完成了：</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), badValue),    <span class="comment">// 当c是vector、string</span></span><br><span class="line">c.<span class="built_in">end</span>());           <span class="comment">// 或deque时这是去掉</span></span><br><span class="line"><span class="comment">// badValue返回真</span></span><br><span class="line"><span class="comment">// 的对象的最佳方法</span></span><br><span class="line">c.<span class="built_in">remove_if</span>(badValue);              <span class="comment">// 当c是list时这是去掉</span></span><br><span class="line"><span class="comment">// badValue返回真</span></span><br><span class="line"><span class="comment">// 的对象的最佳方法</span></span><br></pre></td></tr></table></figure>


<p>对于标准关联容器，它不是很直截了当。有两种方法处理该问题，一个更容易编码，另一 个更高效。“更容易但效率较低”的解决方案用<code>remove_copy_if()</code>把我们需要的值拷贝到一 个新容器中，然后把原容器的内容和新的交换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; c;              <span class="comment">// c现在是一种</span></span><br><span class="line">...                                 <span class="comment">// 标准关联容器</span></span><br><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; goodValues;         <span class="comment">// 用于容纳不删除</span></span><br><span class="line"><span class="comment">// 的值的临时容器</span></span><br><span class="line"><span class="built_in">remove_copy_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),          <span class="comment">// 从c拷贝不删除</span></span><br><span class="line"><span class="built_in">inserter</span>(goodValues,        <span class="comment">// 的值到</span></span><br><span class="line">goodValues.<span class="built_in">end</span>()),          <span class="comment">// goodValues</span></span><br><span class="line">badValue);</span><br><span class="line">c.<span class="built_in">swap</span>(goodValues);             <span class="comment">// 交换c和goodValues</span></span><br><span class="line"><span class="comment">// 的内容</span></span><br></pre></td></tr></table></figure>


<p>这种方法的缺点是它拷贝了所有不删除的元素，而这样的拷贝开销可能大于我们期望的底线。</p>
<p>我们可以通过直接从原容器删除元素来避开拷贝的开销。不过，因为关联容器没有提供类似<code>remove_if()</code>的成员函数，所以我们必须写一个循环来迭代c中的元素，和原来一样删除元素.</p>
<p>看起来，这个任务很简单，而且实际上，代码也很简单。不幸的是，那些正确工作的代码 很少是跃出脑海的代码。例如，这是很多程序员首先想到的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>();   <span class="comment">// 清晰，直截了当</span></span><br><span class="line">i!= c.<span class="built_in">end</span>();                                <span class="comment">// 而漏洞百出的用于</span></span><br><span class="line">++i) &#123;                                      <span class="comment">// 删除c中badValue返回真</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c.<span class="built_in">erase</span>(i);                   <span class="comment">// 的每个元素的代码</span></span><br><span class="line">&#125;                                                   <span class="comment">// 不要这么做！&lt;/int&gt;&lt;/int&gt;</span></span><br></pre></td></tr></table></figure>


<p>​    </p>
<p>唉，这有未定义的行为。当容器的一个元素被删时，指向那个元素的所有迭代器都失效了 。当c.erase(i)返回时，i已经失效。那对于这个循环是个坏消息，因为在erase()返回后， i通过for循环的++i部分自增。</p>
<p>为了避免这个问题，我们必须保证在调用erase之前就得到了c中下一元素的迭代器。最容 易的方法是当我们调用时在i上使用后置递增：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>();   <span class="comment">// for循环的第三部分</span></span><br><span class="line">i != c.<span class="built_in">end</span>();                                   <span class="comment">// 是空的；i现在在下面</span></span><br><span class="line"><span class="comment">/*nothing*/</span> )&#123;                                 <span class="comment">// 自增</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c.<span class="built_in">erase</span>(i++);     <span class="comment">// 对于坏的值，把当前的</span></span><br><span class="line"><span class="keyword">else</span> ++i;                           <span class="comment">// i传给erase，然后</span></span><br><span class="line">&#125;                                       <span class="comment">// 作为副作用增加i；</span></span><br><span class="line"><span class="comment">// 对于好的值，</span></span><br><span class="line"><span class="comment">// 只增加i</span></span><br></pre></td></tr></table></figure>


<p>这种调用erase()的解决方法可以工作，因为表达式i++的值是i的旧值，但作为副作用，i增 加了。因此，我们把i的旧值（没增加的）传给erase，但在erase开始执行前i已经自增了 。那正好是我们想要的。正如我所说的，代码很简单，只不过不是大多数程序员在第一次 尝试时想到的。</p>
<p>现在让我们进一步修改该问题。不仅删除badValue返回真的每个元素，而且每当一个元素 被删掉时，我们也想把一条消息写到日志文件中。</p>
<p>对于关联容器，这说多容易就有多容易，因为只需要对我们刚才开发的循环做一个微不足 道的修改就行了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream logFile;                   <span class="comment">// 要写入的日志文件</span></span><br><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>();   <span class="comment">// 循环条件和前面一样</span></span><br><span class="line">i !=c.<span class="built_in">end</span>();)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">badValue</span>(*i))&#123;</span><br><span class="line">logFile &amp;lt;&amp;lt; <span class="string">&quot;Erasing &quot;</span> &amp;lt;&amp;lt; *i &amp;lt;&amp;lt;<span class="string">&#x27;\n&#x27;</span>;   <span class="comment">// 写日志文件 </span></span><br><span class="line">        c.<span class="built_in">erase</span>(i++);           <span class="comment">// 删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在是vector、string和deque给我们带来麻烦。我们不能再使用<code>erase-remove</code>惯用法，因为没有办法让erase()或remove()写日志文件。而且，我们不能使用刚刚为关联容器开发的循环, 因为它为vector、string和deque产生未定义的行为！要记得对于那样的容器，调用erase不仅使所有指向被删元素的迭代器失效，也使被删元素之后的所有迭代器失效。在我们的情况里，那包括所有i之后的迭代器。我们写i++，++i或你能想起的其它任何东西都没有用，因为没有能导致迭代器有效的。</p>
<p>我们必须对vector、string和deque采用不同的战略。特别是，我们必须利用erase()的返回值。那个返回值正是我们需要的：一旦删除完成，它就是指向紧接在被删元素之后的元素的有效迭代器。换句话说，我们这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>();</span><br><span class="line">i != c.<span class="built_in">end</span>();)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">badValue</span>(*i))&#123;</span><br><span class="line">logFile &amp;lt;&amp;lt; <span class="string">&quot;Erasing &quot;</span> &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">        i = c.<span class="built_in">erase</span>(i);         <span class="comment">// 通过把erase的返回值</span></span><br><span class="line">    &#125;                   <span class="comment">// 赋给i来保持i有效</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这可以很好地工作，但只用于标准序列容器。由于论证一个可能的问题（条款5做了），标准关联容器的erase()的返回类型是void[1]。对于那些容器，你必须使用“后置递增你要传给erase()的迭代器”技术。（顺便说说，在为序列容器编码和为关联容器编码之间的这种差别是为什么写容器无关代码一般缺乏考虑的一个例子——参见条款2。)</p>
<p>为了避免你奇怪list的适当方法是什么，事实表明对于迭代和删除，你可以像vector/str ing/deque一样或像关联容器一样对待list；两种方法都可以为list工作。</p>
<p>如果我们观察在本条款中提到的所有东西，我们得出下列结论：</p>
<p>去除一个容器中有特定值的所有对象： 如果容器是vector、string或deque，使用erase-remove惯用法。</p>
<p>如果容器是list，使用list::remove。</p>
<p>如果容器是标准关联容器，使用它的erase成员函数。</p>
<p>去除一个容器中满足一个特定判定式的所有对象： 如果容器是vector、string或deque，使用<code>erase-remove_if</code>惯用法。</p>
<p>如果容器是list，使用list::remove_if。</p>
<p>如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素， 当你把迭代器传给erase时记得后置递增它。</p>
<p>在循环内做某些事情（除了删除对象之外）： 如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。 如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</p>
<p>如你所见，与仅仅调用erase相比，有效地删除容器元素有更多的东西。解决问题的最好方法取决于你是怎样鉴别出哪个对象是要被去掉的，储存它们的容器的类型，和当你删除它们的时候你还想要做什么（如果有的话）。只要你小心而且注意了本条款的建议，你将毫不费力。如果你不小心，你将冒着产生不必要低效的代码或未定义行为的危险。</p>
<h2><span id="-">------------------------------------------------------------------------------</span></h2><p>[1] 这仅对带有迭代器实参的erase()形式是正确的。关联容器也提供一个带有一个值的实参 的erase()形式，而那种形式返回被删掉的元素个数。但这里，我们只关心通过迭代器删除东 西。</p>
<p><a href="https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_3%2FC%2Fnetres%2Feffstl%2Ffile10.html">参考地址</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch集群节点</title>
    <url>/dbb730e9/</url>
    <content><![CDATA[<h2><span id="主节点或候选主节点">主节点（或候选主节点）</span></h2><p>主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作， 主节点负荷相对较轻， 客户端请求可以直接发往任何节点， 由对应节点负责分发和返回处理结果。</p>
<p>一个节点启动之后， 采用 Zen Discovery机制去寻找集群中的其他节点， 并与之建立连接， 集群会从候选主节点中选举出一个主节点， 并且一个集群只能选举一个主节点， 在某些情况下， 由于网络通信丢包等问题， 一个集群可能会出现多个主节点， 称为“脑裂现象”， 脑裂会存在丢失数据的可能， 因为主节点拥有最高权限， 它决定了什么时候可以创建索引， 分片如何移动等， 如果存在多个主节点， 就会产生冲突， 容易产生数据丢失。要尽量避免这个问题， 可以通过 discovery.zen.minimum_master_nodes 来设置最少可工作的候选主节点个数。  建议设置为（候选主节点/2） + 1 比如三个候选主节点，该配置项为 （3/2）+1 ,来保证集群中有半数以上的候选主节点， 没有足够的master候选节点， 就不会进行master节点选举，减少脑裂的可能。</p>
<p>主节点的参数设置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node.master = <span class="literal">true</span></span><br><span class="line">node.data = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2><span id="数据节点">数据节点</span></h2><p>数据节点负责数据的存储和CRUD等具体操作，数据节点对机器配置要求比较高、，首先需要有足够的磁盘空间来存储数据，其次数据操作对系统CPU、Memory和IO的性能消耗都很大。通常随着集群的扩大，需要增加更多的数据节点来提高可用性。</p>
<p>数据节点的参数设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.<span class="property">master</span> = <span class="literal">false</span></span><br><span class="line">node.<span class="property">data</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2><span id="客户端节点">客户端节点</span></h2><p>客户端节点不做候选主节点， 也不做数据节点的节点，只负责请求的分发、汇总等等，增加客户端节点类型更多是为了负载均衡的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.<span class="property">master</span> = <span class="literal">false</span></span><br><span class="line">node.<span class="property">data</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2><span id="提取节点预处理节点">提取节点（预处理节点）</span></h2><p>能执行预处理管道，有自己独立的任务要执行， 在索引数据之前可以先对数据做预处理操作， 不负责数据存储也不负责集群相关的事务。</p>
<h2><span id="协调节点">协调节点</span></h2><p>协调节点，是一种角色，而不是真实的Elasticsearch的节点，不能通过配置项来指定哪个节点为协调节点。集群中的任何节点，都可以充当协调节点的角色。当一个节点A收到用户的查询请求后，会把查询子句分发到其它的节点，然后合并各个节点返回的查询结果，最后返回一个完整的数据集给用户。在这个过程中，节点A扮演的就是协调节点的角色。</p>
<p>ES的一次请求非常类似于Map-Reduce操作。在ES中对应的也是两个阶段，称之为scatter-gather。客户端发出一个请求到集群的任意一个节点，这个节点就是所谓的协调节点，它会把请求转发给含有相关数据的节点(scatter阶段)，这些数据节点会在本地执行请求然后把结果返回给协调节点。协调节点将这些结果汇总(reduce)成一个单一的全局结果集(gather阶段) 。</p>
<h2><span id="部落节点">部落节点</span></h2><p>在多个集群之间充当联合客户端， 它是一个特殊的客户端 ， 可以连接多个集群，在所有连接的集群上执行搜索和其他操作。 部落节点从所有连接的集群中检索集群状态并将其合并成全局集群状态。 掌握这一信息，就可以对所有集群中的节点执行读写操作，就好像它们是本地的。 请注意，部落节点需要能够连接到每个配置的集群中的每个单个节点。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch Mapping 参数</title>
    <url>/7a9a148e/</url>
    <content><![CDATA[<blockquote>
<p>本文基于 Elasticsearch 6.6.0</p>
</blockquote>
<h2><span id="analyzer">analyzer</span></h2><p>指定分词器(分析器更合理)，对索引和查询都有效。如下，指定ik分词的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="normalizer">normalizer</span></h2><p>normalizer用于解析前的标准化配置，比如把所有的字符转化为小写等。例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;normalizer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;my_normalizer&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">          <span class="string">&quot;char_filter&quot;</span>: [],</span><br><span class="line">          <span class="string">&quot;filter&quot;</span>: [<span class="string">&quot;lowercase&quot;</span>, <span class="string">&quot;asciifolding&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;foo&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;normalizer&quot;</span>: <span class="string">&quot;my_normalizer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;BÀR&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;baz&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST index/_refresh</span><br><span class="line"></span><br><span class="line">GET index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;BAR&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BÀR经过normalizer过滤以后转换为bar，文档1和文档2会被搜索到。</p>
<h2><span id="boost">boost</span></h2><p>boost字段用于设置字段的权重，比如，关键字出现在title字段的权重是出现在content字段中权重的2倍，设置mapping如下，其中content字段的默认权重是1.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;boost&quot;</span>: 2 </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，在查询时指定权重也是一样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;quick brown fox&quot;</span>,</span><br><span class="line">                <span class="string">&quot;boost&quot;</span>: 2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐在查询时指定boost，第一中在mapping中写死，如果不重新索引文档，权重无法修改，使用查询可以实现同样的效果。</p>
<h2><span id="coerce">coerce</span></h2><p>coerce属性用于清除脏数据，coerce的默认值是true。整型数字5有可能会被写成字符串“5”或者浮点数5.0.coerce属性可以用来清除脏数据：</p>
<ul>
<li>字符串会被强制转换为整数</li>
<li>浮点数被强制转换为整数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;number_one&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;number_two&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">          <span class="string">&quot;coerce&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;number_one&quot;</span>: <span class="string">&quot;10&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;number_two&quot;</span>: <span class="string">&quot;10&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapping中指定number_one字段是integer类型，虽然插入的数据类型是String，但依然可以插入成功。number_two字段关闭了coerce，因此插入失败。</p>
<h2><span id="copy_to">copy_to</span></h2><p>copy_to属性用于配置自定义的_all字段。换言之，就是多个字段可以合并成一个超级字段。比如，first_name和last_name可以合并为full_name字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;first_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;last_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;first_name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last_name&quot;</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;full_name&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="doc_values">doc_values</span></h2><p>doc_values是为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;status_code&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>:       <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;session_id&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>:       <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;doc_values&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注:text类型不支持doc_values。</p>
<h2><span id="dynamic">dynamic</span></h2><p>dynamic属性用于检测新发现的字段，有三个取值：</p>
<ul>
<li>true:新发现的字段添加到映射中。（默认）</li>
<li>flase:新检测的字段被忽略。必须显式添加新字段。</li>
<li>strict:如果检测到新字段，就会引发异常并拒绝文档。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;social_networks&quot;</span>: &#123; </span><br><span class="line">              <span class="string">&quot;dynamic&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="string">&quot;properties&quot;</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：取值如果为strict (非布尔值)要加引号。</p>
<p>文档中有一个之前没有出现过的字段被添加到ELasticsearch之后，文档的type mapping中会自动添加一个新的字段。这个可以通过dynamic属性去控制，dynamic属性为false会忽略新增的字段、dynamic属性为strict会抛出异常。如果dynamic为true的话，ELasticsearch会自动根据字段的值推测出来类型进而确定mapping：</p>
<table>
<thead>
<tr>
<th>JSON格式的数据</th>
<th>自动推测的字段类型</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>没有字段被添加</td>
</tr>
<tr>
<td>true or false</td>
<td>boolean类型</td>
</tr>
<tr>
<td>floating类型数字</td>
<td>floating类型</td>
</tr>
<tr>
<td>integer</td>
<td>long类型</td>
</tr>
<tr>
<td>JSON对象</td>
<td>object类型</td>
</tr>
<tr>
<td>数组</td>
<td>由数组中第一个非空值决定</td>
</tr>
<tr>
<td>string</td>
<td>有可能是date类型（开启日期检测)、double或long类型、text类型、keyword类型</td>
</tr>
</tbody></table>
<p>日期检测默认是检测符合以下日期格式的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&quot;strict_date_optional_time&quot;</span>,<span class="string">&quot;yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create_date&quot;</span>: <span class="string">&quot;2015/09/02&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_mapping</span><br></pre></td></tr></table></figure>

<p>mapping 如下，可以看到create_date为date类型：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;my_index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;my_type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;create_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>关闭日期检测：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;date_detection&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create&quot;</span>: <span class="string">&quot;2015/09/02&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次查看mapping，create字段已不再是date类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET my_index/_mapping</span><br><span class="line">返回结果：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;my_index&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;date_detection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;create&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="string">&quot;ignore_above&quot;</span>: 256</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义日期检测的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic_date_formats&quot;</span>: [<span class="string">&quot;MM/dd/yyyy&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create_date&quot;</span>: <span class="string">&quot;09/25/2015&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启数字类型自动检测：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;numeric_detection&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;my_float&quot;</span>:   <span class="string">&quot;1.0&quot;</span>, </span><br><span class="line">  <span class="string">&quot;my_integer&quot;</span>: <span class="string">&quot;1&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="enabled">enabled</span></h2><p>ELasticseaech默认会索引所有的字段，enabled设为false的字段，es会跳过字段内容，该字段只能从_source中获取，但是不可搜。而且字段可以是任意类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;session&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;user_id&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:  <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;last_updated&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;session_data&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/session/session_1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;kimchy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;session_data&quot;</span>: &#123; </span><br><span class="line">    <span class="string">&quot;arbitrary_object&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;some_array&quot;</span>: [ <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, &#123; <span class="string">&quot;baz&quot;</span>: 2 &#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;last_updated&quot;</span>: <span class="string">&quot;2015-12-06T18:20:22&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/session/session_2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;jpountz&quot;</span>,</span><br><span class="line">  <span class="string">&quot;session_data&quot;</span>: <span class="string">&quot;none&quot;</span>, </span><br><span class="line">  <span class="string">&quot;last_updated&quot;</span>: <span class="string">&quot;2015-12-06T18:22:13&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="fielddata">fielddata</span></h2><p>搜索要解决的问题是“包含查询关键词的文档有哪些？”，聚合恰恰相反，聚合要解决的问题是“文档包含哪些词项”，大多数字段再索引时生成doc_values，但是text字段不支持doc_values。</p>
<p>取而代之，text字段在查询时会生成一个fielddata的数据结构，fielddata在字段首次被聚合、排序、或者使用脚本的时候生成。ELasticsearch通过读取磁盘上的倒排记录表重新生成文档词项关系，最后在Java堆内存中排序。</p>
<p>text字段的fielddata属性默认是关闭的，开启fielddata非常消耗内存。在你开启text字段以前，想清楚为什么要在text类型的字段上做聚合、排序操作。大多数情况下这么做是没有意义的。</p>
<p>“New York”会被分析成“new”和“york”，在text类型上聚合会分成“new”和“york”2个桶，也许你需要的是一个“New York”。这是可以加一个不分词的keyword字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;my_field&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;keyword&quot;</span>: &#123; </span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的mapping中实现了通过my_field字段做全文搜索，my_field.keyword做聚合、排序和使用脚本。</p>
<h2><span id="format">format</span></h2><p>format属性主要用于格式化日期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:   <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多内置的日期格式：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html</a></p>
<h2><span id="ignore_above">ignore_above</span></h2><p>ignore_above用于指定字段索引和存储的长度最大值，超过最大值的会被忽略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignore_above&quot;</span>: 15</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Syntax error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Syntax error with some long stacktrace&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 0, </span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;messages&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;message&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapping中指定了ignore_above字段的最大长度为15，第一个文档的字段长小于15，因此索引成功，第二个超过15，因此不索引，返回结果只有”Syntax error”,结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;messages&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2><span id="ignore_malformed">ignore_malformed</span></h2><p>ignore_malformed可以忽略不规则数据，对于login字段，有人可能填写的是date类型，也有人填写的是邮件格式。给一个字段索引不合适的数据类型发生异常，导致整个文档索引失败。如果ignore_malformed参数设为true，异常会被忽略，出异常的字段不会被索引，其它字段正常索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;number_one&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignore_malformed&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;number_two&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>:       <span class="string">&quot;Some text value&quot;</span>,</span><br><span class="line">  <span class="string">&quot;number_one&quot;</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>:       <span class="string">&quot;Some text value&quot;</span>,</span><br><span class="line">  <span class="string">&quot;number_two&quot;</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中number_one接受integer类型，ignore_malformed属性设为true，因此文档一种number_one字段虽然是字符串但依然能写入成功；number_two接受integer类型，默认ignore_malformed属性为false，因此写入失败。</p>
<h2><span id="include_in_all">include_in_all</span></h2><p>include_in_all属性用于指定字段是否包含在_all字段里面，默认开启，除索引时index属性为no。<br>例子如下，title和content字段包含在_all字段里，date不包含。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>include_in_all也可用于字段级别，如下my_type下的所有字段都排除在_all字段之外，author.first_name 和author.last_name 包含在in _all中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>:          &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;first_name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;,</span><br><span class="line">            <span class="string">&quot;last_name&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;editor&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;first_name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span> &#125;, </span><br><span class="line">            <span class="string">&quot;last_name&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;include_in_all&quot;</span>: <span class="literal">true</span> &#125; </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="index">index</span></h2><p>index属性指定字段是否索引，不索引也就不可搜索，取值可以为true或者false。</p>
<h2><span id="index_options">index_options</span></h2><p>index_options控制索引时存储哪些信息到倒排索引中，接受以下配置：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>docs</td>
<td>只存储文档编号</td>
</tr>
<tr>
<td>freqs</td>
<td>存储文档编号和词项频率</td>
</tr>
<tr>
<td>positions</td>
<td>文档编号、词项频率、词项的位置被存储，偏移位置可用于临近搜索和短语查询</td>
</tr>
<tr>
<td>offsets</td>
<td>文档编号、词项频率、词项的位置、词项开始和结束的字符位置都被存储，offsets设为true会使用Postings highlighter</td>
</tr>
</tbody></table>
<h2><span id="fields">fields</span></h2><p>fields可以让同一文本有多种不同的索引方式，比如一个String类型的字段，可以使用text类型做全文检索，使用keyword类型做聚合和排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;city&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: &#123; </span><br><span class="line">              <span class="string">&quot;type&quot;</span>:  <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;city&quot;</span>: <span class="string">&quot;York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;city&quot;</span>: <span class="string">&quot;york&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;city.raw&quot;</span>: <span class="string">&quot;asc&quot;</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Cities&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;city.raw&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="norms">norms</span></h2><p>norms参数用于标准化文档，以便查询时计算文档的相关性。norms虽然对评分有用，但是会消耗较多的磁盘空间，如果不需要对某个字段进行评分，最好不要开启norms。</p>
<h2><span id="null_value">null_value</span></h2><p>值为null的字段不索引也不可以搜索，null_value参数可以让值为null的字段显式的可索引、可搜索。例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;status_code&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:       <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;null_value&quot;</span>: <span class="string">&quot;NULL&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;status_code&quot;</span>: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;status_code&quot;</span>: [] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NULL&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档1可以被搜索到，因为status_code的值为null，文档2不可以被搜索到，因为status_code为空数组，但不是null。</p>
<h2><span id="position_increment_gap">position_increment_gap</span></h2><p>为了支持近似或者短语查询，text字段被解析的时候会考虑此项的位置信息。举例，一个字段的值为数组类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;names&quot;: [ &quot;John Abraham&quot;, &quot;Lincoln Smith&quot;]</span><br></pre></td></tr></table></figure>

<p>为了区别第一个字段和第二个字段，Abraham和Lincoln在索引中有一个间距，默认是100。例子如下，这是查询”Abraham Lincoln”是查不到的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/groups/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;names&quot;</span>: [ <span class="string">&quot;John Abraham&quot;</span>, <span class="string">&quot;Lincoln Smith&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/groups/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;names&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Abraham Lincoln&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定间距大于100可以查询到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET my_index/groups/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;names&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Abraham Lincoln&quot;</span>,</span><br><span class="line">                <span class="string">&quot;slop&quot;</span>: 101 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mapping中通过position_increment_gap参数指定间距：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;groups&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;names&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;position_increment_gap&quot;</span>: 0 </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="properties">properties</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;manager&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;employees&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;nested&quot;</span>,</span><br><span class="line">          <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的文档结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;region&quot;</span>: <span class="string">&quot;US&quot;</span>,</span><br><span class="line">  <span class="string">&quot;manager&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice White&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: 30</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;employees&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: 34</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Peter Brown&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: 26</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以对manager.name、manager.age做搜索、聚合等操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;manager.name&quot;: &quot;Alice White&quot; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;Employees&quot;: &#123;</span><br><span class="line">      &quot;nested&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;employees&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;Employee Ages&quot;: &#123;</span><br><span class="line">          &quot;histogram&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;employees.age&quot;, </span><br><span class="line">            &quot;interval&quot;: 5</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="search_analyzer">search_analyzer</span></h2><p>大多数情况下索引和搜索的时候应该指定相同的分析器，确保query解析以后和索引中的词项一致。但是有时候也需要指定不同的分析器，例如使用edge_ngram过滤器实现自动补全。</p>
<p>默认情况下查询会使用analyzer属性指定的分析器，但也可以被search_analyzer覆盖。例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;autocomplete_filter&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;edge_ngram&quot;</span>,</span><br><span class="line">          <span class="string">&quot;min_gram&quot;</span>: 1,</span><br><span class="line">          <span class="string">&quot;max_gram&quot;</span>: 20</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;autocomplete&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">          <span class="string">&quot;tokenizer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">          <span class="string">&quot;filter&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">            <span class="string">&quot;autocomplete_filter&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;autocomplete&quot;</span>, </span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Quick Brown Fox&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Quick Br&quot;</span>, </span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="similarity">similarity</span></h2><ul>
<li>BM25 ：ES和Lucene默认的评分模型</li>
<li>classic ：TF/IDF评分</li>
<li>boolean：布尔模型评分<br>例子</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;default_field&quot;</span>: &#123; </span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;classic_field&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;similarity&quot;</span>: <span class="string">&quot;classic&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;boolean_sim_field&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;similarity&quot;</span>: <span class="string">&quot;boolean&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default_field自动使用BM25评分模型，classic_field使用TF/IDF经典评分模型，boolean_sim_field使用布尔评分模型。</p>
<h2><span id="store">store</span></h2><p>默认情况下，自动是被索引的也可以搜索，但是不存储，这也没关系，因为_source字段里面保存了一份原始文档。在某些情况下，store参数有意义，比如一个文档里面有title、date和超大的content字段，如果只想获取title和date，可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;store&quot;</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">          <span class="string">&quot;store&quot;</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>:   <span class="string">&quot;Some short title&quot;</span>,</span><br><span class="line">  <span class="string">&quot;date&quot;</span>:    <span class="string">&quot;2015-01-01&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;A very long content field...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;stored_fields&quot;</span>: [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;date&quot;</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>: 1,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;date&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;2015-01-01T00:00:00.000Z&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;Some short title&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stored fields返回的总是数组，如果想返回原始字段，还是要从_source中取。</p>
<h2><span id="term_vector">term_vector</span></h2><p>词向量包含了文本被解析以后的以下信息：</p>
<ul>
<li>词项集合</li>
<li>词项位置</li>
<li>词项的起始字符映射到原始文档中的位置。</li>
</ul>
<p>term_vector参数有以下取值：</p>
<table>
<thead>
<tr>
<th>参数取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>默认值，不存储词向量</td>
</tr>
<tr>
<td>yes</td>
<td>只存储词项集合</td>
</tr>
<tr>
<td>with_positions</td>
<td>存储词项和词项位置</td>
</tr>
<tr>
<td>with_offsets</td>
<td>词项和字符偏移位置</td>
</tr>
<tr>
<td>with_positions_offsets</td>
<td>存储词项、词项位置、字符偏移位置</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:        <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;term_vector&quot;</span>: <span class="string">&quot;with_positions_offsets&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Quick brown fox&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;brown fox&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="动态mapping-_default_">动态Mapping <code>_default_</code></span></h2><p>在mapping中使用<em>default</em>字段，那么其它字段会自动继承<em>default</em>中的设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;_default_&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: &#123;&#125;, </span><br><span class="line">    <span class="string">&quot;blogpost&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;_all&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 mapping 中，<code>_default_</code> 中关闭了 <code>_all</code> 字段，<code>user</code>会继承 <code>_default_</code> 中的配置，因此 <code>user</code> 中的 <code>_all</code> 字段也是关闭的，<code>blogpost</code> 中开启 <code>_all</code>，覆盖了 <code>_default</code> 的默认配置。</p>
<p>当<em>default</em>被更新以后，只会对后面新加的文档产生作用。</p>
<h2><span id="dynamic_templates">dynamic_templates</span></h2><p>动态模板可以根据字段名称设置mapping，如下对于string类型的字段，设置mapping为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;mapping&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但是匹配字段名称为long_<em>格式的，不匹配</em>_text格式的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;longs_as_strings&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;match&quot;</span>:   <span class="string">&quot;long_*&quot;</span>,</span><br><span class="line">            <span class="string">&quot;unmatch&quot;</span>: <span class="string">&quot;*_text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;long_num&quot;</span>: <span class="string">&quot;5&quot;</span>, </span><br><span class="line">  <span class="string">&quot;long_text&quot;</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<p>写入文档以后，long_num字段为long类型，long_text 仍为string类型。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Gerrit + apache 安装</title>
    <url>/2eb2e06d/</url>
    <content><![CDATA[<p>使用gerrit自带的数据库h2, 验证方式为HTTP, SMTP 服务器未配置</p>
<h6><span id="git-安装">git 安装</span></h6><p>可直接从yum 源安装</p>
<h6><span id="gerrit-安装">gerrit 安装</span></h6><p>先添加gerrit 用户. gerrit 从2.10开始, 换成了新版界面. 几乎国内所有的镜像都会下载失败, 需要翻墙下载. 下载完成后, 初始化命令为: <code>java -jar gerrrit-war init -d /home/gerrit/repository</code></p>
<p>初始化启动时, “Authentication method” 设为”http” ,其他默认 “Listen on port [8080]“ 可用默认, 如端口被占用, 初始化后也可在配置文件修改</p>
<h6><span id="apache-安装">apache 安装</span></h6><p>直接从yum源安装 apache名字为httpd, 服务名也是httpd. 服务启动后, 默认以apache用户运行. 如需访问其他用户的文件, 如<code>/home/gerrit/repository/htpasswd</code>, 需要确保apache 用户有足够的权限</p>
<h6><span id="配置-apache">配置 apache</span></h6><p>修改 apache 的conf 文件, 一般路径为<code>/etc/httpd/conf/httpd.conf</code> windows 下的配置文件路径为 <code>INSTALL_DIR/conf/httpd.conf</code></p>
<p>去掉下面几行的注释</p>
<pre><code>LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_connect_module modules/mod_proxy_connect.so
LoadModule proxy_http_module modules/mod_proxy_http.so
LoadModule proxy_ftp_module modules/mod_proxy_ftp.so
LoadModule negotiation_module modules/mod_negotiation.so</code></pre><p>在最后追加下面配置</p>
<pre><code>&lt;VirtualHost *:8080&gt;  
  ServerName v3server
  ProxyRequests Off  
  ProxyVia Off  
  ProxyPreserveHost On  


  &lt;Proxy *:8080&gt;  
        Order deny,allow  
        Allow from all  
  &lt;/Proxy&gt;  


    &lt;Location /login/&gt;
      AuthType Basic
      AuthName &quot;Gerrit Code Review&quot;
      Require valid-user
     AuthUserFile D:/git/htpasswd
    &lt;/Location&gt;


  ProxyPass / http://10.14.132.179:9080/
  ProxyPassReverse / http://10.14.132.179:9080/
&lt;/VirtualHost&gt;</code></pre><p>如端口被占用, 修改conf文件的”Listen 8080” 字段, 换成其他的端口 查看某个端口是否被占用 : <code>netstat -lnp | grep 8080</code> <code>ProxyPass</code> 和 <code>proxyPassReverse</code> 的端口需与gerrit的conf文件里端口一致</p>
<h6><span id="配置-gerrit">配置 gerrit</span></h6><p>修改<code>GERRIT_DIR/etc/gerrit.config</code> 文件</p>
<pre><code>[gerrit]
basePath = git
canonicalWebUrl = http://10.14.132.179:9080/
[database]
type = H2
database = db/ReviewDB
[auth]
type = HTTP
logoutUrl = http://aa:aa@10.14.132.179:8080/
[sendemail]
smtpServer = smtp.163.com
smtpUser = useremail@163.com
  smtpPass = userpass
  from = useremail@163.com
[container]
user = admin
javaHome = C:\\Program Files\\Java\\jdk1.6.0_27\\jre
[sshd]
listenAddress = *:29418
[httpd]
listenUrl = http://10.14.132.179:9080/
[cache]
directory = cache</code></pre><p>需要修改的内容: - canonicalWebUrl - auth/type</p>
<p>需要注意: canonicalWebUrl 和 listenAddress 不是8080. apache 的端口和 gerrit 的端口是不同的, 用户访问地址为 apache 的地址</p>
<h6><span id="启动-gerrit">启动 gerrit</span></h6><p><code>GERRIT_DIR/bin/gerrit.sh start</code></p>
<h6><span id="启动-apache">启动 apache</span></h6><p><code>service httpd start</code></p>
<h6><span id="添加账号和密码">添加账号和密码</span></h6><p><code>htpasswd -cm /home/gerrit/repository/htpasswd USER_NAME</code></p>
<ul>
<li>htpasswd 为apache 的命令工具</li>
<li>参数c 意为新建文件, 即 <code>/home/gerrit/repository/htpasswd</code> 文件不存在时, 新建名为htpasswd的文件</li>
<li>参数m 为使用md5 加密</li>
<li>当htpasswd文件存在时, 可以使用<code>htpasswd -m /PATH_TO_HTPASSWD USER_NAME</code> 添加账号</li>
<li>保存账号密码信息的文件(htpasswd), 名字为自定义的, 但需要与apache 的conf 配置文件里 <code>AuthUserFile</code> 一致</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 1.18 的工作区模式</title>
    <url>/a51740e5/</url>
    <content><![CDATA[<p>当一个项目越来越复杂的时候，一定会拆分为多个模块，以便进行代码复用和更好的多人协作开发。</p>
<p>假设我们已经有了两个模块 <code>xxx.org/util</code> 和 <code>xxx.org/product</code> ，模块<code>xxx.org/product</code>依赖 <code>xxx.org/util</code> 。</p>
<p>现在有一个需求，需要同时修改这两个模块，以便让<code>xxx.org/util</code>新增的方法给模块<code>xxx.org/product</code>使用。</p>
<p>但是当同事A在模块<code>xxx.org/util</code>中增加新的方法后，要么推送到VCS中，让负责模块<code>xxx.org/product</code>的同事B使用，这是发布的场景。</p>
<p>如果模块<code>xxx.org/util</code>没有发布呢？那么就只能通过go.mod中的replace指令进行替换，把对模块<code>xxx.org/util</code>的引用，换成本地的未发布的版本，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replace xxx.org/util =&gt; /Users/xxx/<span class="keyword">go</span>/demo/util</span><br></pre></td></tr></table></figure>




<p>相信我们都遇到过以上两种情形，这两种情形都有相应的弊端，比如：</p>
<ol>
<li>把没有调试、没有测试的代码发布了，会影响其他正常构建</li>
<li>replace的时候，忘记改回来，提交到VCS中了，影响了其他人使用</li>
</ol>
<p>为了解决以上问题，Go 团队提出了工作区的概念，并且在Go 1.18 中发布。</p>
<p>Go 工作区，是你的工作区，它和多人协作、VCS等无关。说白了它就是个本地目录，通过go.work文件来管理多个go.mod模块。</p>
<p>要创建一个Go 工作区非常简单，通过如下命令即可:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mkdir workspace</span><br><span class="line">cd workspace</span><br><span class="line"><span class="keyword">go</span> work init /Users/xxx/<span class="keyword">go</span>/demo/util /Users/xxx/<span class="keyword">go</span>/demo/product</span><br></pre></td></tr></table></figure>




<p>在以上示例中，workspace是我创建的一个工作区,可以在你的电脑的任何地方,名字也可以自取。</p>
<p>然后<code>go work init</code> 后是两个go.mod的绝对路径，用空格分开，当然你也可以用相对路径。</p>
<p>运行以上代码后,就会在workspace目录下生成一个go.work文件，它的内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">  /Users/xxx/<span class="keyword">go</span>/demo/product</span><br><span class="line">  /Users/xxx/<span class="keyword">go</span>/demo/util</span><br><span class="line">)</span><br></pre></td></tr></table></figure>




<p><code>use</code>是<code>go.work</code>文件的一个指令，用于管理包含的go.mod模块。</p>
<p>除了<code>use</code>指令，go.work还有<code>replace</code>指令，它和go.mod的replace很像，它用于把Go 工作区间管理的go.mod全部替换为指定的路径，并且它的优先级要比go.mod的replace要高。</p>
<p>现在，我们用到的这两个模块都在同一个工作区了，那么就不需要再修改模块xxx/product的go.mod replace 指令完成本地的依赖了。</p>
<p>这时候，在工作区 workspce目录下，运行如下命令，即可进行验证。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  workspace <span class="keyword">go</span> run xxx.org/product</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>




<p>因为都在一个工作区，go可以帮你找到模块xxx.org/product所依赖的xxx.org/util模块。</p>
<p>如果你只是切换到product目录下运行以上命令，只会提示你：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  product <span class="keyword">go</span> run main.<span class="keyword">go</span> </span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">8</span>: no required module provides <span class="keyword">package</span> xxx.org/util; to add it:</span><br><span class="line">  <span class="keyword">go</span> get xxx.org/util</span><br></pre></td></tr></table></figure>




<p>不止我上面这种依赖上游模块的例子可以使用Go工作区，如果你一个代码库中有多个模块也是可以用的，只需要把他们都加入到Go 工作区即可。</p>
<p>go work命令有一个use可以把本地目录的模块加入工作区，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> work use [path-to-your-module]</span><br></pre></td></tr></table></figure>




<p>方括号中的路径，可以换成你自己电脑上的本地模块路径。</p>
<p>当然你也可以直接修改go.work文件，效果是一样的,这里不再举例，你可以自己试试。</p>
<p>go.work本质上是一种本地化的解决办法，因为go.mod都是放在VCS中的，和项目息息相关，所以我们很少去修改它来达到一些Hack的操作。</p>
<p>现在有了go.work就好办多了，因为它就是一个本地的东西，不在VCS中，想怎么改就怎么改，又不</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 发送邮件</title>
    <url>/c296dcc8/</url>
    <content><![CDATA[<p>需要引入 smtp包 mail.go</p>
<pre><code>package main

import (
    &quot;bytes&quot;
    &quot;encoding/base64&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/smtp&quot;
    &quot;strings&quot;
)

const const_smtp_server = &quot;server-ip:port&quot;

//const const_email_content_type = &quot;Content-Type: text/plain; charset=UTF-8&quot;
const const_email_content_type = &quot;Content-Type: text/html; charset=UTF-8&quot;
const const_boundary = &quot;THIS_IS_THE_BOUNDARY_FOR_EMAIL_BY_LXB&quot;

func SendEmail(sender string, receivers []string, subject string, content string, attach_files []string) error &#123;

    var buf bytes.Buffer
    buf.WriteString(&quot;To: &quot;)
    buf.WriteString(strings.Join(receivers, &quot;,&quot;))
    buf.WriteString(&quot;\r\nFrom: &quot;)
    //nickname := strings.Split(sender,&quot;@&quot;)[0]
    //buf.WriteString(nickname)
    buf.WriteString(&quot;&lt;&quot;)
    buf.WriteString(sender)
    buf.WriteString(&quot;&gt;&quot;)
    buf.WriteString(&quot;\r\nSubject: &quot;)
    buf.WriteString(subject)
    buf.WriteString(&quot;\r\nContent-Type: multipart/mixed; boundary=&quot;)
    buf.WriteString(const_boundary)
    buf.WriteString(&quot;\r\n--&quot;)
    buf.WriteString(const_boundary)
    buf.WriteString(&quot;\r\n&quot;)
    buf.WriteString(const_email_content_type)
    buf.WriteString(&quot;\r\n\r\n&quot;)
    buf.WriteString(content)
    buf.WriteString(&quot;\r\n\r\n--&quot;)
    buf.WriteString(const_boundary)
    buf.WriteString(&quot;\r\n&quot;)

    for _, filepath := range attach_files &#123;
        // 第一个附件
        filedepts := strings.Split(filepath, &quot;/&quot;)
        filename := filedepts[len(filedepts)-1]
        buf.WriteString(&quot;Content-Type: application/octet-stream\r\n&quot;)
        buf.WriteString(&quot;Content-Description: 附件\r\n&quot;)
        buf.WriteString(&quot;Content-Transfer-Encoding: base64\r\n&quot;)
        buf.WriteString(&quot;Content-Disposition: attachment; filename=\&quot;&quot; + filename + &quot;\&quot;\r\n\r\n&quot;)
        //读取并编码文件内容
        attaData, err := ioutil.ReadFile(filepath)
        if err != nil &#123;
            print(err)
            return err
        &#125;
        b := make([]byte, base64.StdEncoding.EncodedLen(len(attaData)))
        base64.StdEncoding.Encode(b, attaData)
        buf.Write(b)
        buf.WriteString(fmt.Sprintf(&quot;\r\n--%s\r\n&quot;, const_boundary))
    &#125;

    fmt.Println(buf.String())
    err := smtp.SendMail(const_smtp_server, nil, sender, receivers, buf.Bytes())

    fmt.Println(&quot;send mail err:&quot;, err)
    return err
&#125;</code></pre><p>main.go</p>
<pre><code>package main

import (
    //&quot;flag&quot;
    //&quot;fmt&quot;
    &quot;os&quot;
)

func main() &#123;

    //var task string

    //flag.StringVar(&amp;task, &quot;t&quot;, &quot;&quot;, &quot;task id&quot;)
    //flag.Parse()

    //if task == &quot;&quot; &#123;
    //  fmt.Println(&quot;task is required.&quot;)
    //  flag.Usage()
    //  os.Exit(2)
    //&#125;

    testStr := os.Args[1]

    cont := &quot;&lt;html&gt;&lt;body&gt;&lt;p align=\&quot;center\&quot;&gt;表: 1&lt;/p&gt;&lt;table align=\&quot;center\&quot; border=\&quot;1\&quot; cellpadding=\&quot;10\&quot;&gt;&lt;tr&gt;&lt;td&gt;任务ID&lt;/td&gt;&lt;td&gt;列1&lt;/td&gt;&lt;td&gt;列2&lt;/td&gt;&lt;td&gt;列3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;td&gt;&quot; + testStr + &quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;

    sender := &quot;&quot;
    rcvs := []string&#123;&#125;
    sbj := &quot;test email&quot;
    //  cont := &quot;This is content&quot;
    file := []string&#123;&#125;

    SendEmail(sender, rcvs, sbj, cont, file)

&#125;</code></pre>]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 环境变量</title>
    <url>/2ddd6919/</url>
    <content><![CDATA[<h5><span id="goroot">GOROOT</span></h5><p>，在Linux系统中一般安装在<code>/usr/go</code>或者<code>/usr/local/go</code>，这样Linux系统中的PATH变量一般都包含了这两个目录，所以就可以直接运行go命令，而Windows系统中一般默认安装在<code>C:\go</code>中</p>
<p>自定义 GO安装路径, 可修改环境变量配置文件 <code>export GOROOT=$HOME/go</code></p>
<h5><span id="gopath">GOPATH</span></h5><p>go的工作目录，这个目录指定了需要从哪个地方寻找GO的包、可执行程序等，这个目录可以是多个目录表示，go编译或者运行时会从这个环境变量中去对应查找，工作目录或者如官方文档中说的workspace 在这个目录进行编译、链接最后生成所需要的库、可执行文件，我们对比C程序的目录，也许更能方便理解，一般在C的工程项目中包含三个文件，一个include目录、src目录、Makefile文件。 <code>include</code>目录存放了所有的头文件可供其他地方包含 <code>src</code>目录则存放所有的.c后缀的源文件 <code>Makefile</code>则是该项目的编译，在编译整个工程时需要执行make命令，这里就发现GO就不需要去写什么Makefile了，执行<code>go build xxx.go</code>命令就可以编译</p>
<p>GOPATH 下的目录下, 一般有三个 目录 <code>bin</code> <code>pkg</code> <code>src</code> <code>bin</code>目录包含了可执行程序，注意是可执行的，不需要解释执行。 <code>pkg</code>目录包含了使用的包或者说库。 <code>src</code>里面包含了go的代码源文件，其中仍按包的不同进行组织</p>
<p>包名一般和目录名相同, 编译时, 可以在某个包下, 执行<code>go build</code> , 也可以在包上层直接编译包名<code>go build pkg_name</code></p>
<p><code>go install &lt;pkg_name/exe_name/all&gt;</code> 先编译后把编译生成的可执行文件复制到<code>bin</code> 下</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 教程</title>
    <url>/be2cf138/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">全文搜索</a>属于最常见的需求，开源的 <a href="https://www.elastic.co/">Elasticsearch</a> （以下简称 Elastic）是目前全文搜索引擎的首选。</p>
<p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403031501235.png" alt></p>
<p>Elastic 的底层是开源库 <a href="https://lucene.apache.org/">Lucene</a>。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</p>
<p>本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。</p>
<h2><span id="一-安装">一、安装</span></h2><p>Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8">这篇文章</a>，注意要保证环境变量<code>JAVA_HOME</code>正确设置。</p>
<p>安装完 Java，就可以跟着<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html">官方文档</a>安装 Elastic。直接下载压缩包比较简单。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip </span><br><span class="line">$ unzip elasticsearch-5.5.1.zip </span><br><span class="line">$ <span class="built_in">cd</span> elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接着，进入解压后的目录，运行下面的命令，启动 Elastic。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果这时<a href="https://github.com/spujadas/elk-docker/issues/92">报错</a>“max virtual memory areas vm.max_map_count [65530] is too low”，要运行下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl localhost:9200 </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;atntrTf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cluster_name&quot;</span>:<span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cluster_uuid&quot;</span>:<span class="string">&quot;tf9250XhQ6ee4h7YI11anA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;number&quot;</span>:<span class="string">&quot;5.5.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build_hash&quot;</span>:<span class="string">&quot;19c13d0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build_date&quot;</span>:<span class="string">&quot;2017-07-18T20:44:24.823Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build_snapshot&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;lucene_version&quot;</span>:<span class="string">&quot;6.6.0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;tagline&quot;</span>:<span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。</p>
<p>按下 <code>Ctrl + C</code>，Elastic 就会停止运行。</p>
<p>默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的<code>config/elasticsearch.yml</code>文件，去掉<code>network.host</code>的注释，将它的值改成<code>0.0.0.0</code>，然后重新启动 Elastic。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，设成<code>0.0.0.0</code>让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。</p>
<p>通过 docker 启动一个单节点集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:6.7.2</span><br></pre></td></tr></table></figure>

<p>使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X &lt;METHOD&gt; http://localhost:9200/&lt;PATH&gt;?&lt;QUERY_STRING&gt; -d <span class="string">&#x27;&lt;BODY&gt;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2><span id="二-基本概念">二、基本概念</span></h2><h3><span id="20-抽象类比">2.0 抽象类比</span></h3><table>
<thead>
<tr>
<th>MySql</th>
<th>Es</th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>Index(Type)</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
</tr>
<tr>
<td>SQL</td>
<td>DSL</td>
</tr>
</tbody></table>
<h3><span id="21-node-与-cluster">2.1 Node 与 Cluster</span></h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例，所以并不能说一台机器就是一个 node，大多数情况下每个node运行在一个独立的环境或虚拟机上。</p>
<p>单个 Elastic 实例称为一个节点（node），一组节点构成一个集群（cluster），每个集群都有一个cluster name作为标识</p>
<h3><span id="22-index">2.2 Index</span></h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<p>下面的命令可以查看当前节点的所有 Index。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X GET <span class="string">&#x27;http://localhost:9200/_cat/indices?v&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Index 即一系列 documents 的集合。每个索引可以有多个type，不过7.0之后将会被废弃，略过。</p>
<h3><span id="23-document">2.3 Document</span></h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>
<p>Document 使用 JSON 格式表示，下面是一个例子。</p>
<blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h3><span id="24-type">2.4 Type</span></h3><p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<p>下面的命令可以列出每个 Index 所包含的 Type。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/_mapping?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>
<h3><span id="25-mappings映射">2.5 mappings(映射)</span></h3><p>映射, 就像数据库中的 schema ，描述了文档可能具有的字段或 属性 、每个字段的数据类型—比如 string, integer 或 date —以及Lucene是如何索引和存储这些字段的。</p>
<ul>
<li>字符串: string</li>
<li>整数: byte, short, integer, long</li>
<li>浮点数: float, double</li>
<li>布尔型: boolean</li>
<li>日期: date</li>
<li>keyword：存储数据时候，不会分词建立索引</li>
<li>text：存储数据时候，会自动分词，并生成索引</li>
</ul>
<h3><span id="26-shard分片">2.6 shard(分片)</span></h3><p>ES是分布式搜索引擎，每个索引有一个或多个分片，索引的数据被分配到各个分片上，相当于一桶水用了N个杯子装。分片有助于横向扩展，N个分片会被尽可能平均地（rebalance）分配在不同的节点上（例如你有2个节点，4个主分片(不考虑备份)，那么每个节点会分到2个分片，后来你增加了2个节点，那么你这4个节点上都会有1个分片，这个过程叫 relocation，ES感知后自动完成)。分片是独立的，对于一个 Search Request 的行为，每个分片都会执行这个  Request。</p>
<h3><span id="27-replica备份">2.7. replica(备份)</span></h3><p>可以理解为备份分片，相应地有 primary  shard（主分片)，主分片和备分片不会出现在同一个节点上（防止单点故障），默认情况下一个索引创建5个分片一个备份（即5primary+5replica=10个分片）。如果你只有一个节点，那么5个 replica 都无法分配（unassigned），此时cluster status会变成Yellow。</p>
<h3><span id="28-倒排索引">2.8 倒排索引</span></h3><p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p>
<h3><span id="29-analysis">2.9 analysis</span></h3><p>Document 中的数据是如何转变成倒排索引的，以及查询语句是如何转换成一个个词(Term)使高效率文本搜索变得可行，这种转换数据的过程就称为文本分析(analysis)。</p>
<p>elasticsearch会用某种算法(Tokenizer)对要建索引的文档进行分析，  从文档中提取出若干Token(词元)， 这些算法称为Tokenizer(分词器)， 这些Token会被进一步处理， 比如转成小写等，  这些进一步的处理算法被称为Filter(过滤器), 被处理后的结果被称为Term(词)，  文档中包含了几个这样的Term被称为Frequency(词频)。 引擎会建立Term和原文档的Inverted Index(倒排索引)，  这样就能根据Term很快到找到源文档了。<br> 文本分析(analysis)工作由analyzer(分析器)组件负责。analyzer由一个分词器(tokenizer)和0个或者多个过滤器(filter)组成,也可能会有0个或者多个字符映射器(character mappers)组成。<br> tokenizer用来把文本拆分成一个个的Token。Token包含了比较多的信息，比如Term在文本的中的位置及Term原始文本，以及Term的长度。文本经过tokenizer处理后的结果称为token stream。token stream其实就是一个个Token的顺序排列。token stream将等待着filter来处理。<br> filter链将用来处理Token Stream中的每一个token。这些处理方式包括删除Token, 改变Token，甚至添加新的Token。比如变小写，去掉里面的HTML标记， 这些处理的算法被称为Character Filter(字符过滤器)</p>
<h3><span id="210-es集群状态">2.10 ES集群状态：</span></h3><ul>
<li>Green：所有主分片和备份分片都准备就绪（分配成功），即使有一台机器挂了（假设一台机器一个实例），数据都不会丢失，但会变成Yellow状态</li>
<li>Yellow：所有主分片准备就绪，但存在至少一个主分片（假设是A）对应的备份分片没有就绪，此时集群属于警告状态，意味着集群高可用和容灾能力下降，如果刚好A所在的机器挂了，并且你只设置了一个备份（已处于未就绪状态），那么A的数据就会丢失（查询结果不完整），此时集群进入Red状态</li>
<li>Red：至少有一个主分片没有就绪（直接原因是找不到对应的备份分片成为新的主分片）,此时查询的结果会出现数据丢失（不完整）</li>
</ul>
<h3><span id="211-replica作用">2.11 replica作用：</span></h3><ul>
<li>容灾：primary分片丢失，replica分片就会被顶上去成为新的主分片，同时根据这个新的主分片创建新的replica，集群数据安然无恙;</li>
<li>提高查询性能：replica和primary分片的数据是相同的，所以对于一个query既可以查主分片也可以查备分片，在合适的范围内多个replica性能会更优（但要考虑资源占用也会提升[cpu/disk/heap]），另外index request只能发生在主分片上，replica不能执行index request。</li>
</ul>
<p>对于一个索引，除非重建索引否则不能调整分片的数目（主分片数, number_of_shards），但可以随时调整 replica 数(number_of_replicas)。</p>
<h2><span id="三-新建和删除-index">三、新建和删除 Index</span></h2><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫<code>weather</code>的 Index。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，我们发出 DELETE 请求，删除这个 Index。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="四-中文分词设置">四、中文分词设置</span></h2><p>首先，安装中文分词插件。这里使用的是 <a href="https://github.com/medcl/elasticsearch-analysis-ik/">ik</a>，也可以考虑其他插件（比如 <a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-smartcn.html">smartcn</a>）。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ ./bin/elasticsearch-plugin install <span class="attr">https</span>:<span class="comment">//github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。</p>
<p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p>
<p>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;mappings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;person&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;properties&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;user&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class="line"><span class="string">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class="line"><span class="string">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;title&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class="line"><span class="string">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class="line"><span class="string">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;desc&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;text&quot;,</span></span><br><span class="line"><span class="string">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span></span><br><span class="line"><span class="string">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，首先新建一个名称为<code>accounts</code>的 Index，里面有一个名称为<code>person</code>的 Type。<code>person</code>有三个字段。</p>
<blockquote>
<ul>
<li>user</li>
<li>title</li>
<li>desc</li>
</ul>
</blockquote>
<p>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。</p>
<p>Elastic 的分词器称为 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">analyzer</a>。我们对每个字段指定分词器。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>analyzer</code>是字段文本的分词器，<code>search_analyzer</code>是搜索词的分词器。<code>ik_max_word</code>分词器是插件<code>ik</code>提供的，可以对文本进行最大数量的分词。</p>
<h2><span id="五-数据操作">五、数据操作</span></h2><h3><span id="51-新增记录">5.1 新增记录</span></h3><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向<code>/accounts/person</code>发送请求，就可以新增一条人员记录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;user&quot;: &quot;张三&quot;,</span></span><br><span class="line"><span class="string">  &quot;title&quot;: &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">  &quot;desc&quot;: &quot;数据库管理&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">2</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">1</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果你仔细看，会发现请求路径是<code>/accounts/person/1</code>，最后的<code>1</code>是该条记录的 Id。它不一定是数字，任意字符串（比如<code>abc</code>）都可以。</p>
<p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST <span class="string">&#x27;localhost:9200/accounts/person&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;user&quot;: &quot;李四&quot;,</span></span><br><span class="line"><span class="string">  &quot;title&quot;: &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">  &quot;desc&quot;: &quot;系统管理&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，向<code>/accounts/person</code>发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，<code>_id</code>字段就是一个随机字符串。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;AV3qGfrC6jMbsbXb6k1p&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">2</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">1</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，如果没有先创建 Index（这个例子是<code>accounts</code>），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p>
<h3><span id="52-查看记录">5.2 查看记录</span></h3><p>向<code>/Index/Type/Id</code>发出 GET 请求，就可以查看这条记录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/1?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码请求查看<code>/accounts/person/1</code>这条记录，URL 的参数<code>pretty=true</code>表示以易读的格式返回。</p>
<p>返回的数据中，<code>found</code>字段表示查询成功，<code>_source</code>字段返回原始记录。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">    <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果 Id 不正确，就查不到数据，<code>found</code>字段就是<code>false</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/weather/beijing/abc?pretty=true&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;found&quot;</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="53-删除记录">5.3 删除记录</span></h3><p>删除记录就是发出 DELETE 请求。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里先不要删除这条记录，后面还要用到。</p>
<h3><span id="54-更新记录">5.4 更新记录</span></h3><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;user&quot; : &quot;张三&quot;,</span></span><br><span class="line"><span class="string">    &quot;title&quot; : &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:2,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:2,<span class="string">&quot;successful&quot;</span>:1,<span class="string">&quot;failed&quot;</span>:0&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;_version&quot;</span> : 2,</span><br><span class="line"><span class="string">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,</span><br><span class="line"><span class="string">&quot;created&quot;</span> : <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，记录的 Id 没变，但是版本（version）从<code>1</code>变成<code>2</code>，操作类型（result）从<code>created</code>变成<code>updated</code>，<code>created</code>字段变成<code>false</code>，因为这次不是新建记录。</p>
<h3><span id="55-操作索引">5.5 操作索引</span></h3><p>新建索引时可以指定设置或者映射，也可以不指定自动生成</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ PUT foo_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;number_of_shards&quot;</span> :   1,   <span class="comment">#每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。</span></span><br><span class="line">        <span class="string">&quot;number_of_replicas&quot;</span> : 0    <span class="comment">#每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。</span></span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type_one&quot;</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        <span class="string">&quot;type_two&quot;</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改索引设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ PUT foo_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改索引映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ PUT foo_index/_mappings/_doc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除索引</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ DELETE foo_index</span><br></pre></td></tr></table></figure>



<h3><span id="56-操作文档">5.6 操作文档</span></h3><p>使用put新建文档项指定id为1</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ PUT foo_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;demo 1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;demo foo bar&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用post可以不指定id来新建文档，自动生成id</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ POST foo_index/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;demo test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;demo test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看id=1的文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ GET foo_index/_doc/1</span><br></pre></td></tr></table></figure>



<h2><span id="六-数据查询">六、数据查询</span></h2><h3><span id="61-返回所有记录">6.1 返回所有记录</span></h3><p>使用 GET 方法，直接请求<code>/Index/Type/_search</code>，就会返回所有记录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>:2,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:5,<span class="string">&quot;successful&quot;</span>:5,<span class="string">&quot;failed&quot;</span>:0&#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>:2,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>:1.0,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;AV3qGfrC6jMbsbXb6k1p&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>:1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;系统管理&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>:1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;数据库管理，软件开发&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，返回结果的 <code>took</code>字段表示该操作的耗时（单位为毫秒），<code>timed_out</code>字段表示是否超时，<code>hits</code>字段表示命中的记录，里面子字段的含义如下。</p>
<blockquote>
<ul>
<li><code>total</code>：返回记录数，本例是2条。</li>
<li><code>max_score</code>：最高的匹配程度，本例是<code>1.0</code>。</li>
<li><code>hits</code>：返回的记录组成的数组。</li>
</ul>
</blockquote>
<p>返回的记录中，每条记录都有一个<code>_score</code>字段，表示匹配的程序，默认是按照这个字段降序排列。</p>
<h3><span id="62-全文搜索">6.2 全文搜索</span></h3><p>Elastic 的查询非常特别，使用自己的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html">查询语法</a>，要求 GET 请求带有数据体。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-match-query.html">Match 查询</a>，指定的匹配条件是<code>desc</code>字段里面包含”软件”这个词。返回结果如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:<span class="number">5</span>,<span class="string">&quot;successful&quot;</span>:<span class="number">5</span>,<span class="string">&quot;failed&quot;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>:<span class="number">0.28582606</span>,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>:<span class="number">0.28582606</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;数据库管理，软件开发&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Elastic 默认一次返回10条结果，可以通过<code>size</code>字段改变这个设置。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，每次只返回一条结果。</p>
<p>还可以通过<code>from</code>字段，指定位移。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;from&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p>
<h3><span id="63-逻辑运算">6.3 逻辑运算</span></h3><p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码搜索的是<code>软件 or 系统</code>。</p>
<p>如果要执行多个关键词的<code>and</code>搜索，必须使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html">布尔查询</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;bool&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;must&quot;: [</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;,</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="64-搜索demo">6.4 搜索demo</span></h3><p>使用 <code>curl -X GET foo_index/_search -d &#39;body&#39;</code> 来搜索文档</p>
<p>match_all匹配所有文档，等价于空查询{}</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>mathc匹配包含，如果在一个精确值的字段上使用match，例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>多字段match使用multi_match</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span>    <span class="string">&quot;full text search&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span>   <span class="punctuation">[</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span> <span class="string">&quot;body&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>term查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串，term 查询对于输入的文本不分析 ，所以它将给定的值进行精确查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>terms查询被用于匹配多个精确值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;demo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;demo1&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>合并(bool)查询可以组合多种查询方法</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span>     <span class="punctuation">&#123;</span> <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;tweet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;mary&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span>   <span class="punctuation">&#123;</span> <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;tweet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;full text&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span>   <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;gt&quot;</span> <span class="punctuation">:</span> <span class="number">30</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2><span id="七-参考链接">七、参考链接</span></h2><ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">ElasticSearch 官方手册</a></li>
<li><a href="https://www.elastic.co/blog/a-practical-introduction-to-elasticsearch">A Practical Introduction to Elasticsearch</a></li>
</ul>
<p>（完）</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 调用 GoogleSheets API 写入数据</title>
    <url>/ee1035bf/</url>
    <content><![CDATA[<h2><span id="前置依赖">前置依赖</span></h2><h3><span id="1-创建-google-cloud-项目">1 创建 Google Cloud 项目</span></h3><p><a href="https://console.cloud.google.com/projectcreate">https://console.cloud.google.com/projectcreate</a></p>
<p>在项目页面上，确保启用了 Google Sheets API。你可以在“API 和服务”&gt;“库”中搜索并启用该 API。</p>
<h3><span id="2-创建服务账号密钥">2 创建服务账号密钥：</span></h3><ul>
<li>在 Google Cloud Console 的项目页面上，导航到“API 和服务”&gt;“凭据”。</li>
<li>点击“创建凭据”按钮，选择“服务账号密钥”。</li>
<li>在“服务账号”部分，选择“新建服务账号”，并为其指定一个名称。</li>
<li>在“角色”部分，选择“项目”&gt;“编辑者”角色。</li>
<li>选择“JSON”作为密钥类型，并点击“创建”按钮。这将下载一个 JSON 文件，其中包含你的服务账号密钥。</li>
<li>Google Sheet 分享给服务账号，邀请其成为“编辑者”，被邀请人填入服务账号的邮箱</li>
</ul>
<h2><span id="go-代码">Go 代码</span></h2><p>安装 Go 的 Google Sheets API 客户端库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u google.golang.org/api/sheets/v4</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;golang.org/x/oauth2/google&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/api/sheets/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载密钥文件</span></span><br><span class="line">	b, err := ioutil.ReadFile(credential.json)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;无法读取密钥文件：%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从密钥文件创建一个配置</span></span><br><span class="line">	config, err := google.JWTConfigFromJSON(b, sheets.SpreadsheetsScope)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;无法创建配置：%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用配置创建一个客户端</span></span><br><span class="line">	client := config.Client(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 Sheets 服务</span></span><br><span class="line">	sheetsService, err := sheets.New(client)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;无法创建 Sheets 服务：%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定要写入的 Spreadsheet ID 和 Sheet 名称</span></span><br><span class="line">	spreadsheetID := <span class="string">&quot;MY_GG_SHEET_ID&quot;</span></span><br><span class="line">	<span class="comment">// sheetName := &quot;test&quot;</span></span><br><span class="line">	sheetName := time.Now().Format(<span class="string">&quot;010215&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 SheetProperties 对象，指定新 Sheet 的名称</span></span><br><span class="line">	sheetProperties := &amp;sheets.SheetProperties&#123;</span><br><span class="line">		Title: sheetName,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 AddSheetRequest 对象，将 SheetProperties 放入其中</span></span><br><span class="line">	addSheetRequest := &amp;sheets.AddSheetRequest&#123;</span><br><span class="line">		Properties: sheetProperties,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 BatchUpdateSpreadsheetRequest 对象，将 AddSheetRequest 放入其中</span></span><br><span class="line">	batchUpdateRequest := &amp;sheets.BatchUpdateSpreadsheetRequest&#123;</span><br><span class="line">		Requests: []*sheets.Request&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				AddSheet: addSheetRequest,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行批量更新操作，创建新的 Sheet</span></span><br><span class="line">	batUpdResp, err := sheetsService.Spreadsheets.BatchUpdate(spreadsheetID, batchUpdateRequest).Do()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Unable to create new sheet: %v&quot;</span>, err)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;执行批量更新操作，创建新的 Sheet失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印新 Sheet 的 ID</span></span><br><span class="line">	newSheetID := batUpdResp.Replies[<span class="number">0</span>].AddSheet.Properties.SheetId</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Created new sheet with ID: %d\n&quot;</span>, newSheetID)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建要写入的数据</span></span><br><span class="line">	values := [][]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Value 1&quot;</span>, <span class="string">&quot;Value 2&quot;</span>, <span class="string">&quot;Value 3&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Value 4&quot;</span>, <span class="string">&quot;Value 5&quot;</span>, <span class="string">&quot;Value 6&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建写入请求</span></span><br><span class="line">	writeRequest := &amp;sheets.ValueRange&#123;</span><br><span class="line">		Values: values,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//// 执行写入请求</span></span><br><span class="line">	<span class="comment">//_, err = sheetsService.Spreadsheets.Values.Update(spreadsheetID, sheetName, writeRequest).ValueInputOption(&quot;RAW&quot;).Do()</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	log.Fatalf(&quot;无法写入数据：%v&quot;, err)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;数据已成功写入 Google Sheets！&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行追加操作</span></span><br><span class="line">	appendResp, err := sheetsService.Spreadsheets.Values.Append(spreadsheetID, sheetName, writeRequest).ValueInputOption(<span class="string">&quot;USER_ENTERED&quot;</span>).Do()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Unable to append data: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印追加操作的结果</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Appended %d rows\n&quot;</span>, appendResp.Updates.UpdatedRows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="参考资料">参考资料</span></h2><p><a href="https://developers.google.com/docs/api/reference/rest">https://developers.google.com/docs/api/reference/rest</a><br><a href="https://github.com/googleworkspace/go-samples/tree/main/sheets/quickstart">https://github.com/googleworkspace/go-samples/tree/main/sheets/quickstart</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>GoogleSheets</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Go 1.14 中接口的菱形组合</title>
    <url>/ace0b2ab/</url>
    <content><![CDATA[<p>按照<a href="https://github.com/golang/proposal/blob/master/design/6977-overlapping-interfaces.md">部分重叠的接口提议</a>，Go 1.14 现在允许嵌入有部分方法重叠的接口。本文是一篇解释这次修改的简要说明。</p>
<p>我们先来看 io 包中的三个关键接口：io.Reader、io.Writer 和 io.Closer：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在结构体中嵌入类型时，如果在结构体中声明了被嵌入的类型，那么该类型的字段和方法允许被访问<a href="也就是说，嵌入提升了类型的字段和方法。">^1</a>，对于接口来说这个处理也成立。因此下面两种方式：显式声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和使用嵌入来组成接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有区别。</p>
<p>你甚至可以混合使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，在 Go 1.14 之前，如果你用这种方式来声明接口，你可能会得到类似这样的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadCloser</span><br><span class="line">	WriterCloser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% Go build interfaces.go</span><br><span class="line">command-line-arguments</span><br><span class="line">./interfaces.go:27:2: duplicate method Close</span><br></pre></td></tr></table></figure>

<p>幸运的是，在 Go 1.14 中这不再是一个限制了，因此这个改动解决了在菱形嵌入时出现的问题。</p>
<p>然而，在我向本地的用户组解释这个特性时也陷入了麻烦 — 只有 Go 编译器使用 1.14（或更高版本）语言规范时才支持这个特性。</p>
<p>我理解的编译过程中 Go 语言规范所使用的版本的规则似乎是这样的：</p>
<ol>
<li>如果你的源码是在 GOPATH 下（或者你用 GO111MODULE=off <em>关闭</em>了 module），那么 Go 语言规范会使用你编译器的版本来编译。换句话说，如果安装了 Go 1.13，那么你的 Go 版本就是 1.13。如果你安装了 Go 1.14，那么你的版本就是 1.14。这里符合认知。</li>
<li>如果你的源码保存在 GOPATH 外（或你用 GO111MODULE=on 强制开启了 module），那么 Go tool 会从 go.mod 文件中获取 Go 版本。</li>
<li>如果 go.mod 中没有列出 Go 版本，那么语言规范会使用安装的 Go 的版本。这跟第 1 点是一致的。</li>
<li>如果你用的是 Go module 模式，不管是源码在 GOPATH 外还是设置了 GO111MODULE=on，但是在当前目录或所有父目录中都没有 go.mod 文件，那么 Go 语言规范会默认用 Go 1.13 版本来编译你的代码。</li>
</ol>
<p>我曾经遇到过第 4 点的情况。</p>
<hr>
<p>via: <a href="https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14">https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14</a></p>
<p>作者：<a href="https://dave.cheney.net/">Dave Cheney</a> </p>
<p>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a> </p>
<p>校对：<a href="https://github.com/polaris1119">polaris1119</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]Go GC 怎么标记内存</title>
    <url>/b3baee92/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p>
<p>ℹ️ 本文基于 <em>Go 1.13</em>。关于内存管理的概念的讨论在我的文章 <a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">Go 中的内存管理和分配</a> 中有详细的解释。</p>
<p>Go GC 的作用是回收不再使用的内存。实现的算法是并发的三色标记和清除回收法。本中文，我们研究三色标记法，以及各个颜色的不同用处。</p>
<p>你可以在 Ken Fox 的 <a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">解读垃圾回收算法</a> 中了解更多关于不同垃圾回收机制的信息。</p>
<h2><span id="标记阶段">标记阶段</span></h2><p>这个阶段浏览内存来了解哪些块儿是在被我们的代码使用和哪些块儿应该被回收。</p>
<p>然而，因为 GC 和我们的 Go 程序并行，GC 扫描期间内存中某些对象的状态可能被改变，所以需要一个检测这种可能的变化的方法。为了解决这个潜在的问题，实现了 <a href="https://en.wikipedia.org/wiki/Write_barrier">写屏障</a> 算法，GC 可以追踪到任何的指针修改。使写屏障生效的唯一条件是短暂终止程序，又名 “Stop the World”。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/01.png" alt></p>
<p>在进程启动时，Go 也在每个 processor 起了一个标记 worker 来辅助标记内存。</p>
<p>然后，当 root 被加入到处理队列中后，标记阶段就开始遍历和用颜色标记内存。</p>
<p>为了了解在标记阶段的每一步，我们来看一个简单的程序示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	a, b <span class="type">int64</span></span><br><span class="line">	c, d <span class="type">float64</span></span><br><span class="line">	e *struct2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> struct2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	f, g <span class="type">int64</span></span><br><span class="line">	h, i <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := allocStruct1()</span><br><span class="line">	s2 := allocStruct2()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		_ = allocStruct2()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	runtime.GC()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1 = %X, s2 = %X\n&quot;</span>, &amp;s1, &amp;s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct1</span><span class="params">()</span></span> *struct1 &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;struct1&#123;</span><br><span class="line">		e: allocStruct2(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocStruct2</span><span class="params">()</span></span> *struct2 &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;struct2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>struct2</code> 不包含指针，因此它被储存在一个专门存放不被其他对象引用的对象的 span 中。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/02.png" alt="不包含指针的结构体储存在专有的 span 中"></p>
<p>这减少了 GC 的工作，因为标记内存时不需要扫描这个 span。</p>
<p>分配工作结束后，我们的程序强迫 GC 重复前面的步骤。下面是流程图：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/03.png" alt="扫描内存"></p>
<p>GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。扫描到被标记为 <code>no scan</code> 的 span 时，停止扫描。然而，这个工作是在多个协程中完成的，每个指针被加入到一个 work pool 中的队列。然后，后台运行的标记 worker 从这个 work pool 中拿到前面出列的 work，扫描这个对象然后把在这个对象里找到的指针加入到队列。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/04.png" alt="garbage collector work pool"></p>
<h2><span id="颜色标记">颜色标记</span></h2><p>worker 需要一种记录哪些内存需要扫描的方法。GC 使用一种 <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">三色标记算法</a>，工作流程如下：</p>
<ul>
<li>开始时，所有对象都被认为是<strong>白色</strong></li>
<li>root 对象（栈，堆，全局变量）被标记为<strong>灰色</strong></li>
</ul>
<p>这个初始步骤完成后，GC 会：</p>
<ul>
<li>选择一个<strong>灰色</strong>的对象，标记为<strong>黑色</strong></li>
<li>追踪这个对象的所有指针，把所有引用的对象标记为<strong>灰色</strong></li>
</ul>
<p>然后，GC 重复以上两步，直到没有对象可被标记。在这一时刻，对象非黑即白，没有灰色。白色的对象表示没有其他对象引用，可以被回收。</p>
<p>下面是前面例子的图示：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/05.png" alt></p>
<p>初始状态下，所有的对象被认为是白色的。然后，遍历到的且被其他对象引用的对象，被标记为灰色。如果一个对象在被标记为 <code>no scan</code> 的 span 中，因为它不需要被扫描，所以可以标记为黑色。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/06.png" alt></p>
<p>现在灰色的对象被加入到扫描队列并被标记为黑色：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/07.png" alt></p>
<p>对加入到扫描队列的所有对象重复做相同的操作，直到没有对象需要被处理：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/08.png" alt></p>
<p>处理结束时，黑色对象表示内存中在使用的对象，白色对象是要被回收的对象。我们可以看到，由于 <code>struct2</code> 的实例是在一个匿名函数中创建的且不再存在于栈上，因此它是白色的且可以被回收。</p>
<p>归功于每一个 span 中的名为 <code>gcmarkBits</code> 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 scan。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/09.png" alt></p>
<p>我们可以看到，黑色和灰色表示的意义相同。处理的不同之处在于，标记为灰色时是把对象加入到扫描队列，而标记为黑色时，不再扫描。</p>
<p>GC 最终 STW，清除每一次写屏障对 work pool 做的改变，继续后续的标记。</p>
<p><em>你可以在我的文章 <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35">Go GC 怎样监控你的应用</a> 中找到关于并发处理和 GC 的标记阶段更详细的描述</em>。</p>
<h2><span id="runtime-分析器">runtime 分析器</span></h2><p>Go 提供的工具使我们可以对每一步进行可视化，观察 GC 在我们的程序中的影响。开启 tracing 运行我们的代码，可以看到前面所有步骤的一个概览。下面是追踪结果：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/10.png" alt="traces of the garbage collector"></p>
<p>标记 worker 的生命周期也可以在追踪结果中以协程等级可视化。下面是在启动之前先在后台等待标记内存的 goroutine #33 的例子。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/11.png" alt="marking worker"></p>
<hr>
<p>via: <a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976</a></p>
<p>作者：<a href="https://medium.com/@blanchon.vincent">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf">lxbwolf</a> 校对：<a href="https://github.com/polaris1119">polaris1119</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go channel 原理</title>
    <url>/7b2461e3/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#section1-channel-使用">Section1 channel 使用</a><ul>
<li><a href="#11-make-channel">1.1 make channel</a></li>
<li><a href="#12-sends-and-receives">1.2 sends and receives</a></li>
</ul>
</li>
<li><a href="#section2-channel源码">Section2 channel源码</a><ul>
<li><a href="#21-channel数据存储结构">2.1 channel数据存储结构</a></li>
<li><a href="#22-环形队列">2.2 环形队列</a></li>
<li><a href="#23-等待队列">2.3 等待队列</a></li>
<li><a href="#24-类型信息">2.4 类型信息</a></li>
<li><a href="#25-锁">2.5 锁</a></li>
</ul>
</li>
<li><a href="#section3-channel读写">Section3 channel读写</a><ul>
<li><a href="#31-创建channel">3.1 创建channel</a></li>
<li><a href="#32-协程向channel写入数据goroutine-sender-data">3.2 协程向channel写入数据(goroutine sender data)</a></li>
<li><a href="#33-协程从channel接收数据goroutine-receive-data">3.3 协程从channel接收数据(goroutine receive data)</a></li>
<li><a href="#34-关闭channel">3.4 关闭channel</a></li>
</ul>
</li>
<li><a href="#section4-常见用法">Section4 常见用法</a><ul>
<li><a href="#41-单向channel">4.1 单向channel</a></li>
<li><a href="#42-select">4.2 select</a></li>
<li><a href="#43-range">4.3 range</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="section1-channel-使用">Section1 channel 使用</span></h1><h2><span id="11-make-channel">1.1 make channel</span></h2><p>一种是带缓冲的channel一种是不带缓冲的channel。创建方式分别如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// unbuffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p><strong>buffered channel</strong></p>
<p>如果我们创建一个带buffer的channel，底层的数据模型如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170000.png" alt></p>
<p>当我们向channel里面写入数据时候，会直接把数据存入circular queue(send)。当Queue存满了之后就会是如下的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170039.png" alt></p>
<p>当dequeue一个元素时候，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170108.png" alt></p>
<p>从上图可知，recvx自增加一，表示出队了一个元素，其实也就是循环数组实现FIFO语义。</p>
<p>那么还有一个问题，当我们新建channel的时候，底层创建的hchan数据结构是在哪里分配内存的呢？其实Section2里面源码分析时候已经做了分析，hchan是在heap里面分配的。</p>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170236.png" alt></p>
<p>当我们使用make去创建一个channel的时候，实际上返回的是一个指向channel的pointer，所以我们能够在不同的function之间直接传递channel对象，而不用通过指向channel的指针。</p>
<h2><span id="12-sends-and-receives">1.2 sends and receives</span></h2><p>不同goroutine在channel上面进行读写时，涉及到的过程比较复杂，比如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170342.png" alt></p>
<p>上图中G1会往channel里面写入数据，G2会从channel里面读取数据。</p>
<p>G1作用于底层hchan的流程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170423.png" alt></p>
<ol>
<li>先获取全局锁；</li>
<li>然后enqueue元素(通过移动拷贝的方式)；</li>
<li>释放锁；</li>
</ol>
<p>G2读取时候作用于底层数据结构流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170525.png" alt></p>
<ol>
<li>先获取全局锁；</li>
<li>然后dequeue元素(通过移动拷贝的方式)；</li>
<li>释放锁；</li>
</ol>
<p>上面的读写思路其实很简单，除了hchan数据结构外，不要通过共享内存去通信；而是通过通信(复制)实现共享内存。</p>
<p><strong>写入满channel的场景</strong></p>
<p>如下图所示：channel写入3个task之后队列已经满了，这时候G1再写入第四个task的时候会发生什么呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170644.png" alt></p>
<p>G1这时候会暂停直到出现一个receiver。</p>
<p>这个地方需要介绍一下Golang的scheduler的。我们知道goroutine是用户空间的线程，创建和管理协程都是通过Go的runtime，而不是通过OS的thread。</p>
<p>但是Go的runtime调度执行goroutine却是基于OS thread的。如下图：<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173326.png" alt></p>
<p>当向已经满的channel里面写入数据时候，会发生什么呢？如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173420.png" alt></p>
<p>上图流程大概如下：</p>
<p>当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态；<br>将M和G1绑定关系断开；<br>scheduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G。<br>所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。</p>
<p>那么blocked的G1怎么恢复呢？<strong>当有一个receiver接收channel数据的时候，会恢复 G1。</strong></p>
<p>实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173537.png" alt></p>
<p>等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行<code>ch&lt;-task4</code>的时候，G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173614.png" alt></p>
<p>这个时候，如果G2进行一个读取channel操作，读取前和读取后的变化图如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173709.png" alt></p>
<p>整个过程如下：</p>
<ol>
<li>G2调用 t:=&lt;-ch 获取一个元素；</li>
<li>从channel的buffer里面取出一个元素task1；</li>
<li>从sender等待队列里面pop一个sudog；</li>
<li>将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；</li>
<li>这时候需要将G1置为Runable状态，表示G1可以恢复运行；</li>
</ol>
<p>这个时候将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173855.png" alt></p>
<ol>
<li>首先G2会调用goready(G1)，唤起scheduler的调度；</li>
<li>将G1设置成Runable状态；</li>
<li>G1会加入到局部调度器P的local queue队列，等待运行。</li>
</ol>
<p><strong>读取空channel的场景</strong></p>
<p>当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173959.png" alt></p>
<p>会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。</p>
<p>这个时候，如果有一个G1执行写入操作，最直观的流程就是：</p>
<ol>
<li><p>将recvq中的task存入buffer；</p>
</li>
<li><p>goready(G2) 唤醒G2；</p>
</li>
</ol>
<pre><code>**但是**我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。如下图：

![](https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312174123.png)

具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲。</code></pre><h1><span id="section2-channel源码">Section2 channel源码</span></h1><h2><span id="21-channel数据存储结构">2.1 channel数据存储结构</span></h2><p>在源码<code>runtime/chan.go</code> 里面定义了channel的数据模型，channel可以理解成一个缓冲队列，这个缓冲队列用来存储元素，并且提供FIFO的语义。源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//channel队列里面总的数据量</span></span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	<span class="comment">// 循环队列的容量，如果是非缓冲的channel就是0</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	<span class="comment">// 缓冲队列，数组类型。</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	<span class="comment">// 元素占用字节的size</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// 当前队列关闭标志位，非零表示关闭</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	<span class="comment">// 队列里面元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 队列send索引</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 队列索引</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待channel的G队列。</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 向channel发送数据的G队列。</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	<span class="comment">// 全局锁</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel的数据结构相对比较简单，主要是两个结构：<br>1）一个数组实现的环形队列，数组有两个下标索引分别表示读写的索引，用于保存channel缓冲区数据。<br>2）channel的send和recv队列，队列里面都是持有goroutine的sudog元素，队列都是双链表实现的。<br>3）channel的全局锁。</p>
<h2><span id="22-环形队列">2.2 环形队列</span></h2><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。</p>
<p>下图展示了一个可缓存6个元素的channel示意图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312174357.png" alt></p>
<ul>
<li>dataqsiz指示了队列长度为6，即可缓存6个元素；</li>
<li>buf指向队列的内存，队列中还剩余两个元素；</li>
<li>qcount表示队列中还有两个元素；</li>
<li>sendx指示后续写入的数据存储的位置，取值[0, 6)；</li>
<li>recvx指示从该位置读取数据, 取值[0, 6)；</li>
</ul>
<h2><span id="23-等待队列">2.3 等待队列</span></h2><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。<br>向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p>
<p>被阻塞的goroutine将会挂在channel的等待队列中：</p>
<ul>
<li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li>
<li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li>
</ul>
<p>下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312174513.png" alt></p>
<p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p>
<h2><span id="24-类型信息">2.4 类型信息</span></h2><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p>
<ul>
<li>elemtype代表类型，用于数据传递过程中的赋值；</li>
<li>elemsize代表类型大小，用于在buf中定位元素位置。</li>
</ul>
<h2><span id="25-锁">2.5 锁</span></h2><p>一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。</p>
<h1><span id="section3-channel读写">Section3 channel读写</span></h1><h2><span id="31-创建channel">3.1 创建channel</span></h2><p>我们新建一个channel的时候一般使用 <code>make(chan, n)</code> 语句，这个语句的执行编译器会重写然后执行 chan.go里面的 makechan函数。函数源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size &lt; <span class="number">0</span> || <span class="type">uintptr</span>(size) &gt; maxSliceCap(elem.size) || <span class="type">uintptr</span>(size)*elem.size &gt; maxAlloc-hchanSize &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line">	<span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">	<span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line">	<span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> size == <span class="number">0</span> || elem.size == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Queue or element size is zero.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">		c.buf = unsafe.Pointer(c)</span><br><span class="line">	<span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">		<span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="type">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// Elements contain pointers.</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(<span class="type">uintptr</span>(size)*elem.size, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; elemalg=&quot;</span>, elem.alg, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数接收两个参数，一个是channel里面保存的元素的数据类型，一个是缓冲的容量(如果为0表示是非缓冲buffer)，创建流程如下：</p>
<ul>
<li>根据传递的缓冲大小size是否为零，分别创建不带buffer的channel或则带size大小的缓冲channel：<ul>
<li>对于不带缓冲channel，申请一个hchan数据结构的内存大小；</li>
<li>对于带缓冲channel，new一个hchan对象，并初始化buffer内存</li>
</ul>
</li>
<li>更新 chan中循环队列的关键属性：elemsize、elemtype、dataqsiz。</li>
</ul>
<p>创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p>
<p>创建channel的伪代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	c = <span class="built_in">new</span>(hchan)</span><br><span class="line">	c.buf = malloc(元素类型大小*size)</span><br><span class="line">	c.elemsize = 元素类型大小</span><br><span class="line">	c.elemtype = 元素类型</span><br><span class="line">	c.dataqsiz = size</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="32-协程向channel写入数据goroutine-sender-data">3.2 协程向channel写入数据(goroutine sender data)</span></h2><p>所有执行 c &lt; ep 将ep发送到channel的代码，最后都会调用到chan.go里面的 chansend函数。</p>
<p>函数的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数有三个参数，第一个代表channel的数据结构，第二个是要指向写入的数据的指针，第三个block代表写入操作是否阻塞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175238.png" alt></p>
<p>向一个channel中写数据简单过程如下：</p>
<ol>
<li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li>
<li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；</li>
<li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；</li>
</ol>
<p>流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175356.png" alt></p>
<h2><span id="33-协程从channel接收数据goroutine-receive-data">3.3 协程从channel接收数据(goroutine receive data)</span></h2><p>所有执行 <code>ep &lt; c</code> 使用ep接收channel数据的代码，最后都会调用到chan.go里面的 <code>chanrecv函数</code>。</p>
<p>函数的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码注释就可以知道，该函数从channel里面接收数据，然后将接收到的数据写入到ep指针指向的对象里面。</p>
<p>还有一个参数block，表示当channel无法返回数据时是否阻塞等待。当block=false并且channel里面没有数据时候，函数直接返回(false,false)。<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175531.png" alt></p>
<p>从一个channel读数据简单过程如下：</p>
<ol>
<li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li>
<li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li>
<li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li>
<li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li>
</ol>
<p>简单流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175628.png" alt></p>
<h2><span id="34-关闭channel">3.4 关闭channel</span></h2><p>当我们执行channel的close操作的时候会关闭channel。</p>
<p>关闭的主要流程如下所示：</p>
<ol>
<li>获取全局锁；</li>
<li>设置channel数据结构chan的关闭标志位；</li>
<li>获取当前channel上面的读goroutine并链接成链表；</li>
<li>获取当前channel上面的写goroutine然后拼接到前面的读链表后面；</li>
<li>释放全局锁；</li>
<li>唤醒所有的读写goroutine。</li>
</ol>
<p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。</p>
<p>除此之外，panic出现的常见场景还有：</p>
<ol>
<li>关闭值为nil的channel</li>
<li>关闭已经被关闭的channel</li>
<li>向已经关闭的channel写数据</li>
</ol>
<h1><span id="section4-常见用法">Section4 常见用法</span></h1><h2><span id="41-单向channel">4.1 单向channel</span></h2><p>单向channel指只能用于发送或接收数据，实际上并没有单向channel。</p>
<p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p>
<ul>
<li>func readChan(chanName &lt;-chan int)： 通过形参限定函数内部只能从channel中读取数据</li>
<li>func writeChan(chanName chan&lt;- int)： 通过形参限定函数内部只能向channel中写入数据</li>
</ul>
<p>一个简单的示例程序如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(chanName &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(chanName <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    chanName &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mychan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来写。</p>
<h2><span id="42-select">4.2 select</span></h2><p>使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。</p>
<p>一个简单的示例程序如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumberToChan</span><span class="params">(chanName <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        chanName &lt;- <span class="number">1</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan1)</span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan2)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Get element from chan1: %d\n&quot;</span>, e)</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Get element from chan2: %d\n&quot;</span>, e)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;No element in chan1 and chan2.\n&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p>
<p>程序输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go run main.go</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">No element <span class="keyword">in</span> chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element <span class="keyword">in</span> chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element <span class="keyword">in</span> chan1 and chan2.</span><br></pre></td></tr></table></figure>

<p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的，关于select的实现原理会有专门章节分析。</p>
<p>通过这个示例想说的是：<strong>select的case语句读channel不会阻塞</strong>，尽管channel中没有数据。这是由于case语句编译后调用读channel时会<strong>明确传入不阻塞的参数</strong>，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p>
<h2><span id="43-range">4.3 range</span></h2><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanRange</span><span class="params">(chanName <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> e := <span class="keyword">range</span> chanName &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Get element from chan: %d\n&quot;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 八股</title>
    <url>/30fc3293/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-相比较于其他语言-go-有什么优势或者特点"><strong>1. 相比较于其他语言, Go 有什么优势或者特点？</strong></a></li>
<li><a href="#2-golang-里的-gmp-模型"><strong>2. Golang 里的 GMP 模型？</strong></a></li>
<li><a href="#3-goroutine-的协程有什么特点和线程相比"><strong>3. goroutine 的协程有什么特点，和线程相比？</strong></a></li>
<li><a href="#4-go-的垃圾回收机制"><strong>4. Go 的垃圾回收机制？</strong></a></li>
<li><a href="#5-go-的内存分配是怎么样的"><strong>5. go 的内存分配是怎么样的？</strong></a></li>
<li><a href="#6-channel-的内部实现是怎么样的"><strong>6. channel 的内部实现是怎么样的？</strong></a></li>
<li><a href="#7-对已经关闭的-channel-进行读写会怎么样"><strong>7. 对已经关闭的 channel 进行读写，会怎么样？</strong></a></li>
<li><a href="#8-map-为什么不是线程安全的"><strong>8. map 为什么不是线程安全的？</strong></a></li>
<li><a href="#9-map-的-key-为什么得是可比较类型的"><strong>9. map 的 key 为什么得是可比较类型的？</strong></a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-相比较于其他语言-go-有什么优势或者特点"><strong>1. 相比较于其他语言, Go 有什么优势或者特点？</strong></span></h2><ul>
<li>Go 允许跨平台编译，编译出来的是二进制的可执行文件，直接部署在对应系统上即可运行。</li>
<li>Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型， 即所谓的<code>通过通信来共享内存</code>；Go 在 runtime 运行时里实现了属于自己的调度机制：GMP，降低了内核态和用户态的切换成本。</li>
<li>Go 的代码风格是强制性的统一，如果没有按照规定来，会编译不通过。</li>
</ul>
<h2><span id="2-golang-里的-gmp-模型"><strong>2. Golang 里的 GMP 模型？</strong></span></h2><p>GMP 模型是 golang 自己的一个调度模型，它抽象出了下面三个结构：</p>
<ul>
<li><code>G：</code> 也就是协程 goroutine，由 Go runtime 管理。我们可以认为它是用户级别的线程。</li>
<li><code>P：</code> processor 处理器。每当有 goroutine 要创建时，会被添加到 P 上的 goroutine 本地队列上，如果 P 的本地队列已满，则会维护到全局队列里。</li>
<li><code>M：</code> 系统线程。在 M 上有调度函数，它是真正的调度执行者，M 需要跟 P 绑定，并且会让 P 按下面的原则挑出个 goroutine 来执行：</li>
</ul>
<p>优先从 P 的本地队列获取 goroutine 来执行；如果本地队列没有，从全局队列获取，如果全局队列也没有，会从其他的 P 上偷取 goroutine。</p>
<h2><span id="3-goroutine-的协程有什么特点和线程相比"><strong>3. goroutine 的协程有什么特点，和线程相比？</strong></span></h2><p>goroutine 非常的<strong>轻量</strong>，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。</p>
<p>而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。</p>
<h2><span id="4-go-的垃圾回收机制"><strong>4. Go 的垃圾回收机制？</strong></span></h2><p>Go 采用的是三色标记法，将内存里的对象分为了三种：</p>
<ul>
<li>白色对象：未被使用的对象；</li>
<li>灰色对象：当前对象有引用对象，但是还没有对引用对象继续扫描过；</li>
<li>黑色对象，对上面提到的灰色对象的引用对象已经全部扫描过了，下次不用再扫描它了。</li>
</ul>
<p>当垃圾回收开始时，Go 会把根对象标记为灰色，其他对象标记为白色，然后从根对象遍历搜索，按照上面的定义去不断的对灰色对象进行扫描标记。当没有灰色对象时，表示所有对象已扫描过，然后就可以开始清除白色对象了。</p>
<h2><span id="5-go-的内存分配是怎么样的"><strong>5. go 的内存分配是怎么样的？</strong></span></h2><p>Go 的内存分配借鉴了 Google 的 TCMalloc 分配算法，其核心思想是内存池 + 多级对象管理。内存池主要是预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan、arenas、mcentral、mcache。它们以 mspan 作为基本分配单位。具体的分配逻辑如下：</p>
<ul>
<li>当要分配大于 32K 的对象时，从 mheap 分配。</li>
<li>当要分配的对象小于等于 32K 大于 16B 时，从 P 上的 mcache 分配，如果 mcache 没有内存，则从 mcentral 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则从操作系统申请内存。</li>
<li>当要分配的对象小于等于 16B 时，从 mcache 上的微型分配器上分配。</li>
</ul>
<h2><span id="6-channel-的内部实现是怎么样的"><strong>6. channel 的内部实现是怎么样的？</strong></span></h2><p>channel 内部维护了两个 goroutine 队列，一个是待发送数据的 goroutine 队列，另一个是待读取数据的 goroutine 队列。</p>
<p>每当对 channel 的读写操作超过了可缓冲的 goroutine 数量，那么当前的 goroutine 就会被挂到对应的队列上，直到有其他 goroutine 执行了与之相反的读写操作，将它重新唤起。</p>
<h2><span id="7-对已经关闭的-channel-进行读写会怎么样"><strong>7. 对已经关闭的 channel 进行读写，会怎么样？</strong></span></h2><p>当 channel 被关闭后，如果继续往里面写数据，程序会直接 <strong>panic</strong> 退出。如果是读取关闭后的 channel，不会产生 pannic，还可以读到数据。但关闭后的 channel 没有数据可读取时，将得到零值，即对应类型的默认值。</p>
<p>为了能知道当前 channel 是否被关闭，可以使用下面的写法来判断。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if v, ok := &lt;-ch; !ok &#123;</span><br><span class="line"> fmt.Println(&quot;channel 已关闭，读取不到数据&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用下面的写法不断的获取 channel 里的数据：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for data := range ch &#123;</span><br><span class="line"> // get data dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种用法会在读取完 channel 里的数据后就结束 for 循环，执行后面的代码。</p>
<h2><span id="8-map-为什么不是线程安全的"><strong>8. map 为什么不是线程安全的？</strong></span></h2><p>map 在扩缩容时，需要进行数据迁移，迁移的过程并没有采用锁机制防止并发操作，而是会对某个标识位标记为 1，表示此时正在迁移数据。如果有其他 goroutine 对 map 也进行写操作，当它检测到标识位为 1 时，将会直接 panic。</p>
<p>如果我们想要并发安全的 map，则需要使用 sync.map。</p>
<h2><span id="9-map-的-key-为什么得是可比较类型的"><strong>9. map 的 key 为什么得是可比较类型的？</strong></span></h2><p>map 的 key、value 是存在 buckets 数组里的，每个 bucket 又可以容纳 8 个 key 和 8 个 value。当要插入一个新的 key - value 时，会对 key 进行 hash 运算得到一个 hash 值，然后根据 hash 值 的低几位(取几位取决于桶的数量，比如一开始桶的数量是 5，则取低 5 位)来决定命中哪个 bucket。</p>
<p>在命中某个 bucket 后，又会根据 hash 值的高 8 位来决定是 8 个 key 里的哪个位置。如果不巧，发生了 hash 冲突，即该位置上已经有<strong>其他 key</strong> 存在了，则会去其他空位置寻找插入。如果全都满了，则使用 overflow 指针指向一个新的 bucket，重复刚刚的寻找步骤。</p>
<p>从上面的流程可以看出，在判断 hash 冲突，即该位置是否已有<strong>其他 key</strong> 时，肯定是要进行比较的，所以 key 必须得是可比较类型的。像 slice、map、function 就不能作为 key。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Go 字符串中的潜在问题</title>
    <url>/10e5e8ba/</url>
    <content><![CDATA[<p>在我之前的文章 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike">Go 中我喜欢的东西</a>中提到过，我喜欢的 <a href="https://golang.org/">Go</a> 的东西其中之一就是它的字符串（通常还有切片）。从一个 Python 开发者的角度看，它们之所以伟大，是因为创建它们时开销很少，因为它们通常不需要复制。在 Python 中，任何时候操作字符串都需要复制一部分或全部字符串，而 <a href="https://utcc.utoronto.ca/~cks/space/blog/python/StringSpeedSurprises">这很容易对性能造成影响</a>。想要写高性能的 Python 代码需要谨慎考虑复制的问题。在 Go 中，几乎所有的字符串操作都是不复制的，仅仅是从原字符串取一个子集（例如去除字符串首尾的空白字符），因此你可以更自由地操作字符串。这个机制可以非常直接地解决你的问题，并且非常高效。</p>
<p>（当然，不是所有的字符串操作都不复制。例如，把一个字符串转换成大写需要复制，尽管 Go 中的实现已经足够智能，在不需要改变原字符串时 — 例如由于它已经是一个全大写的字符串 — 可以规避掉复制。）</p>
<p>但是这个优势也带来了潜在的坏处，那些没有开销的子字符串使原来的整个字符串一直存在于内存中。Go 中的字符串（和切片）操作之所以内存开销很少，是因为它们只是底层存储（字符串或切片底层的数组的真实数据）的一些部分的引用；创建一个字符串做的操作就是创建了一个新的引用。但是 Go（目前）不会对字符串数据或数组进行部分的垃圾回收，所以即使它一个很小的 bit 被其它元素引用，整个对象也会一直保持在内存中。换句话说，一个单字符的字符串（目前）足够让一个巨大的字符串不被 GC 回收。</p>
<p>当然，不会有很多人遇到这个问题。为了遇到它，你需要处理一个非常庞大的原字符串，或造成大量的内存消耗（或者两者都做），在这个基础上，你必须创建那些不持久的字符串的持久的小子字符串（好吧，你是多么希望它是非持久的）。很多使用场景不会复现这个问题；要么你的原字符串不够大，要么你的子集获取了大部分原字符串（例如你把原字符串进行了分词处理），要么子字符串生命周期不够长。简而言之，如果你是一个普通的 Go 开发者，你可以忽略这个问题。处理长字符串并且长时间维持原字符串的很小部分的人才会关注这个问题。</p>
<p>（我之所以关注到这个问题，是因为一次我花了大量精力用尽可能少的内存写 Python 程序，尽管它是从一个大的配置文件解析结果然后分块储存。这让我联想到了一些其他的事，如字符串的生命周期、限制字符串只复制一次，等等。然后我用 Go 语言写了一个解析器，这让我由重新考虑了一下这些问题，我意识到由于我的解析器截取出和维持的 bit 一直存在于内存中，从输入文件解析出的庞大字符串也会一直存在与内存中。）</p>
<p>顺便说一下，我认为这是 Go 做了权衡之后的正确结果。大部分使用字符串的开发者不会遇到这个问题，而且截取子字符串开销很小对于开发者来说用处很大。这种低开销的截取操作也减轻了 GC 的负担；当代码使用大量的子字符串截取（像 Python 中那样）时，你只需要处理固定长度的字符串引用就可以了，而不是需要处理长度变化的字符串。</p>
<p>当你的代码遇到这个问题时，当然有明显的解决方法：创建一个函数，通过把字符串转换成 <code>[]byte</code> 来 ”最小化“ 字符串，然后返回。这种方法生成了一个最小化的字符串，内存开销是理论上最完美实现的只复制一次，而 Go 现在很容易就可以实现。</p>
<h2><span id="附加问题stringstoupper-等怎样规避没有必要的复制">附加问题：<code>strings.ToUpper()</code> 等怎样规避没有必要的复制</span></h2><p>所有的主动转换函数像 <code>ToUpper()</code> 和 <code>ToTitle()</code> 是用 <code>strings.Map()</code> 和 <a href="http://golang.org/pkg/unicode/">unicode 包</a> 中的函数实现的。<code>Map()</code> 足够智能，在映射的函数返回一个与已存在的 <code>rune</code> 不同的结果之前不会创建新的字符串。因此，你代码中所有类似的直接使用 <code>Map()</code> 的地方都不会有内存开销。</p>
<hr>
<p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding">https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding</a></p>
<p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann">Chris Siebenmann</a><br>译者：<a href="https://github.com/lxbwolf">lxbwolf</a><br>校对：<a href="https://github.com/校对者ID">校对者ID</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 1.21 新增特性</title>
    <url>/f002ff66/</url>
    <content><![CDATA[<h2><span id="新的内置函数">新的内置函数</span></h2><p>1.21添加了三个新的内置函数：<code>min</code>、<code>max</code>和<code>clear</code>。</p>
<p><code>min</code>、<code>max</code>如其字面意思，用了选出一组变量里（数量大于等于1，只有一个变量的时候就返回那个变量的值）最大的或者最小的值。两个函数定义是这样的：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span>[<span class="title">T</span> <span class="title">cmp</span>.<span class="title">Ordered</span>]<span class="params">(x T, y ...T)</span></span> T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span>[<span class="title">T</span> <span class="title">cmp</span>.<span class="title">Ordered</span>]<span class="params">(x T, y ...T)</span></span> T</span><br></pre></td></tr></table></figure>

<p>注意那个类型约束，这是新的标准库里提供的，原型如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说只有基于所有除了map，chan，slice以及复数之外的基本类型的变量才能使用这两个函数。或者换句话说，只有可以使用<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>==</code>和<code>!=</code>进行比较的类型才可以使用min和max。</p>
<p>有了min和max，可以把许多自己手写的代码替换成新的内置函数，可以少写一些帮助函数。而且使用新的内置函数还有一个好处，在变量个数比较少的时候还有编译器的优化可用，比自己写min函数性能上要稍好一些。</p>
<p>使用上也很简单：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">maxIntValue := max(<span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment">// 7 type int</span></span><br><span class="line">minIntValue := min(<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment">// 1 type int</span></span><br></pre></td></tr></table></figure>

<p>目前max和min都不支持slice的解包操作：<code>max(1, numbers...)</code>。</p>
<p>对于clear来说事情比min和max复杂。clear只接受slice和map，如果是对泛型的类型参数使用clear，那么类型参数的type set必须是map或者slice，否则编译报错。</p>
<p>clear的定义如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clear</span>[<span class="title">T</span> ~[]<span class="title">Type</span> | ~<span class="title">map</span>[<span class="title">Type</span>]<span class="title">Type1</span>]<span class="params">(t T)</span></span></span><br></pre></td></tr></table></figure>

<p>对于参数是map的情况，clear会删除所有map里的元素（不过由于golang的map本身的特性，map存储的数据会被正常销毁，但map已经分配的空间不会释放）：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">3</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 5</span></span><br><span class="line">clear(m)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而对于slice，它的行为又不同了：会把slice里所有元素变回零值。看个例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>) <span class="comment">// 故意给个大的cap便于观察</span></span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;...)</span><br><span class="line">fmt.Println(s) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// len: 5; cap: 100</span></span><br><span class="line">clear(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// len: 5; cap: 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就比较反直觉了，毕竟clear首先想到的应该是把所有元素删除。那它的意义是什么呢？对于map来说意义是很明确的，但对于slice来说就有点绕弯了：</p>
<p><strong>slice的真实大小是cap所显示的那个大小，如果只是用<code>s := s[:0]</code>来把所有元素“删除”，那么这些元素实际上还是留在内存里的，直到s本身被gc回收或者往s里添加新元素把之前的对象覆盖掉，否则这些对象是不会被回收掉的，这一方面可以提高内存的利用率，另一方面也会带来泄露的问题（比如存储的是指针类型或者包含指针类型的值的时候，因为指针还存在，所以被指向的对象始终有一个有效的引用导致无法被回收），所以golang选择了折中的办法：把所有已经存在的元素设置成0值</strong></p>
<p>如果想安全的正常删除slice的所有元素，有想复用slice的内存，该怎么办？答案是：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="number">100</span>) <span class="comment">// 故意给个大的cap便于观察</span></span><br><span class="line">s = <span class="built_in">append</span>(s, []T&#123;*<span class="built_in">new</span>(T), *<span class="built_in">new</span>(T)&#125;...)</span><br><span class="line"></span><br><span class="line">clear(s)</span><br><span class="line">s = s[:<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>如果没有内置函数clear，那么我们得自己循环一个个赋值处理。而有clear的好处是，编译器会直接用memset把slice的内存里的数据设置为0，比循环会快很多。有兴趣的可以看看clear在slice上的实现：<a href="https://github.com/golang/go/blob/master/src/runtime/mbarrier.go#L330">代码在这</a> 。</p>
<h2><span id="类型推导">类型推导</span></h2><p>以前类似这样的代码在某些情况下没法正常进行推导：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">func F<span class="selector-attr">[T ~E[]</span>, E any](t T, callable func(E))</span><br><span class="line"></span><br><span class="line">func generic<span class="selector-attr">[E any]</span>(e E) &#123;&#125;</span><br><span class="line"><span class="built_in">F</span>(t, generic) <span class="comment">// before go1.21: error; after go1.21: ok</span></span><br></pre></td></tr></table></figure>

<p>理论上只要能推导出E的类型，那么<code>F</code>和<code>generic</code>的所有类型参数都能推导出来，哪怕<code>generic</code>本身是个泛型函数。以前想正常使用就得这么写：<code>F(t, generic[Type])</code>。</p>
<p>所以与其说是新特性，不如说是对类型推导的bug修复。</p>
<p>针对类型推导还有其他一些修复和报错信息的内容优化，但这些都没上面这个变化大，所以恕不赘述。</p>
<h2><span id="panic的行为变化">panic的行为变化</span></h2><p>1.21开始如果goroutine里有panic，那么这个goroutine里的defer里调用的recover必然不会返回nil值。</p>
<p>这导致了一个问题：recover的返回值是传给panic的参数的值，<code>panic(nil)</code>这样的代码怎么办？</p>
<p>先要提醒一下，<code>panic(nil)</code>本身是无意义的，且会导致recover的调用方无法判断究竟发生了什么，所以一直是被各类linter包括<code>go vet</code>命令警告的。然而这么写语法上完全正确，所以只有警告并不能解决问题。</p>
<p>解决办法是，如果现在使用<code>panic(nil)</code>或者<code>panic(值为nil的接口)</code>，recover会收到一个新类型的error：<code>*runtime.PanicNilError</code>。</p>
<p>总体上算是解决了问题，然而它把有类型的但值是nil的接口也给转换了，虽然从最佳实践的角度来讲panic一个空值的接口是不应该的，但多少还是会给使用上带来一些麻烦。</p>
<p>所以目前想要禁用这一行为的话，可以设置环境变量：<code>export GODEBUG=panicnil=1</code>。如果go.mod里声明的go版本小于等于1.20，这个环境变量的功能自动启用。</p>
<p>对于modules的变化，会在下一节讲解。</p>
<h2><span id="modules的变化">modules的变化</span></h2><p>最大的变化是现在mod文件里写的go版本号的意义改变了。</p>
<p>变成了：mod文件里写的go的版本意味着这个mod最低支持的golang版本是多少。</p>
<p>比如：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">module github.com/apocelipes/flatmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.21</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>意味着这个modules最低要求go的版本是<code>go1.21.0</code>，而且可以注意到，现在patch版本也算在内里，所以一个声明为<code>go 1.21.1</code>的modules没法被1.21.0版本的go编译。</p>
<p>这么做的好处是能严格控制自己的程序和库可以在哪些版本的golang上运行，且可以推动库版本和golang本身版本的升级。</p>
<p>如果严格按照官方要求使用语义版本来控制自己的modules的话，这个改动没有什么明显的坏处，唯一的缺点是只有1.21及更高版本的go工具链才有这样的功能。</p>
<p>这个变更对<code>go.work</code>文件同样适用。</p>
<h2><span id="包初始化顺序的改变">包初始化顺序的改变</span></h2><p>现在按新的顺序来初始化包：</p>
<ol>
<li>把所有的packages按导入路径进行排序（字符串字典顺序）存进一个列表</li>
<li>按要求和顺序找到列表里第一个符合条件的package，要求是这个package所有的import的包都已经完成初始化</li>
<li>初始化这个找到的包然后把它移出列表，接着重复第二步</li>
<li>列表为空的时候初始化流程结束</li>
</ol>
<p>这样做的好处是包的初始化顺序终于有明确的标准化的定义了，坏处有两点：</p>
<ol>
<li>以前的程序如果依赖于特定的初始化顺序，那么在新版本会出问题</li>
<li>现在可以通过修改package的导入路径（主要能改的部分是包的名字）和控制导入的包来做到让A包始终在B包之前初始化，因此B包的初始化流程里可以对A包公开出来的接口或者数据进行修改，这样做耦合性很高也不安全，尤其是B包如果是某个包含恶意代码的包的话。</li>
</ol>
<p>我们能做的只有遵守最佳实践：不要依赖特定的包直接的初始化顺序；以及在使用某个第三方库前要仔细考量。</p>
<h2><span id="编译器和runtime的变化">编译器和runtime的变化</span></h2><p>runtime的变化上，gc一如既往地得到了小幅度优化，现在对于gc压力较大的程序来说gc延迟和内存占用都会有所减少。</p>
<p>cgo也有优化，现在cgo函数调用最大可以比原先快一个数量级。</p>
<p>编译器的变化上比较显著的是这个：PGO已经可以正式投入生产使用。<a href="https://go.dev/doc/pgo">使用教程</a>。</p>
<p>PGO可以带来6%左右的性能提升，1.21凭借PGO和上个版本的优化现在不仅没有了泛型带来的编译速度减低，相比以前还有细微提升。</p>
<p>还有最后一个变化，这个和编译器关系：现在没有被使用的全局的map类型的变量（需要达到一定大小，且初始化的语句中没有任何副作用会产生），现在编译完成的程序里不会在包含这个变量。因为map本身占用内存且初始化需要花费一定时间（map越大花的时间越多）。这个好处是很实在的，既可以减小产生的二进制可执行文件的大小，又可以提升运行性能。但有个缺点，如果有什么程序要依赖编译好的可执行文件内部的某些数据的话，这个变更可能会带来麻烦，普通用户可以忽略这点。</p>
<h2><span id="新标准库">新标准库</span></h2><p>这个版本添加了大把的新标准库，一起来看看。</p>
<h3><span id="logslog和testingslogtest">log/slog和testing/slogtest</span></h3><p>官方提供的结构化日志库。</p>
<p>可以通过实现<code>slog.Handler</code>来定义自己的日志处理器，可以把日志转换成json等格式。标准库自带了很多预定义的处理器，比如json的：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br><span class="line">logger.Info(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;&quot;time&quot;:&quot;2023-08-09T15:28:26.000000000+09:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;hello&quot;,&quot;count&quot;:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>简单得说，就是个简化版的zap，如果想使用最基础的结构化日志的功能，又不想引入zap这样的库，那么slog是个很好的选择。</p>
<p>testing/slogtest里有帮助函数用来测试自己实现的日志处理器是否符合标准库的要求。</p>
<h3><span id="slices和maps">slices和maps</span></h3><p>把<code>golang.org/x/exp/slices</code>和<code>golang.org/x/exp/maps</code>引入了标准库。</p>
<p>slices库提供了排序、二分查找、拼接、增删改查等常用功能，sort这个标准库目前可以停止使用用slices来替代了。</p>
<p>maps提供了常见的对map的增删改查拼接合并等功能。</p>
<p>两个库使用泛型，且针对golang的slice和map进行了细致入微的优化，性能上比自己写的版本有更多优势，比标准库sort更是有数量级的碾压。</p>
<p>这两个库本来1.20就该被接收进标准库了，但因为需要重新设计api和进行优化，所以拖到1.21了。</p>
<h3><span id="cmp">cmp</span></h3><p>这个也是早该进入标准库的，但拖到了现在。随着slices、maps和新内置函数都进入了新版本，这个库想不接收也不行了。</p>
<p>这个库一共有三个东西：<code>Ordered</code>、<code>Less</code>、<code>Compare</code>。</p>
<p>最重要的是<code>Ordered</code>，它是所有可以使用内置运算符进行比较的类型的集合。</p>
<p><code>Less</code>和<code>Ordered</code>顾名思义用来比大小的，且只能比<code>Ordered</code>类型的大小。</p>
<p>之所以还有单独造出这两个函数，是因为他们对Nan有检查，比如：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Less reports whether x is less than y.</span></span><br><span class="line"><span class="comment">// For floating-point types, a NaN is considered less than any non-NaN,</span></span><br><span class="line"><span class="comment">// and -0.0 is not less than (is equal to) 0.0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Less</span>[<span class="title">T</span> <span class="title">Ordered</span>]<span class="params">(x, y T)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (isNaN(x) &amp;&amp; !isNaN(y)) || x &lt; y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以在泛型函数里不知道要比较的数据的类型是不是有float的时候，用cmp里提供的函数是最安全的</strong>。这就是他俩存在的意义。</p>
<p>但如果可以100%确定没有float存在，那么就不应该用<code>Less</code>等，应该直接用运算符去比较，因为大家都看到，Less和直接比较相比效率是较低的。</p>
<h2><span id="已有的标准库的变化">已有的标准库的变化</span></h2><p>因为是速览，所以我只挑重点说。</p>
<h3><span id="bytes">bytes</span></h3><p><code>bytes.Buffer</code>添加了<code>AvailableBuffer</code>和<code>Available</code>两个方法，分别返回目前可用的buf切片和可用的长度。主要可以配合<code>strconv.AppendInt</code>来使用，直接把数据写入buffer对应的内存里，可以提升性能。<strong>不要对<code>AvailableBuffer</code>返回的切片扩容，否则必然踩坑</strong>。</p>
<h3><span id="context">context</span></h3><p>新的<code>context.WithoutCancel</code>会把原来的<code>context.Context</code>复制一份，并去除cancel函数，这意味着原先被复制的上下文取消了这个新的上下文也将继续存在。例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">newCtx := context.WithoutCancel(ctx)</span><br><span class="line">cancel()</span><br><span class="line">&lt;-ctx.Done() <span class="comment">// ok, ctx has cancled.</span></span><br><span class="line">&lt;-newCtx.Done() <span class="comment">// error: dead lock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以会死锁，是因为<code>newCtx</code>没有被取消，Done返回的chan会永远阻塞住。而且更根本的，<code>newCtx</code>无法被取消。</p>
<p>新增了<code>context.WithDeadlineCause</code>和<code>context.WithTimeoutCause</code>，可以增加超时上下文被取消时的信息：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">d := time.Now().Add(shortDuration)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d, &amp;MyError&#123;<span class="string">&quot;my message&quot;</span>&#125;)</span><br><span class="line">cancel()</span><br><span class="line">context.Cause(ctx) <span class="comment">// --&gt; &amp;MyError&#123;&quot;my message&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然不如<code>context.WithCancelCause</code>灵活，但也很实用。</p>
<h3><span id="cryptosha256">crypto/sha256</span></h3><p>现在在x86_64平台上计算sha256会尽量利用硬件指令（simd和x86_64平台的SHA256ROUND等指令），这带来了3-4倍的性能提升。</p>
<h3><span id="net">net</span></h3><p>现在golang在Linux上已经初步支持Multipath TCP。有关Multipath TCP的信息可以在这查阅：<a href="https://www.multipath-tcp.org/">https://www.multipath-tcp.org/</a></p>
<h3><span id="reflect">reflect</span></h3><p>ValueOf现在会根据逃逸分析把值分配在栈上，以前都是直接分配到堆上的。对于比较小的类型来说可以获得10%以上的性能提升。利好很多使用反射的ORM框架。</p>
<p>新增了<code>Value.Clear</code>，对应第一节的clear内置函数，如果type不是map或者slice的话这个函数和其他反射的方法一样会panic。</p>
<h3><span id="runtime">runtime</span></h3><p>最值得一提的变化是新增了<code>runtime.Pinner</code>。</p>
<p>它的能力是可以让某个go的对象不会gc回收，一直到<code>Unpin</code>方法被调用。这个是为了方便cgo代码里让c使用go的对象而设计的。</p>
<p><strong>不要滥用这个接口，如果想告诉gc某个对象暂时不能回收，应该正确使用<code>runtime.KeepAlive</code></strong>。</p>
<p>runtime/trace现在有了很大的性能提升，因此观察程序行为的时候开销更小，更接近程序真实的负载。</p>
<h3><span id="sync">sync</span></h3><p>添加了<code>OnceFunc</code>、<code>OnceValue</code>、<code>OnceValues</code>这三个帮助函数。主要是为了简化代码。</p>
<p>1.21前：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> initFlag sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSomeThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">initFlag.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">真正的初始化逻辑</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 后续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在变成：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doInit = sync.OnceFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">真正的初始化逻辑</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSomeThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">doInit()</span><br><span class="line"><span class="comment">// 后续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码要简单点。</p>
<p><code>OnceValue</code>、<code>OnceValues</code>是函数带返回值的版本，支持一个和两个返回值的函数。</p>
<h3><span id="errors">errors</span></h3><p>新增了<code>errors.ErrUnsupported</code>。这个错误表示当前操作系统、硬件、协议、或者文件系统不支持某种操作。</p>
<p>目前os，filepath，syscall，io里的一些函数已经会返回这个错误，可以用<code>errors.Is(err, errors.ErrUnsupported)</code>来检查。</p>
<h3><span id="unicode">unicode</span></h3><p>升级到了最新的Unicode 15.0.0。</p>
<h2><span id="平台支持变化">平台支持变化</span></h2><p>新增了wasip1支持，这是一个对WASI（WebAssembly System Interface）的初步支持。</p>
<p>对于macOS，go1.21需要macOS 10.15 Catalina及以上版本。</p>
<p>龙芯上golang现在支持将代码编译为c的动态和静态链接库，基本上在龙芯上已经可以尝试投入生产环境了。</p>
<p>发版日志 <a href="https://go.dev/doc/go1.21">Go 1.21 Release Notes - The Go Programming Language</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言内存分配</title>
    <url>/57be14fe/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#基础概念">基础概念</a></li>
<li><a href="#内存管理单元">内存管理单元</a></li>
<li><a href="#内存管理组件">内存管理组件</a></li>
<li><a href="#mcache">mcache</a></li>
<li><a href="#mcentral">mcentral</a></li>
<li><a href="#mheap">mheap</a></li>
<li><a href="#分配流程">分配流程</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p>
<p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的 TCMalloc算法，全称 Thread-CachingMalloc。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p>
<h2><span id="基础概念">基础概念</span></h2><p>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。</p>
<p>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204105.png" alt></p>
<p><code>arena区域</code>就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成<code>8KB</code>大小的页，一些页组合起来称为<code>mspan</code>。</p>
<p><code>bitmap区域</code>标识<code>arena</code>区域哪些地址保存了对象，并且用<code>4bit</code>标志位表示对象是否包含指针、<code>GC</code>标记信息。<code>bitmap</code>中一个<code>byte</code>大小的内存对应<code>arena</code>区域中4个指针大小（指针大小为 8B ）的内存，所以<code>bitmap</code>区域的大小是<code>512GB/(4*8B)=16GB</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204132.png" alt></p>
<p>从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。</p>
<p><code>spans区域</code>存放<code>mspan</code>（也就是一些<code>arena</code>分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以<code>spans</code>区域的大小就是<code>512GB/8KB*8B=512MB</code>。除以8KB是计算<code>arena</code>区域的页数，而最后乘以8是计算<code>spans</code>区域所有指针的大小。创建<code>mspan</code>的时候，按页填充对应的<code>spans</code>区域，在回收<code>object</code>时，根据地址很容易就能找到它所属的<code>mspan</code>。</p>
<h2><span id="内存管理单元">内存管理单元</span></h2><p><code>mspan</code>：Go中内存管理的基本单元，是由一片连续的<code>8KB</code>的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：<code>mspan</code>是一个包含起始地址、<code>mspan</code>规格、页的数量等内容的双端链表。</p>
<p>每个<code>mspan</code>按照它自身的属性<code>Size Class</code>的大小分割成若干个<code>object</code>，每个<code>object</code>可存储一个对象。并且会使用一个位图来标记其尚未使用的<code>object</code>。属性<code>Size Class</code>决定<code>object</code>大小，而<code>mspan</code>只会分配给和<code>object</code>尺寸大小接近的对象，当然，对象的大小要小于<code>object</code>大小。还有一个概念：<code>Span Class</code>，它和<code>Size Class</code>的含义差不多，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Size_Class = Span_Class / <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这是因为其实每个 <code>Size Class</code>有两个<code>mspan</code>，也就是有两个<code>Span Class</code>。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。</p>
<p>如下图，<code>mspan</code>由一组连续的页组成，按照一定大小划分成<code>object</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204238.png" alt></p>
<p>Go1.9.2里<code>mspan</code>的<code>Size Class</code>共有67种，每种<code>mspan</code>分割的object大小是8*2n的倍数，这个是写死在代码里的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="type">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>,<span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>mspan</code>的<code>Size Class</code>可以得到它划分的<code>object</code>大小。 比如<code>Size Class</code>等于3，<code>object</code>大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个<code>object</code>中。</p>
<p>数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型<code>Size Class</code>为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过<code>mspan</code>来分配。</p>
<p>对于mspan来说，它的<code>Size Class</code>会决定它所能分到的页数，这也是写死在代码里的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/sizeclasses.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="type">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>比如当我们要申请一个<code>object</code>大小为<code>32B</code>的<code>mspan</code>的时候，在class_to_size里对应的索引是3，而索引3在<code>class_to_allocnpages</code>数组里对应的页数就是1。</p>
<p><code>mspan</code>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    next *mspan </span><br><span class="line">    <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    prev *mspan </span><br><span class="line">    <span class="comment">// 起始地址，也即所管理页的地址</span></span><br><span class="line">    startAddr <span class="type">uintptr</span> </span><br><span class="line">    <span class="comment">// 管理的页数</span></span><br><span class="line">    npages <span class="type">uintptr</span> </span><br><span class="line">    <span class="comment">// 块个数，表示有多少个块可供分配</span></span><br><span class="line">    nelems <span class="type">uintptr</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配位图，每一位代表一个块是否已分配</span></span><br><span class="line">    allocBits *gcBits </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已分配块的个数</span></span><br><span class="line">    allocCount <span class="type">uint16</span> </span><br><span class="line">    <span class="comment">// class表中的class ID，和Size Classs相关</span></span><br><span class="line">    spanclass spanClass  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// class表中的对象大小，也即块大小</span></span><br><span class="line">    elemsize <span class="type">uintptr</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>mspan</code>放到更大的视角来看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204350.png" alt></p>
<p>上图可以看到有两个<code>S</code>指向了同一个<code>mspan</code>，因为这两个<code>S</code>指向的<code>P</code>是同属一个<code>mspan</code>的。所以，通过<code>arena</code>上的地址可以快速找到指向它的<code>S</code>，通过<code>S</code>就能找到<code>mspan</code>，回忆一下前面我们说的<code>mspan</code>区域的每个指针对应一页。</p>
<p>假设最左边第一个<code>mspan</code>的<code>Size Class</code>等于10，根据前面的<code>class_to_size</code>数组，得出这个<code>msapn</code>分割的<code>object</code>大小是144B，算出可分配的对象个数是<code>8KB/144B=56.89</code>个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有<code>Size Class</code>的<code>mspan</code>浪费的内存的大小；再根据<code>class_to_allocnpages</code>数组，得到这个<code>mspan</code>只由1个<code>page</code>组成；假设这个<code>mspan</code>是分配给无指针对象的，那么<code>spanClass</code>等于20。</p>
<p><code>startAddr</code>直接指向<code>arena</code>区域的某个位置，表示这个<code>mspan</code>的起始地址，<code>allocBits</code>指向一个位图，每位代表一个块是否被分配了对象；<code>allocCount</code>则表示总共已分配的对象个数。</p>
<p>这样，左起第一个<code>mspan</code>的各个字段参数就如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204458.png" alt></p>
<h2><span id="内存管理组件">内存管理组件</span></h2><p>内存分配由内存分配器完成。分配器由3种组件构成：<code>mcache</code>, <code>mcentral</code>, <code>mheap</code>。</p>
<h2><span id="mcache">mcache</span></h2><p><code>mcache</code>：每个工作线程都会绑定一个mcache，本地缓存可用的<code>mspan</code>资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。</p>
<p><code>mcache</code>的结构体定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcache.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [numSpanClasses]*mspan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>67*2=134</code>，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的<code>mspan</code>中分配的对象不包含指针，另一半则包含指针。</p>
<p>对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204550.png" alt></p>
<p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p>
<h2><span id="mcentral">mcentral</span></h2><p><code>mcentral</code>：为所有<code>mcache</code>提供切分好的<code>mspan</code>资源。每个<code>central</code>保存一种特定大小的全局<code>mspan</code>列表，包括已分配出去的和未分配出去的。 每个<code>mcentral</code>对应一种<code>mspan</code>，而<code>mspan</code>的种类导致它分割的<code>object</code>大小不同。当工作线程的<code>mcache</code>中没有合适（也就是特定大小的）的<code>mspan</code>时就会从<code>mcentral</code>获取。</p>
<p><code>mcentral</code>被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mcentral.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    lock mutex </span><br><span class="line">    <span class="comment">// 规格</span></span><br><span class="line">    sizeclass <span class="type">int32</span> </span><br><span class="line">    <span class="comment">// 尚有空闲object的mspan链表</span></span><br><span class="line">    nonempty mSpanList </span><br><span class="line">    <span class="comment">// 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表</span></span><br><span class="line">    empty mSpanList </span><br><span class="line">    <span class="comment">// 已累计分配的对象个数</span></span><br><span class="line">    nmalloc <span class="type">uint64</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204644.png" alt></p>
<p><code>empty</code>表示这条链表里的<code>mspan</code>都被分配了<code>object</code>，或者是已经被<code>cache</code>取走了的<code>mspan</code>，这个<code>mspan</code>就被那个工作线程独占了。而<code>nonempty</code>则表示有空闲对象的<code>mspan</code>列表。每个<code>central</code>结构体都在<code>mheap</code>中维护。</p>
<p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p>
<ul>
<li>获取 加锁；从<code>nonempty</code>链表找到一个可用的<code>mspan</code>；并将其从<code>nonempty</code>链表删除；将取出的<code>mspan</code>加入到<code>empty</code>链表；将<code>mspan</code>返回给工作线程；解锁。</li>
<li>归还 加锁；将<code>mspan</code>从<code>empty</code>链表删除；将<code>mspan</code>加入到<code>nonempty</code>链表；解锁。</li>
</ul>
<h2><span id="mheap">mheap</span></h2><p><code>mheap</code>：代表Go程序持有的所有堆空间，Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p>
<p>当<code>mcentral</code>没有空闲的<code>mspan</code>时，会向<code>mheap</code>申请。而<code>mheap</code>没有资源时，会向操作系统申请新内存。<code>mheap</code>主要用于大对象的内存分配，以及管理未切割的<code>mspan</code>，用于给<code>mcentral</code>切割成小对象。</p>
<p>同时我们也看到，<code>mheap</code>中含有所有规格的<code>mcentral</code>，所以，当一个<code>mcache</code>从<code>mcentral</code>申请<code>mspan</code>时，只需要在独立的<code>mcentral</code>中使用锁，并不会影响申请其他规格的<code>mspan</code>。</p>
<p><code>mheap</code>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//path: /usr/local/go/src/runtime/mheap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// spans: 指向mspans区域，用于映射mspan和page的关系</span></span><br><span class="line">    spans []*mspan </span><br><span class="line">    <span class="comment">// 指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span><br><span class="line">    bitmap <span class="type">uintptr</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示arena区首地址</span></span><br><span class="line">    arena_start <span class="type">uintptr</span> </span><br><span class="line">    <span class="comment">// 指示arena区已使用地址位置</span></span><br><span class="line">    arena_used  <span class="type">uintptr</span> </span><br><span class="line">    <span class="comment">// 指示arena区末地址</span></span><br><span class="line">    arena_end   <span class="type">uintptr</span> </span><br><span class="line"></span><br><span class="line">    central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="type">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204738.png" alt></p>
<p>上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。</p>
<h2><span id="分配流程">分配流程</span></h2><p>变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是”zero garbage”，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。</p>
<p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。</p>
<p>大体上的分配流程：</p>
<ul>
<li>32KB 的对象，直接从mheap上分配；</li>
<li>&lt;=16B 的对象使用mcache的tiny分配器分配；</li>
<li>(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；</li>
<li>如果mcache没有相应规格大小的mspan，则向mcentral申请</li>
<li>如果mcentral没有相应规格大小的mspan，则向mheap申请</li>
<li>如果mheap中也没有合适大小的mspan，则向操作系统申请</li>
</ul>
<h2><span id="总结">总结</span></h2><ul>
<li>Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li>
<li>Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。</li>
<li>mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。</li>
<li>极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。</li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的反射</title>
    <url>/1d3c1f0e/</url>
    <content><![CDATA[<h4><span id="编程语言中反射的概念">编程语言中反射的概念</span></h4><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
<p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p>
<p>Golang的gRPC也是通过反射实现的。</p>
<h4><span id="interface-和反射">interface 和反射</span></h4><p>先来看看Golang关于类型设计的一些原则</p>
<ul>
<li>变量包括（value, type）两部分<ul>
<li>理解这一点就知道为什么nil != nil了</li>
</ul>
</li>
<li>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</li>
<li>类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</li>
</ul>
<p>反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p>
<p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p>
<p><code>(value, type)</code></p>
<p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p>
<p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)</span><br><span class="line"></span><br><span class="line">var r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>

<p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>

<p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p>
<p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p>
<h4><span id="reflect-基本功能typeof和valueof">reflect 基本功能TypeOf和ValueOf</span></h4><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ValueOf returns a new Value initialized to the concrete value</span><br><span class="line">// stored in the interface i.  ValueOf(nil) returns the zero </span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><br><span class="line">// If i is a nil interface value, TypeOf returns nil.</span><br><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</span><br></pre></td></tr></table></figure>

<p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;type: &quot;, reflect.TypeOf(num))</span><br><span class="line">	fmt.Println(&quot;value: &quot;, reflect.ValueOf(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">type:  float64</span><br><span class="line">value:  1.2345</span><br></pre></td></tr></table></figure>

<h4><span id="说明">说明</span></h4><ol>
<li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li>
<li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li>
<li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li>
</ol>
<h4><span id="从relfectvalue中获取接口interface的信息">从relfect.Value中获取接口interface的信息</span></h4><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p>
<p><strong>已知原有类型【进行“强制转换”】</strong></p>
<p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var num float64 = 1.2345</span><br><span class="line"></span><br><span class="line">	pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">	// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span><br><span class="line">	// Golang 对类型要求非常严格，类型一定要完全符合</span><br><span class="line">	// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span><br><span class="line">	convertPointer := pointer.Interface().(*float64)</span><br><span class="line">	convertValue := value.Interface().(float64)</span><br><span class="line"></span><br><span class="line">	fmt.Println(convertPointer)</span><br><span class="line">	fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">0xc42000e238</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure>

<h5><span id="说明">说明</span></h5><ol>
<li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li>
<li>转换的时候，要区分是指针还是指</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
</ol>
<p><strong>未知原有类型【遍历探测其Filed】</strong></p>
<p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">	Id   int</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFunc() &#123;</span><br><span class="line">	fmt.Println(&quot;Allen.Wu ReflectCallFunc&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line"></span><br><span class="line">	DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="line">func DoFiledAndMethod(input interface&#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">	getType := reflect.TypeOf(input)</span><br><span class="line">	fmt.Println(&quot;get Type is :&quot;, getType.Name())</span><br><span class="line"></span><br><span class="line">	getValue := reflect.ValueOf(input)</span><br><span class="line">	fmt.Println(&quot;get all Fields is:&quot;, getValue)</span><br><span class="line"></span><br><span class="line">	// 获取方法字段</span><br><span class="line">	// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="line">	// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="line">	// 3. 最后通过Field的Interface()得到对应的value</span><br><span class="line">	for i := 0; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">		field := getType.Field(i)</span><br><span class="line">		value := getValue.Field(i).Interface()</span><br><span class="line">		fmt.Printf(&quot;%s: %v = %v\n&quot;, field.Name, field.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 获取方法</span><br><span class="line">	// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br><span class="line">	for i := 0; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">		m := getType.Method(i)</span><br><span class="line">		fmt.Printf(&quot;%s: %v\n&quot;, m.Name, m.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">get Type is : User</span><br><span class="line">get all Fields is: &#123;1 Allen.Wu 25&#125;</span><br><span class="line">Id: int = 1</span><br><span class="line">Name: string = Allen.Wu</span><br><span class="line">Age: int = 25</span><br><span class="line">ReflectCallFunc: func(main.User)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5><span id="说明">说明</span></h5><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumField进行遍历</li>
<li>再通过reflect.Type的Field获取其Field</li>
<li>最后通过Field的Interface()得到对应的value</li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<p><strong>通过reflect.Value设置实际变量的值</strong></p>
<p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	var num float64 = 1.2345</span><br><span class="line">	fmt.Println(&quot;old value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">	// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br><span class="line">	pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;type of pointer:&quot;, newValue.Type())</span><br><span class="line">	fmt.Println(&quot;settability of pointer:&quot;, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">	// 重新赋值</span><br><span class="line">	newValue.SetFloat(77)</span><br><span class="line">	fmt.Println(&quot;new value of pointer:&quot;, num)</span><br><span class="line"></span><br><span class="line">	////////////////////</span><br><span class="line">	// 如果reflect.ValueOf的参数不是指针，会如何？</span><br><span class="line">	pointer = reflect.ValueOf(num)</span><br><span class="line">	//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: 1.2345</span><br><span class="line">type of pointer: float64</span><br><span class="line">settability of pointer: true</span><br><span class="line">new value of pointer: 77</span><br></pre></td></tr></table></figure>

<h4><span id="说明">说明</span></h4><ol>
<li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li>
<li>如果传入的参数不是指针，而是变量，那么<ul>
<li>通过Elem获取原始值对应的对象则直接panic</li>
<li>通过CanSet方法查询是否可以设置返回false</li>
</ul>
</li>
<li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li>
<li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li>
<li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<p><strong>通过reflect.ValueOf来进行方法的调用</strong></p>
<p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">	Id   int</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncHasArgs(name string, age int) &#123;</span><br><span class="line">	fmt.Println(&quot;ReflectCallFuncHasArgs name: &quot;, name, &quot;, age:&quot;, age, &quot;and origal User.Name:&quot;, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) ReflectCallFuncNoArgs() &#123;</span><br><span class="line">	fmt.Println(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何通过反射来进行方法的调用？</span><br><span class="line">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	user := User&#123;1, &quot;Allen.Wu&quot;, 25&#125;</span><br><span class="line">	</span><br><span class="line">	// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span><br><span class="line">	getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">	// 一定要指定参数为正确的方法名</span><br><span class="line">	// 2. 先看看带有参数的调用方法</span><br><span class="line">	methodValue := getValue.MethodByName(&quot;ReflectCallFuncHasArgs&quot;)</span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(&quot;wudebao&quot;), reflect.ValueOf(30)&#125;</span><br><span class="line">	methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">	// 一定要指定参数为正确的方法名</span><br><span class="line">	// 3. 再看看无参数的调用方法</span><br><span class="line">	methodValue = getValue.MethodByName(&quot;ReflectCallFuncNoArgs&quot;)</span><br><span class="line">	args = make([]reflect.Value, 0)</span><br><span class="line">	methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span><br><span class="line">ReflectCallFuncNoArgs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="说明">说明</span></h4><ol>
<li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li>
<li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li>
<li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li>
<li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li>
<li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li>
</ol>
<p><strong>golang的反射reflect性能</strong></p>
<p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field field = clazz.getField(&quot;hello&quot;);</span><br><span class="line">field.get(obj1);</span><br><span class="line">field.get(obj2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。</p>
<p>但是Golang的反射不是这样设计的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type_ := reflect.TypeOf(obj)</span><br><span class="line">field, _ := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type_ := reflect.ValueOf(obj)</span><br><span class="line">fieldValue := type_.FieldByName(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p>
<p>Golang reflect慢主要有两个原因</p>
<ol>
<li>涉及到内存分配以及后续的GC；</li>
<li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li>
</ol>
<h4><span id="总结">总结</span></h4><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p>
<ul>
<li>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地<ul>
<li>反射必须结合interface才玩得转</li>
<li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li>
</ul>
</li>
<li>反射可以将“接口类型变量”转换为“反射类型对象”<ul>
<li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li>
</ul>
</li>
<li>反射可以将“反射类型对象”转换为“接口类型变量<ul>
<li>reflect.value.Interface().(已知的类型)</li>
<li>遍历reflect.Type的Field获取其Field</li>
</ul>
</li>
<li>反射可以修改反射类型对象，但是其值必须是“addressable”<ul>
<li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li>
</ul>
</li>
<li>通过反射可以“动态”调用方法</li>
<li>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang编译器漏洞和标准库设计失误</title>
    <url>/4fe063a2/</url>
    <content><![CDATA[<p>字节切片（byte slice）相关的编译器漏洞和标准库设计失误</p>
<p>假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  x = []byte(y) // error: 非法的转换</span><br><span class="line">  y = []MyByte(x) // error: 非法的转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如上例所示，在Go中，这两个类型的值之间的类型转换是非法的。因为Go规定两个切片只有在它们的类型的底层类型（underlying type）相同的情况下才能转换到对方的类型。而一个非定义类型（undefined type）的底层类型为此非定义类型本身。类型[]MyByte和[]byte均为非定义类型，所以它们的底层类型不同，从而它们的值也就不能转换到对方的类型。</p>
<p>难道真没有办法实现它们之间的转换了？有，而且有好几种。第一种方法是使用类型非安全指针来实现双向转换，另外两种方法只能实现单向转换。另外的这两种方法要么利用了编译器的漏洞，要么利用了reflect标准库包的设计失误。</p>
<p><strong>使用类型非安全指针的实现。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  p := unsafe.Pointer(&amp;y)</span><br><span class="line">  x = *(*[]byte)(p)</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用类型非安全指针的实现中，转换结果和原切片共享底层元素。</p>
<p><strong>利用标准编译器的bug</strong></p>
<p>我们可以将一个[]byte切片值转换为string, 再把string转换为类型[]MyByte。转换结果和原切片不共享底层元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go白皮书提到一个字节切片可以转换为一个字符串，反之亦然。但是什么是字节切片类型呢？底层类型为[]byte的切片类型还是元素类型的底层类型为byte的切片类型？如果字节切片类型定义为<strong>元素类型的底层类型为byte的切片类型</strong>，则[]MyByte和[]byte都可称为字节切片类型。如果字节切片类型定义为<strong>底层类型为[]byte的切片类型</strong>，则只有[]byte可以被称为字节切片类型。我们认为标准编译器采纳了<strong>底层类型为[]byte的切片类型才称为字节切片</strong>这一定义，因为下面这个程序使用标准编译器是编译不过的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">  _ = string(y) // error: 非法转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，标准编译器（v1.12）却认为转换[]MyByte(“abc”)是合法的。这显然是一个漏洞。</p>
<p>对于码点切片（rune slice）和字符串之间的转换，同样的情况也存在。</p>
<p>对于gccgo编译器来说，此漏洞是对称的，因而更严重。此更严重的漏洞使得上述两种类型的值之间的转换是双向有效的。比如，下面这段代码使用gccgo（v8.0）编译是没问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = []MyByte(string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  x = []byte(string(y))</span><br><span class="line">  x[0] = 127</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，gccgo编译器在内置copy和append函数的实现中也存在着同样的漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  copy(y, string(x))</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 下一行利用了编译器漏洞</span><br><span class="line">  y = append([]MyByte(nil), string(x)...)</span><br><span class="line">  y[0] = 99</span><br><span class="line">  println(x[0]) // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方法利用了<code>reflect</code>标准库包的设计失误。此失误导致将<code>[]MyByte</code>值单向转换为类型<code>[]byte</code>是可行的，虽然这违反了Go类型系统确定的规则。使用第三种方法得到的结果切片和原切片共享底层元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;reflect&quot;</span><br><span class="line"></span><br><span class="line">type MyByte byte</span><br><span class="line">var (</span><br><span class="line">  x = []byte&#123;1, 2, 3&#125;</span><br><span class="line">  y = []MyByte&#123;1, 2, 3&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  v := reflect.ValueOf(y)</span><br><span class="line">  x = v.Bytes()</span><br><span class="line">  x[0] = 99</span><br><span class="line">  println(y[0]) // 99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Go中的模糊测试</title>
    <url>/dfd7f257/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#什么是模糊测试">什么是模糊测试？</a></li>
<li><a href="#go-中的软件测试">Go 中的软件测试</a></li>
<li><a href="#新增对模糊测试的支持">新增对模糊测试的支持</a></li>
<li><a href="#安装-gotip-来获取最新的功能">安装 gotip 来获取最新的功能</a></li>
<li><a href="#社区对于模糊测试的观点">社区对于模糊测试的观点</a></li>
<li><a href="#现实中的模糊测试">现实中的模糊测试</a></li>
<li><a href="#为什么在-go-中新增对模糊测试的原生支持">为什么在 Go 中新增对模糊测试的原生支持</a></li>
<li><a href="#模糊测试工具">模糊测试工具</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>Go 团队接受了新增对模糊测试的支持的提议。</p>
</blockquote>
<p><a href="https://go.dev/">Go</a> 的应用越来越广泛。现在它是云原生软件、容器软件、命令行工具和数据库等等的首选语言。Go 很早之前就已经有了内建的 <a href="https://pkg.go.dev/testing">对测试的支持</a>。这使得写测试代码和运行都相当简单。</p>
<h3><span id="什么是模糊测试">什么是模糊测试？</span></h3><p><ruby>模糊测试<rt>fuzz testing</rt></ruby>（fuzzing）是指向你的软件输入非预期的数据。理想情况下，这种测试会让你的应用程序崩溃或有非预期的表现。抛开最终的结果，从程序对非预期的输入数据的处理结果中你可以得到很多信息，这样你就可以增加一些合适的错误处理。</p>
<p>任何一个软件都有对不同来源的输入或数据的接收说明，软件会对这些数据进行处理并返回适当的结果。软件开发后，测试工程师团队对其进行测试，找出软件中的错误，给出测试报告，并（由开发者）修复。通常测试的目的是验证软件的行为是否符合预期。测试又可以细分为不同的类型，如功能测试、集成测试、性能测试等等。每种测试方法关注软件功能的某一个方面，以便发现错误或者提升可靠性或性能。</p>
<p>模糊测试在这一测试过程上更进一步，尝试向软件程序输入一些“无效”或“随机”的数据。这种输入是故意的，期望得到的结果就是程序崩溃或输出异常，这样就可以暴露程序中的错误以便由开发者来修复它们。与其他测试类似，很少需要手动进行模糊测试，业界有大量的模糊测试工具可以将这个过程自动化。</p>
<h3><span id="go-中的软件测试">Go 中的软件测试</span></h3><p>举个例子，假如你想测试 <code>add.go</code> 中的 <code>Add()</code> 函数，你可以在 <code>add_test.go</code> 中导入 <code>testing</code> 包并把测试体写在以 <code>TestXXX()</code>  开头的函数内。</p>
<p>考虑如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func Add(num1, num2 int) int &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>add_test.go</code> 文件中，你可能有如下测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test</span><br></pre></td></tr></table></figure>

<h3><span id="新增对模糊测试的支持">新增对模糊测试的支持</span></h3><p>Go 团队已经接受了 <a href="https://github.com/golang/go/issues/44551">新增对模糊测试的支持的提议</a>，以进一步推动这项工作。这涉及到新增一个 <code>testing.F</code> 类型，在 <code>_test.go</code> 文件中新增 <code>FuzzXXX()</code> 函数，在 Go 工具中会新增一个 <code>-fuzz</code> 选项来执行这些测试。</p>
<p>在 <code>add_test.go</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func FuzzAdd(f *testing.F) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go test -fuzz</span><br></pre></td></tr></table></figure>

<p>在本文编写时，这个 <a href="https://go.dev/blog/fuzz-beta">功能还是试验性的</a>，但是应该会在 1.18 发布版本中包含。（LCTT 译注：<a href="https://go.dev/blog/go1.18">Go 1.18</a> 刚刚发布，已经包含了对模糊测试的支持）目前很多功能如 <code>-keepfuzzing</code>、<code>-race</code> 等也还没有支持。Go 团队最近发布了一篇 <a href="https://go.dev/doc/tutorial/fuzz">模糊测试教程</a>，值得读一下。</p>
<h3><span id="安装-gotip-来获取最新的功能">安装 gotip 来获取最新的功能</span></h3><p>如果你极度渴望在正式发布之前尝试这些功能，你可以使用 <code>gotip</code> 来测试即将正式发布的 Go 功能并反馈给他们。你可以使用下面的命令来安装 <code>gotip</code>。安装之后，你可以用 <code>gotip</code> 程序代替以前的 <code>go</code> 程序来编译和运行程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go install golang.org/dl/gotip@latest</span><br><span class="line">$ gotip download</span><br><span class="line"></span><br><span class="line">$ gotip version</span><br><span class="line">go version devel go1.18-f009910 Thu Jan 6 16:22:21 2022 +0000 linux/amd64</span><br></pre></td></tr></table></figure>

<h3><span id="社区对于模糊测试的观点">社区对于模糊测试的观点</span></h3><p>软件社区中经常会讨论模糊测试，不同的人对模糊测试有不同的看法。有些人认为这是一种有用的技术，可以找到错误，尤其是在安全方面。然而考虑到模糊测试所需要的资源（CPU、内存），有人就认为这是一种浪费，而他们更愿意用其他的测试方法。即使在 Go 团队内部，意见也不统一。我们可以看到 Go 的联合创始人 Rob Pike 对模糊测试的使用和在 Go 中的实现是持轻微的怀疑态度的。</p>
<blockquote>
<p>…<em>虽然模糊测试有助于发现某类错误，但是它会占用大量的 CPU 和存储资源，并且效益成本比率也不明确。我担心为了写模糊测试浪费精力，或者 git 仓库中充斥大量无用的测试数据</em></p>
<p>~<a href="https://github.com/golang/go/issues/44551#issuecomment-784584785">Rob Pike</a></p>
</blockquote>
<p>然而，Go 安全团队的另一个成员，Filo Sottile，似乎对 Go 新增支持模糊测试很乐观，举了很多例子来支持，也希望模糊测试能成为开发过程中的一部分。</p>
<blockquote>
<p><em>我想说模糊测试可以发现极端情况下的错误。这是我们作为安全团队对其感兴趣的原因：在极端情况下发现的错误可以避免在生产环境中成为弱点。</em></p>
<p><em>我们希望模糊测试能成为开发的一部分 —— 不只是构建或安全方面 —— 而是整个开发过程：它能提升相关代码的质量…</em></p>
<p>~<a href="https://github.com/golang/go/issues/44551#issuecomment-784655571">Filo Sottile</a></p>
</blockquote>
<h3><span id="现实中的模糊测试">现实中的模糊测试</span></h3><p>对我而言，模糊测试在发现错误以及让系统变得更安全和更有弹性方面似乎非常有效。举个例子，Linux 内核也会使用名为 <a href="https://github.com/google/syzkaller">syzkaller</a> 的工具进行模糊测试，这个工具已经发现了 <a href="https://github.com/google/syzkaller/blob/master/docs/linux/found_bugs.md">大量</a> 错误。</p>
<p><a href="https://github.com/google/AFL">AFL</a> 也是比较流行的模糊测试工具，用来测试 C/C++ 写的程序。</p>
<p>之前也有对 Go 程序进行模糊测试的观点，其中之一就是 Filo 在 GitHub 评论中提到的 <a href="https://github.com/dvyukov/go-fuzz">go-fuzz</a>。</p>
<blockquote>
<p><em>go-fuzz 的记录提供了相当惊人的证据，证明模糊处理能很好地找到人类没有发现的错误。根据我的经验，我们只需要消耗一点点 CPU 的时间就可以得到极端情况下非常高效的测试结果。</em></p>
</blockquote>
<h3><span id="为什么在-go-中新增对模糊测试的原生支持">为什么在 Go 中新增对模糊测试的原生支持</span></h3><p>如果我们的需求是对 Go 程序进行模糊测试，之前的工具像 <code>go-fuzz</code> 就可以完成，那么为什么要在这种语言中增加原生支持呢？<a href="https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md">Go 模糊测试设计草案</a> 中说明了这样做的一些根本原因。设计的思路是让开发过程更简单，因为前面说的工具增加了开发者的工作量，还有功能缺失。如果你没有接触过模糊测试，那么我建议你读一下设计草案文档。</p>
<blockquote>
<p>开发者可以使用诸如 <code>go-fuzz</code> 或 <code>fzgo</code>（基于 <code>go-fuzz</code>）来解决某些需求。然而，已有的每种解决方案都需要在典型的 Go 测试上做更多的事，而且还缺少关键的功能。相比于其他的 Go 测试（如基准测试和单元测试），模糊测试不应该比它们复杂，功能也不应该比它们少。已有的解决方案增加了额外的开销，比如自定义命令行工具。</p>
</blockquote>
<h3><span id="模糊测试工具">模糊测试工具</span></h3><p>在大家期望 Go 语言新增功能的列表中，模糊测试是其中很受欢迎的一项。虽然现在还是试验性的，但在将要到来的发布版本中会变得更强大。这给了我们足够的时间去尝试它以及探索它的使用场景。我们不应该把它视为一种开销，如果使用得当它会是一种发现错误非常高效的测试工具。使用 Go 的团队应该推动它的使用，开发者可以写简单的模糊测试，测试团队去慢慢扩展以此来使用它全部的能力。</p>
<hr>
<p>via: <a href="https://opensource.com/article/22/1/native-go-fuzz-testing">https://opensource.com/article/22/1/native-go-fuzz-testing</a></p>
<p>作者：<a href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中用exec执行命令的五种姿势</title>
    <url>/a9bb05dc/</url>
    <content><![CDATA[<p>在 Golang 中用于执行命令的库是 <code>os/exec</code>，exec.Command 函数返回一个 <code>Cmd</code> 对象，根据不同的需求，可以将命令的执行分为三种情况</p>
<ol>
<li>只执行命令，不获取结果</li>
<li>执行命令，并获取结果（不区分 stdout 和 stderr）</li>
<li>执行命令，并获取结果（区分 stdout 和 stderr）</li>
</ol>
<h2><span id="第一种只执行命令不获取结果">第一种：只执行命令，不获取结果</span></h2><p>直接调用 Cmd 对象的 Run 函数，返回的只有成功和失败，获取不到任何输出的结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/log/&quot;</span>)</span><br><span class="line">err := cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="第二种执行命令并获取结果">第二种：执行命令，并获取结果</span></h2><p>有时候我们执行一个命令就是想要获取输出结果，此时你可以调用 Cmd 的 CombinedOutput 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/log/&quot;</span>)</span><br><span class="line">out, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;combined out:\n%s\n&quot;</span>, <span class="type">string</span>(out))</span><br><span class="line">log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;combined out:\n%s\n&quot;</span>, <span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CombinedOutput 函数，只返回 out，并不区分 stdout 和 stderr。如果你想区分他们，可以直接看第三种方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go </span><br><span class="line">combined out:</span><br><span class="line">total 11540876</span><br><span class="line">-rw-r--r--  2 root       root         4096 Oct 29  2018 yum.log</span><br><span class="line">drwx------  2 root       root           94 Nov  6 05:56 audit</span><br><span class="line">-rw-r--r--  1 root       root    185249234 Nov 28  2019 message</span><br><span class="line">-rw-r--r--  2 root       root        16374 Aug 28 10:13 boot.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过在那之前，我却发现一个小问题：有时候，shell 命令能执行，并不代表代码 exec 也能执行。</p>
<p>比如我只想查看 <code>/var/log/</code> 目录下的 log 后缀名的文件呢？shell命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /var/log/*.<span class="built_in">log</span></span><br><span class="line">total 11540</span><br><span class="line">-rw-r--r--  2 root       root         4096 Oct 29  2018 /var/log/yum.log</span><br><span class="line">-rw-r--r--  2 root       root        16374 Aug 28 10:13 /var/log/boot.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按照这个写法将它放入到 <code>exec.Command</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/log/*.log&quot;</span>)</span><br><span class="line">out, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;combined out:\n%s\n&quot;</span>, <span class="type">string</span>(out))</span><br><span class="line">log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;combined out:\n%s\n&quot;</span>, <span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>什么情况？居然不行，报错了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go </span><br><span class="line">combined out:</span><br><span class="line"><span class="built_in">ls</span>: cannot access /var/log/*.<span class="built_in">log</span>: No such file or directory</span><br><span class="line"></span><br><span class="line">2020/11/11 19:46:00 cmd.Run() failed with <span class="built_in">exit</span> status 2</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么会报错呢？</p>
<p>其实很简单，原来 <code>ls -l /var/log/*.log</code> 并不等价于下面这段代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/log/*.log&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这段代码对应的 Shell 命令应该是下面这样，如果你这样子写，ls 就会把参数里的内容当成具体的文件名，而忽略通配符 <code>*</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l <span class="string">&quot;/var/log/*.log&quot;</span></span><br><span class="line"><span class="built_in">ls</span>: cannot access /var/log/*.<span class="built_in">log</span>: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="第三种执行命令并区分stdout-和-stderr">第三种：执行命令，并区分stdout 和 stderr</span></h2><p>上面的写法，无法实现区分标准输出和标准错误，只要换成下面种写法，就可以实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/log/*.log&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> stdout, stderr bytes.Buffer</span><br><span class="line">cmd.Stdout = &amp;stdout  <span class="comment">// 标准输出</span></span><br><span class="line">cmd.Stderr = &amp;stderr  <span class="comment">// 标准错误</span></span><br><span class="line">err := cmd.Run()</span><br><span class="line">outStr, errStr := <span class="type">string</span>(stdout.Bytes()), <span class="type">string</span>(stderr.Bytes())</span><br><span class="line">fmt.Printf(<span class="string">&quot;out:\n%s\nerr:\n%s\n&quot;</span>, outStr, errStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下，可以看到前面的报错内容被归入到标准错误里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go </span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line"><span class="built_in">ls</span>: cannot access /var/log/*.<span class="built_in">log</span>: No such file or directory</span><br><span class="line"></span><br><span class="line">2020/11/11 19:59:31 cmd.Run() failed with <span class="built_in">exit</span> status 2</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="第四种多条命令组合请使用管道">第四种：多条命令组合，请使用管道</span></h2><p>将上一条命令的执行输出结果，做为下一条命令的参数。在 Shell 中可以使用管道符 <code>|</code> 来实现。</p>
<p>比如下面这条命令，统计了 message 日志中 ERROR 日志的数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep ERROR /var/log/messages | <span class="built_in">wc</span> -l</span><br><span class="line">19</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似的，在 Golang 中也有类似的实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">CopyCopypackage main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;/var/log/messages&quot;</span>)</span><br><span class="line">    c2 := exec.Command(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>)</span><br><span class="line">    c2.Stdin, _ = c1.StdoutPipe()</span><br><span class="line">    c2.Stdout = os.Stdout</span><br><span class="line">    _ = c2.Start()</span><br><span class="line">    _ = c1.Run()</span><br><span class="line">    _ = c2.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go </span><br><span class="line">19</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="第五种设置命令级别的环境变量">第五种：设置命令级别的环境变量</span></h2><p>使用 os 库的 Setenv 函数来设置的环境变量，是作用于整个进程的生命周期的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">os.Setenv(<span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;myname&quot;</span>)</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;echo&quot;</span>, os.ExpandEnv(<span class="string">&quot;$NAME&quot;</span>))</span><br><span class="line">out, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;cmd.Run() failed with %s\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>, out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只要在这个进程里，<code>NAME</code> 这个变量的值都会是 <code>myname</code>，无论你执行多少次命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go </span><br><span class="line">myname</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想把环境变量的作用范围再缩小到命令级别，也是有办法的。</p>
<p>为了方便验证，我新建个 sh 脚本，内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /home/myname/demo.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line">$ bash /home/myname/demo.sh   <span class="comment"># 由于全局环境变量中没有 NAME，所以无输出</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，demo.go 里的代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChangeYourCmdEnvironment</span><span class="params">(cmd * exec.Cmd)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">env := os.Environ()</span><br><span class="line">cmdEnv := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> env &#123;</span><br><span class="line">cmdEnv = <span class="built_in">append</span>(cmdEnv, e)</span><br><span class="line">&#125;</span><br><span class="line">cmdEnv = <span class="built_in">append</span>(cmdEnv, <span class="string">&quot;NAME=myname&quot;</span>)</span><br><span class="line">cmd.Env = cmdEnv</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd1 := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;/home/myname/demo.sh&quot;</span>)</span><br><span class="line">  ChangeYourCmdEnvironment(cmd1) <span class="comment">// 添加环境变量到 cmd1 命令: NAME=myname</span></span><br><span class="line">out1, _ := cmd1.CombinedOutput()</span><br><span class="line">fmt.Printf(<span class="string">&quot;output: %s&quot;</span>, out1)</span><br><span class="line"></span><br><span class="line">cmd2 := exec.Command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;/home/myname/demo.sh&quot;</span>)</span><br><span class="line">out2, _ := cmd2.CombinedOutput()</span><br><span class="line">fmt.Printf(<span class="string">&quot;output: %s&quot;</span>, out2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行后，可以看到第二次执行的命令，是没有输出 NAME 的变量值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run demo.go </span><br><span class="line">output: myname</span><br><span class="line">output: </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go命令行库cobra</title>
    <url>/e80bf483/</url>
    <content><![CDATA[<blockquote>
<p>Cobra 是一个 Golang 包，它提供了简单的接口来创建命令行程序。同时，Cobra 也是一个应用程序，用来生成应用框架，从而开发以 Cobra 为基础的应用。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305062144121.png" alt></p>
<h2><span id="主要功能">主要功能</span></h2><ul>
<li>简易的子命令行模式，如 app server， app fetch 等等</li>
<li>完全兼容 posix 命令行模式</li>
<li>嵌套子命令 subcommand</li>
<li>支持全局，局部，串联 flags</li>
<li>使用 cobra 很容易的生成应用程序和命令，使用 cobra create appname 和 cobra add cmdname</li>
<li>如果命令输入错误，将提供智能建议，如 app srver，将提示 srver 没有，是不是 app server</li>
<li>自动生成 commands 和 flags 的帮助信息</li>
<li>自动生成详细的 help 信息，如 app help</li>
<li>自动识别帮助 flag -h，–help</li>
<li>自动生成应用程序在 bash 下命令自动完成功能</li>
<li>自动生成应用程序的 man 手册</li>
<li>命令行别名</li>
<li>自定义 help 和 usage 信息</li>
<li>可选的与 viper apps 的紧密集成</li>
</ul>
<h2><span id="cobra-中的主要概念">cobra 中的主要概念</span></h2><ul>
<li>commands 行为</li>
<li>args 命令行参数(或称为位置参数)</li>
<li>flags 对行为的改变(即命令行选项)</li>
</ul>
<p>执行命令行程序时的一般格式为： <code>APPNAME COMMAND ARG --FLAG</code></p>
<h2><span id="创建-cobra-应用">创建 cobra 应用</span></h2><p>获取最新版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/spf13/cobra@latest</span><br></pre></td></tr></table></figure>

<p>安装 cobra-cli</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> install github.com/spf13/cobra-cli@latest</span><br></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /pathto/mysrc</span><br><span class="line">$ go mod init</span><br><span class="line">$ cobra-cli init</span><br></pre></td></tr></table></figure>

<p>执行后，该目录下生成的结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">▾ demo</span><br><span class="line">    ▾ cmd/</span><br><span class="line">        root.go</span><br><span class="line">    main.go</span><br></pre></td></tr></table></figure>



<h2><span id="使用-cobra-程序生成命令代码">使用 cobra 程序生成命令代码</span></h2><p>除了生成应用程序框架，还可以生成子命令的代码文件。添加自命令 mysub1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /pathto/mysrc</span><br><span class="line">$ cobra-cli add mysub1</span><br></pre></td></tr></table></figure>



<h2><span id="为命令添加具体的功能">为命令添加具体的功能</span></h2><p>打开文件 <code>cmd/root.go</code> ，找到变量 rootCmd 的初始化过程并为之设置 Run 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cobra demo program&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>创建一个 version Command 用来输出当前的软件版本。先在 cmd 目录下添加 version.go 文件，编辑文件的内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rootCmd.AddCommand(versionCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">&quot;version&quot;</span>,</span><br><span class="line">    Short: <span class="string">&quot;Print the version number of cobrademo&quot;</span>,</span><br><span class="line">    Long:  <span class="string">`All software has versions. This is cobrademo&#x27;s`</span>,</span><br><span class="line">    Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;cobrademo version is v1.0&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="为-command-添加选项flags">为 Command 添加选项(flags)</span></h2><p>选项(flags)用来控制 Command 的具体行为。根据选项的作用范围，可以把选项分为两类：</p>
<ul>
<li>persistent</li>
<li>local</li>
</ul>
<p>对于 persistent 类型的选项，既可以设置给该 Command，又可以设置给该 Command 的子 Command。对于一些全局性的选项，比较适合设置为 persistent 类型，比如控制输出的 verbose 选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Verbose <span class="type">bool</span></span><br><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, <span class="string">&quot;verbose&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;verbose output&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>local 类型的选项只能设置给指定的 Command，比如下面定义的 source 选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Source <span class="type">string</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;Source, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Source directory to read from&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>该选项不能指定给 rootCmd 之外的其它 Command。<br>默认情况下的选项都是可选的，但一些用例要求用户必须设置某些选项，这种情况 cobra 也是支持的，通过 Command 的 MarkFlagRequired 方法标记该选项即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Name <span class="type">string</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;Name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;user name (required)&quot;</span>)</span><br><span class="line">rootCmd.MarkFlagRequired(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="命令行参数arguments">命令行参数(arguments)</span></h2><p>命令行参数(arguments)与命令行选项的区别(flags/options)。以常见的 ls 命令来说，其命令行的格式为：<br><code>ls [OPTION]... [FILE]…</code><br>其中的 OPTION 对应本文中介绍的 flags，以 <code>-</code> 或 <code>--</code> 开头；而 FILE 则被称为参数(arguments)或位置参数。一般的规则是参数在所有选项的后面，上面的 … 表示可以指定多个选项和多个参数。</p>
<p>cobra 默认提供了一些验证方法：</p>
<ul>
<li>NoArgs - 如果存在任何位置参数，该命令将报错</li>
<li>ArbitraryArgs - 该命令会接受任何位置参数</li>
<li>OnlyValidArgs - 如果有任何位置参数不在命令的 ValidArgs 字段中，该命令将报错</li>
<li>MinimumNArgs(int) - 至少要有 N 个位置参数，否则报错</li>
<li>MaximumNArgs(int) - 如果位置参数超过 N 个将报错</li>
<li>ExactArgs(int) - 必须有 N 个位置参数，否则报错</li>
<li>ExactValidArgs(int) 必须有 N 个位置参数，且都在命令的 ValidArgs 字段中，否则报错</li>
<li>RangeArgs(min, max) - 如果位置参数的个数不在区间 min 和 max 之中，报错</li>
</ul>
<h2><span id="帮助信息help-command">帮助信息(help command)</span></h2><p>cobra 会自动添加 <code>--help(-h)</code> 选项，同时还自动添加了 help 子命，默认效果和使用 –help 选项相同。如果为 help 命令传递其它命令作为参数，则会显示对应命令的帮助信息。也可以自定义 help 的处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd.SetHelpCommand(cmd *Command)</span><br><span class="line">cmd.SetHelpFunc(f <span class="function"><span class="keyword">func</span><span class="params">(*Command, []<span class="type">string</span>)</span></span>)</span><br><span class="line">cmd.SetHelpTemplate(s <span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="提示信息usage-message">提示信息(usage message)</span></h2><p>提示信息和帮助信息很相似，只不过它是在你输入了非法的参数、选项或命令时才出现的。也可以自定义提示信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd.SetUsageFunc(f <span class="function"><span class="keyword">func</span><span class="params">(*Command)</span></span> <span class="type">error</span>)</span><br><span class="line">cmd.SetUsageTemplate(s <span class="type">string</span>)</span><br></pre></td></tr></table></figure>



<h2><span id="在-commnad-执行前后执行额外的操作">在 Commnad 执行前后执行额外的操作</span></h2><p>Command 执行的操作是通过 Command.Run 方法实现的，为了支持我们在 Run 方法执行的前后执行一些其它的操作，Command 还提供了额外的几个方法，它们的执行顺序如下：</p>
<ol>
<li>PersistentPreRun</li>
<li>PreRun</li>
<li>Run</li>
<li>PostRun</li>
<li>PersistentPostRun</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">&quot;cobrademo&quot;</span>,</span><br><span class="line">    Short: <span class="string">&quot;sparkdev&#x27;s cobra demo&quot;</span>,</span><br><span class="line">    Long: <span class="string">&quot;the demo show how to use cobra package&quot;</span>,</span><br><span class="line">    PersistentPreRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Inside rootCmd PersistentPreRun with args: %v\n&quot;</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PreRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Inside rootCmd PreRun with args: %v\n&quot;</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;cobra demo program, with args: %v\n&quot;</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PostRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Inside rootCmd PostRun with args: %v\n&quot;</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    PersistentPostRun: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Inside rootCmd PersistentPostRun with args: %v\n&quot;</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="代码解析">代码解析</span></h2><h3><span id="command-结构体">Command 结构体</span></h3><p>Command 结构体是 cobra 抽象出来的核心概念，它的实例表示一个命令或者是一个命令的子命令。下面的代码仅展示 Command 结构体中一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;    </span><br><span class="line">    <span class="comment">// 用户通过指定 Run 函数来完成命令</span></span><br><span class="line">    <span class="comment">// PreRun 和 PostRun 则允许用户在 Run 运行的前后时机执行自定义代码</span></span><br><span class="line">    PersistentPreRun <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="type">string</span>)</span></span></span><br><span class="line">    PreRun <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="type">string</span>)</span></span></span><br><span class="line">    Run <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="type">string</span>)</span></span></span><br><span class="line">    PostRun <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="type">string</span>)</span></span></span><br><span class="line">    PersistentPostRun <span class="function"><span class="keyword">func</span><span class="params">(cmd *Command, args []<span class="type">string</span>)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// commands 字段包含了该命令的所有子命令</span></span><br><span class="line">    commands []*Command</span><br><span class="line">    <span class="comment">// parent 字段记录了该命令的父命令</span></span><br><span class="line">    parent *Command</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该命令的 help 子命令</span></span><br><span class="line">    helpCommand *Command</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="执行命令的逻辑">执行命令的逻辑</span></h3><p>cobra 包启动程序执行的代码一般为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd.Execute()</span><br></pre></td></tr></table></figure>

<p>Execute() 函数会调用我们定义的 rootCmd(Command 的一个实例)的 Execute() 方法。<br>在 Command 的 Execute() 方法中又调用了 Command 的 ExecuteC() 方法，我们可以通过下面的调用堆栈看到执行命令逻辑的调用过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd.Execute() -&gt;                  <span class="comment">// main.go</span></span><br><span class="line">rootCmd.Execute() -&gt;              <span class="comment">// root.go</span></span><br><span class="line">c.ExecuteC() -&gt;                   <span class="comment">// command.go</span></span><br><span class="line">cmd.execute(flags) -&gt;             <span class="comment">// command.go</span></span><br><span class="line">c.Run()                           <span class="comment">// command.go</span></span><br></pre></td></tr></table></figure>

<p>c.Run() 方法即用户为命令(Command) 设置的执行逻辑。</p>
<h3><span id="解析命令行子命令">解析命令行子命令</span></h3><p>ExecuteC() 方法中，在执行 execute() 方法前，需要先通过 Find() 方法解析命令行上的子命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd, flags, err = c.Find(args)</span><br></pre></td></tr></table></figure>

<p>比如我们执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./myApp mycmd1</span><br></pre></td></tr></table></figure>

<p>解析出的 cmd 就是 imamycmd1ge 子命令，接下来就是执行 mycmd1 子命令的执行逻辑。</p>
<p>Find() 方法的逻辑如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./myApp <span class="built_in">help</span> mycmd1</span><br></pre></td></tr></table></figure>

<p>这里的 myApp 对应代码中的 rootCmd，Find() 方法中定义了一个名称为 innerfind 的函数，innerfind 从参数中解析出下一个名称，这里是 help，然后从 rootCmd 开始查找解析出的名称 help 是不是当前命令的子命令，如果 help 是 rootCmd 的子命令，继续查找。接下来查找名称 mycmd1，发现 mycmd1 不是 help 的子命令，innerfind 函数就返回 help 命令。execute() 方法中就执行这个找到的 help 子命令。</p>
<h3><span id="为根命令添加-help-子命令">为根命令添加 help 子命令</span></h3><p>在执行 ExecuteC() 方法时，cobra 会为根命令添加一个 help 子命令，这个子命令主要用来提供子命令的帮助信息。因为任何一个程序都需要提供输出帮助信息的方式，所以 cobra 就为它实现了一套默认的逻辑。help 子命令是通过 InitDefaultHelpCmd() 方法添加的，其实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InitDefaultHelpCmd adds default help command to c.</span></span><br><span class="line"><span class="comment">// It is called automatically by executing the c or by calling help and usage.</span></span><br><span class="line"><span class="comment">// If c already has help command or c has no subcommands, it will do nothing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span></span> InitDefaultHelpCmd() &#123;</span><br><span class="line">    <span class="keyword">if</span> !c.HasSubCommands() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.helpCommand == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.helpCommand = &amp;Command&#123;</span><br><span class="line">            Use:   <span class="string">&quot;help [command]&quot;</span>,</span><br><span class="line">            Short: <span class="string">&quot;Help about any command&quot;</span>,</span><br><span class="line">            Long: <span class="string">`Help provides help for any command in the application.</span></span><br><span class="line"><span class="string">Simply type `</span> + c.Name() + <span class="string">` help [path to command] for full details.`</span>,</span><br><span class="line"></span><br><span class="line">            Run: <span class="function"><span class="keyword">func</span><span class="params">(c *Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                cmd, _, e := c.Root().Find(args)</span><br><span class="line">                <span class="keyword">if</span> cmd == <span class="literal">nil</span> || e != <span class="literal">nil</span> &#123;</span><br><span class="line">                    c.Printf(<span class="string">&quot;Unknown help topic %#q\n&quot;</span>, args)</span><br><span class="line">                    c.Root().Usage()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cmd.InitDefaultHelpFlag() <span class="comment">// make possible &#x27;help&#x27; flag to be shown</span></span><br><span class="line">                    cmd.Help()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.RemoveCommand(c.helpCommand)</span><br><span class="line">    c.AddCommand(c.helpCommand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果没有找到用户指定的子命令</strong>,就输出错误信息，并调用根命令的 Usage() 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.Printf(<span class="string">&quot;Unknown help topic %#q\n&quot;</span>, args)</span><br><span class="line">c.Root().Usage()</span><br></pre></td></tr></table></figure>

<p>cobra 默认提供的 usage 模板如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`Usage:&#123;&#123;if .Runnable&#125;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#123;.UseLine&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasAvailableSubCommands&#125;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#123;.CommandPath&#125;&#125; [command]&#123;&#123;end&#125;&#125;&#123;&#123;if gt (len .Aliases) 0&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Aliases:</span></span><br><span class="line"><span class="string">  &#123;&#123;.NameAndAliases&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasExample&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">&#123;&#123;.Example&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasAvailableSubCommands&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available Commands:&#123;&#123;range .Commands&#125;&#125;&#123;&#123;if (or .IsAvailableCommand (eq .Name &quot;help&quot;))&#125;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#123;rpad .Name .NamePadding &#125;&#125; &#123;&#123;.Short&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasAvailableLocalFlags&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Flags:</span></span><br><span class="line"><span class="string">&#123;&#123;.LocalFlags.FlagUsages | trimTrailingWhitespaces&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasAvailableInheritedFlags&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Global Flags:</span></span><br><span class="line"><span class="string">&#123;&#123;.InheritedFlags.FlagUsages | trimTrailingWhitespaces&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasHelpSubCommands&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Additional help topics:&#123;&#123;range .Commands&#125;&#125;&#123;&#123;if .IsAdditionalHelpTopicCommand&#125;&#125;</span></span><br><span class="line"><span class="string">  &#123;&#123;rpad .CommandPath .CommandPathPadding&#125;&#125; &#123;&#123;.Short&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if .HasAvailableSubCommands&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use &quot;&#123;&#123;.CommandPath&#125;&#125; [command] --help&quot; for more information about a command.&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p><strong>如果找到用户指定的子命令</strong>，就为子命令添加默认的 help flag，并执行其 Help() 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd.InitDefaultHelpFlag() <span class="comment">// make possible &#x27;help&#x27; flag to be shown</span></span><br><span class="line">cmd.Help()</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p>通过 cobra 实现了一个命令行程序 myApp，它有一个子命令 image，image 也有一个子命令 times。执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./myApp <span class="built_in">help</span> mycmd1</span><br></pre></td></tr></table></figure>

<p>在 help 命令的 Run 方法中，c 为 help 命令， args 为 mycmd1。结果就是通过 help 查看 mycmd1 命令的帮助文档。如果 mycmd1 后面还有其他的子命令，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./myApp <span class="built_in">help</span> mycmd1 mysub1</span><br></pre></td></tr></table></figure>

<p>则 c.Root().Find(args) 逻辑会找出子命令 mysub1(此时 args 为 mycmd1 mysub1)，最终由 help 查看 mysub1 命令的帮助文档。<br>注意：help 信息中包含 usage 信息。</p>
<h3><span id="为命令添加-help-flag">为命令添加 help flag</span></h3><p>除了在 InitDefaultHelpCmd() 方法中会调用 InitDefaultHelpFlag() 方法，在 execute() 方法中执行命令逻辑前也会调用 InitDefaultHelpFlag() 方法为命令添加默认的 help flag，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.InitDefaultHelpFlag()</span><br></pre></td></tr></table></figure>

<p>下面是 InitDefaultHelpFlag() 方法的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InitDefaultHelpFlag adds default help flag to c.</span></span><br><span class="line"><span class="comment">// It is called automatically by executing the c or by calling help and usage.</span></span><br><span class="line"><span class="comment">// If c already has help flag, it will do nothing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span></span> InitDefaultHelpFlag() &#123;</span><br><span class="line">    c.mergePersistentFlags()</span><br><span class="line">    <span class="keyword">if</span> c.Flags().Lookup(<span class="string">&quot;help&quot;</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">        usage := <span class="string">&quot;help for &quot;</span></span><br><span class="line">        <span class="keyword">if</span> c.Name() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            usage += <span class="string">&quot;this command&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usage += c.Name()</span><br><span class="line">        &#125;</span><br><span class="line">        c.Flags().BoolP(<span class="string">&quot;help&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="literal">false</span>, usage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这让我们不必为命令添加 help flag 就可以直接使用</p>
<h3><span id="输出-help-信息">输出 help 信息</span></h3><p>不管是 help 命令还是 help falg，最后都是通过 HelpFunc() 方法来获得输出 help 信息的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelpFunc returns either the function set by SetHelpFunc for this command</span></span><br><span class="line"><span class="comment">// or a parent, or it returns a function with default help behavior.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span></span> HelpFunc() <span class="function"><span class="keyword">func</span><span class="params">(*Command, []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.helpFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.helpFunc</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.HasParent() &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Parent().HelpFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Command, a []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        c.mergePersistentFlags()</span><br><span class="line">        err := tmpl(c.OutOrStdout(), c.HelpTemplate(), c)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果我们没有指定自定义的逻辑，就找父命令的，再没有就用 cobra 的默认逻辑。cobra 默认设置的帮助模板如下(包含 usage)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`&#123;&#123;with (or .Long .Short)&#125;&#125;&#123;&#123;. | trimTrailingWhitespaces&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;&#123;&#123;if or .Runnable .HasSubCommands&#125;&#125;&#123;&#123;.UsageString&#125;&#125;&#123;&#123;end&#125;&#125;`</span></span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<ul>
<li><a href="https://cobra.dev/">Cobra. Dev</a></li>
<li><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a></li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 基础语法</title>
    <url>/936ea20/</url>
    <content><![CDATA[<p>有意思的变量和不安分的常量</p>
<ul>
<li>变量默认初始化有零值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestVariableZeroValue(t *testing.T) &#123;</span><br><span class="line">    var a int</span><br><span class="line">    var s string</span><br><span class="line">    // 0</span><br><span class="line">    t.Log(a, s)</span><br><span class="line">    // 0 &quot;&quot;</span><br><span class="line">    t.Logf(&quot;%d %q&quot;, a, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>int 类型的变量初始化默认零值是零 0, string 类型的变量默认初始化零值是空字符串 ,其他类型也有相应的零值.</p>
<ul>
<li>多个变量可以同时赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestVariableInitialValue(t *testing.T) &#123;</span><br><span class="line">    var a, b int = 1, 2</span><br><span class="line">    var s string = &quot;hello Go&quot;</span><br><span class="line">    // 1 2 hello Go</span><br><span class="line">    t.Log(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其他主要的编程语言大多支持多个变量初始化,但极少数有像 Go 语言这样,不仅支持同时初始化,还可以同时赋值.</p>
<ul>
<li>多个变量可以用小括号 () 统一定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestVariableShorter(t *testing.T) &#123;</span><br><span class="line">    var (</span><br><span class="line">    a int    = 1</span><br><span class="line">    b int    = 2</span><br><span class="line">    s string = &quot;hello go&quot;</span><br><span class="line">    )</span><br><span class="line">    // 1 2 hello Go</span><br><span class="line">    t.Log(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用小括号 () 方式,省略了相同的 var 关键字,看起来更加统一</p>
<ul>
<li>变量类型可以被自动推断</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariableTypeDeduction</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a, b, s = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello Go&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 2 hello Go</span></span><br><span class="line"></span><br><span class="line">    t.Log(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go 语言可以根据变量值推测出变量类型,所以可以省略变量类型,再一次简化了变量定义,但是变量类型仍然是强类型,并不像 Js 那样的弱类型.</p>
<ul>
<li>变量可以用 := 形式更加简化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestVariableTypeDeductionShorter(t *testing.T) &#123;</span><br><span class="line">    a, b, s := 1, 2, &quot;hello Go&quot;</span><br><span class="line">    // 1 2 hello Go</span><br><span class="line">    t.Log(a, b, s)</span><br><span class="line">    s = &quot;hello golang&quot;</span><br><span class="line">    // 1 2 hello golang</span><br><span class="line"></span><br><span class="line">    t.Log(a, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>省略了关键字 var,转而使用 := 符号声明并初始化变量值且利用自动类型推断能力进一步就简化变量定义,再次赋值时不能再使用 := 符号.</p>
<ul>
<li>变量 var 声明作用域大于变量 := 声明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. var globalTestId = 2</span><br><span class="line"></span><br><span class="line">2. // globalTestName := &quot;type_test&quot; is not supported</span><br><span class="line"></span><br><span class="line">3. var globalTestName = &quot;type_test&quot;</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. func TestVariableScope(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">6. ```</span><br><span class="line">    // 2 type_test</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><pre><code>t.Log(globalTestId, globalTestName)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. </span><br><span class="line"></span><br><span class="line">9. ```</span><br><span class="line">    globalTestName = &quot;TestVariableScope&quot;</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// 2 TestVariableScope
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">12. ```</span><br><span class="line">    t.Log(globalTestId, globalTestName)</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var 声明的变量可以作用于函数外或函数内,而 := 声明的变量只能作用于函数内, Go 并没有全局变量的概念,变量的作用范围只是针对包而言.</span><br><span class="line"></span><br><span class="line">* 常量的使用方式和变量一致</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>func TestConstant(t *testing.T) {</p>
</li>
<li><pre><code>const a, b = 3, 4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">    const s = &quot;hello Go&quot;</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// 3 4 hello Go
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. ```</span><br><span class="line">    t.Log(a, b, s)</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常量声明关键字 const,常量和变量的使用方式一致,具备类型推断能力,也存在多种简化常量定义的形式.</span><br><span class="line"></span><br><span class="line">* 虽然没有枚举类型,但可以用 iota 配合常量来实现枚举</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>func TestConstant2Enum(t *testing.T) {</p>
</li>
<li><pre><code>const (
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">    java = iota</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>golang
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. ```</span><br><span class="line">    cpp</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>python
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7. ```</span><br><span class="line">    javascript</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">9. ```</span><br><span class="line">    // 0 1 2 3 4</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>t.Log(java, golang,cpp,python,javascript)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">11. &#125;</span><br></pre></td></tr></table></figure>


</code></pre></li>
</ol>
<p>iota 在一组常量定义中首次出现时,其值为 0,应用到下一个常量时,其值为开始自增 1,再次遇到 iota 恢复 0 .效果非常像 for 循环中的循环索引 i,明明是常量,偏偏玩出了变量的味道,也是我觉得 iota 不安分的原因.</p>
<ul>
<li>常量 iota 有妙用,还可以进行位运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. func TestConstantIotaBitCalculate(t *testing.T)&#123;</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">    const (</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><pre><code>Readable = 1 &lt;&lt; iota
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">    Writable</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>Executable
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. ```</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>// 0001 0010 0100 即 1 2 4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. ```</span><br><span class="line">    t.Log(Readable, Writable, Executable)</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// 0111 即 7,表示可读,可写,可执行
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">11. ```</span><br><span class="line">    accessCode := 7</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>t.Log(accessCode&amp;Readable == Readable, accessCode&amp;Writable == Writable, accessCode&amp;Executable == Executable)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">13. &#125;</span><br></pre></td></tr></table></figure>


</code></pre></li>
</ol>
<p>定义二进制位最低位为 1 时表示可读的,左移一位表示可写的,左移两位表示可执行的,按照按位与运算逻辑,目标权限位若拥有可读权限,此时和可读常量进行按位与运算之后的结果一定是可读的,由此可见, iota 非常适合此类操作.</p>
<p>总体来说, Go 语言中的变量很有意思,常量 iota 不那么安分,从上述归纳总结中不难看出, Go 语言和其他主流的编程语言还是有很大不同的,学习时要侧重于这些特殊之处.</p>
<p>如果想要回顾本节知识点,可以关注公众号[雪之梦技术驿站]找到<a href="https://mp.weixin.qq.com/s?__biz=MzU3NTc1MDMwOQ==&mid=2247484101&idx=1&sn=e93944978b6b88d2594e40d8ca9527fa&scene=21#wechat_redirect">go 学习笔记之有意思的变量和不安分的常量</a> 这篇文章进行查看.</p>
<p>简洁的类型中格外关照了复数</p>
<p>在学习 Go 语言中的变量和常量时,虽然没有特意强调变量或常量的类型,但是大多数编程语言的类型基本都是差不多的,毕竟大家所处的现实世界是一样的嘛!</p>
<p>光是猜测是不够的,现在我们要梳理一遍 Go 语言的类型有哪些,和其他主流的编程语言相比有什么不同?</p>
<p>Go 语言的变量类型大致可以分为以下几种:</p>
<ul>
<li>bool</li>
</ul>
<p>布尔类型 bool,表示真假 true|false</p>
<ul>
<li>(u)int , (u)int8 , (u)int16, (u)int32, (u)int64, uintptr</li>
</ul>
<p>int 类型表示整数,虽然不带位数并不表示没有位数, 32 位操作系统时长度为 32 位, 64 位操作系统时长度为 64 位.最后一个 uintptr 是指针类型.</p>
<ul>
<li>byte(uint8) , rune(int32), string</li>
</ul>
<p>byte 是字节类型,也是 uint8 的别名,而 rune 是 Go 中的字符类型,也是 int32 的别名.</p>
<ul>
<li>float32 , float64 , complex64 , complex128</li>
</ul>
<p>只有 float 类型表示小数,没有 double 类型,类型越少对于开发者而言越简单,不是吗? complex64=float32+float32 是复数类型,没错!就是高中数学书本上的复数, 3+4i 那种奇怪的数字!</p>
<p>Go 的类型还是比较简单的,整数,小数,复数,字节,字符和布尔类型,相同种类的类型没有继续细分不同的名称而是直接根据类型长度进行命名的,这样是非常直观的,见名知意,根据数据大小直接选用类型,不费脑!</p>
<p>作为一种通用的编程语言, Go 内建类型中居然格外关照了复数这种数学概念类型,是一件有意思的事情,是不是意味着 Go 在工程化项目上做得更好?就像 Go 天生支持并发一样?</p>
<p>既然为数不多的类型中格外关照了复数类型,那我们简单使用下复数类型吧,毕竟其他类型和其他主流的编程语言相差不大.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. func TestComplex(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">    c := 3 + 4i</span><br></pre></td></tr></table></figure>

<ol start="3">
<li></li>
<li><pre><code>// 5
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. ```</span><br><span class="line">    t.Log(cmplx.Abs(c))</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">生命苦短,直接利用变量类型推断简化变量声明,求出复数类型 c 的模(绝对值)</span><br><span class="line"></span><br><span class="line">既然学习了复数,怎么能少得了欧拉公式,毕竟是&quot;世界上最美的公式&quot;,刚好用到了复数的相关知识,那我们就简单验证一下吧!</span><br><span class="line"></span><br><span class="line">![](//note.youdao.com/src/39fd719ebc6278f7fddaf5a345fde1be)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e&lt;sup&gt;iπ&lt;/sup&gt; + 1 = 0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>func TestEuler(t *testing.T) {</p>
</li>
<li><pre><code>// (0+1.2246467991473515e-16i)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">    t.Log(cmplx.Pow(math.E, 1i*math.Pi) + 1)</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// (0+1.2246467991473515e-16i)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. ```</span><br><span class="line">    t.Log(cmplx.Exp(1i*math.Pi) + 1)</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// (0.000+0.000i)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">9. ```</span><br><span class="line">    t.Logf(&quot;%.3f&quot;, cmplx.Exp(1i*math.Pi)+1)</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于复数 complex 是使用 float 类型表示的,而 float 类型无论是什么编程语言都是不准确的,所以欧拉公式的计算结果非常非常接近于零,当只保留小数点后三位时,计算结果便是 (0.000+0.000i) ,复数的模也就是 0,至此验证了欧拉公式.</span><br><span class="line"></span><br><span class="line">看过复数还是要研究类型特点</span><br><span class="line"></span><br><span class="line">复数很重要,但其他类型也很重要,简单了解过复数的相关知识后,我们仍然要把注意力放到研究这些内建类型的特殊之处上或者说这些类型总体来说相对于其他主流的编程语言有什么异同.</span><br><span class="line"></span><br><span class="line">* 只有显示类型转换,不存在隐式类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>func TestExplicitTypeConvert(t *testing.T) {</p>
</li>
<li><pre><code>var a, b int = 3, 4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">    var c int</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>c = int(math.Sqrt(float64(a*a + b*b)))
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. </span><br><span class="line"></span><br><span class="line">6. ```</span><br><span class="line">    // 3 4 5</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>t.Log(a, b, c)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. &#125;</span><br></pre></td></tr></table></figure>


</code></pre></li>
</ol>
<p>已知勾股定理的两条直角边计算斜边,根据勾股定理得,直角边长度的平方和再开根号即斜边长度,然而 math.Sqrt 方法接收的 float64 类型,返回的也是 float64 类型,可实际值全是 int 类型,这种情况下并不会自动进行类型转换,只能进行强制类型转换才能得到我们的期望值,这就是显示类型转换.</p>
<ul>
<li>别名类型和原类型也不能进行隐式类型转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. func TestImplicitTypeConvert2(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">    type MyInt64 int64</span><br></pre></td></tr></table></figure>

<ol start="3">
<li></li>
<li><pre><code>var a int64 = 1
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. ```</span><br><span class="line">    var b MyInt64</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// b = a : cannot use a (type int64) as type MyInt64 in assignment
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. ```</span><br><span class="line">    b = MyInt64(a)</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>t.Log(a, b)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">10. &#125;</span><br></pre></td></tr></table></figure>


</code></pre></li>
</ol>
<p>MyInt64 是 int64 的别名,别名类型的 b 和原类型的 a 也不能进行也不能进行隐式类型转换,会报错 cannotusea(type int64)astypeMyInt64inassignment,只能进行显示类型转换.</p>
<ul>
<li>支持指针类型,但不支持任何形式的计算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. func TestPointer(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">    var a int = 1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><pre><code>var pa *int = &amp;a
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. ```</span><br><span class="line">    // 0xc0000921d0 1 1</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>t.Log(pa, *pa, a)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7. </span><br><span class="line"></span><br><span class="line">8. ```</span><br><span class="line">    *pa = 2</span><br></pre></td></tr></table></figure></code></pre></li>
<li></li>
<li><pre><code>// 0xc0000901d0 2 2
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">11. ```</span><br><span class="line">    t.Log(pa, *pa, a)</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同样的,指针类型也是其他编程语言反过来书写的,个人觉得这种反而不错,指向 int 类型的指针 *int, &amp;a是变量 a 的内存地址,所以变量 pa 存的就是变量 a 的地址, *pa 刚好也就是变量 a 的值.</span><br><span class="line"></span><br><span class="line">上例显示声明了变量类型却没有利用到 Go 的类型推断能力,摆在那的能力却不利用简直是浪费,所以提供一种更简短的方式重写上述示例,并顺便解释后半句: &quot;指针类型不支持任何形式的计算&quot;</span><br><span class="line"></span><br><span class="line">1. func TestPointerShorter(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   a := 1</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>pa := &amp;a</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. </span><br><span class="line">5. ```</span><br><span class="line">   // 0xc0000e6010 1 1</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(pa, *pa, a)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. </span><br><span class="line">8. ```</span><br><span class="line">   *pa = 2</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>```<br>// 0xc0000e6010 2 2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   t.Log(pa, *pa, a)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>```<br>// pa = pa + 1 : invalid operation: pa + 1 (mismatched types *int and int)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14. ```</span><br><span class="line">   //pa = pa + 1</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>```<br>// *int int int</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17. ```</span><br><span class="line">   t.Logf(&quot;%T %T %T&quot;, pa, *pa,a)</span><br></pre></td></tr></table></figure></li>
<li><p>}</p>
</li>
</ol>
<p>变量 pa 是指针类型,存储的是变量的内存地址,只可远观而不可亵玩, *pa 就是指针所指向的变量的值,可以进行修改,当然没问题就像可以重新赋值变量 a 一样,但是指针 pa 是不可以进行任何形式的运算的, pa=pa+1 就会报错 invalid operation.</p>
<p>你猜运算符操作有没有彩蛋呢</p>
<p>变量和类型还只是孤立的声明语句,没有计算不成逻辑,并不是所有的程序都是预定义的变量, Go 的运算符是简单还是复杂呢,让我们亲自体验一下!</p>
<ul>
<li>算术运算符少了 ++i 和 –i</li>
</ul>
<ol>
<li>func TestArithmeticOperator(t *testing.T) {</li>
<li>```<br>a := 0<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   // 0</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. </span><br><span class="line">6. ```</span><br><span class="line">   a = a + 1</span><br></pre></td></tr></table></figure></li>
<li>```<br>// 1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. ```</span><br><span class="line">   t.Log(a)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>a = a * 2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   // 2</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13. </span><br><span class="line">14. ```</span><br><span class="line">   a = a % 2</span><br></pre></td></tr></table></figure></li>
<li>```<br>// 0<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16. ```</span><br><span class="line">   t.Log(a)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>a++<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19. ```</span><br><span class="line">   // 1</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21. &#125;</span><br><span class="line"></span><br><span class="line">支持大部分正常的运算符,不支持前置自增,前置自减,这也是好事,再也不会弄错 i++ 和 ++i 的运算结果啦,因为根本不支持 ++i !</span><br><span class="line"></span><br><span class="line">* 比较运算符是否相等有花样</span><br><span class="line"></span><br><span class="line">1. func TestComparisonOperator(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   a, b := 0, 1</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a, b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. </span><br><span class="line">5. ```</span><br><span class="line">   // false true true</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a &gt; b, a &lt; b, a != b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. &#125;</span><br><span class="line"></span><br><span class="line">大于,小于,不等于这种关系很正常, Golang 也没玩出新花样,和其他主流的编程语言逻辑一样,不用特别关心.但是关于比较数组 ==, Go 表示有话要说!</span><br><span class="line"></span><br><span class="line">Go 中的数组是可以进行比较的,当待比较的两个数组的维度和数组元素的个数相同时,两个数组元素顺序一致且相同时,则两个数组相等,而其他主流的编程语言一般而言比较的都是数组的引用,所以这一点需要特别注意.</span><br><span class="line"></span><br><span class="line">1. func TestCompareArray(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   a := [...]int&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure></li>
<li>```<br>//b := […]int{2, 4}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   c := [...]int&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure></li>
<li>```<br>d := […]int{1, 2, 4}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. </span><br><span class="line">7. ```</span><br><span class="line">   // a == b --&gt; invalid operation: a == b (mismatched types [3]int and [2]int)</span><br></pre></td></tr></table></figure></li>
<li>```<br>//t.Log(a == b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. </span><br><span class="line">10. ```</span><br><span class="line">   // true false</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a == c,a == d)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. &#125;</span><br><span class="line"></span><br><span class="line">数组 a 和 c 均是一维数组且元素个数都是 3,因此两个数组可以比较且相等,若数组 a 和 b 进行比较,则报错 invalid operation,是因为两个数组的元素个数不相同,无法比较!</span><br><span class="line"></span><br><span class="line">* 逻辑运算符老实本分无异常</span><br><span class="line"></span><br><span class="line">1. func TestLogicalOperator(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   a, b := true, false</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a, b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. </span><br><span class="line">5. ```</span><br><span class="line">   // false true false true</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a&amp;&amp;b,a||b,!a,!b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. &#125;</span><br><span class="line"></span><br><span class="line">* 位运算符新增按位清零 &amp;^ 很巧妙</span><br><span class="line"></span><br><span class="line">Go 语言中定义按位清零运算符是 &amp;^,计算规律如下:</span><br><span class="line"></span><br><span class="line">当右边操作位数为 1 时,左边操作为不论是 1 还是 0 ,结果均为 0;</span><br><span class="line">当右边操作位数为 0 时,结果同左边操作位数.</span><br><span class="line"></span><br><span class="line">1. func TestClearZeroOperator(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   // 0 0 1 0</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(1&amp;^1, 0&amp;^1, 1&amp;^0, 0&amp;^1)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. &#125;</span><br><span class="line"></span><br><span class="line">不知道还记不记得,在介绍常量 iota 时,曾经以文件权限为例,判断给定的权限码是否拥有特定权限,同样是给定的权限码,又该如何撤销特定权限呢?</span><br><span class="line"></span><br><span class="line">1. func TestClearZeroOperator(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   const (</span><br></pre></td></tr></table></figure></li>
<li>```<br>Readable = 1 &lt;&lt; iota<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   Writable</span><br></pre></td></tr></table></figure></li>
<li>```<br>Executable<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></li>
<li>```<br>// 0001 0010 0100 即 1 2 4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. ```</span><br><span class="line">   t.Log(Readable, Writable, Executable)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>// 0111 即 7,表示可读,可写,可执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   accessCode := 7</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(accessCode&amp;Readable == Readable, accessCode&amp;Writable == Writable, accessCode&amp;Executable == Executable)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13. </span><br><span class="line">14. ```</span><br><span class="line">   // 0111 &amp;^ 0001 = 0110 即清除可读权限</span><br></pre></td></tr></table></figure></li>
<li>```<br>accessCode = accessCode &amp;^ Readable<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16. ```</span><br><span class="line">   t.Log(accessCode&amp;Readable == Readable, accessCode&amp;Writing == Writing, accessCode&amp;Executable == Executable)</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>accessCode=accessCode&amp;^Readable 进行按位清零操作后就失去了可读权限, accessCode&amp;Readable==Readable 再次判断时就没有可读权限了.</p>
<p>流程控制语句也有自己的傲娇</p>
<p>if 有话要说</p>
<p>有了变量类型和各种运算符的加入,现在实现简单的语句已经不是问题了,如果再辅助流程控制语句,那么实现较为复杂拥有一定逻辑的语句便可更上一层楼.</p>
<p>Go 语言的 if 条件语句和其他主流的编程语言的语义是一样的,不一样的是书写规则和一些细节上有着自己特点.</p>
<ul>
<li>条件表达式不需要小括号 ()</li>
</ul>
<ol>
<li><p>func TestIfCondition(t *testing.T) {</p>
</li>
<li><p>```<br>for i := 0; i &lt; 10; i++ {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   if i%2 == 0 &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. ```</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. &#125;</span><br><span class="line"></span><br><span class="line">Go 语言的各种省略形式使得整体上非常简洁,但也让拥有其他主流编程语言的开发者初次接触时很不习惯,语句结束不用分号 ;,条件表达式不用小括号 () 等等细节,如果不用 IDE 的自动提示功能,这些细节肯定要耗费不少时间.</span><br><span class="line"></span><br><span class="line">* 条件表达式中可以定义变量,只要最后的表达式结果是布尔类型即可</span><br><span class="line"></span><br><span class="line">1. func TestIfConditionMultiReturnValue(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   const filename = &quot;test.txt&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>if content, err := ioutil.ReadFile(filename); err != nil {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   t.Log(err)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>} else {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   t.Logf(&quot;%s</span><br></pre></td></tr></table></figure>

<p>“, content)</p>
</li>
<li><p>```<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. &#125;</span><br><span class="line"></span><br><span class="line">Go 语言的函数支持返回多个值,这一点稍后再细说, ioutil.ReadFile 函数返回文件内容和错误信息,当存在错误信息时 err!=nil,输出错误信息,否则输出文件内容.</span><br><span class="line"></span><br><span class="line">* 条件表达式中定义的变量作用域仅限于当前语句块</span><br><span class="line"></span><br><span class="line">![](//note.youdao.com/src/fd5c4b52006416939abd0b6a472d596c)</span><br><span class="line"></span><br><span class="line">如果尝试在 if 语句块外访问变量 content,则报错 undefined:content</span><br><span class="line"></span><br><span class="line">switch 不甘示弱</span><br><span class="line"></span><br><span class="line">同其他主流的编程语言相比, switch 语句最大的特点就是多个 case 不需要 break, Go 会自动进行 break,这一点很人性化.</span><br><span class="line"></span><br><span class="line">* switch 会自动 break,除非使用 fallthrough</span><br><span class="line"></span><br><span class="line">1. func TestSwitchCondition(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   switch os := runtime.GOOS; os &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>case “darwin”:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   t.Log(&quot;Mac&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>case “linux”:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   t.Log(&quot;Linux&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>case “windows”:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. ```</span><br><span class="line">   t.Log(&quot;Windows&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>default:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10. ```</span><br><span class="line">   t.Log(os)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. &#125;</span><br><span class="line"></span><br><span class="line">* 条件表达式不限制为常量或整数</span><br><span class="line"></span><br><span class="line">其他主流的编程语言中 switch 的条件表达式仅支持有限类型,使用方式存在一定局限性, Go 语言则不同,这一点变化也是很有意思的,使用 switch 做分支控制时不用担心变量类型了!</span><br><span class="line"></span><br><span class="line">* case 语言支持多种条件,用逗号 , 分开,逻辑或</span><br><span class="line"></span><br><span class="line">1. func TestSwitchMultiCase(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   for i := 0; i &lt; 10; i++ &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>switch i {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   case 0, 2, 4, 6, 8, 10:</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(“Even”, i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   case 1, 3, 5, 7, 9:</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(“odd”, i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. ```</span><br><span class="line">   default:</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(“default”, i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10. ```</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. &#125;</span><br><span class="line"></span><br><span class="line">* 省略 switch 的条件表达式时, switch 的逻辑和多个 ifelse 逻辑相同</span><br><span class="line"></span><br><span class="line">1. func TestSwitchCaseCondition(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   for i := 0; i &lt; 10; i++ &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>switch {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   case i%2 == 0:</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(“Even”, i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   case i%2 == 1:</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(“odd”, i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. ```</span><br><span class="line">   default:</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(“default”, i)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10. ```</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. &#125;</span><br><span class="line"></span><br><span class="line">for 姗姗来迟</span><br><span class="line"></span><br><span class="line">最后登场的是 for 循环,一个人完成了其他主流编程语言三个人的工作, Go 语言中既没有 while 循环也,也没有 dowhile 循环,有的只是 for 循环.</span><br><span class="line"></span><br><span class="line">* 循环条件不需要小括号 ()</span><br><span class="line"></span><br><span class="line">1. func TestForLoop(t *testing.T) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   sum := 0</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>for i := 1; i &lt;= 100; i++ {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   sum += i</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   // 1+2+3+...+99+100=5050</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(sum)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. &#125;</span><br><span class="line"></span><br><span class="line">再一次看到条件表达式不需要小括号 () 应该不会惊讶了吧? if 的条件语句表达式也是类似的,目前为止,接触到明确需要小括号的 () 也只有变量或常量定义时省略形式了.</span><br><span class="line"></span><br><span class="line">* 可以省略初始条件</span><br><span class="line"></span><br><span class="line">1. func convert2Binary(n int) string &#123;</span><br><span class="line">2. ```</span><br><span class="line">   result := &quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>for ; n &gt; 0; n /= 2 {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   lsb := n % 2</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>result = strconv.Itoa(lsb) + result</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>return result</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. &#125;</span><br><span class="line">9. </span><br><span class="line">10. func TestConvert2Binary(t *testing.T) &#123;</span><br><span class="line">11. ```</span><br><span class="line">   // 1 100 101 1101</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>t.Log(</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13. ```</span><br><span class="line">   convert2Binary(1),</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>convert2Binary(4),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15. ```</span><br><span class="line">   convert2Binary(5),</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>convert2Binary(13),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17. ```</span><br><span class="line">   )</span><br></pre></td></tr></table></figure></li>
<li><p>}</p>
</li>
</ol>
<p>利用整数相除法,不断取余相除,得到给定整数的二进制字符串,这里就省略了初始条件,只有结束条件和递增表达式.这种写法同样在其他主流的编程语言是没有的,体现了 Go 设计的简洁性,这种特性在以后的编程中会越来越多的用到,既然可以省略初始条件,相信你也能猜到可不可以省略其他两个条件呢?</p>
<ul>
<li>可以省略初始条件和递增表达式</li>
</ul>
<ol>
<li>func printFile(filename string) {</li>
<li>```<br>if file, err := os.Open(filename); err != nil {<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   panic(err)</span><br></pre></td></tr></table></figure></li>
<li>```<br>} else {<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. ```</span><br><span class="line">   scanner := bufio.NewScanner(file)</span><br></pre></td></tr></table></figure></li>
<li>```<br>for scanner.Scan() {<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. ```</span><br><span class="line">   fmt.Println(scanner.Text())</span><br></pre></td></tr></table></figure></li>
<li>```<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. ```</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func TestPrintFile(t *testing.T) {</li>
<li>```<br>const filename = “test.txt”<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14. ```</span><br><span class="line">   printFile(filename)</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>打开文件并逐行读取内容,其中 scanner.Scan() 的返回值类型是 bool,这里省略了循环的初始条件和递增表达式,只有循环的终止条件,也顺便实现了 while 循环的效果.</p>
<ul>
<li>初始条件,终止条件和递增表达式可以全部省略</li>
</ul>
<ol>
<li>func forever() {</li>
<li>```<br>for {<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   fmt.Println(&quot;hello go&quot;)</span><br></pre></td></tr></table></figure></li>
<li>```<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. &#125;</span><br><span class="line">6. </span><br><span class="line">7. func TestForever(t *testing.T) &#123;</span><br><span class="line">8. ```</span><br><span class="line">   forever()</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>for 循环中没有任何表达式,意味着这是一个死循环,常用于 Web 请求中监控服务端口,是不是比 while(true) 要更加简单?</p>
<p>压轴的一等公民函数隆重登场</p>
<p>虽然没有特意强制函数,但是示例代码中全部都是以函数形式给出的,函数是封装的一种形式,更是 Go语言的一等公民.</p>
<ul>
<li>返回值在函数声明的最后,多个返回值时用小括号 ()</li>
</ul>
<ol>
<li>func eval(a, b int, op string) int {</li>
<li>```<br>var result int<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   switch op &#123;</span><br></pre></td></tr></table></figure></li>
<li>```<br>case “+”:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. ```</span><br><span class="line">   result = a + b</span><br></pre></td></tr></table></figure></li>
<li>```<br>case “-“:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. ```</span><br><span class="line">   result = a - b</span><br></pre></td></tr></table></figure></li>
<li>```<br>case “*”:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. ```</span><br><span class="line">   result = a * b</span><br></pre></td></tr></table></figure></li>
<li>```<br>case “/“:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   result = a / b</span><br></pre></td></tr></table></figure></li>
<li>```<br>default:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13. ```</span><br><span class="line">   panic(&quot;unsupported operator: &quot; + op)</span><br></pre></td></tr></table></figure></li>
<li>```<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15. ```</span><br><span class="line">   return result</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func TestEval(t *testing.T) {</li>
<li>```<br>t.Log(<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20. ```</span><br><span class="line">   eval(1, 2, &quot;+&quot;),</span><br></pre></td></tr></table></figure></li>
<li>```<br>eval(1, 2, “-“),<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22. ```</span><br><span class="line">   eval(1, 2, &quot;*&quot;),</span><br></pre></td></tr></table></figure></li>
<li>```<br>eval(1, 2, “/“),<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24. ```</span><br><span class="line">   //eval(1, 2, &quot;%&quot;),</span><br></pre></td></tr></table></figure></li>
<li>```<br>)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">26. &#125;</span><br><span class="line"></span><br><span class="line">不论是变量的定义还是函数的定义, Go 总是和其他主流的编程语言相反,个人觉得挺符合思维顺序,毕竟都是先有输入才能输出,多个输出当然要统一隔离在一块了.</span><br><span class="line"></span><br><span class="line">* 可以有零个或一个或多个返回值</span><br><span class="line"></span><br><span class="line">1. func divide(a, b int) (int, int) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   return a / b, a % b</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func TestDivide(t *testing.T) {</li>
<li>```<br>// 2 1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. ```</span><br><span class="line">   t.Log(divide(5, 2))</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>小学时就知道两个整数相除,除不尽的情况下还有余数.只不过编程中商和余数都是分别计算的, Go 语言支持返回多个结果,终于可以实现小学除法了!</p>
<ul>
<li>返回多个结果时可以给返回值起名字</li>
</ul>
<ol>
<li>func divideReturnName(a, b int) (q, r int) {</li>
<li>```<br>return a / b, a % b<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. &#125;</span><br><span class="line">4. </span><br><span class="line">5. func TestDivideReturnName(t *testing.T) &#123;</span><br><span class="line">6. ```</span><br><span class="line">   q, r := divideReturnName(5, 2)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>// 2 1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. ```</span><br><span class="line">   t.Log(q, r)</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>还是整数除法的示例,只不过给返回值起了变量名称 (q,rint),但这并不影响调用者,某些 IDE 可能会基于次特性自动进行代码补全,调用者接收时的变量名不一定非要是 q,r .</p>
<ul>
<li>其他函数可以作为当前函数的参数</li>
</ul>
<ol>
<li>func apply(op func(int, int) int, a, b int) int {</li>
<li>```<br>p := reflect.ValueOf(op).Pointer()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   opName := runtime.FuncForPC(p).Name()</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>fmt.Printf(“Calling function %s with args (%d,%d)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   &quot;, opName, a, b)</span><br><span class="line">6. ```</span><br><span class="line">   return op(a, b)</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func pow(a, b int) int {</li>
<li>```<br>return int(math.Pow(float64(a), float64(b)))<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. &#125;</span><br><span class="line">12. </span><br><span class="line">13. func TestApply(t *testing.T) &#123;</span><br><span class="line">14. ```</span><br><span class="line">   // 1</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(apply(func(a int, b int) int {<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16. ```</span><br><span class="line">   return a % b</span><br></pre></td></tr></table></figure></li>
<li>```<br>}, 5, 2))<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18. </span><br><span class="line">19. ```</span><br><span class="line">   // 25</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(apply(pow, 5, 2))<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21. &#125;</span><br><span class="line"></span><br><span class="line">apply 函数的第一个参数是 op 函数,第二,第三个参数是 int 类型的 a,b.其中 op 函数也接收两个 int参数,返回一个 int 结果,因此 apply 函数的功能就是将 a,b 参数传递给 op 函数去执行,这种方式比 switch 固定运算类型要灵活方便!</span><br><span class="line"></span><br><span class="line">* 没有默认参数,可选参数等复杂概念,只有可变参数列表</span><br><span class="line"></span><br><span class="line">1. func sum(numbers ...int) int &#123;</span><br><span class="line">2. ```</span><br><span class="line">   result := 0</span><br></pre></td></tr></table></figure></li>
<li>```<br>for i := range numbers {<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. ```</span><br><span class="line">   result += numbers[i]</span><br></pre></td></tr></table></figure></li>
<li>```<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   return result</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func TestSum(t *testing.T) {</li>
<li>```<br>// 15<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   t.Log(sum(1, 2, 3, 4, 5))</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>range 遍历方式后续再说,这里可以简单理解为其他主流编程语言中的 foreach 循环,一般包括当前循环索引和循环项.</p>
<p>指针类型很方便同时也很简单</p>
<p>Go 的语言整体上比较简单,没有太多花里胡哨的语法,稍微有点特殊的当属变量的定义方式了,由于具备类型推断能力,定义变量的方式有点多,反而觉得选择困难症,不知道这种情况后续会不会有所改变?</p>
<p>在 Go 语言的为数不多的类型中就有指针类型,指针本来是 c 语言的概念,其他主流的编程语言也有类似的概念,可能不叫做指针而是引用,但 Go 语言的发展和 c++ 有一定关系,保留了指针的概念.</p>
<p>但是这并不意味着 Go 语言的指针像 C 语言那样复杂,相反, Go 语言的指针很方便也很简单,方便是由于提供我们操作内存地址的方式,简单是因为不能对指针做任何运算!</p>
<p>简单回忆一下指针的基本使用方法:</p>
<ol>
<li>func TestPointerShorter(t *testing.T) {</li>
<li>```<br>a := 1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. ```</span><br><span class="line">   pa := &amp;a</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>// 0xc0000e6010 1 1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. ```</span><br><span class="line">   t.Log(pa, *pa, a)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>*pa = 2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. </span><br><span class="line">10. ```</span><br><span class="line">   // 0xc0000e6010 2 2</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(pa, *pa, a)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. </span><br><span class="line">13. ```</span><br><span class="line">   // pa = pa + 1 : invalid operation: pa + 1 (mismatched types *int and int)</span><br></pre></td></tr></table></figure></li>
<li>```<br>//pa = pa + 1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15. </span><br><span class="line">16. ```</span><br><span class="line">   // *int int int</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Logf(“%T %T %T”, pa, *pa,a)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18. &#125;</span><br><span class="line"></span><br><span class="line">&amp; 可以获取变量的指针类型, * 指向变量,但不可以对指针进行运算,所以指针很简单!</span><br><span class="line"></span><br><span class="line">当指针类型和其他类型和函数一起发生化学反应时,我们可能更加关心参数传递问题,其他主流的编程语言可能有值传递和引用传递两种方式, Go 语言进行参数传递时又是如何表现的呢?</span><br><span class="line"></span><br><span class="line">1. func swapByVal(a, b int) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   a, b = b, a</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func TestSwapByVal(t *testing.T) {</li>
<li>```<br>a, b := 3, 4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. </span><br><span class="line">8. ```</span><br><span class="line">   swapByVal(a, b)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>// 3 4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   t.Log(a, b)</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>swapByVal 函数内部实现了变量交换的逻辑,但外部函数 TestSwapByVal 调用后变量 a,b 并没有改变,可见 Go 语言这种参数传递是值传递而不是引用传递.</p>
<p>上面示例中参数传递的类型都是普通类型,如果参数是指针类型的话,结果会不会不一样呢?</p>
<ol>
<li>func swapByRef(a, b *int) {</li>
<li>```<br>*a, *b = *b, *a<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. &#125;</span><br><span class="line">4. </span><br><span class="line">5. func TestSwapByRef(t *testing.T) &#123;</span><br><span class="line">6. ```</span><br><span class="line">   a, b := 3, 4</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>swapByRef(&amp;a, &amp;b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. </span><br><span class="line">10. ```</span><br><span class="line">   // 4 3</span><br></pre></td></tr></table></figure></li>
<li>```<br>t.Log(a, b)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. &#125;</span><br><span class="line"></span><br><span class="line">指针类型进行参数传递时可以交换变量的值,拷贝的是内存地址,更改内存地址的指向实现了原始变量的交换,参数传递的仍然是值类型.</span><br><span class="line"></span><br><span class="line">实际上, Go 语言进行参数传递的只有值类型一种,这一点不像其他主流的编程语言那样可能既存在值类型又存在引用类型.</span><br><span class="line"></span><br><span class="line">既然是值类型进行参数传递,也就意味着参数传递时直接拷贝一份变量供函数调用,函数内部如何修改参数并不会影响到调用者的原始数据.</span><br><span class="line"></span><br><span class="line">如果只是简单类型并且不希望参数值被修改,那最好不过,如果希望参数值被修改呢?那只能像上例那样传递指针类型.</span><br><span class="line"></span><br><span class="line">简单类型不论是传递普通类型还是指针类型,变量的拷贝过程不会太耗费内存也不会影响状态.</span><br><span class="line"></span><br><span class="line">如果传递的参数本身是比较复杂的类型,仍然进行变量拷贝过程估计就不能满足特定需求了,可能会设计成出传递复杂对象的某种内部指针,不然真的要进行值传递,那还怎么玩?</span><br><span class="line"></span><br><span class="line">Go 只有值传递一种方式,虽然简单,但实际中如何使用应该有特殊技巧,以后再具体分析,现在回到交换变量的例子,换一种思路.</span><br><span class="line"></span><br><span class="line">1. func swap(a, b int) (int, int) &#123;</span><br><span class="line">2. ```</span><br><span class="line">   return b, a</span><br></pre></td></tr></table></figure></li>
<li>}</li>
<li></li>
<li>func TestSwap(t *testing.T) {</li>
<li>```<br>a, b := 3, 4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. </span><br><span class="line">8. ```</span><br><span class="line">   a, b = swap(a, b)</span><br></pre></td></tr></table></figure></li>
<li></li>
<li>```<br>// 4 3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. ```</span><br><span class="line">   t.Log(a, b)</span><br></pre></td></tr></table></figure></li>
<li>}</li>
</ol>
<p>利用 Go 函数可以返回多个值特性,返回交换后的变量值,调用者接收时相当于重新赋值,比传递指针类型要简单不少!</p>
<p>基础语法知识总结和下文预告</p>
<p>刚刚接触 Go 语言时觉得 Go 的语言很简单也很特别,和其他主流的编程语言相比,有着自己独特的想法.</p>
<p>语句结束不用分号 ; 而是直接回车换行,这一点有些不习惯,好在强大的 IDE 可以纠正这些细节.</p>
<p>变量声明时变量名在前,变量类型在后,可能更加符合大脑思维,但是习惯了先写变量类型再写变量名,这确实有一定程度的不方便,后来索性不写变量类型,自然就没有问题了.</p>
<p>函数声明同变量声明类似,返回值放到了最后部分,并且还可以有多个返回值,经过了变量的洗礼,再熟悉函数的这一特点也就不那么惊讶了,先输入后输出,想一想也有道理,难道其他编程语言的顺序都是错的?</p>
<p>接下来就是语法的细节,比如 if 的条件表达式可以进行变量赋值, switch 表达式可以不用 break,只有 for 循环一种形式等等.</p>
<p>这些细节总体来说比较简单方便,不用关心细节,放心大胆使用,从而专注于业务逻辑,等到语法不对时, IDE 自然会给出相应的报错提醒,放心大胆 Go !</p>
<p>本文主要介绍了 Go 的基本语法以及和其他主流的编程语言的异同,你 Get 到了吗?</p>
<p>下文将开始介绍 Go 的内建容器类型,数组,切片, Map 来一遍!</p>
<p>欢迎大家一起学习交流,如有不当之处,恳请指正,如需完整源码,请在公众号[雪之梦技术驿站]留言回复,感谢你的评论与转发!</p>
<p><img src="//note.youdao.com/src/b06096c411b66b176cfc4c48c64b44fd" alt></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Float 的精度</title>
    <url>/b936d10f/</url>
    <content><![CDATA[<p>[toc]</p>
<p>在 Go 中浮点数表示方式和其他语言一样，都是通过科学计数法表示，float 在存储中分为三部分：</p>
<blockquote>
<p>符号位（Sign）: 0代表正，1代表为负<br>指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储<br>尾数部分（Mantissa）：尾数部分</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072227340.png" alt></p>
<p>这种计数法在 Go 里面会有哪些问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">100000.001</span></span><br><span class="line">b := <span class="number">1.0001</span></span><br><span class="line">c := <span class="number">1.0002</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a * (b + c))</span><br><span class="line">fmt.Println(a*b + a*c)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">200030.00200030004</span><br><span class="line">200030.0020003</span><br></pre></td></tr></table></figure>

<p>如果想要准确计算浮点的话，可以尝试 <a href="https://github.com/shopspring/decimal">https://github.com/shopspring/decimal</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := decimal.NewFromFloat(<span class="number">100000.001</span>)</span><br><span class="line">b := decimal.NewFromFloat(<span class="number">1.0001</span>)</span><br><span class="line">c := decimal.NewFromFloat(<span class="number">1.0002</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Mul(b.Add(c))) <span class="comment">//200030.0020003</span></span><br></pre></td></tr></table></figure>



<h2><span id="其他">其他</span></h2><p><a href="https://studygolang.com/articles/14407">在 Go 中探索 IEEE-754 标准 - Go语言中文网 - Golang中文社区 (studygolang.com)</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Happens Before 保证</title>
    <url>/a81f14e2/</url>
    <content><![CDATA[<p>[toc]</p>
<p>创建 goroutine 发生先于 goroutine 执行，所以下面这段代码先读一个变量，然后在 goroutine 中写变量不会发生 data race 问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            i++    </span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>

<p>goroutine 退出没有任何 happen before保证，例如下面代码会有 data race ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            i++</span><br><span class="line">    &#125;()    </span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>

<p>channel 操作中 send 操作是 happens before receive 操作 ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">  c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> f()</span><br><span class="line">  &lt;-c</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面执行顺序应该是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">variable change -&gt; channel send -&gt; channel receive -&gt; variable <span class="built_in">read</span></span><br></pre></td></tr></table></figure>

<p>上面能够保证一定输出 “hello, world”。</p>
<p>close channel 是 happens before receive 操作，所以下面这个例子中也不会有 data race 问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            &lt;-ch</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line">    i++</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>在无缓冲的 channel 中 receive 操作是 happens before send 操作的，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">  &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> f()</span><br><span class="line">  c &lt;- <span class="number">0</span></span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样能保证输出 hello, world。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Shadow 变量</title>
    <url>/7edb3d45/</url>
    <content><![CDATA[<p>[toc]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line">  <span class="keyword">if</span> tracing &#123;</span><br><span class="line">    client, err := createClientWithTracing()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(client)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client, err := createDefaultClient()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(client)  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，声明了一个 client 变量，然后使用 tracing 控制变量的初始化，可能是因为没有声明 err 的缘故，使用的是 := 进行初始化，那么会导致<strong>外层的 client 变量永远是 nil</strong>。这个例子实际上是很容易发生在我们实际的开发中，尤其需要注意。</p>
<p>如果是因为 err 没有初始化的缘故，我们在初始化的时候可以这么做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="keyword">if</span> tracing &#123;</span><br><span class="line">    client, err = createClientWithTracing() </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 防止重复代码</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>或者内层的变量声明换一个变量名字，这样就不容易出错了。</p>
<p>我们也可以使用工具分析代码是否有 shadow，先安装一下工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow</span><br></pre></td></tr></table></figure>

<p>然后使用 shadow 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go vet -vettool=/path/to/shadow ./main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:15:3: declaration of <span class="string">&quot;client&quot;</span> shadows declaration at line 13</span><br><span class="line">./main.go:21:3: declaration of <span class="string">&quot;client&quot;</span> shadows declaration at line 13</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Range</title>
    <url>/ad6a336e/</url>
    <content><![CDATA[<p>[toc]</p>
<h2><span id="copy-的问题">copy 的问题</span></h2><p>使用 range 的时候如果我们直接修改它返回的数据会不生效，因为返回的数据并不是原始数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> account <span class="keyword">struct</span> &#123;</span><br><span class="line">  balance <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  accounts := []account&#123;</span><br><span class="line">    &#123;balance: <span class="number">100.</span>&#125;,</span><br><span class="line">    &#123;balance: <span class="number">200.</span>&#125;,</span><br><span class="line">    &#123;balance: <span class="number">300.</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, a := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">    a.balance += <span class="number">1000</span>  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果像上面这么做，那么输出的 accounts 是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[&#123;100&#125; &#123;200&#125; &#123;300&#125;]</span><br></pre></td></tr></table></figure>

<p>所以我们想要改变 range 中的数据可以这么做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">  accounts[i].balance += <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>range slice 的话也会 copy 一份：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="number">10</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码在 range 的时候会 copy 一份，因此只会调用三次 append 后停止。</p>
<h2><span id="指针问题">指针问题</span></h2><p>比方我们想要 range slice 并将返回值存到 map 里面供后面业务使用，类似这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">string</span></span><br><span class="line">    Balance <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test := []Customer&#123;</span><br><span class="line">      &#123;ID: <span class="string">&quot;1&quot;</span>, Balance: <span class="number">10</span>&#125;,</span><br><span class="line">      &#123;ID: <span class="string">&quot;2&quot;</span>, Balance: <span class="number">-10</span>&#125;,</span><br><span class="line">      &#123;ID: <span class="string">&quot;3&quot;</span>, Balance: <span class="number">0</span>&#125;,</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]*Customer</span><br><span class="line"><span class="keyword">for</span> _, customer := <span class="keyword">range</span> test &#123;</span><br><span class="line">    m[customer.ID] = &amp;customer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样遍历 map 里面存的并不是我们想要的，你会发现存的 value 都是最后一个：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;1&quot;</span>:&#123;<span class="string">&quot;ID&quot;</span>:<span class="string">&quot;3&quot;</span>,<span class="string">&quot;Balance&quot;</span>:<span class="number">0</span>&#125;,<span class="string">&quot;2&quot;</span>:&#123;<span class="string">&quot;ID&quot;</span>:<span class="string">&quot;3&quot;</span>,<span class="string">&quot;Balance&quot;</span>:<span class="number">0</span>&#125;,<span class="string">&quot;3&quot;</span>:&#123;<span class="string">&quot;ID&quot;</span>:<span class="string">&quot;3&quot;</span>,<span class="string">&quot;Balance&quot;</span>:<span class="number">0</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当我们使用 range 遍历 slice 的时候，返回的 customer 变量实际上是一个固定的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, customer := <span class="keyword">range</span> test &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;customer) <span class="comment">//我们想要获取这个指针的时候</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x1400000e240</span><br><span class="line">0x1400000e2400x1400000e240</span><br></pre></td></tr></table></figure>

<p>这是因为迭代器会把数据都放入到 0x1400000e240 这块空间里面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072255914.png" alt></p>
<p>所以我们可以这样在 range 里面获取指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, customer := <span class="keyword">range</span> test &#123;</span><br><span class="line">    current := customer <span class="comment">// 使用局部变量</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;current) <span class="comment">// 这里获取的指针是 range copy 出来元素的指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> test &#123;</span><br><span class="line">    current := &amp;test[i] <span class="comment">// 使用局部变量</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, current)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: String Format 带来的 Dead Lock</title>
    <url>/1dadf84f/</url>
    <content><![CDATA[<p>[toc]</p>
<p>如果类型定义了 String() 方法，它会被用在 fmt.Printf() 中生成默认的输出：等同于使用格式化描述符 %v 产生的输出。还有 fmt.Print() 和 fmt.Println() 也会自动使用 String() 方法。</p>
<p>那么我们看看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span> &#123;</span><br><span class="line">  mutex sync.RWMutex</span><br><span class="line">  id <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Customer)</span></span> UpdateAge(age <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">  c.mutex.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;age should be positive for customer %v&quot;</span>, c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c.age = age</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Customer)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;enter string method&quot;</span>)</span><br><span class="line">  c.mutex.RLock()</span><br><span class="line">  <span class="keyword">defer</span> c.mutex.RUnlock()</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;id %s, age %d&quot;</span>, c.id, c.age)&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，如果调用 UpdateAge 方法 age 小于0会调用 fmt.Errorf，格式化输出，这个时候 String() 方法里面也进行了加锁，那么这样会造成死锁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutex.Lock -&gt; check age -&gt; Format error -&gt; call String() -&gt; mutex.RLock</span><br></pre></td></tr></table></figure>

<p>解决方法也很简单，一个是缩小锁的范围，在 check age 之后再加锁，另一种方法是 Format error 的时候不要 Format 整个结构体，可以改成 Format id 就行了。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Slice 相关</title>
    <url>/46d0864d/</url>
    <content><![CDATA[<p>[toc]</p>
<h2><span id="slice-的-length-和-capacity">slice 的 length 和 capacity</span></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>在 make 函数里面，capacity 是可选的参数。上面这段代码我们创建了一个 length 是 3，capacity 是 6 的 slice，那么底层的数据结构是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072236023.png" alt></p>
<p>slice 的底层实际上指向了一个数组。当然，由于我们的 length 是 3，所以这样设置 s[4] = 0 会 panic 的。需要使用 append 才能添加新元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panic: runtime error: index out of range [4] with length 3</span><br></pre></td></tr></table></figure>

<p>当 appned 超过 cap 大小的时候，slice 会自动帮我们扩容，<strong>在元素数量小于 1024 的时候每次会扩大一倍，当超过了 1024 个元素每次扩大 25%</strong>。</p>
<p>有时候我们会使用 ：操作符从另一个 slice 上面创建一个新切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">s2 := s1[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>实际上这两个 slice 还是指向了底层同样的数组，构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072242263.png" alt></p>
<p>由于指向了同一个数组，那么当我们改变第一个槽位的时候，比如 s1[1]=2，实际上两个 slice 的数据都会发生改变：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072242344.png" alt></p>
<p>但是当我们使用 append 的时候情况会有所不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1) <span class="comment">// [0 2 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">// [2 0 3]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072245415.png" alt></p>
<p>s1 的 len 并没有被改变，所以看到的还是3元素。</p>
<p>还有一件比较有趣的细节是，如果再接着 append s1 那么第四个元素会被覆盖掉：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">4</span>)</span><br><span class="line">  fmt.Println(s1) <span class="comment">// [0 2 0 4]</span></span><br><span class="line">  fmt.Println(s2) <span class="comment">// [2 0 4]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072246667.png" alt></p>
<p>再继续 append s2 直到 s2 发生扩容，这个时候会发现 s2 实际上和 s1 指向的不是同一个数组了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">fmt.Println(s1) <span class="comment">//[0 2 0 4]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[2 0 4 5 6 7]</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072247151.png" alt></p>
<p>除了上面这种情况，还有一种情况 append 会产生意想不到的效果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := s1[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072249781.png" alt></p>
<p>如果 print 它们应该是这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1=[<span class="number">1</span> <span class="number">2</span> <span class="number">10</span>], s2=[<span class="number">2</span>], s3=[<span class="number">2</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure>



<h2><span id="slice-初始化">slice 初始化</span></h2><p>slice 的初始化有很多种方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">        log(<span class="number">1</span>, s)</span><br><span class="line"></span><br><span class="line">        s = []<span class="type">string</span>(<span class="literal">nil</span>)</span><br><span class="line">        log(<span class="number">2</span>, s)</span><br><span class="line"></span><br><span class="line">        s = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">        log(<span class="number">3</span>, s)</span><br><span class="line"></span><br><span class="line">        s = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">        log(<span class="number">4</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(i <span class="type">int</span>, s []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d: empty=%t\tnil=%t\n&quot;</span>, i, <span class="built_in">len</span>(s) == <span class="number">0</span>, s == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">true</span></span><br><span class="line"><span class="number">2</span>: empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">true</span></span><br><span class="line"><span class="number">3</span>: empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">false</span></span><br><span class="line"><span class="number">4</span>: empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>前两种方式会创建一个 nil 的 slice，后两种会进行初始化，并且这些 slice 的大小都为 0 。</p>
<p>对于 var s []string 这种方式来说，好处就是<strong>不用做任何的内存分配</strong>。比如下面场景可能可以节省一次内存分配:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">        <span class="keyword">if</span> foo() &#123;</span><br><span class="line">                s = <span class="built_in">append</span>(s, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bar() &#123;</span><br><span class="line">                s = <span class="built_in">append</span>(s, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 s := []string{} 这种方式来说，它<strong>比较适合初始化一个已知元素的 slice</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有这个需求其实用 var s []string 比较好，反正在使用的适合都是通过 append 添加元素， var s []string 还能节省一次内存分配。</p>
<p>如果我们初始化了一个空的 slice， 那么<strong>最好是使用</strong> len(xxx) == 0<strong>来判断 slice 是不是空的</strong>，如果使用 nil 来判断可能会永远非空的情况，因为对于 s := []string{} 和 s = make([]string, 0) 这两种初始化都是非 nil 的。</p>
<p>对于 []string(nil) 这种初始化的方式，使用场景很少，一种比较方便地使用场景是用它来进行 slice 的 copy：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dst := <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), src...)</span><br></pre></td></tr></table></figure>

<p>对于 make 来说，它可以初始化 slice 的 length 和 capacity，如果我们能确定 slice 里面会存放多少元素，<strong>从性能的角度考虑最好使用 make 初始化好</strong>，因为对于一个空的 slice append 元素进去每次达到阈值都需要进行扩容，下面是填充 100 万元素的 benchmark：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BenchmarkConvert_EmptySlice-4 22 49739882 ns/op</span><br><span class="line">BenchmarkConvert_GivenCapacity-4 86 13438544 ns/op</span><br><span class="line">BenchmarkConvert_GivenLength-4 91 12800411 ns/op</span><br></pre></td></tr></table></figure>

<p>可以看到，如果我们提前填充好 slice 的容量大小，性能是空 slice 的四倍，因为少了扩容时元素复制以及重新申请新数组的开销。</p>
<h2><span id="copy-slice">copy slice</span></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> dst []<span class="type">int</span></span><br><span class="line"><span class="built_in">copy</span>(dst, src)</span><br><span class="line">fmt.Println(dst) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>使用 copy 函数 copy slice 的时候需要注意，上面这种情况实际上会 copy 失败，因为对 slice 来说是由 length 来控制可用数据，copy 并没有复制这个字段，要想 copy 我们可以这么做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(src))</span><br><span class="line"><span class="built_in">copy</span>(dst, src)</span><br><span class="line">fmt.Println(dst) <span class="comment">//[0 1 2]</span></span><br></pre></td></tr></table></figure>

<p>除此之外也可以用上面提到的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dst := <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), src...)</span><br></pre></td></tr></table></figure>

<h2><span id="slice-capacity内存释放问题">slice capacity内存释放问题</span></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  v []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepFirstTwoElementsOnly</span><span class="params">(foos []Foo)</span></span> []Foo &#123;</span><br><span class="line">  <span class="keyword">return</span> foos[:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  foos := <span class="built_in">make</span>([]Foo, <span class="number">1_000</span>)</span><br><span class="line">  printAlloc()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(foos); i++ &#123;</span><br><span class="line">    foos[i] = Foo&#123;</span><br><span class="line">      v: <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printAlloc()</span><br><span class="line"></span><br><span class="line">  two := keepFirstTwoElementsOnly(foos)</span><br><span class="line">  runtime.GC()</span><br><span class="line">  printAlloc()</span><br><span class="line">  runtime.KeepAlive(two)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中使用 printAlloc 函数来打印内存占用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAlloc</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">  runtime.ReadMemStats(&amp;m)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d KB\n&quot;</span>, m.Alloc/<span class="number">1024</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 foos 初始化了 1000 个容量的 slice ，里面 Foo struct 每个都持有 1M 内存的 slice，然后通过 keepFirstTwoElementsOnly 返回持有前两个元素的 Foo 切片，我们的想法是手动执行 GC 之后其他的 998 个 Foo 会被 GC 销毁，但是输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">387</span> KB</span><br><span class="line"><span class="number">1024315</span> KB1024319 KB</span><br></pre></td></tr></table></figure>

<p>实际上并没有，原因就是实际上 keepFirstTwoElementsOnly 返回的 slice 底层持有的数组是和 foos 持有的同一个：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072252699.png" alt></p>
<p>所以我们真的要只返回 slice 的前2个元素的话应该这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepFirstTwoElementsOnly</span><span class="params">(foos []Foo)</span></span> []Foo &#123;</span><br><span class="line">        res := <span class="built_in">make</span>([]Foo, <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">copy</span>(res, foos)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过上面这种方法会初始化一个新的 slice，然后将两个元素 copy 过去。不想进行多余的分配可以这么做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepFirstTwoElementsOnly</span><span class="params">(foos []Foo)</span></span> []Foo &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(foos); i++ &#123;</span><br><span class="line">                foos[i].v = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> foos[:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Defer</title>
    <url>/725e70e6/</url>
    <content><![CDATA[<p>[toc]</p>
<h2><span id="注意-defer-的调用时机">注意 defer 的调用时机</span></h2><p>有时候我们会像下面一样使用 defer 去关闭一些资源：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> path := <span class="keyword">range</span> ch &#123;</span><br><span class="line">                    file, err := os.Open(path)</span><br><span class="line">                    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> err</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// Do something with file</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为defer会在方法结束的时候调用，但是<strong>如果上面的 readFiles 函数永远没有 return，那么 defer 将永远不会被调用</strong>，从而造成内存泄露。并且 defer 写在 for 循环里面，编译器也无法做优化，会影响代码执行性能。</p>
<p>为了避免这种情况，我们可以 wrap 一层：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> path := <span class="keyword">range</span> ch &#123; </span><br><span class="line">          <span class="keyword">if</span> err := readFile(path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> err</span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">      file, err := os.Open(path)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do something with file</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="注意-defer-的参数">注意 defer 的参数</span></h2><p>defer 声明时会先计算确定参数的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> notice(i) <span class="comment">// 0</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notice</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 i 在 defer 被调用的时候就已经确定了，而不是在 defer执行的时候，所以上面的语句输出的是 0。</p>
<p>所以我们想要获取这个变量的真实值，应该用引用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">defer</span> notice(&amp;i) <span class="comment">// 1</span></span><br><span class="line">  i++</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="defer-下的闭包">defer 下的闭包</span></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(i + <span class="number">1</span>) <span class="comment">//12</span></span><br><span class="line">  &#125;()</span><br><span class="line">  i++</span><br><span class="line">  <span class="keyword">return</span> i+<span class="number">10</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  fmt.Println(a()) <span class="comment">//11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果换成闭包的话，<strong>实际上闭包中对变量i是通过</strong>指针传递<strong>的</strong>，所以可以读到真实的值。但是上面的例子中 a 函数返回的是 11 是因为执行顺序是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">先计算（i+10）-&gt; (call defer) -&gt; (<span class="built_in">return</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: String 相关</title>
    <url>/b23a493c/</url>
    <content><![CDATA[<p>[toc]</p>
<h3><span id="迭代带来的问题">迭代带来的问题</span></h3><p>在 Go 语言中，字符串是一种基本类型，<strong>默认是通过 utf8 编码的字符序列</strong>，当字符为 ASCII 码时则占用 1 个字节，其他字符根据需要占用 2-4 个字节，比如中文编码通常需要 3 个字节。</p>
<p>那么我们在做 string 迭代的时候可能会产生意想不到的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hêllo&quot;</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;position %d: %c\n&quot;</span>, i, s[i])</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;len=%d\n&quot;</span>, <span class="built_in">len</span>(s))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">position 0: h</span><br><span class="line">position 1: Ã</span><br><span class="line">position 3: l</span><br><span class="line">position 4: l</span><br><span class="line">position 5: o</span><br><span class="line">len=6</span><br></pre></td></tr></table></figure>

<p>上面的输出中发现第二个字符是 Ã，不是 ê，并且位置2的输出”消失“了，这其实就是因为 ê 在 utf8 里面实际上占用 2 个 byte：</p>
<table>
<thead>
<tr>
<th>s</th>
<th>h</th>
<th>ê</th>
<th>l</th>
<th>l</th>
<th>o</th>
</tr>
</thead>
<tbody><tr>
<td>[]byte(s)</td>
<td>68</td>
<td>c3 aa</td>
<td>6c</td>
<td>6c</td>
<td>6f</td>
</tr>
</tbody></table>
<p>所以我们在迭代的时候 s[1] 等于 c3 这个 byte 等价 Ã 这个 utf8 值，所以输出的是 hÃllo 而不是 hêllo。</p>
<p>那么根据上面的分析，我们就可以知道在迭代获取字符的时候不能只获取单个 byte，应该使用 range 返回的 value值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hêllo&quot;</span></span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;position %d: %c\n&quot;</span>, i, v)  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>或者我们可以把 string 转成 rune 数组，在 go 中 rune 代表 Unicode码位，用它可以输出单个字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hêllo&quot;</span></span><br><span class="line">  runes := []<span class="type">rune</span>(s)</span><br><span class="line">  <span class="keyword">for</span> i, _ := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;position %d: %c\n&quot;</span>, i, runes[i])  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">position 0: h</span><br><span class="line">position 1: ê</span><br><span class="line">position 2: l</span><br><span class="line">position 3: l</span><br><span class="line">position 4: o</span><br></pre></td></tr></table></figure>

<h2><span id="截断带来的问题">截断带来的问题</span></h2><p>Go 中<strong>在对slice使用 ：操作符进行截断的时候，底层的数组实际上指向同一个</strong>，在 string 里面也需要注意这个问题，比如下面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s store)</span></span> handleLog(log <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(log) &lt; <span class="number">36</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> errors.New(<span class="string">&quot;log is not correctly formatted&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            uuid := log[:<span class="number">36</span>]</span><br><span class="line">            s.store(uuid)</span><br><span class="line">            <span class="comment">// Do something    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用了 ：操作符进行截断，但是如果 log 这个对象很大，比如上面的 store 方法把 uuid 一直存在内存里，可能会造成底层的数组一直不释放，从而造成内存泄露。</p>
<p>为了解决这个问题，我们可以先复制一份再处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s store)</span></span> handleLog(log <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(log) &lt; <span class="number">36</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> errors.New(<span class="string">&quot;log is not correctly formatted&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            uuid := strings.Clone(log[:<span class="number">36</span>]) <span class="comment">// copy一份</span></span><br><span class="line">            s.store(uuid)</span><br><span class="line">            <span class="comment">// Do something    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: 八进制整数</title>
    <url>/8f80ddfc/</url>
    <content><![CDATA[<p>[toc]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">100</span> + <span class="number">011</span>  fmt.Println(sum)</span><br></pre></td></tr></table></figure>

<p>运行之后，不会输出 111，而是 108， 因为<strong>在 Go 中以 0 开头的整数表示八进制</strong></p>
<p>它经常用在处理 Linux 权限相关的代码上，如下面打开一个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">&quot;foo&quot;</span>, os.O_RDONLY, <span class="number">0644</span>)</span><br></pre></td></tr></table></figure>

<p>所以为了可读性，我们在用八进制的时候最好使用 “0o” 的方式表示，比如上面这段代码可以表示为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">&quot;foo&quot;</span>, os.O_RDONLY, <span class="number">0o644</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go闭包技术</title>
    <url>/eb01d7dc/</url>
    <content><![CDATA[<p>斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201002956.png" alt></p>
<p>斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和.<br>为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">// a b</span><br><span class="line">// a b</span><br><span class="line">a, b := 0, 1</span><br></pre></td></tr></table></figure>

<p>初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    fmt.Print(a, &quot; &quot;)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func fibonacciByNormal() &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        fmt.Print(a, &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacciByNormal(t *testing.T) &#123;</span><br><span class="line">    fibonacciByNormal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func fibonacci() func() int &#123;</span><br><span class="line">    a, b := 0, 1</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1 1 2 3 5 8 13 21 34 55</span><br><span class="line">func TestFibonacci(t *testing.T) &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Print(f(), &quot; &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为”闭包”!</p>
<p>闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func autoIncrease() func() int &#123;</span><br><span class="line">    i := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        i = i + 1</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestAutoIncrease(t *testing.T) &#123;</span><br><span class="line">    a := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(a(), a(), a())</span><br><span class="line">    b := autoIncrease()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(b(), b(), b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果.</p>
<p>普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生.</p>
<p>但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会”长生不老”,并不会因为出身于函数内就和普通变量拥有一样的短暂人生.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func fightWithHorse() func() int &#123;</span><br><span class="line">    horseShowTime := 0</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        horseShowTime++</span><br><span class="line">        fmt.Printf(&quot;(%d)祖国需要我,我就提枪上马立即战斗!\n&quot;,horseShowTime)</span><br><span class="line">        return horseShowTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFightWithHorse(t *testing.T) &#123;</span><br><span class="line">    f := fightWithHorse()</span><br><span class="line">    // 1 2 3</span><br><span class="line">    t.Log(f(), f(), f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心!<br>下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestCountByClosure(t *testing.T) &#123;</span><br><span class="line">    // 4 4 4</span><br><span class="line">    for _, c := range countByClosureButWrong() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c.</p>
<p>当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4.</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003531.png" alt></p>
<p>原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了!</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003721.png" alt></p>
<p>长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4.</p>
<p>既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛!</p>
<p>最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func countByClosureButWrong() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        n := i</span><br><span class="line">        fmt.Printf(&quot;for i=%d n=%d \n&quot;, i,n)</span><br><span class="line">        arr = append(arr, func() int &#123;</span><br><span class="line">            fmt.Printf(&quot;append i=%d n=%d\n&quot;, i, n)</span><br><span class="line">            return n</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003831.png" alt></p>
<p>上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级.</p>
<p>既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func countByClosureWithOk() []func() int &#123;</span><br><span class="line">    var arr []func() int</span><br><span class="line"> for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;for i=%d \n&quot;, i)</span><br><span class="line">        func(n int) &#123;</span><br><span class="line">            arr = append(arr, func() int &#123;</span><br><span class="line">                fmt.Printf(&quot;append n=%d \n&quot;, n)</span><br><span class="line">                return n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestCountByClosureWithOk(t *testing.T) &#123;</span><br><span class="line">    // 1 2 3</span><br><span class="line">    for _, c := range countByClosureWithOk() &#123;</span><br><span class="line">        t.Log(c())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟类和对象的关系,也可以实现封装,具备一定面向对象能力<ul>
<li>每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系.</li>
</ul>
</li>
<li>缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本.<ul>
<li>长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用.</li>
</ul>
</li>
<li>实现闭包成本较高,同时也增加了理解难度.<ul>
<li>普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性.</li>
</ul>
</li>
<li>滥用容易占用过多内存,可能造成内存泄漏.<ul>
<li>过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的坑: Init 函数</title>
    <url>/dc53dc63/</url>
    <content><![CDATA[<p>[toc]</p>
<h2><span id="init-函数会在全局变量之后被执行">init 函数会在全局变量之后被执行</span></h2><p><strong>init 函数并不是最先被执行的，如果声明了 const 或全局变量，那么 init 函数会在它们之后执行：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">a</span><br><span class="line">initmain</span><br></pre></td></tr></table></figure>

<h2><span id="init-初始化按解析的依赖关系顺序执行">init 初始化按解析的依赖关系顺序执行</span></h2><p>比如 main 包里面有 init 函数，依赖了 redis 包，main 函数执行了 redis 包的 Store 函数，恰好 redis 包里面也有 init 函数，那么执行顺序会是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072221755.png" alt></p>
<p>还有一种情况，如果是使用 “import _ foo” 这种方式引入的，也是会先调用 foo 包中的 init 函数。</p>
<h2><span id="扰乱单元测试">扰乱单元测试</span></h2><p>比如我们在 init 函数中初始了一个全局的变量，但是单测中并不需要，那么实际上会增加单测得复杂度，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  dataSourceName := os.Getenv(<span class="string">&quot;MYSQL_DATA_SOURCE_NAME&quot;</span>)</span><br><span class="line">    d, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dataSourceName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    db = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中 init 函数初始化了一个 db 全局变量，那么在单测的时候也会初始化一个这样的变量，但是很多单测其实是很简单的，并不需要依赖这个东西。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Go：异步抢占</title>
    <url>/5698ca18/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/00.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French"></p>
<p>ℹ️ 本文基于 Go 1.14。</p>
<p>抢占是调度器的重要部分，基于抢占调度器可以在各个协程中分配运行的时间。实际上，如果没有抢占机制，一个长时间占用 CPU 的协程会阻塞其他的协程被调度。1.14 版本引入了一项新的异步抢占的技术，赋予了调度器更大的能力和控制力。</p>
<p><em>我推荐你阅读我的文章<a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7">”Go：协程和抢占“</a>来了解更多之前的特性和它的弊端。</em></p>
<h2><span id="工作流">工作流</span></h2><p>我们以一个需要抢占的例子来开始。下面一段代码开启了几个协程，在几个循环中没有其他的函数调用，意味着调度器没有机会抢占它们：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/01.png" alt></p>
<p>然而，当把这个程序的追踪过程可视化后，我们清晰地看到了协程间的抢占和切换：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/02.png" alt></p>
<p>我们还可以看到表示协程的每个块儿的长度都相等。所有的协程运行时间相同（约 10 到 20 毫秒）。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/03.png" alt></p>
<p>异步抢占是基于一个时间条件触发的。当一个协程运行超过 10ms 时，Go 会尝试抢占它。</p>
<p>抢占是由线程 <code>sysmon</code> 初始化的，该线程专门用于监控包括长时间运行的协程在内的运行时。当某个协程被检测到运行超过 10ms 后，<code>sysmon</code> 向当前的线程发出一个抢占信号。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/04.png" alt></p>
<p>之后，当信息被信号处理器接收到时，线程中断当前的操作来处理信号，因此不会再运行当前的协程，在我们的例子中是 <code>G7</code>。取而代之的是，<code>gsignal</code> 被调度为管理发送来的信号。当它发现它是一个抢占指令后，在程序处理信号后恢复时它准备好指令来中止当前的协程。下面是这第二个阶段的示意图：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/05.png" alt></p>
<p><em>如果你想了解更多关于 <code>gsignal</code> 的信息，我推荐你读一下我的文章<a href="https://medium.com/a-journey-with-go/go-gsignal-master-of-signals-329f7ff39391">”Go：gsignal，信号的掌控者“</a>。</em></p>
<h2><span id="实现">实现</span></h2><p>我们在被选中的信号 <code>SIGURG</code> 中第一次看到了实现的细节。这个选择在提案<a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">”提案：非合作式协程抢占“</a>中有详细的解释：</p>
<blockquote>
<ul>
<li>它应该是调试者默认传递过来的一个信号。</li>
<li>它不应该是 Go/C 混合二进制中 libc 内部使用的信号。</li>
<li>它应该是一个可以伪造而没有其他后果的信号。</li>
<li>我们需要在没有实时信号时与平台打交道。<br>然后，当信号被注入和接收时，Go 需要一种在程序恢复时能终止当前协程的方式。为了实现这个过程，Go 会把一条指令推进程序计数器，这样看起来运行中的程序调用了运行时的函数。该函数暂停了协程并把它交给了调度器，调度器之后还会运行其他的协程。</li>
</ul>
</blockquote>
<p><em>我们应该注意到 Go 不能做到在任何地方终止程序；当前的指令必须是一个安全点。例如，如果程序现在正在调用运行时，那么抢占协程并不安全，因为运行时很多函数不应该被抢占。</em></p>
<p>这个新的抢占机制也让垃圾回收器受益，可以用更高效的方式终止所有的协程。诚然，STW 现在非常容易，Go 仅需要向所有运行的线程发出一个信号就可以了。下面是垃圾回收器运行时的一个例子：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/06.png" alt></p>
<p>然后，所有的线程都接收到这个信号，在垃圾回收器重新开启全局之前会暂停执行。</p>
<p><em>如果你想了解更多关于 STW 的信息，我建议你阅读我的文章<a href="https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846">”Go：Go 怎样实现 STW？“</a>。</em></p>
<p>最后，这个特性被封装在一个参数中，你可以用这个参数关闭异步抢占。你可以用 <code>GODEBUG=asyncpreemptoff=1</code> 来运行你的程序，如果你因为升级到了 Go 1.14 发现了不正常的现象就可以调试你的程序，或者观察你的程序有无异步抢占时的不同表现。</p>
<hr>
<p>via: <a href="https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c">https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c</a></p>
<p>作者：<a href="https://medium.com/@blanchon.vincent">Vincent Blanchon</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/polaris1119">polaris1119</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo pure主题配置utteranc评论</title>
    <url>/852e4155/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-安装应用">1 安装应用</a></li>
<li><a href="#2-基本参数">2 基本参数</a></li>
<li><a href="#3-pure-主题配置">3 pure 主题配置</a></li>
</ul>
<!-- tocstop -->

<p>utteranc 官网<br><a href="https://utteranc.es/">https://utteranc.es/</a></p>
<h2><span id="1-安装应用">1 安装应用</span></h2><p><a href="https://github.com/apps/utterances">https://github.com/apps/utterances</a><br>设置指定仓库</p>
<h2><span id="2-基本参数">2 基本参数</span></h2><p>官方的脚本如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span><br><span class="line">        repo=<span class="string">&quot;yansheng836/yansheng836.github.io&quot;</span></span><br><span class="line">        issue-term=<span class="string">&quot;title&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;github-light&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>主要参数：</p>
<ul>
<li>repo：存放评论的issues的仓库名（即步骤1指定访问的仓库），可以和博客相同，也可以不同。</li>
<li>issue-term：指定issues的标题，title表示使用文章的标题作为issues的标题。可选参数（只介绍部分）：</li>
<li>URL：博客网址：网址全路径</li>
<li>pathname：URL 去掉域名</li>
<li>title：博客标题（推荐使用这个，因为上面两个涉及到网址，如果网址包含中文，会被转义，不方便看。）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20221216220503.png" alt></p>
<ul>
<li>theme：评论系统的主题，在Theme里面，选择主题，页面会变色：<a href="https://utteranc.es/#heading-theme">https://utteranc.es/#heading-theme</a></li>
</ul>
<h2><span id="3-pure-主题配置">3 pure 主题配置</span></h2><p>修改 <code>themes/pure/_config.yml</code></p>
<p><strong>comment type 改为 utterance</strong><br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20221216220923.png" alt></p>
<p><strong>添加 utterance 相关配置</strong><br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20221216221120.png" alt></p>
<p><strong>修改 ejs</strong><br>在 <code>themes/pure/layout/_partial/post/comment.ejs</code> 文件中插入以下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% &#125; <span class="keyword">else</span> <span class="keyword">if</span> (theme.<span class="property">comment</span>.<span class="property">type</span> === <span class="string">&#x27;utterance&#x27;</span>) &#123; %&gt;</span><br><span class="line">      &lt;% <span class="keyword">if</span> (theme.<span class="property">comment</span>.<span class="property">utterance</span>.<span class="property">enable</span>)&#123; %&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="selector-class">.utterances</span>&#123;<span class="attribute">max-width</span>: <span class="number">100%</span>;&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">          </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">repo</span>=<span class="string">&quot;&lt;%= theme.comment.utterance.repo %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">issue-term</span>=<span class="string">&quot;&lt;%= theme.comment.utterance.issue_term %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">theme</span>=<span class="string">&quot;&lt;%= theme.comment.utterance.theme %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">async</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">      &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】How to split a string in C++</title>
    <url>/9747854a/</url>
    <content><![CDATA[<p>这个问题是说, 怎么得到组成一句话的各个单词, 或者得到CSV中的各个数据片段. 这在C++中是个很简单的问题, 却有很多种答案.</p>
<p>有3种方案, 每种有利有弊. 使用时请自己选择最佳方案. 这篇文章的目的是说明 迭代器的接口是如何优胜于简单的容器的, 并且阐明 <a href="http://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/">design of the STL</a> 是何等强大.</p>
<p>方案1使用的标准组件(虽然方案1.2 做了微调). 方案2相对好点但使用了<code>boost</code>. 而方案3 更好但使用了<code>ranges</code>. 所以到底应该用哪个, 取决于你需要什么和你能使用什么.</p>
<h3><span id="solution-1-iterating-on-a-stream">Solution 1: Iterating on a stream</span></h3><h4><span id="stepping-into-the-world-of-streams">Stepping into the world of streams</span></h4><p>“流” 是一个 能生成 与源或希望连接的目标 的联系 的对象. 流可以从源中获取信息(<code>std::istream</code>), 或为目标提供信息(<code>std::ostream</code>), 或者两者皆可(<code>std::iostream</code>).</p>
<p>源和目标可以是标准输入(<code>std::cin</code>), 标准输出(<code>std::cout</code>), 一个文件, 或者一个字符串, 前提是方式得当. 对流的主要操作包括: - 对于输入流: 使用操作符<code>&gt;&gt;</code> 从里面读取信息 - 对于输出流: 使用操作符<code>&lt;&lt;</code>, 向它推入信息</p>
<p>一个指向字符串的输入流, <code>std::istringstream</code>, 有个有趣的特性: 它的操作符<code>&gt;&gt;</code> 在源字符串中制造出去向下一个空格的字符串.</p>
<h4><span id="istream_iterator">istream_iterator</span></h4><p><code>std::istream_iterator</code> 是连接输入流的迭代器. 它代表了输入迭代器的普遍接口, 但它的操作符<code>++</code> 更像是输入流.</p>
<p><code>istream_iterator</code> 以它从流里读取的类型为模板. 我们现在使用<code>istream_iterator&lt;std::string&gt;</code>, 它从流里读取字符串, 分离时为我们提供一个字符串.</p>
<p>当到达流的终点时, 流向它的迭代器发送信号, 然后迭代器被标记为结束.</p>
<h3><span id="solution-11">Solution 1.1</span></h3><p>现在, 我们可以借迭代器的接口使用算法, 这真切地证明了<code>STL</code> 设计的灵活性. 为了使用<code>STL</code>, 我们需要一个<code>begin</code> 和一个<code>end</code> (请参考<a href="http://www.fluentcpp.com/2017/03/28/inserting-several-elements-into-an-stl-container/">Inserting several elements into an STL container efficiently</a>). <code>begin</code> 是一个 还没开始着手分割的字符串的<code>istreamstream</code> 的迭代器: <code>std::istream_iterator&lt;std::string&gt;(iss)</code> . 按照惯例, <code>end</code> 的默认值也是个<code>istream_iterator</code> : <code>std::istream_iterator&lt;string&gt;()</code>.</p>
<p>代码如下:</p>
<pre><code>std::string text = &quot;Let me split this into words&quot;;
std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;std::string&gt;(iss)), std::istream_iterator&lt;std::string&gt;());</code></pre><p><strong>第一个参数的额外的括号是为了避免与一个函数调用的歧义–请参考Scott Meyers的著作Effective STL 条目6 “most vexing parse”</strong></p>
<p>优: - 仅使用标准组件 - 除字符串外, 对所有流都适用 劣: - 只能以空格为分隔符进行分割, 而且这在解析CSV时会是个至关重要的问题 - 在性能方面有待优化(但如果这不是影响你整个程序的瓶颈, 这也不是个大问题) - 很多人认为仅为了分割一个字符串, 写了太多代码</p>
<h3><span id="solution12-pimp-my-operatorgtgt">Solution1.2: Pimp my operator&gt;&gt;</span></h3><p>导致上面两条劣势的原因是同一个: <code>istream_iterator</code> 从流里读取字符串时调用的操作符<code>&gt;&gt;</code>. 这个操作符做了很多事: 在下一个空格处停止(这是我们的最初的需求, 但这个不能自定义), 格式化, 读取然后设置一些标志位, 构造对象, 等等. 而以上这些, 大部分我们是不需要的. 所以我们希望自己实现下面的函数:</p>
<pre><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; is, std::string&amp; output)
&#123;
    // ...does lots of things...
&#125;</code></pre><p>实际上, 我们无法改变这些, 因为这是在标注库里的. 我们可以用另一个类型重载它, 但是这个类型需要是<code>string</code> 的一种.</p>
<p>所以现在的需求就是, 用另一种类型伪装成<code>string</code>. 有两种方案: 继承<code>std::string</code> 和 用显式转换封装<code>string</code>. 这里我们选择继承.</p>
<p>假如我们希望以逗号为分割符分割一个字符串:</p>
<pre><code>class WordDelimitedByCommas: pulic std::string
&#123;&#125;;</code></pre><p>我必须承认这是有争议的. 有人会说:”<code>std::string</code> 没有虚析构函数, 所以你不应该继承它!” 这可能, 大概, 也许是有一点点点点武断. 这里我要说的是, 继承本身不会产生问题. 诚然, 当一个指向<code>WordDelimitedByCommas</code> 的指针以<code>std::string</code> 的形式被<code>delete</code> 掉时, 会产生问题. 继续读, 你会发现, 我们不会这么做. 现在我们可以阻止写代码的人借<code>WordDelimitedByCommas</code> 突发冷箭破坏程序吗? 我们不能. 但是这个险值得我们冒吗? 请继续读, 然后你自己判断.</p>
<p>现在为了仅实现我们需要的功能, 我们可以重载操作符<code>&gt;&gt;</code> : 获取下一个逗号之前的所有字符. 这个可以借用<code>getline</code> 函数实现:</p>
<pre><code>std::istream&amp; operator&gt;&gt;(std::istream* is, std::WordDelimitedByCommas&amp;)
&#123;
    std::getline(is, output, &apos;,&apos;);
    return is;
&#125;</code></pre><p><strong>返回值<code>is</code> 保证了可以连续调用操作符<code>&gt;&gt;</code></strong></p>
<p>现在我们可以写初级代码了:</p>
<pre><code>std::string text = &quot;Let,me,split,this,into,words&quot;;
std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedByCommas&gt;(iss)), std::istream_iterator&lt;WordDelimitedByCommas&gt;());</code></pre><p>我们可以通过模板化<code>WordDelimitedByCommas</code> 泛华所有的分隔符:</p>
<pre><code>template&lt;char delemiter&gt;
class WordDelimitedBy: pulic std::string
&#123;&#125;;</code></pre><p>现在以分号举例:</p>
<pre><code>std::string text = &quot;Let;me;split;this;into;words&quot;;
std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedBy&lt;&apos;;&apos;&gt;&gt;(iss)), std::istream_iterator&lt;WordDelimitedBy&lt;&apos;;&apos;&gt;&gt;());</code></pre><p>优: - 编译时允许任何分隔符 - 不仅是字符串, 对任何流都可以操作 - 比方案1更快(快20%到30%) 劣: - 虽然可以很方便的复用, 但仍不是标准 - 仅仅为了分割一个字符串, 这个方案仍然使用了大量代码</p>
<h3><span id="solution2-using-boostsplit">Solution2: Using <code>boost::split</code></span></h3><p>这个方案比方案1高级, 除非你需要对所有的流都进行操作.</p>
<pre><code>#include &lt;boost/algorithm/string.hpp&gt;

std::string text = &quot;Let me split this into words&quot;;
std::vector&lt;std::string&gt; result;
boost::split&lt;results, text, [](char c)&#123;return &apos; &apos; == c;&#125;);</code></pre><p>传给<code>boost::split</code> 的第三个参数是一个函数或函数对象, 确定一个字符是不是分隔符. 上面的例子是使用<code>lambda</code> 表达式, 传入一个<code>char</code>, 返回这个<code>char</code> 是否是空格.</p>
<p><code>boost::split</code> 的实现很简单: 在到达字符串的结束位置之前, 重复地调用<code>find_if</code> .</p>
<p>优: - 非常直观的接口 - 允许任何分隔符, 甚至是多个 - 高效: 比方案1.1 快 60% 劣: - 暂不是标准: 需要用到<code>boost</code></p>
<h3><span id="solution-3未来-usingranges">Solution 3(未来): Using<code>ranges</code></span></h3><p>虽然它们现在还没有像标准库甚至<code>boost</code> 里的组件一样被广泛使用, <code>ranges</code> 是<a href="http://www.fluentcpp.com/2017/01/12/ranges-stl-to-the-next-level/">future of the STL</a> . 在未来几年, 会大量面世.</p>
<p>Eric Neiber 的 <a href="https://github.com/ericniebler/range-v3/blob/master/test/view/split.cpp">range-v3</a> 库 提供了非常友好的接口. 为了生成一个字符串的分割<code>view</code>, 代码如下:</p>
<pre><code>std::string text = &quot;Let me split this into words&quot;;
auto splitText = text | view::split(&apos; &apos;);</code></pre><p>它有很多有趣的特性, 诸如 使用一个子字符串作为分隔符. <code>ranges</code> 会被<code>C++20</code> 引入, 所以我们应该能在几年之内就可以使用这个功能了.</p>
<h3><span id="so-how-do-i-split-my-string">So, how do I split my string?</span></h3><p>如果你能使用<code>boost</code>, 务必使用方案2. 或者你可以自己写算法, 像<code>boost</code> 那样基于<code>find_if</code> 分割字符串.</p>
<p>如果你不想这么做, 你可以使用标准, 即方案1.1, 如果你需要自定义分隔符, 或者发现1.1是个瓶颈, 那么你可以选择方案1.2 .</p>
<p>如果你可以使用<code>ranges</code> , 那么就应该选择方案3.</p>
<p>翻译原文: <a href="http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/">http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Inlining Optimisations in Go</title>
    <url>/6ce34c49/</url>
    <content><![CDATA[<h1><span id="go-中的内联优化">Go 中的内联优化</span></h1><blockquote>
<p>本文讨论 Go 编译器是如何实现内联的，以及这种优化方法如何影响你的 Go 代码。</p>
</blockquote>
<p><em>请注意：</em>本文重点讨论 <em>gc</em>，这是来自 <a href="https://github.com/golang/go">golang.org</a> 的事实标准的 Go 编译器。讨论到的概念可以广泛适用于其它 Go 编译器，如 gccgo 和 llgo，但它们在实现方式和功效上可能有所差异。</p>
<h3><span id="内联是什么">内联是什么？</span></h3><p><ruby>内联<rt>inlining</rt></ruby>就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经成为编译过程中自动实现的基本优化过程的其中一步。</p>
<h3><span id="为什么内联很重要">为什么内联很重要？</span></h3><p>有两个原因。第一个是它消除了函数调用本身的开销。第二个是它使得编译器能更高效地执行其他的优化策略。</p>
<h4><span id="函数调用的开销">函数调用的开销</span></h4><p>在任何语言中，调用一个函数 [^1] 都会有消耗。把参数编组进寄存器或放入栈中（取决于 ABI），在返回结果时的逆反过程都会有开销。引入一次函数调用会导致程序计数器从指令流的一点跳到另一点，这可能导致管道滞后。函数内部通常有<ruby>前置处理<rt>preamble</rt></ruby>，需要为函数执行准备新的栈帧，还有与前置相似的<ruby>后续处理<rt>epilogue</rt></ruby>，需要在返回给调用方之前释放栈帧空间。</p>
<p>在 Go 中函数调用会消耗额外的资源来支持栈的动态增长。在进入函数时，goroutine 可用的栈空间与函数需要的空间大小进行比较。如果可用空间不同，前置处理就会跳到<ruby>运行时<rt>runtime</rt></ruby>的逻辑中，通过把数据复制到一块新的、更大的空间的来增长栈空间。当这个复制完成后，运行时就会跳回到原来的函数入口，再执行栈空间检查，现在通过了检查，函数调用继续执行。这种方式下，goroutine 开始时可以申请很小的栈空间，在有需要时再申请更大的空间。[^2]</p>
<p>这个检查消耗很小，只有几个指令，而且由于 goroutine 的栈是成几何级数增长的，因此这个检查很少失败。这样，现代处理器的分支预测单元可以通过假定检查肯定会成功来隐藏栈空间检查的消耗。当处理器预测错了栈空间检查，不得不放弃它在推测性执行所做的操作时，与为了增加 goroutine 的栈空间运行时所需的操作消耗的资源相比，管道滞后的代价更小。</p>
<p>虽然现代处理器可以用预测性执行技术优化每次函数调用中的泛型和 Go 特定的元素的开销，但那些开销不能被完全消除，因此在每次函数调用执行必要的工作过程中都会有性能消耗。一次函数调用本身的开销是固定的，与更大的函数相比，调用小函数的代价更大，因为在每次调用过程中它们做的有用的工作更少。</p>
<p>因此，消除这些开销的方法必须是要消除函数调用本身，Go 的编译器就是这么做的，在某些条件下通过用函数的内容来替换函数调用来实现。这个过程被称为<em>内联</em>，因为它在函数调用处把函数体展开了。</p>
<h4><span id="改进的优化机会">改进的优化机会</span></h4><p>Cliff Click 博士把内联描述为现代编译器做的优化措施，像常量传播（LCTT 译注：此处作者笔误，原文为 constant proportion，修正为 constant propagation）和死代码消除一样，都是编译器的基本优化方法。实际上，内联可以让编译器看得更深，使编译器可以观察调用的特定函数的上下文内容，可以看到能继续简化或彻底消除的逻辑。由于可以递归地执行内联，因此不仅可以在每个独立的函数上下文处进行这种优化决策，也可以在整个函数调用链中进行。</p>
<h3><span id="实践中的内联">实践中的内联</span></h3><p>下面这个例子可以演示内联的影响：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Result <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(<span class="number">-1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个基准，会得到如下结果：[^3]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=. </span><br><span class="line">BenchmarkMax-4   530687617         2.24 ns/op</span><br></pre></td></tr></table></figure>

<p>在我的 2015 MacBook Air 上 <code>max(-1, i)</code> 的耗时约为 2.24 纳秒。现在去掉 <code>//go:noinline</code> 编译指令，再看下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% go <span class="built_in">test</span> -bench=. </span><br><span class="line">BenchmarkMax-4   1000000000         0.514 ns/op</span><br></pre></td></tr></table></figure>

<p>从 2.24 纳秒降到了 0.51 纳秒，或者从 <code>benchstat</code> 的结果可以看出，有 78% 的提升。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old <span class="keyword">time</span>/op  new <span class="keyword">time</span>/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.49ns ± 6%  -77.96%  (p=0.000 n=18+19)</span><br></pre></td></tr></table></figure>

<p>这个提升是从哪儿来的呢？</p>
<p>首先，移除掉函数调用以及与之关联的前置处理 [^4] 是主要因素。把 <code>max</code> 函数的函数体在调用处展开，减少了处理器执行的指令数量并且消除了一些分支。</p>
<p>现在由于编译器优化了 <code>BenchmarkMax</code>，因此它可以看到 <code>max</code> 函数的内容，进而可以做更多的提升。当 <code>max</code> 被内联后，<code>BenchmarkMax</code> 呈现给编译器的样子，看起来是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">-1</span> &gt; i &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行一次基准，我们看一下手动内联的版本和编译器内联的版本的表现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% benchstat &#123;old,new&#125;.txt</span><br><span class="line">name   old <span class="keyword">time</span>/op  new <span class="keyword">time</span>/op  delta</span><br><span class="line">Max-4  2.21ns ± 1%  0.48ns ± 3%  -78.14%  (p=0.000 n=18+18)</span><br></pre></td></tr></table></figure>

<p>现在编译器能看到在 <code>BenchmarkMax</code> 里内联 <code>max</code> 的结果，可以执行以前不能执行的优化措施。例如，编译器注意到 <code>i</code> 初始值为 <code>0</code>，仅做自增操作，因此所有与 <code>i</code> 的比较都可以假定 <code>i</code> 不是负值。这样条件表达式 <code>-1 &gt; i</code> 永远不是 <code>true</code>。[^5]</p>
<p>证明了 <code>-1 &gt; i</code> 永远不为 true 后，编译器可以把代码简化为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">            r = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且因为分支里是个常量，编译器可以通过下面的方式移除不会走到的分支：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = i</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过内联和由内联解锁的优化过程，编译器把表达式 <code>r = max(-1, i))</code> 简化为 <code>r = i</code>。</p>
<h3><span id="内联的限制">内联的限制</span></h3><p>本文中我论述的内联称作<ruby>叶子内联<rt>leaf inlining</rt></ruby>：把函数调用栈中最底层的函数在调用它的函数处展开的行为。内联是个递归的过程，当把函数内联到调用它的函数 A 处后，编译器会把内联后的结果代码再内联到 A 的调用方，这样持续内联下去。例如，下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxMaxMax</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = max(max(<span class="number">-1</span>, i), max(<span class="number">0</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    Result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前的例子中的代码运行速度一样快，因为编译器可以对上面的代码重复地进行内联，也把代码简化到 <code>r = i</code> 表达式。</p>
<p>下一篇文章中，我会论述当 Go 编译器想要内联函数调用栈中间的某个函数时选用的另一种内联策略。最后我会论述编译器为了内联代码准备好要达到的极限，这个极限 Go 现在的能力还达不到。</p>
<p>[^1]: 在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。<br>[^2]: 在 Go 1.14 以前，栈检查的前置处理也被垃圾回收器用于 STW，通过把所有活跃的 goroutine 栈空间设为 0，来强制它们切换为下一次函数调用时的运行时状态。这个机制[最近被替换][8]为一种新机制，新机制下运行时可以不用等 goroutine 进行函数调用就可以暂停 goroutine。<br>[^3]: 我用 <code>//go:noinline</code> 编译指令来阻止编译器内联 <code>max</code>。这是因为我想把内联 <code>max</code> 的影响与其他影响隔离开，而不是用 <code>-gcflags=&#39;-l -N&#39;</code> 选项在全局范围内禁止优化。关于 <code>//go:</code> 注释在[这篇文章][10]中详细论述。<br>[^4]: 你可以自己通过比较 <code>go test -bench=. -gcflags=-S</code> 有无 <code>//go:noinline</code> 注释时的不同结果来验证一下。<br>[^5]: 你可以用 <code>-gcflags=-d=ssa/prove/debug=on</code> 选项来自己验证一下。</p>
<h4><span id="相关文章">相关文章：</span></h4><ol>
<li><a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast">使 Go 变快的 5 件事</a></li>
<li><a href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite">为什么 Goroutine 的栈空间会无限增长？</a></li>
<li><a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">Go 中怎么写基准测试</a></li>
<li><a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas">Go 中隐藏的编译指令</a></li>
</ol>
<hr>
<p>via: <a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go">https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go</a></p>
<p>作者：<a href="https://dave.cheney.net/author/davecheney">Dave Cheney</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
<p>[3]: tmp.gBQ2tEtMHc#easy-footnote-bottom-2-4053 “Up until Go 1.14 the stack check preamble was also used by the garbage collector to stop the world by setting all active goroutine’s stacks to zero, forcing them to trap into the runtime the next time they made a function call. This system was <a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">recently replaced</a> with a mechanism which allowed the runtime to pause an goroutine without waiting for it to make a function call.”<br>[4]: tmp.gBQ2tEtMHc#easy-footnote-bottom-3-4053 “I’m using the <code>//go:noinline</code> pragma to prevent the compiler from inlining <code>max</code>. This is because I want to isolate the effects of inlining on <code>max</code> rather than disabling optimisations globally with <code>-gcflags='-l -N'</code>. I go into detail about the <code>//go:</code> comments in <a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas">this presentation</a>.”<br>[5]: tmp.gBQ2tEtMHc#easy-footnote-bottom-4-4053 “You can check this for yourself by comparing the output of <code>go test -bench=. -gcflags=-S</code> with and without the <code>//go:noinline</code> annotation.”<br>[6]: tmp.gBQ2tEtMHc#easy-footnote-bottom-5-4053 “You can check this yourself with the <code>-gcflags=-d=ssa/prove/debug=on</code> flag.”<br>[7]: tmp.gBQ2tEtMHc#easy-footnote-1-4053<br>[8]: <a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md</a><br>[9]: tmp.gBQ2tEtMHc#easy-footnote-2-4053<br>[10]: <a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas">https://dave.cheney.net/2018/01/08/gos-hidden-pragmas</a><br>[11]: tmp.gBQ2tEtMHc#easy-footnote-3-4053<br>[12]: tmp.gBQ2tEtMHc#easy-footnote-4-4053<br>[13]: tmp.gBQ2tEtMHc#easy-footnote-5-4053<br>[14]: <a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast">https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast</a> “Five things that make Go fast”<br>[15]: <a href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite">https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite</a> “Why is a Goroutine’s stack infinite ?”<br>[16]: <a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go</a> “How to write benchmarks in Go”<br>[17]: <a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas">https://dave.cheney.net/2018/01/08/gos-hidden-pragmas</a> “Go’s hidden #pragmas”</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins的Api</title>
    <url>/6316d574/</url>
    <content><![CDATA[<h2><span id="术语定义">术语定义</span></h2><table>
<thead>
<tr>
<th align="left"><strong>名词</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">job</td>
<td align="left">任务</td>
</tr>
<tr>
<td align="left">payload</td>
<td align="left">在POST请求中提交的数据</td>
</tr>
<tr>
<td align="left">{optionalFolderPath}</td>
<td align="left">可选参数：任务所在目录的路径</td>
</tr>
<tr>
<td align="left">{job_name}</td>
<td align="left">必须参数：任务名称</td>
</tr>
</tbody></table>
<ul>
<li>在 GET/POST 时需要附加 HTTP 认证才能访问 API</li>
<li>本文使用的数据结构可以在 jenkins-rest/domain 中查看详细定义</li>
</ul>
<h2><span id="api类型">API类型</span></h2><table>
<thead>
<tr>
<th align="left"><strong>API类型</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">JobsAP</td>
<td align="left">任务管理（任务信息、创建、修改）</td>
</tr>
<tr>
<td align="left">OBPluginManagerAPI</td>
<td align="left">插件管理（插件信息、安装插件）</td>
</tr>
<tr>
<td align="left">QueueAPI</td>
<td align="left">任务队列相关（队列状态）</td>
</tr>
<tr>
<td align="left">StatisticsAPI</td>
<td align="left">Jenkins统计信息</td>
</tr>
<tr>
<td align="left">CrumbIssuerAPI</td>
<td align="left">系统哈希值信息（用于防御CSRF攻击）</td>
</tr>
<tr>
<td align="left">SystemAPI</td>
<td align="left">Jenkins系统状态（版本、路径）</td>
</tr>
</tbody></table>
<h2><span id="api汇总">API汇总</span></h2><table>
<thead>
<tr>
<th>名称</th>
<th>API</th>
</tr>
</thead>
<tbody><tr>
<td>创建 Job</td>
<td><code>POST http://localhost:8080/createItem/api/json</code></td>
</tr>
<tr>
<td>更新 Job</td>
<td><code>POST http://localhost:8080/job/&#123;job_name&#125;/config.xml/api/json</code></td>
</tr>
<tr>
<td>获取 Job</td>
<td><code>GET http://localhost:8080/job/&#123;job_name&#125;/api/json</code></td>
</tr>
<tr>
<td>获取 JobXml</td>
<td><code>GET http://localhost:8080/job/&#123;job_name&#125;/config.xml/api/json</code></td>
</tr>
<tr>
<td>删除 Job</td>
<td><code>POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/doDelete</code></td>
</tr>
<tr>
<td>enable Job</td>
<td><code>POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/enable</code></td>
</tr>
<tr>
<td>disable Job</td>
<td><code>POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/disable</code></td>
</tr>
<tr>
<td>获取任务描述</td>
<td><code>GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/description</code></td>
</tr>
<tr>
<td>设置任务描述</td>
<td><code>POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/description</code></td>
</tr>
<tr>
<td>创建 Build</td>
<td><code>POST http://localhost:8080/job/&#123;job_name&#125;/build/api/json</code></td>
</tr>
<tr>
<td>获取 QueueItem</td>
<td><code>GET http://localhost:8080/queue/item/17/api/json</code></td>
</tr>
<tr>
<td>取消任务队列</td>
<td><code>POST http://127.0.0.1:8080/cancelItem?id=&#123;id&#125;</code></td>
</tr>
<tr>
<td>所有任务队列信息</td>
<td><code>GET http://127.0.0.1:8080/queue/api/json</code></td>
</tr>
<tr>
<td>获取 Build信息</td>
<td><code>GET http://localhost:8080/job/test/6/api/json</code></td>
</tr>
<tr>
<td>获取上次构建序号</td>
<td><code>GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/lastBuild/buildNumber</code></td>
</tr>
<tr>
<td>获取上次构建时间戳</td>
<td><code>GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/lastBuild/buildTimestamp</code></td>
</tr>
<tr>
<td>获取TXT日志</td>
<td><code>GET http://localhost:8080/job/test/&#123;build_number&#125;/logText/progressiveText/api/json</code></td>
</tr>
<tr>
<td>获取 Html 日志</td>
<td><code>GET http://localhost:8080/job/test/&#123;build_number&#125;/logText/progressiveHtml/api/json</code></td>
</tr>
<tr>
<td>系统哈希值信息</td>
<td><code>GET http://127.0.0.1:8080/crumbIssuer/api/xml?&#123;key&#125;=&#123;value&#125;</code></td>
</tr>
<tr>
<td>load统计信息</td>
<td><code>GET http://127.0.0.1:8080/overallLoad/api/json</code></td>
</tr>
<tr>
<td>插件管理</td>
<td><code>GET http://127.0.0.1:8080/pluginManager/api/json</code></td>
</tr>
<tr>
<td>安装插件</td>
<td><code>POST http://127.0.0.1:8080/pluginManager/installNecessaryPlugins</code></td>
</tr>
</tbody></table>
<h2><span id="api详述">API详述</span></h2><h3><span id="创建-job">创建 Job</span></h3><p>jenkins 的配置都是靠 xml 的格式落地的,所以配置其实都是 xml 的形式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/createItem</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name 任务名称</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">payload XML配置文件</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>返回类型：RequestStatus</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">Boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">errors</td>
<td align="left">List</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何知道 config.xml应该如何编写呢?</p>
<ul>
<li>可以在 jenkins 收工创建一个需要的项目,然后编辑完成后,到 jenkins 工作目录下 找到 jobs/{job_name}/config.xml 用他作为模板来书写你需要的模板.</li>
<li>通过获取 xml 的 api 来获取</li>
</ul>
<p><code>GET http://localhost:8080/job/&#123;job_name&#125;/config.xml/api/json</code></p>
<p><strong>Java Client</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jenkinsServer.createJob(<span class="string">&quot;auto_test_job&quot;</span>, replacedText, <span class="literal">true</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> jenkinsServer.getJobXml(<span class="string">&quot;auto_test_job&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="更新job">更新Job</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:8080/job/&#123;job_name&#125;/config.xml/api/json</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">payload</td>
<td align="left">XML配置文件</td>
</tr>
</tbody></table>
<p>config.xml的内容传入到 body 中,contentType 设置为<code>text/xml</code></p>
<p>返回类型：Boolean</p>
<p><strong>Java Client</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jenkinsServer.updateJob(<span class="string">&quot;auto_test_job&quot;</span>, replacedText, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="job-info-获取任务信息">job-info 获取任务信息</span></h3><p><code>GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/api/json</code></p>
<p>返回类型：JobInfo</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">description</td>
<td align="left">String</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">String</td>
<td align="left">项目名称</td>
</tr>
<tr>
<td align="left">url</td>
<td align="left">boolean</td>
<td align="left">路径</td>
</tr>
<tr>
<td align="left">buildable</td>
<td align="left">String</td>
<td align="left">是否可构建</td>
</tr>
<tr>
<td align="left">builds</td>
<td align="left">List</td>
<td align="left">构建记录</td>
</tr>
<tr>
<td align="left">lastBuild</td>
<td align="left">BuildInfo</td>
<td align="left">上次构建记录</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3><span id="delete-删除任务">delete 删除任务</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;project_name&#125;/doDelete</span><br></pre></td></tr></table></figure>



<p>返回类型：RequestStatus</p>
<p><strong>补充：</strong></p>
<p>也可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE https://&lt;Jenkins_url&gt;/job/&lt;job_name&gt;/</span><br></pre></td></tr></table></figure>

<p>注意最后有个 <code>/</code>，不加 <code>/</code> 不能正常删除</p>
<h3><span id="enable允许任务">enable允许任务</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;project_name&#125;/enable</span><br></pre></td></tr></table></figure>

<p>返回类型：Boolean</p>
<h3><span id="disable-禁止任务">disable 禁止任务</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;project_name&#125;/disable</span><br></pre></td></tr></table></figure>

<p>返回类型：Boolean</p>
<h3><span id="get-description-获取任务描述">get-description 获取任务描述</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;project_name&#125;/description</span><br></pre></td></tr></table></figure>

<p>返回类型：String</p>
<h3><span id="set-description-设置任务描述">set-description 设置任务描述</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;project_name&#125;/description</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">description</td>
<td align="left">描述</td>
</tr>
</tbody></table>
<p>返回类型：Boolean</p>
<h3><span id="创建-build">创建 Build</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/build</span><br><span class="line">POST http://localhost:8080/job/&#123;job_name&#125;/build/api/json</span><br></pre></td></tr></table></figure>

<p>返回类型： IntegerResponse</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">Integer</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">errors</td>
<td align="left">List</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4><span id="build-with-params-使用参数创建任务">build-with-params 使用参数创建任务</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/buildWithParameters</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">payload</td>
<td align="left">Map&lt;String, List&gt; properties</td>
</tr>
</tbody></table>
<p>返回类型： IntegerResponse</p>
<p>新的构建请求提交到服务器成功后返回一个类似于队列ID的东西,因为是异步构建,那么要获取构建的状态,就需要,用这个队列 id去进一步的获取. 例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v  -XPOST http://localhost:8080/job/test/build/api/json</span><br><span class="line">*   Trying ::1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to localhost (::1) port 8080 (#0)</span><br><span class="line">&gt; POST /job/test/build/api/json HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 201 Created</span><br><span class="line">&lt; Date: Sat, 05 Jan 2019 08:33:45 GMT</span><br><span class="line">&lt; X-Content-Type-Options: nosniff</span><br><span class="line">&lt; Location: http://localhost:8080/queue/item/17/</span><br><span class="line">&lt; Content-Length: 0</span><br><span class="line">&lt; Server: Jetty(9.4.z-SNAPSHOT)</span><br><span class="line">&lt;</span><br><span class="line">* Connection <span class="comment">#0 to host localhost left intact</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的<code>Location: http://localhost:8080/queue/item/17/</code>就是返回的队列信息,下面的 queueItem 获取就是依赖这个.</p>
<h3><span id="根据-queueid-获取-queueitem">根据 QueueId 获取 QueueItem</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8080/queue/item/17/api/json </span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">{queueId}</td>
<td align="left">任务队列ID</td>
</tr>
</tbody></table>
<p><strong>返回类型</strong>：QueueItem</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl  http://localhost:8080/queue/item/17/api/json\?pretty\=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;hudson.model.Queue<span class="variable">$LeftItem</span>&quot;</span>,</span><br><span class="line">  <span class="string">&quot;actions&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;hudson.model.CauseAction&quot;</span>,</span><br><span class="line">      <span class="string">&quot;causes&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;hudson.model.Cause<span class="variable">$UserIdCause</span>&quot;</span>,</span><br><span class="line">          <span class="string">&quot;shortDescription&quot;</span> : <span class="string">&quot;由用户 anonymous 启动&quot;</span>,</span><br><span class="line">          <span class="string">&quot;userId&quot;</span> : null,</span><br><span class="line">          <span class="string">&quot;userName&quot;</span> : <span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;blocked&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;buildable&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span> : 17,</span><br><span class="line">  <span class="string">&quot;inQueueSince&quot;</span> : 1546677225670,</span><br><span class="line">  <span class="string">&quot;params&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stuck&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;task&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;hudson.maven.MavenModuleSet&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span> : <span class="string">&quot;http://localhost:8080/job/test/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;color&quot;</span> : <span class="string">&quot;blue&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;queue/item/17/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;why&quot;</span> : null,</span><br><span class="line">  <span class="string">&quot;cancelled&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;executable&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;hudson.maven.MavenModuleSetBuild&quot;</span>,</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : 6,</span><br><span class="line">    <span class="string">&quot;url&quot;</span> : <span class="string">&quot;http://localhost:8080/job/test/6/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="cancel-取消任务队列">cancel 取消任务队列</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/cancelItem?id=&#123;id&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">{id}</td>
<td align="left">任务队列ID</td>
</tr>
</tbody></table>
<p><strong>返回类型</strong>：RequestStatus</p>
<h3><span id="queue-所有任务队列信息">queue 所有任务队列信息</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/queue/api/json</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：List</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">blocked</td>
<td align="left">Boolean</td>
<td align="left">是否阻塞</td>
</tr>
<tr>
<td align="left">buildable</td>
<td align="left">Boolean</td>
<td align="left">是否可构建</td>
</tr>
<tr>
<td align="left">id</td>
<td align="left">Integer</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inQueueSince</td>
<td align="left">Long</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">params</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left">任务参数</td>
</tr>
<tr>
<td align="left">task</td>
<td align="left">Task</td>
<td align="left">Task中包含任务名称和URL</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3><span id="获取-build-详情">获取 Build 详情</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/&#123;number&#125;/api/json</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：BuildInfo</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">artifacts</td>
<td align="left">List</td>
<td align="left">artifacts</td>
</tr>
<tr>
<td align="left">actions</td>
<td align="left">Lis</td>
<td align="left">actions</td>
</tr>
<tr>
<td align="left">building</td>
<td align="left">boolean 路径</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">description</td>
<td align="left">String</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/job/test/6/api/json\?pretty\=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;building&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span> : null,</span><br><span class="line">  <span class="string">&quot;displayName&quot;</span> : <span class="string">&quot;#6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;duration&quot;</span> : 13631,</span><br><span class="line">  <span class="string">&quot;estimatedDuration&quot;</span> : 17999,</span><br><span class="line">  <span class="string">&quot;executor&quot;</span> : null,</span><br><span class="line">  <span class="string">&quot;fullDisplayName&quot;</span> : <span class="string">&quot;test #6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span> : <span class="string">&quot;6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;keepLog&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;number&quot;</span> : 6,</span><br><span class="line">  <span class="string">&quot;queueId&quot;</span> : 17,</span><br><span class="line">  <span class="string">&quot;result&quot;</span> : <span class="string">&quot;SUCCESS&quot;</span>,</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span> : 1546677234794,</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;http://localhost:8080/job/test/6/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;builtOn&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从返回结果可以看到 是否还在 build:<code>&quot;building&quot; : false</code>,如果 build 结束状态就在:<code>&quot;result&quot; : &quot;SUCCESS&quot;</code></p>
<h4><span id="获取上次build详情">获取上次Build详情</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://172.12.12.234:8080/job/pytest_7.0/lastBuild/api/xml --user jenkins:1</span><br></pre></td></tr></table></figure>



<h3><span id="last-build-number-获取上次构建序号">last-build-number 获取上次构建序号</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/lastBuild/buildNumber</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：Integer</p>
<h3><span id="last-build-timestamp-获取上次构建时间戳">last-build-timestamp 获取上次构建时间戳</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/lastBuild/buildTimestamp</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：String</p>
<h3><span id="progressive-text-获取构建控制台输出">progressive-text 获取构建控制台输出</span></h3><p>获取上次构建的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/&#123;optionalFolderPath&#125;job/&#123;job_name&#125;/lastBuild/logText/progressiveText</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：ProgressiveText</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">text</td>
<td align="left">String</td>
<td align="left">控制台输出</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">Integer</td>
<td align="left">字数</td>
</tr>
<tr>
<td align="left">hasMoreData</td>
<td align="left">Boolean</td>
<td align="left">是否有更多数据</td>
</tr>
</tbody></table>
<p>获取某次构建的日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// text</span><br><span class="line">GET http://localhost:8080/job/test/&#123;build_number&#125;/logText/progressiveText/api/json</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">GET http://localhost:8080/job/test/&#123;build_number&#125;/logText/progressiveHtml/api/json</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JobWithDetails</span> <span class="variable">job</span> <span class="operator">=</span> jenkinsServer.getJob(jenkinsJob);</span><br><span class="line">...</span><br><span class="line"> <span class="type">QueueReference</span> <span class="variable">reference</span> <span class="operator">=</span> job.build( <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line"><span class="type">QueueItem</span> <span class="variable">queueItem</span> <span class="operator">=</span> jenkinsServer.getQueueItem(<span class="keyword">new</span> <span class="title class_">QueueReference</span>(queuePart));</span><br><span class="line">...</span><br><span class="line"><span class="type">Build</span> <span class="variable">build</span> <span class="operator">=</span> jenkinsServer.getBuild(queueItem);</span><br><span class="line">...</span><br><span class="line"><span class="type">BuildWithDetails</span> <span class="variable">details</span> <span class="operator">=</span> build.details();</span><br><span class="line"><span class="type">BuildResult</span> <span class="variable">result</span> <span class="operator">=</span> details.getResult();</span><br><span class="line">...</span><br><span class="line"><span class="type">String</span> <span class="variable">logs</span> <span class="operator">=</span>  details.getConsoleOutputText();</span><br></pre></td></tr></table></figure>

<h3><span id="crumbissuer-系统哈希值信息用于防御csrf攻击">CrumbIssuer 系统哈希值信息（用于防御CSRF攻击）</span></h3><ul>
<li>CrumbIssuerApi</li>
<li>path: /crumbIssuer/api/xml</li>
</ul>
<h4><span id="crumb">crumb</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/crumbIssuer/api/xml?&#123;key&#125;=&#123;value&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">key</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xpath</td>
<td align="left">concat(//crumbRequestField,”:”,//crumb)</td>
</tr>
</tbody></table>
<p><strong>返回类型</strong>：Crumb</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">errors</td>
<td align="left">List</td>
</tr>
</tbody></table>
<h3><span id="statistics-统计信息">Statistics 统计信息</span></h3><ul>
<li>StatisticsApi</li>
<li>path: /</li>
</ul>
<h4><span id="overall-load">overall-load</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/overallLoad/api/json</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：OverallLoad</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">availableExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">busyExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">connectingExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">definedExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">idleExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onlineExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">queueLength</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">totalExecutors</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">totalQueueLength</td>
<td align="left">Map&lt;String, String&gt;</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3><span id="system-系统信息">System 系统信息</span></h3><ul>
<li>path: /</li>
</ul>
<p><strong>返回类型</strong>：SystemInfo</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hudsonVersion</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">jenkinsVersion</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">jenkinsSession</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">instanceIdentity</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">sshEndpoint</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">server</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3><span id="pluginmanager-插件管理插件信息-安装插件">PluginManager 插件管理（插件信息、安装插件）</span></h3><ul>
<li>PluginManagerApi</li>
<li>path: /pluginManager</li>
</ul>
<h4><span id="plugins-插件列表">plugins 插件列表</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/pluginManager/api/json</span><br></pre></td></tr></table></figure>

<p><strong>返回类型</strong>：List</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">active</td>
<td align="left">Boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">backupVersion String</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">bundled</td>
<td align="left">Boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">deleted</td>
<td align="left">Boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">downgradable</td>
<td align="left">Boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">enabled</td>
<td align="left">Boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">longName</td>
<td align="left">String</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">……</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3><span id="installnecessaryplugins-安装插件">installNecessaryPlugins 安装插件</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/pluginManager/installNecessaryPlugins</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload: &lt;jenkins&gt;&lt;install plugin=&quot;&#123;pluginID&#125;&quot;/&gt;&lt;/jenkins&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">{pluginID}</td>
<td align="left">要安装的插件ID</td>
</tr>
</tbody></table>
<p><strong>返回类型</strong>：RequestStatus</p>
<h2><span id="代码示例">代码示例</span></h2><h3><span id="配置">配置</span></h3><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jenkins-java-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.offbytwo.jenkins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jenkins-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建连接配置，配置对应的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.JenkinsServer;</span><br><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.client.JenkinsHttpClient;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JenkinsConnect</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JenkinsConnect</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 连接 Jenkins 需要设置的信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JENKINS_URL</span> <span class="operator">=</span> <span class="string">&quot;http://jenkins:8080/&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JENKINS_USERNAME</span> <span class="operator">=</span> <span class="string">&quot;jenkins&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JENKINS_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;jenkins&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Http 客户端工具</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果有些 API 该Jar工具包未提供，可以用此Http客户端操作远程接口，执行命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JenkinsHttpClient <span class="title function_">getClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JenkinsHttpClient</span> <span class="variable">jenkinsHttpClient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jenkinsHttpClient = <span class="keyword">new</span> <span class="title class_">JenkinsHttpClient</span>(<span class="keyword">new</span> <span class="title class_">URI</span>(JENKINS_URL), JENKINS_USERNAME, JENKINS_PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jenkinsHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接 Jenkins</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JenkinsServer <span class="title function_">connection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JenkinsServer</span> <span class="variable">jenkinsServer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jenkinsServer = <span class="keyword">new</span> <span class="title class_">JenkinsServer</span>(<span class="keyword">new</span> <span class="title class_">URI</span>(JENKINS_URL), JENKINS_USERNAME, JENKINS_PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jenkinsServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JENKINS_URL是Jenkins的反向代理地址， <code>Configure System -&gt; Jenkins location url</code>， 一般和Jenkins首页访问地址一致</p>
<p>JENKINS_USERNAME Jenkins登录账号</p>
<p>JENKINS_PASSWORD Jenkins账号密码</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202304151033105.png" alt></p>
<h4><span id="使用示例">使用示例</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.JenkinsServer;</span><br><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.client.JenkinsHttpClient;</span><br><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.model.Build;</span><br><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.model.Job;</span><br><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.model.JobWithDetails;</span><br><span class="line"><span class="keyword">import</span> com.offbytwo.jenkins.model.MavenJobWithDetails;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobApi</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Jenkins 对象</span></span><br><span class="line">    <span class="keyword">private</span> JenkinsServer jenkinsServer;</span><br><span class="line">    <span class="comment">// http 客户端对象</span></span><br><span class="line">    <span class="keyword">private</span> JenkinsHttpClient jenkinsHttpClient;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法中调用连接 Jenkins 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JobApi() &#123;</span><br><span class="line">        <span class="comment">// 连接 Jenkins</span></span><br><span class="line">        jenkinsServer = JenkinsConnect.connection();</span><br><span class="line">        <span class="comment">// 设置客户端连接 Jenkins</span></span><br><span class="line">        jenkinsHttpClient = JenkinsConnect.getClient();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 Job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ceateJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**创建一个流水线任务，且设置一个简单的脚本**/</span></span><br><span class="line">            <span class="comment">// 创建 Pipeline 脚本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;node()&#123; \n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;echo &#x27;hello world!&#x27; \n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">            <span class="comment">// xml配置文件，且将脚本加入到配置中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;flow-definition plugin=\&quot;workflow-job@2.32\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;description&gt;测试项目&lt;/description&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;definition class=\&quot;org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition\&quot; plugin=\&quot;workflow-cps@2.66\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;script&gt;&quot;</span> + script + <span class="string">&quot;&lt;/script&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;sandbox&gt;true&lt;/sandbox&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/definition&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/flow-definition&gt;&quot;</span>;</span><br><span class="line">            <span class="comment">// 创建 Job</span></span><br><span class="line">            jenkinsServer.createJob(<span class="string">&quot;test-job&quot;</span>,xml, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 Job</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 更改之前创建的无参数Job，更改其为参数Job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 更改一个流水线任务，让一个无参数的任务变成带参数任务</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 创建 Pipeline 脚本，用一个key变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;node()&#123; \n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;echo \&quot;$&#123;key&#125;\&quot; \n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">            <span class="comment">// xml配置文件，且将脚本加入到配置中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;flow-definition plugin=\&quot;workflow-job@2.32\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;actions/&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;description&gt;测试项目&lt;/description&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;keepDependencies&gt;false&lt;/keepDependencies&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;properties&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;hudson.model.ParametersDefinitionProperty&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;parameterDefinitions&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;hudson.model.StringParameterDefinition&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;name&gt;key&lt;/name&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;description&gt;用于测试的字符变量&lt;/description&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;defaultValue&gt;hello&lt;/defaultValue&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;trim&gt;false&lt;/trim&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/hudson.model.StringParameterDefinition&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/parameterDefinitions&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/hudson.model.ParametersDefinitionProperty&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/properties&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;definition class=\&quot;org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition\&quot; plugin=\&quot;workflow-cps@2.66\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;script&gt;&quot;</span> + script + <span class="string">&quot;&lt;/script&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;sandbox&gt;true&lt;/sandbox&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/definition&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;disabled&gt;false&lt;/disabled&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/flow-definition&gt;&quot;</span>;</span><br><span class="line">            <span class="comment">// 创建 Job</span></span><br><span class="line">            jenkinsServer.updateJob(<span class="string">&quot;test-job&quot;</span>,xml, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Job 基本信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Job 信息</span></span><br><span class="line">            <span class="type">JobWithDetails</span> <span class="variable">job</span> <span class="operator">=</span> jenkinsServer.getJob(<span class="string">&quot;das-app-android-pkg&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取 Job 名称</span></span><br><span class="line">            System.out.println(job.getName());</span><br><span class="line">            <span class="comment">// 获取 Job URL</span></span><br><span class="line">            System.out.println(job.getUrl());</span><br><span class="line">            <span class="comment">// 获取 Job 下一个 build 编号</span></span><br><span class="line">            System.out.println(job.getNextBuildNumber());</span><br><span class="line">            <span class="comment">// 获取 Job 显示的名称</span></span><br><span class="line">            System.out.println(job.getDisplayName());</span><br><span class="line">            <span class="comment">// 输出 Job 描述信息</span></span><br><span class="line">            System.out.println(job.getDescription());</span><br><span class="line">            <span class="comment">// 获取 Job 下游任务列表</span></span><br><span class="line">            System.out.println(job.getDownstreamProjects());</span><br><span class="line">            <span class="comment">// 获取 Job 上游任务列表</span></span><br><span class="line">            System.out.println(job.getUpstreamProjects());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Maven Job 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMavenJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Job 信息</span></span><br><span class="line">            <span class="type">MavenJobWithDetails</span> <span class="variable">job</span> <span class="operator">=</span> jenkinsServer.getMavenJob(<span class="string">&quot;test-job&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Job 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getJobList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Job 列表</span></span><br><span class="line">            Map&lt;String, Job&gt; jobs = jenkinsServer.getJobs();</span><br><span class="line">            <span class="keyword">for</span> (Job job:jobs.values())&#123;</span><br><span class="line">                System.out.println(job.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 View 名称获取 Job 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getJobListByView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Job 列表</span></span><br><span class="line">            Map&lt;String,Job&gt; jobs = jenkinsServer.getJobs(<span class="string">&quot;all&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Job job:jobs.values())&#123;</span><br><span class="line">                System.out.println(job.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看 Job XML 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getJobConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> jenkinsServer.getJobXml(<span class="string">&quot;test-job&quot;</span>);</span><br><span class="line">            System.out.println(xml);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行无参数 Job build</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jenkinsServer.getJob(<span class="string">&quot;test-job&quot;</span>).build(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行带参数 Job build</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildParamJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 例如，现有一个job，拥有一个字符参数&quot;key&quot;</span></span><br><span class="line"><span class="comment">             * 现在对这个值进行设置，然后执行一个输出这个值的脚本</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 设置参数值</span></span><br><span class="line">            Map&lt;String,String&gt; param = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            param.put(<span class="string">&quot;way&quot;</span>,<span class="string">&quot;gm-R-b&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行 build 任务</span></span><br><span class="line">            jenkinsServer.getJob(<span class="string">&quot;das-app-android-pkg&quot;</span>).build(param, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止最后构建的 Job Build</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopLastJobBuild</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取最后的 build 信息</span></span><br><span class="line">            <span class="type">Build</span> <span class="variable">build</span> <span class="operator">=</span> jenkinsServer.getJob(<span class="string">&quot;test-job&quot;</span>).getLastBuild();</span><br><span class="line">            <span class="comment">// 停止最后的 build</span></span><br><span class="line">            build.Stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 Job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jenkinsServer.deleteJob(<span class="string">&quot;test-job&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用 Job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disableJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jenkinsServer.disableJob(<span class="string">&quot;test-job&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启用 Job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enableJob</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jenkinsServer.enableJob(<span class="string">&quot;test-job&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JobApi</span> <span class="variable">jobApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobApi</span>();</span><br><span class="line"><span class="comment">//        jobApi.getJob();</span></span><br><span class="line"><span class="comment">//        jobApi.getJobList();</span></span><br><span class="line">        jobApi.buildParamJob();</span><br><span class="line"><span class="comment">//        // 创建 Job</span></span><br><span class="line"><span class="comment">//        jobApi.ceateJob();</span></span><br><span class="line"><span class="comment">//        // 构建无参数的 Job</span></span><br><span class="line"><span class="comment">//        jobApi.buildJob();</span></span><br><span class="line"><span class="comment">//        // 构建带参数的 Job</span></span><br><span class="line"><span class="comment">//        jobApi.buildParamJob();</span></span><br><span class="line"><span class="comment">//        // 停止最后构建的 Job Build</span></span><br><span class="line"><span class="comment">//        jobApi.stopLastJobBuild();</span></span><br><span class="line"><span class="comment">//        // 更新 Job</span></span><br><span class="line"><span class="comment">//        jobApi.updateJob();</span></span><br><span class="line"><span class="comment">//        // 获取 Job 信息</span></span><br><span class="line"><span class="comment">//        jobApi.getJob();</span></span><br><span class="line"><span class="comment">//        // 获取 Maven 项目 Job</span></span><br><span class="line"><span class="comment">//        jobApi.getMavenJob();</span></span><br><span class="line"><span class="comment">//        // 获取 Job 配置xml</span></span><br><span class="line"><span class="comment">//        jobApi.getJobConfig();</span></span><br><span class="line">        <span class="comment">// 获取全部 Job 列表</span></span><br><span class="line"><span class="comment">//        jobApi.getJobList();</span></span><br><span class="line">        <span class="comment">// 根据 view 名称获取 Job 列表</span></span><br><span class="line"><span class="comment">//        jobApi.getJobListByView();</span></span><br><span class="line"><span class="comment">//        // 禁用 Job</span></span><br><span class="line"><span class="comment">//        jobApi.disableJob();</span></span><br><span class="line"><span class="comment">//        // 启用 Job</span></span><br><span class="line"><span class="comment">//        jobApi.enableJob();</span></span><br><span class="line"><span class="comment">//        // 删除 Job</span></span><br><span class="line"><span class="comment">//        jobApi.deleteJob();</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>Joplin+坚果云作为主力笔记工具</title>
    <url>/f5496f4b/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#joplin-介绍">Joplin 介绍</a></li>
<li><a href="#joplin-安装">Joplin 安装</a></li>
<li><a href="#界面说明">界面说明</a></li>
<li><a href="#配置坚果云同步">配置坚果云同步</a></li>
</ul>
<!-- tocstop -->

<h1><span id="前言">前言</span></h1><p>之前的云笔记工具一直是有道云，免费版本已经足够使用了。</p>
<p>让我下定决心放弃有道云的导火索是，突然有一天，我发现 MAC 和 Android 端都无法登录了。微博、知乎随便一搜“有道云不能登录”，发现这个问题从 2016 年就有很多用户遇到过（是很多用户，我遇到的问题并不是偶发），一直到 2021 年还没有解决（后来还发现，有道云把微博和知乎有关“有道云不能登录”的用户发帖全删了）。有道云连最基本的可用性和可靠性都无法保证，遂决定弃用有道云，转战其他工具平台。</p>
<p>尝试过的笔记工具：</p>
<ul>
<li><p>印象笔记</p>
</li>
<li><p>OneNote</p>
</li>
<li><p>Notion</p>
</li>
<li><p>语雀</p>
<ul>
<li>不看好语雀</li>
<li>纯在线服务，不能本地存储；当有一天服务端故障时，用户就完全不能使用</li>
<li>阿里内部的绩效项目，开发人员凭这个项目完成晋升后，一定会进入不再开发新功能的轮回</li>
<li>阿里系的其他产品也应谨慎使用</li>
</ul>
</li>
<li><p>为知笔记</p>
<ul>
<li>功能不完善，搜索功能不能用</li>
</ul>
</li>
</ul>
<p>其他笔记都无法完全匹配我的使用习惯。最后决定，使用开源的 joplin。</p>
<p><a href="https://joplinapp.org/">joplin 官网</a></p>
<h1><span id="joplin-介绍">Joplin 介绍</span></h1><p>Joplin 旨在取代印象笔记，成为全平台的免费开源笔记，其笔记的的书写格式是 markdown，界面支持中文。</p>
<p><strong>优点：</strong></p>
<ul>
<li>开源</li>
<li>多种同步方式可选择: WebDav、OneDrive、DroupOut、Nextcloud<ul>
<li>支持 WebDav 的网盘：<ul>
<li>国外网盘：Box、Dropbox、<strong>TeraCLOUD</strong>、yandex、TransIP</li>
<li>国内网盘：坚果云、城通网盘</li>
</ul>
</li>
</ul>
</li>
<li>支持笔记加密，防止数据存储平台偷看笔记内容</li>
<li>全平台支持。我使用的平台有 MacOS、Android、Linux</li>
<li>支持从印象笔记和 markdown 文件导入</li>
<li>有浏览器剪藏插件</li>
<li>笔记格式为 markdown</li>
<li>支持各种插件</li>
</ul>
<h1><span id="joplin-安装">Joplin 安装</span></h1><p><a href="https://joplinapp.org/#installation">Joplin 官网</a> 下载 + 安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509103914.png" alt></p>
<h1><span id="界面说明">界面说明</span></h1><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509103956.png" alt></p>
<h1><span id="配置坚果云同步">配置坚果云同步</span></h1><p><strong>我的同步服务器已从坚果云迁移到 TeraCLOUD</strong></p>
<p><a href="https://lxb.wiki/f3376d3f/">Joplin配置TeraCloud的WebDav进行同步</a></p>
<ol>
<li>注册<a href="https://www.jianguoyun.com/#/">坚果云</a></li>
<li>创建文件夹，起名为 joplin</li>
<li>点击右上角 <strong>账户信息 -&gt; 安全选项 -&gt; 添加应用</strong>；应用名称为 joplin</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509104440.png" alt></p>
<ol start="4">
<li>打开 Joplin，点击菜单<strong>首选项-&gt;同步</strong> <ol>
<li><strong>同步目标</strong> WebDAV</li>
<li><strong>工具-&gt;选项-&gt;同步</strong> <a href="https://dav.jianguoyun.com/dav/joplin">https://dav.jianguoyun.com/dav/joplin</a></li>
<li><strong>WebDAV 用户名</strong> 注册坚果云的用户名</li>
<li><strong>WebDAV 密码</strong> 坚果云新添加的 joplin 的应用密码（不是坚果云登录密码）</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509104829.png" alt></p>
<ol start="5">
<li><p>点击<strong>检查同步配置</strong>，显示成功即可点击应用开始同步</p>
</li>
<li><p>配置外部编辑器（可选）。<strong>首选项 -&gt; 通用选项 -&gt; Path</strong>，在应用程序中选择 Typora</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509105652.png" alt></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>joplin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 主从同步</title>
    <url>/4c6cb38f/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p>Kafka允许topic的分区拥有若干副本，这个数量是可以配置的，你可以为每个topci配置副本的数量。Kafka会自动在每个个副本上备份数据，所以当一个节点down掉时数据依然是可用的。</p>
<p>Kafka的副本功能不是必须的，你可以配置只有一个副本，这样其实就相当于只有一份数据。</p>
<p>创建副本的单位是topic的分区，每个分区都有一个leader和零或多个followers.所有的读写操作都由leader处理，一般分区的数量都比broker的数量多的多，各分区的leader均匀的分布在brokers中。所有的followers都复制leader的日志，日志中的消息和顺序都和leader中的一致。flowers向普通的consumer那样从leader那里拉取消息并保存在自己的日志文件中。<br>许多分布式的消息系统自动的处理失败的请求，它们对一个节点是否<br>着（alive）”有着清晰的定义。Kafka判断一个节点是否活着有两个条件：</p>
<ol>
<li>节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接。</li>
<li>如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久。</li>
</ol>
<p>符合以上条件的节点准确的说应该是“同步中的（in sync）”，而不是模糊的说是“活着的”或是“失败的”。Leader会追踪所有“同步中”的节点，一旦一个down掉了，或是卡住了，或是延时太久，leader就会把它移除。至于延时多久算是“太久”，是由参数replica.lag.max.messages决定的，怎样算是卡住了，怎是由参数replica.lag.time.max.ms决定的。<br>只有当消息被所有的副本加入到日志中时，才算是“committed”，只有committed的消息才会发送给consumer，这样就不用担心一旦leader down掉了消息会丢失。Producer也可以选择是否等待消息被提交的通知，这个是由参数request.required.acks决定的。</p>
<p>Kafka保证只要有一个“同步中”的节点，“committed”的消息就不会丢失。</p>
<p><strong>Leader的选择</strong></p>
<p>Kafka的核心是日志文件，日志文件在集群中的同步是分布式数据系统最基础的要素。  </p>
<p>如果leaders永远不会down的话我们就不需要followers了！一旦leader down掉了，需要在followers中选择一个新的leader.但是followers本身有可能延时太久或者crash，所以必须选择高质量的follower作为leader.必须保证，一旦一个消息被提交了，但是leader down掉了，新选出的leader必须可以提供这条消息。大部分的分布式系统采用了多数投票法则选择新的leader,对于多数投票法则，就是根据所有副本节点的状况动态的选择最适合的作为leader.Kafka并不是使用这种方法。</p>
<p>Kafaka动态维护了一个同步状态的副本的集合（a set of in-sync replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息必须被这个集合中的每个节点读取并追加到日志中了，才回通知外部这个消息已经被提交了。因此这个集合中的任何一个节点随时都可以被选为leader.ISR在ZooKeeper中维护。ISR中有f+1个节点，就可以允许在f个节点down掉的情况下不会丢失消息并正常提供服。ISR的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入ISR.这种leader的选择方式是非常快速的，适合kafka的应用场景。</p>
<p>一个邪恶的想法：如果所有节点都down掉了怎么办？Kafka对于数据不会丢失的保证，是基于至少一个节点是存活的，一旦所有节点都down了，这个就不能保证了。<br>实际应用中，当所有的副本都down掉时，必须及时作出反应。可以有以下两种选择:</p>
<ol>
<li>等待ISR中的任何一个节点恢复并担任leader。</li>
<li>选择所有节点中（不只是ISR）第一个恢复的节点作为leader.</li>
</ol>
<p>这是一个在可用性和连续性之间的权衡。如果等待ISR中的节点恢复，一旦ISR中的节点起不起来或者数据都是了，那集群就永远恢复不了了。如果等待ISR意外的节点恢复，这个节点的数据就会被作为线上数据，有可能和真实的数据有所出入，因为有些数据它可能还没同步到。Kafka目前选择了第二种策略，在未来的版本中将使这个策略的选择可配置，可以根据场景灵活的选择。</p>
<p>这种窘境不只Kafka会遇到，几乎所有的分布式数据系统都会遇到。</p>
<p><strong>副本管理</strong></p>
<p>以上仅仅以一个topic一个分区为例子进行了讨论，但实际上一个Kafka将会管理成千上万的topic分区.Kafka尽量的使所有分区均匀的分布到集群所有的节点上而不是集中在某些节点上，另外主从关系也尽量均衡这样每个几点都会担任一定比例的分区的leader.</p>
<p>优化leader的选择过程也是很重要的，它决定了系统发生故障时的空窗期有多久。Kafka选择一个节点作为“controller”,当发现有节点down掉的时候它负责在游泳分区的所有节点中选择新的leader,这使得Kafka可以批量的高效的管理所有分区节点的主从关系。如果controller down掉了，活着的节点中的一个会备切换为新的controller.</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>Joplin配置TeraCloud的WebDav进行同步</title>
    <url>/f3376d3f/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#为什么不再使用坚果云">为什么不再使用坚果云</a></li>
<li><a href="#joplin-配置teracloud-的webdav">Joplin 配置teracloud 的WebDav</a><ul>
<li><a href="#teracloud注册">TeraCLOUD注册</a></li>
<li><a href="#登录填写推荐码">登录&amp;填写推荐码</a></li>
<li><a href="#设置teracloud">设置TeraCLOUD</a></li>
</ul>
</li>
<li><a href="#使用的插件">使用的插件</a></li>
</ul>
<!-- tocstop -->

<h3><span id="为什么不再使用坚果云">为什么不再使用坚果云</span></h3><p>使用坚果云同步笔记，出现了无法解决的灾难性问题</p>
<blockquote>
<p>第三方应用访问的限制<br>文件上传大小限制： 当前 WebDAV 客户端和网页端上传大小的限制是一致的，默认为 500M（私有云可以通过相关设置调整）。</p>
<p>访问频率限制： 由于WebDAV协议比较占用系统资源，免费版用户限制访问频率为每30分钟不超过600次请求。付费用户限制访问频率为每30分钟不超过1500次请求。</p>
<p>同步目录数限制： 目前坚果云的WebDAV协议单次请求文件数（包含文件和文件夹）为750个，支持分多页多次加载。如果您使用WebDAV的三方工具未实现按分页多次加载，可能会出现文件同步不完整的情况，建议您使用坚果云客户端进行直接同步。</p>
</blockquote>
<p>用坚果云同步joplin是个糟糕的选择，目前有两个问题：<br>一个是短时间大量同步文件，会触发坚果云的限制，导致同步失败，当触发该限制后，我们能做的只有耐心等待6个小时，该限制与免费版/专业版没有关系。<br>另一个才是灾难，坚果云对同一文件夹内的文件采取分页传输的机制，导致Joplin一次不能获取全部文件列表，导致Joplin认为有些文件在服务器端不存在，即认为该文件要被删除，Joplin就会删除本地对应的内容，直接的表现就是当笔记达到一定数量后用坚果云同步就会出现频繁的丢笔记现象。</p>
<p>目前Joplin官方也不建议使用坚果云。</p>
<p><a href="https://joplinapp.org/faq/#the-following-webdav-hosts-are-not-supported">FAQ | Joplin (joplinapp.org)</a></p>
<p>在 2021 年 1 月已经有用户提过 issue</p>
<p><a href="https://github.com/laurent22/joplin/issues/4294">Data lost when using the webdav to sync data · Issue #4294 · laurent22/joplin (github.com)</a></p>
<h3><span id="joplin-配置teracloud-的webdav">Joplin 配置teracloud 的WebDav</span></h3><h4><span id="teracloud注册">TeraCLOUD注册</span></h4><p>官网地址：<a href="https://teracloud.jp/en/。">https://teracloud.jp/en/。</a></p>
<p>进入上述官网地址之后，点击 <code>Create Account</code></p>
<h4><span id="登录amp填写推荐码">登录&amp;填写推荐码</span></h4><p>注册账号之后，在官网地址点击 <code>Login</code> 登录。<br>登录之后，点击 <code>My Page</code> ，进入我的页面。</p>
<p>免费用户默认只给10G空间，如果使用推荐码，可以再增加5G空间。</p>
<p>在 <code>My Page</code> 页面，<code>Referral Bonus-&gt;Enter Friends Referral Code</code>，填写推荐码即可，如下所示。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710182918.png" alt></p>
<p>我的推荐码：BQMZ7。</p>
<h4><span id="设置teracloud">设置TeraCLOUD</span></h4><p><strong>开启WebDAV</strong></p>
<p>进入 <a href="https://teracloud.jp/en/modules/mypage/usage/">My Page</a> 页面，找到<code>Apps Connection</code>，勾选<code>Turn on Apps Connection</code>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710183145.png" alt></p>
<p><strong>创建Joplin同步文件夹</strong></p>
<p>从首页进入 <a href="https://aki.teracloud.jp/browser/">File Browser</a> 页面，创建用于Joplin同步的文件夹，如创建一个名为 <code>terajoplin</code> 的文件件</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710183450.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710183642.png" alt></p>
<p><strong>配置Joplin</strong></p>
<p>打开 Joplin 客户端的 <code>同步</code> 选项</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710184839.png" alt></p>
<ul>
<li><p>同步目标选 <code>Nextcloud</code></p>
</li>
<li><p><code>Nextcloud WebDAV URL</code> 为 <a href="https://teracloud.jp/en/modules/mypage/usage/">My Page|TeraCLOUD</a> 中 <code>Apps Connection</code> 里的 <code>WebDAV Connection URL</code>后加刚刚在 <code>File Browser</code> 创建的目录名</p>
</li>
<li><p><code>Nextcloud username</code> 为 <a href="https://teracloud.jp/en/modules/mypage/usage/">My Page|TeraCLOUD</a> 中 <code>Apps Connection</code> 里的 <code>Connection ID</code></p>
</li>
<li><p><code>Nextcloud password</code> 为 <a href="https://teracloud.jp/en/modules/mypage/usage/">My Page|TeraCLOUD</a> 中 <code>Apps Connection</code> 里的 <code>Apps Password</code></p>
</li>
</ul>
<h3><span id="使用的插件">使用的插件</span></h3><ul>
<li>Embed Search</li>
<li>Event Calendar<ul>
<li>yaml 配置日历事件</li>
</ul>
</li>
<li>Note list and sidebar toggle buttons<ul>
<li>控制左侧 notebooks 和 note 栏的显示/隐藏</li>
</ul>
</li>
<li>macOS theme</li>
<li>Enhancement(弃用)<ul>
<li>在代码块中误输入后，无法撤销</li>
</ul>
</li>
<li>Kitty Minder(naotu)(弃用)</li>
<li>draw.io(弃用)</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>joplin</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 僵尸任务&amp;排队任务清理</title>
    <url>/c71b015c/</url>
    <content><![CDATA[<h2><span id="通过api清理排队的任务">通过API清理排队的任务</span></h2><p>删除已经开始构建的任务（已有build_number）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST &lt;jenkins-server&gt;/job/&lt;job-name&gt;/&lt;build-number&gt;/doDelete</span><br></pre></td></tr></table></figure>

<p>对于排队中的任务</p>
<p>注意下面的id 不是build_number</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&#x27;http://jenkins/queue/cancelItem?id=85&#x27;</span></span><br></pre></td></tr></table></figure>

<p>To find x, you can parse the result of:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://jenkins/queue/api/json?tree=items[<span class="built_in">id</span>,task[name]]</span><br></pre></td></tr></table></figure>

<p>To cancel a build that is in progress:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://jenkins/job/&lt;jobName&gt;/y/stop</span><br></pre></td></tr></table></figure>

<p>To find y, you can parse the result of:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://jenkins/job/&lt;jobName&gt;/lastBuild/api/json?tree=building,number</span><br></pre></td></tr></table></figure>

<h2><span id="脚本处理排队中的任务">脚本处理排队中的任务</span></h2><p>获取jenkins所有排队中任务，然后通过jobname过滤，然后想精确到某个任务可以在任务里通过判断任务的参数来确定：比如唯一的ID。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">fun JenkinsServer.cancelTaskInQueue(<span class="attr">jobName:</span> String, <span class="attr">p1:</span> String, <span class="attr">p2:</span> String, <span class="attr">p3:</span> String)&#123;</span><br><span class="line">    runScript(runScriptHtml(jobName, URLEncoder.encode(<span class="string">&quot;import hudson.model.*\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot; \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;def q = Jenkins.instance.queue\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;q.items.findAll &#123; \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  it.task.name.startsWith(\&quot;$&#123;jobName&#125;\&quot;)\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;.each &#123; \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  p1=\&quot;\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  p2=\&quot;\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  p3=\&quot;\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  it.params.eachLine&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    aa = it.split(\&quot;=\&quot;)\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    if(aa[0].equals(\&quot;p1\&quot;))&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      if(aa.length == 2)&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \tp1 = aa[1]\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    if(aa[0].equals(\&quot;p2\&quot;))&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      if(aa.length == 2)&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \tp2 = aa[1]\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    if(aa[0].equals(\&quot;p3\&quot;))&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      if(aa.length == 2)&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \tp3 = aa[1]\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  if(\&quot;$&#123;p1&#125;\&quot;.equals(p1) &amp;&amp; \&quot;$&#123;p2&#125;\&quot;.equals(p2) &amp;&amp; \&quot;$&#123;p3&#125;\&quot;.equals(p3))&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    println(\&quot;cancel auto build $&#123;p1&#125;:$&#123;p2&#125; is $&#123;p3&#125;\&quot;)\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    q.cancel(it);\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="清除段时间内大量堆积的任务">清除段时间内大量堆积的任务</span></h2><p>进入 <strong>Manage Jenkins -&gt; Script Console</strong> , 然后执行后面的脚本</p>
<h3><span id="单条结束任务">单条结束任务</span></h3><p>查看进程的名字</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Thread.getAllStackTraces().keySet().each() &#123;</span><br><span class="line">  t -&gt; println(<span class="string">&quot;name:&quot;</span>+t.getName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程名字结果示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name:Thread-90</span><br><span class="line">name:Scheduler-174573182-1</span><br><span class="line">name:Thread-116</span><br><span class="line">name:Thread-110</span><br><span class="line">name:Thread-83</span><br><span class="line">name:org.jenkinsci.plugins.workflow.steps.SynchronousNonBlockingStepExecution [#52]</span><br><span class="line">name:SCMTrigger [#10]</span><br></pre></td></tr></table></figure>

<p>停止特定进程</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Thread.getAllStackTraces().keySet().each() &#123;</span><br><span class="line">  t -&gt; <span class="keyword">if</span> (t.getName()==<span class="string">&quot;刚才查出来的某条进程名字&quot;</span> ) &#123;   t.interrupt();  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删掉所有进程</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Thread.getAllStackTraces().keySet().each() &#123;</span><br><span class="line">  t -&gt;   t.interrupt(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="清掉所有build-queue">清掉所有Build Queue</span></h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Jenkins.instance.queue.clear()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Linux 中退出码的含义</title>
    <url>/e28c7f9c/</url>
    <content><![CDATA[<h1><span id="linux-中退出码的含义">Linux 中退出码的含义</span></h1><p><img src="https://img.linux.net.cn/data/attachment/album/202308/03/154628oloxp7sl6s1z4pbl.jpg" alt></p>
<blockquote>
<p>揭开 Linux 中退出码的神秘面纱。了解什么是退出码，以及为什么和如何使用它们。</p>
</blockquote>
<p>退出码（退出状态）可以告诉我们最后一次执行的命令的状态。在命令结束以后，我们可以知道命令是成功完成的还是以错误结束的。</p>
<p><strong>其基本思想是，程序返回退出代码 <code>0</code> 时表示执行成功，没有问题。代码 <code>1</code> 或 <code>0</code> 以外的任何代码都被视为不成功。</strong></p>
<p>退出码除了 0 和 1 外还有很多值，我将在本文介绍它们。</p>
<h3><span id="linux-shell-中的各种退出码">Linux Shell 中的各种退出码</span></h3><p>我们来快速了解一下 Linux Shell 中的主要退出码：</p>
<table>
<thead>
<tr>
<th align="left">退出码</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left">命令成功执行</td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left">通用错误代码</td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left">命令（或参数）使用不当</td>
</tr>
<tr>
<td align="left"><code>126</code></td>
<td align="left">权限被拒绝（或）无法执行</td>
</tr>
<tr>
<td align="left"><code>127</code></td>
<td align="left">未找到命令，或 <code>PATH</code> 错误</td>
</tr>
<tr>
<td align="left"><code>128+n</code></td>
<td align="left">命令被信号从外部终止，或遇到致命错误</td>
</tr>
<tr>
<td align="left"><code>130</code></td>
<td align="left">通过 <code>Ctrl+C</code> 或 <code>SIGINT</code> 终止（_终止代码 2 或键盘中断_）</td>
</tr>
<tr>
<td align="left"><code>143</code></td>
<td align="left">通过 <code>SIGTERM</code> 终止（_默认终止_）</td>
</tr>
<tr>
<td align="left"><code>255/*</code></td>
<td align="left">退出码超过了 0-255 的范围，因此重新计算（LCTT 译注：超过 255 后，用退出码对 256 取模）</td>
</tr>
</tbody></table>
<blockquote>
<p>📋 <code>130</code>（<code>SIGINT</code> 或 <code>^C</code>）和 <code>143</code>（<code>SIGTERM</code>）等终止信号是非常典型的，它们属于 <code>128+n</code> 信号，其中 <code>n</code> 代表终止码。</p>
</blockquote>
<p>在简单了解了退出码之后，我们来看看它们的用法。</p>
<h3><span id="获取退出码">获取退出码</span></h3><p>前一个命令执行的退出码存储在 <a href="https://linuxhandbook.com:443/bash-special-variables/">特殊变量</a> <code>$?</code> 中。你可以通过运行以下命令来获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<p>我们在所有演示中都将使用它来获取退出代码。</p>
<p>请注意，<code>exit</code> 命令支持以带着前一条命令相同的退出码退出。</p>
<h3><span id="退出码-0">退出码 0</span></h3><p>退出码 <code>0</code> 表示命令执行无误，这是完成命令的理想状态。</p>
<p>例如，我们运行这样一条基本命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neofetch </span><br><span class="line"></span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_0.png" alt></p>
<p>这个退出码 <code>0</code> 表示特定命令已成功执行，仅此而已。让我们再演示几个例子。</p>
<p>你可以尝试 <a href="https://itsfoss.com/how-to-find-the-process-id-of-a-program-and-kill-it-quick-tip/">终止一个进程</a>；它也会返回代码 <code>0</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkill lxappearance</span><br></pre></td></tr></table></figure>

<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_0.gif" alt></p>
<p>查看文件内容也会返回退出码 0，这<strong>仅</strong>意味着 <code>cat</code> 命令执行成功。</p>
<h3><span id="退出码-1">退出码 1</span></h3><p>退出码 <code>1</code> 也很常见。它通常表示命令以一般错误结束。</p>
<p>例如，在没有 sudo 权限的情况下使用 <a href="https://itsfoss.com/package-manager/">软件包管理器</a>，就会返回代码 <code>1</code>。在 Arch Linux 中，如果我运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -Sy</span><br></pre></td></tr></table></figure>

<p>它会返回 <code>1</code>， 表示上一条命令运行出错。</p>
<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_1.png" alt="exit code 1 (impermissible operation resulted in this code)"></p>
<blockquote>
<p>📋 如果你在基于 Ubuntu 的发行版中尝试这样做（不使用 <code>sudo</code> 执行 <code>apt update</code>），运行后会得到错误码 <code>100</code>，表示你是在没有权限的情况下运行 <code>apt</code>。<code>100</code> 不是标准错误码，而是 <code>apt</code> 特有的错误码。</p>
</blockquote>
<p>虽然这是一般的理解，但我们也可以将其解释为 “不被允许的操作”。</p>
<p>除以 <code>0</code> 等操作也会返回错误码 <code>1</code>。</p>
<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_1-division_by_0-.png" alt="Division by zero results in code 1"></p>
<h3><span id="退出码-2">退出码 2</span></h3><p>这个退出码出现在当执行的命令有语法错误时。滥用命令参数也会导致此错误。</p>
<p>一般来说，它表示由于使用不当，命令无法执行。</p>
<p>例如，我在一个本应只有一个连字符的选项上添加了两个连字符，那么此时会出现退出码 2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep --z file.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://itsfoss.com/content/images/2023/06/exit_status_2-misusing_arguments--1.png" alt="Invalid argument resulted in exit code 2"></p>
<p>当权限被拒绝时，比如访问 <code>/root</code> 文件夹，就会出现错误码 <code>2</code>。</p>
<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_2-permission_denied-.png" alt="Permission denied gives out code 2"></p>
<h3><span id="退出码-126">退出码 126</span></h3><p>126 是一个特殊的退出码，它用于表示命令或脚本因权限错误而未被执行。</p>
<p>当你尝试执行没有执行权限的 Shell 脚本时，就会出现这个错误。</p>
<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_126.png" alt></p>
<p>请注意，该退出码只出现在没有足够权限的脚本或命令的“_执行_”中，这与一般的<strong>权限被拒绝</strong>错误不同。</p>
<p>因此，不要把它与你之前看到的退出码为 <code>2</code> 的示例混淆。在那个示例中，运行的是 <code>ls</code> 命令，权限问题出自它试图执行的目录。而本例中权限问题来自脚本本身。</p>
<h3><span id="退出码-127">退出码 127</span></h3><p>这是另一个常见的退出码。退出码 <code>127</code> 指的是“<a href="https://itsfoss.com/bash-command-not-found/">未找到命令</a>”。它通常发生在执行的命令有错别字或所需的可执行文件不在 <code>$PATH</code> 变量中时。</p>
<p>例如，当我尝试执行一个不带路径的脚本时，经常会看到这个错误。</p>
<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_127.png" alt="Script executed without the path gives &quot;command not found&quot; or code 127"></p>
<p>当你想运行的可执行文件不在 <code>$PATH</code> 变量中时，也会出现退出码 <code>127</code>。你可以通过 <a href="https://itsfoss.com/add-directory-to-path-linux/">在 PATH 变量中添加命令的目录</a> 来纠正这种情况。</p>
<p>当你输入不存在的命令时，也会得到这样的退出码。</p>
<p><img src="https://itsfoss.com/content/images/2023/06/exit_code_127-command_not_found--1.png" alt="Unmount is not a command, and Screenfetch is not installed, which resulted in code 127"></p>
<h3><span id="退出码-128n-系列">退出码 128+n 系列</span></h3><p>当应用程序或命令因致命错误而终止或执行失败时，将产生 128 系列退出码（<code>128+n</code>），其中 <code>n</code> 为信号编号。</p>
<p><code>n</code> 包括所有类型的终止代码，如 <code>SIGTERM</code>、<code>SIGKILL</code> 等。</p>
<h4><span id="退出码-130-或-sigint">退出码 130 或 SIGINT</span></h4><p>在通过终止信号 <code>2</code> 或按下 <code>Ctrl+C</code> 中断进程时，会发出 <code>SIGINT</code>（键盘中断信号）。</p>
<p>因为终止信号是 <code>2</code>，所以我们得到的退出码是 <code>130</code>（128+2）。下面的视频演示了 <code>lxappearance</code> 的中断信号。</p>
<p><img src="https:/itsfoss.com/content/media/2023/06/exit_code_128-n-SIGINT-_compressed.mp4" alt></p>
<h4><span id="退出码-137-或-sigkill">退出码 137 或 SIGKILL</span></h4><p><code>SIGKILL</code>（立即终止信号）表示终止信号 <code>9</code>。这是终止应用程序时最不应该使用的方法。</p>
<p>因为终止信号为 <code>9</code>，因此我们得到的退出代码为 <code>137</code>（128+9）。</p>
<p><img src="https://itsfoss.com/content/media/2023/06/exit_code_128-n-SIGKILL-_compressed.mp4" alt></p>
<h4><span id="退出码-143-或-sigterm">退出码 143 或 SIGTERM</span></h4><p><code>SIGTERM</code> 是进程在未指定参数的情况下被杀死时的默认行为。</p>
<p><code>SIGTERM</code> 的终止信号为 <code>15</code>，因此该信号的退出码为 <code>143</code>（128+15）。</p>
<p><img src="https://itsfoss.com/content/media/2023/06/exit_code_128-n-SIGTERM-_compressed-1.mp4" alt></p>
<p>还有一些你以前可能不知道的终止信号，它们也有自己类似的退出码。你可以在这里查看它们：</p>
<blockquote>
<p>📋 请注意，如果进程在启动它的同一会话中终止，这些信号可能不会出现。如果要重现这些信号，请从不同的 shell 终止。</p>
<p>就个人而言，信号 <code>128</code> 是无法重现的。</p>
</blockquote>
<h3><span id="当退出码超过了-255-会怎样">当退出码超过了 255 会怎样?</span></h3><p>最新版本的 Bash 甚至保留了超过 255 的原始退出码的值，但一般来说，如果代码超过 255，就会被重新计算。</p>
<p>也就是说，代码 <code>256</code> 会变成 <code>0</code>，<code>257</code> 会变成 <code>1</code>，<code>383</code> 会变成 <code>127</code>，以此类推。为确保更好的兼容性，请将退出码保持在 <code>0</code> 至 <code>255</code> 之间。</p>
<h3><span id="结语">结语</span></h3><p>希望你对 Linux Shell 中的退出码有所了解。在排查各种问题时，使用它们会非常方便。</p>
<p>如果你要在 Shell 脚本中使用这些代码，请确保你了解每个代码的含义，以便更容易地排除故障。</p>
<p>这就是本文的全部内容。如有遗漏，请在评论区告诉我。</p>
<p><em>（题图：MJ/719ff711-1b9f-4aa9-a82e-980704acbdd8）</em></p>
<hr>
<p>via: <a href="https://itsfoss.com/linux-exit-codes/">https://itsfoss.com/linux-exit-codes/</a></p>
<p>作者：<a href="https://itsfoss.com/author/pranav/">Pranav Krishna</a><br>选题：<a href="https://github.com/lkxed/">lkxed</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 架构</title>
    <url>/44075289/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#一-简介">一、简介</a><ul>
<li><a href="#11-概述">1.1 概述</a></li>
<li><a href="#12-消息系统介绍">1.2 消息系统介绍</a></li>
<li><a href="#13-点对点消息传递">1.3 点对点消息传递</a></li>
<li><a href="#14-发布-订阅消息传递">1.4 发布-订阅消息传递</a></li>
<li><a href="#15-kafka的优点">1.5 Kafka的优点</a></li>
<li><a href="#16-常用mq对比">1.6 常用MQ对比</a></li>
<li><a href="#17-kafka中的术语解释">1.7 Kafka中的术语解释</a><ul>
<li><a href="#概述">概述</a></li>
<li><a href="#1-broker">1 broker</a></li>
<li><a href="#2-topic">2 Topic</a></li>
<li><a href="#3-partition">3 <strong>Partition</strong></a></li>
<li><a href="#4-producer">4 Producer</a></li>
<li><a href="#5-consumer">5 Consumer</a></li>
<li><a href="#6-consumer-group">6 Consumer Group</a></li>
<li><a href="#7-leader">7 Leader</a></li>
<li><a href="#8-follower">8 Follower</a></li>
<li><a href="#9-offset">9 Offset</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#一-kafka的架构">一、Kafka的架构</a><ul>
<li><a href="#21-分布式模型">2.1 分布式模型</a></li>
</ul>
</li>
<li><a href="#二-topics和partition">二、Topics和Partition</a></li>
<li><a href="#三-producer消息路由">三、Producer消息路由</a></li>
<li><a href="#四-consumer-group">四、Consumer Group</a></li>
<li><a href="#五-push-vs-pull">五、Push vs. Pull</a></li>
<li><a href="#六-kafka-delivery-guarantee">六、Kafka delivery guarantee</a></li>
</ul>
<!-- tocstop -->

<h2><span id="一-简介">一、简介</span></h2><h3><span id="11-概述">1.1 概述</span></h3><p>Kafka主要设计目标如下：</p>
<ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>支持在线水平扩展</li>
</ul>
<h3><span id="12-消息系统介绍">1.2 消息系统介绍</span></h3><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：<strong>点对点传递模式、发布-订阅模式</strong>。大部分的消息系统选用发布-订阅模式。<strong>Kafka就是一种发布-订阅模式</strong>。</p>
<h3><span id="13-点对点消息传递">1.3 点对点消息传递</span></h3><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。这种架构描述示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305215705.png" alt></p>
<p><strong>生产者发送一条消息到queue，只有一个消费者能收到</strong>。</p>
<h3><span id="14-发布-订阅消息传递">1.4 发布-订阅消息传递</span></h3><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305215731.png" alt></p>
<p><strong>发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息</strong>。</p>
<h3><span id="15-kafka的优点">1.5 Kafka的优点</span></h3><p>1）解耦：</p>
<p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
<p>2）冗余：（副本）</p>
<p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
<p>3）扩展性</p>
<p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p>
<p>4）灵活性&amp;峰值处理能力</p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
<p>5）可恢复性</p>
<p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
<p>6）顺序保证</p>
<p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p>
<p>7）缓冲</p>
<p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p>
<p>8）异步通信</p>
<p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
<h3><span id="16-常用mq对比">1.6 常用MQ对比</span></h3><p>1）RabbitMQ</p>
<p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>
<p>2）Redis</p>
<p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<p>3）ZeroMQ</p>
<p>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p>
<p>4）ActiveMQ</p>
<p>ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p>
<p>5）Kafka/Jafka</p>
<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
<h3><span id="17-kafka中的术语解释">1.7 Kafka中的术语解释</span></h3><h4><span id="概述">概述</span></h4><p>在深入理解Kafka之前，先介绍一下Kafka中的术语。下图展示了Kafka的相关术语以及之间的关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305215821.png" alt></p>
<p>上图中一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p>
<p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p>
<h4><span id="1-broker">1 broker</span></h4><p>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p>
<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>
<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>
<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>
<h4><span id="2-topic">2 Topic</span></h4><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<p>类似于数据库的表名</p>
<h4><span id="3-partition">3 <strong>Partition</strong></span></h4><p>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>
<h4><span id="4-producer">4 Producer</span></h4><p>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息<strong>追加</strong>到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p>
<h4><span id="5-consumer">5 Consumer</span></h4><p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>
<h4><span id="6-consumer-group">6 Consumer Group</span></h4><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</p>
<h4><span id="7-leader">7 Leader</span></h4><p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p>
<h4><span id="8-follower">8 Follower</span></h4><p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>
<h4><span id="9-offset">9 Offset</span></h4><p>kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka</p>
<h2><span id="一-kafka的架构">一、Kafka的架构</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305215857.png" alt></p>
<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h3><span id="21-分布式模型">2.1 分布式模型</span></h3><p>Kafka每个主题的多个分区日志分布式地存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本（Leader），其他节点作为备份副本（Follower，也叫作从副本）。主副本会负责所有的客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本中只有主副本接受读写，所以每个服务器端都会作为某些分区的主副本，以及另外一些分区的备份副本，这样Kafka集群的所有服务端整体上对客户端是负载均衡的。</p>
<p>Kafka的生产者和消费者相对于服务器端而言都是客户端。</p>
<p>Kafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，采用不同的分区策略。消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义（例如hash）确保相同键的消息总是发送到同一分区。</p>
<p>Kafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者；如果要实现“发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。</p>
<p>分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量时300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，增加服务器节点会提升集群的性能，增加消费者数量会提升处理性能。</p>
<p>同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305215916.png" alt></p>
<p>Kafka的消费者消费消息时，只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇中多个分区的消息顺序。而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入“hello”和“Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是“hello”和“Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性，再对消息假设键来保证相同键的所有消息落入同一分区，就可以满足绝大多数的应用。</p>
<h2><span id="二-topics和partition">二、Topics和Partition</span></h2><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。因为每条消息都被append到该Partition中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305215934.png" alt></p>
<p>对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略删除旧数据。一是基于时间，二是基于Partition文件大小。例如可以通过配置$KAFKA_HOME/config/server.properties，让Kafka删除一周前的数据，也可在Partition文件超过1GB时删除旧数据，配置如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion</span></span><br><span class="line">log.retention.hours=168</span><br><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according to the retention policies</span></span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"><span class="comment"># If log.cleaner.enable=true is set the cleaner will be enabled and individual logs can then be marked for log compaction.</span></span><br><span class="line">log.cleaner.enable=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高Kafka性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka会为每一个Consumer Group保留一些metadata信息——当前消费的消息的position，也即offset。这个offset由Consumer控制。正常情况下Consumer会在消费完一条消息后递增该offset。当然，Consumer也可将offset设成一个较小的值，重新消费一些消息。因为offet由Consumer控制，所以Kafka broker是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过broker去保证同一个Consumer Group只有一个Consumer能消费某一条消息，因此也就不需要锁机制，这也为Kafka的高吞吐率提供了有力保障。</p>
<h2><span id="三-producer消息路由">三、Producer消息路由</span></h2><p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O将会成为这个Topic的性能瓶颈，而有了Partition后，不同的消息可以并行写入不同broker的不同Partition里，极大的提高了吞吐率。可以在$KAFKA_HOME/config/server.properties中通过配置项num.partitions来指定新建Topic的默认Partition数量，也可在创建Topic时通过参数指定，同时也可以在Topic创建之后通过Kafka提供的工具修改。</p>
<p>在发送一条消息时，可以指定这条消息的key，Producer根据这个key和Partition机制来判断应该将这条消息发送到哪个Parition。Paritition机制可以通过指定Producer的paritition. class这一参数来指定，该class必须实现kafka.producer.Partitioner接口。</p>
<h2><span id="四-consumer-group">四、Consumer Group</span></h2><p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220305220015.png" alt></p>
<p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p>
<p>实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。根据这一特性，可以使用Storm这种实时流处理系统对消息进行实时在线处理，同时使用Hadoop这种批处理系统进行离线处理，还可以同时将数据实时备份到另一个数据中心，只需要保证这三个操作所使用的Consumer属于不同的Consumer Group即可。</p>
<h2><span id="五-push-vs-pull">五、Push vs. Pull</span></h2><p>作为一个消息系统，Kafka遵循了传统的方式，选择由Producer向broker push消息并由Consumer从broker pull消息。一些logging-centric system，比如Facebook的Scribe和Cloudera的Flume，采用push模式。事实上，push模式和pull模式各有优劣。</p>
<p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。</p>
<p>对于Kafka而言，pull模式更合适。pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>
<h2><span id="六-kafka-delivery-guarantee">六、Kafka delivery guarantee</span></h2><p>有这么几种可能的delivery guarantee：</p>
<blockquote>
<p>At most once 　　消息可能会丢，但绝不会重复传输</p>
<p>At least one 　　 消息绝不会丢，但可能会重复传输</p>
<p>Exactly once 　　 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</p>
</blockquote>
<p>当Producer向broker发送消息时，一旦这条消息被commit，因数replication的存在，它就不会丢。但是如果Producer发送数据给broker后，遇到网络问题而造成通信中断，那Producer就无法判断该条消息是否已经commit。虽然Kafka无法确定网络故障期间发生了什么，但是Producer可以生成一种类似于主键的东西，发生故障时幂等性的重试多次，这样就做到了Exactly once。</p>
<p>接下来讨论的是消息从broker到Consumer的delivery guarantee语义。（仅针对Kafka consumer high level API）。Consumer在从broker读取消息后，可以选择commit，该操作会在Zookeeper中保存该Consumer在该Partition中读取的消息的offset。该Consumer下一次再读该Partition时会从下一条开始读取。如未commit，下一次读取的开始位置会跟上一次commit之后的开始位置相同。当然可以将Consumer设置为autocommit，即Consumer一旦读到数据立即自动commit。如果只讨论这一读取消息的过程，那Kafka是确保了Exactly once。但实际使用中应用程序并非在Consumer读取完数据就结束了，而是要进行进一步处理，而数据处理与commit的顺序在很大程度上决定了消息从broker和consumer的delivery guarantee semantic。</p>
<p><strong>Kafka默认保证At least once</strong>，并且允许通过设置Producer异步提交来实现At most once。而Exactly once要求与外部存储系统协作，幸运的是Kafka提供的offset可以非常直接非常容易得使用这种方式。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装samba</title>
    <url>/8f5b70d0/</url>
    <content><![CDATA[<h5><span id="开发机安装-samba">开发机安装 samba</span></h5><p><code>yum install samba samba-client samba-swat</code></p>
<h5><span id="添加账号">添加账号</span></h5><p><code>sampasswd -a 用户名</code> 用户名只能为已经存在的账号</p>
<h5><span id="配置共享文件夹">配置共享文件夹</span></h5><p>编辑<code>etc/samba/smb.conf</code>, 追加内容:</p>
<pre><code>[samba_share_dir]

comment = samba_share
path = /home/lxb/samba_share
create mask = 0664
directory mask = 0775
writable = yes
valid users = lxb
browseable = yes</code></pre><h5><span id="配置环境变量">配置环境变量</span></h5><p>环境变量文件添加:</p>
<p><code>export LD_LIBRARY_PATH=/usr/local/samba/lib:$LD_LIBRARY_PATH</code></p>
<h5><span id="samba-重启">samba 重启</span></h5><p><code>sudo /etc/init.d/smb restart</code></p>
<h5><span id="mac客户端连接">MAC客户端连接</span></h5><p>Finder -&gt; 前往 -&gt; 连接服务器 -&gt; 输入smb地址</p>
<p><code>smb://user_name@IP/samba_share_dir</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件句柄与文件描述符</title>
    <url>/200486d9/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202307202154896.png" alt></p>
<p>每个进程都有一个打开的文件表（fdtable)。表中的每一项是struct file类型，包含了打开文件的一些属性比如偏移量，读写访问模式等，这是真正意义上的文件句柄。</p>
<p>文件描述符是一个整数。代表fdtable中的索引位置（下标），指向具体的struct file（文件句柄）。</p>
<p>哪些地方会分配文件句柄？</p>
<p>知道文件句柄最终是通过get_empty_filp函数从filp cache中分配的之后，我们顺着函数调用链路简单梳理下，就能知道有哪些地方会分配文件句柄了：</p>
<ul>
<li>open系统调用打开文件（path_openat内核函数)</li>
<li>打开一个目录（dentry_open函数)</li>
<li>共享内存attach （do_shmat函数）</li>
<li>socket套接字（sock_alloc_file函数）</li>
<li>管道（create_pipe_files函数）</li>
<li>epoll/inotify/signalfd等功能用到的匿名inode文件系统（anon_inode_getfile函数)</li>
</ul>
<p>file-nr文件里面的第一个字段代表的是内核分配的struct file的个数，也就是文件句柄个数，而不是文件描述符</p>
<p>机器上的常常会出现文件句柄使用量与常用的lsof命令的数量相去甚远的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202307202156791.png" alt></p>
<p>因为文件描述符和文件句柄是两个不同的东西：lsof在用户空间，主要还是从文件描述符的角度来看文件句柄。</p>
<p>我们来做一个实验：只打开一次文件，然后复制1000次文件描述符。</p>
<p>我们启动dupfd进程打开了一次/dev/zero文件，复制了1000次文件描述符。file-nr中的文件句柄数只是个位数的变化，而lsof看到的结果涨了1000多。</p>
<p>如果我们把前面的代码换成open 1000次， 就可以看到file-nr和lsof的输出几乎都涨了1000。</p>
<p>我们循环1000次打开/dev/zero文件，之后mmap映射到进程地址空间，然后把这些打开的文件描述符都关掉。很显然，打开的描述符都被close掉了，不会有什么变化。 那为什么文件句柄数还是增加了1000个左右呢？</p>
<p>原来，linux内核中很多对象都是有引用计数的。 虽然文件句柄是由open先打开的，但mmap之后，引用计数被加1，尽管我们接着把文件描述符close掉了，但是底层指向的struct file由于引用数大于0，不会被回收。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下 su 和 su - 的区别</title>
    <url>/686a477f/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p>大部分Linux发行版的默认账户是普通用户，而更改系统文件或者执行某些命令，需要root身份才能进行，这就需要从当前用户切换到root用户。Linux中切换用户的命令是su或su -。前天我在使用useradd这个命令时，才体会到这两者的本质区别。如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503112328.png" alt></p>
<p>我首先是用su命令切换到root身份的，但是运行useradd时，出现错误：bash: useradd: command not found。google了一下，原因是在这个用su命令切换过来的root用户上。</p>
<p><strong>su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。用echo $PATH命令看一下su和su -以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用su -命令。</strong> 如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503112427.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 守护进程的启动方法</title>
    <url>/2e3ff18f/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-问题的由来">1 问题的由来</a></li>
<li><a href="#2-前台任务与后台任务">2 前台任务与后台任务</a></li>
<li><a href="#3-sighup信号">3 SIGHUP信号</a></li>
<li><a href="#4-disown-命令">4 disown 命令</a></li>
<li><a href="#5-标准-io">5 标准 I/O</a></li>
<li><a href="#6-nohup-命令">6 nohup 命令</a></li>
<li><a href="#7-screen-命令与-tmux-命令">7 Screen 命令与 Tmux 命令</a></li>
<li><a href="#8-node-工具">8 Node 工具</a></li>
<li><a href="#9-systemd">9 Systemd</a></li>
</ul>
<!-- tocstop -->

<p><a href="http://baike.baidu.com/view/53123.htm">“守护进程”</a>（daemon）就是一直在后台运行的进程（daemon）。</p>
<p>如何将一个 Web 应用，启动为守护进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/201130/00.png" alt></p>
<h2><span id="1-问题的由来">1 问题的由来</span></h2><p>Web应用写好后，下一件事就是启动，让它一直在后台运行。</p>
<p>这并不容易。举例来说，下面是一个最简单的Node应用<code>server.js</code>，只有6行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>你在命令行下启动它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node server.js</span><br></pre></td></tr></table></figure>

<p>看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。</p>
<p>怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？</p>
<h2><span id="2-前台任务与后台任务">2 前台任务与后台任务</span></h2><p>上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。</p>
<p>变成守护进程的第一步，就是把它改成”后台任务”（background job）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node server.js &amp;</span><br></pre></td></tr></table></figure>

<p>只要在命令的尾部加上符号<code>&amp;</code>，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按<code>ctrl + z</code>，然后执行<code>bg</code>命令（让最近一个暂停的”后台任务”继续执行）。</p>
<p>“后台任务”有两个特点。</p>
<ol>
<li>继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。</li>
<li>不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。</li>
</ol>
<p>可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。</p>
<h2><span id="3-sighup信号">3 SIGHUP信号</span></h2><p>变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？</p>
<p>Linux系统是这样设计的。</p>
<ol>
<li>用户准备退出 session</li>
<li>系统向该 session 发出<code>SIGHUP</code>信号</li>
<li>session 将<code>SIGHUP</code>信号发给所有子进程</li>
<li>子进程收到<code>SIGHUP</code>信号后，自动退出</li>
</ol>
<p>上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了<code>SIGHUP</code>信号。</p>
<p>那么，”后台任务”是否也会收到<code>SIGHUP</code>信号？</p>
<p>这由 Shell 的<code>huponexit</code>参数决定的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> | grep huponexit</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，就会看到<code>huponexit</code>参数的值。</p>
<p>大多数Linux系统，这个参数默认关闭（<code>off</code>）。因此，session 退出的时候，不会把<code>SIGHUP</code>信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出。</p>
<h2><span id="4-disown-命令">4 disown 命令</span></h2><p>通过”后台任务”启动”守护进程”并不保险，因为有的系统的<code>huponexit</code>参数可能是打开的（<code>on</code>）。</p>
<p>更保险的方法是使用<code>disown</code>命令。它可以将指定任务从”后台任务”列表（<code>jobs</code>命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session 就肯定不会向它发出<code>SIGHUP</code>信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node server.js &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure>

<p>执行上面的命令以后，<code>server.js</code>进程就被移出了”后台任务”列表。你可以执行<code>jobs</code>命令验证，输出结果里面，不会有这个进程。</p>
<p><code>disown</code>的用法如下。</p>
<p>​    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移出最近一个正在执行的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出所有正在执行的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出所有后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不移出后台任务，但是让它们不会收到SIGHUP信号</span></span><br><span class="line">$ <span class="built_in">disown</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据jobId，移出指定的后台任务</span></span><br><span class="line">$ <span class="built_in">disown</span> %2</span><br><span class="line">$ <span class="built_in">disown</span> -h %2</span><br></pre></td></tr></table></figure>

<h2><span id="5-标准-io">5 标准 I/O</span></h2><p>使用<code>disown</code>命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准I/O有交互，它还是会挂掉。</p>
<p>还是以上面的脚本为例，现在加入一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server starts...&#x27;</span>); <span class="comment">// 加入此行</span></span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>启动上面的脚本，然后再执行<code>disown</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node server.js &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure>

<p>接着，你退出 session，访问5000端口，就会发现连不上。</p>
<p>这是因为”后台任务”的标准 I/O 继承自当前 session，<code>disown</code>命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。</p>
<p>为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node server.js &gt; stdout.txt 2&gt; stderr.txt &lt; /dev/null &amp;</span><br><span class="line">$ <span class="built_in">disown</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面这样执行，基本上就没有问题了。</p>
<h2><span id="6-nohup-命令">6 nohup 命令</span></h2><p>还有比<code>disown</code>更方便的命令，就是<code>nohup</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> node server.js &amp;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>nohup</code>命令对<code>server.js</code>进程做了三件事。</p>
<blockquote>
<ul>
<li>阻止<code>SIGHUP</code>信号发到这个进程。</li>
<li>关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。</li>
<li>重定向标准输出和标准错误到文件<code>nohup.out</code>。</li>
</ul>
</blockquote>
<p>也就是说，<code>nohup</code>命令实际上将子进程与它所在的 session 分离了。</p>
<p>注意，<code>nohup</code>命令不会自动把进程变为”后台任务”，所以必须加上<code>&amp;</code>符号。</p>
<h2><span id="7-screen-命令与-tmux-命令">7 Screen 命令与 Tmux 命令</span></h2><p>另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 <a href="https://www.gnu.org/software/screen/">Screen</a> 命令和 <a href="https://tmux.github.io/">Tmux</a> 命令。</p>
<p>它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。</p>
<p>Screen 的用法如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个 session</span></span><br><span class="line">$ screen</span><br><span class="line">$ node server.js</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，按下<code>ctrl + A</code>和<code>ctrl + D</code>，回到原来的 session，从那里退出登录。下次登录时，再切回去。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ screen -r</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果新建多个后台 session，就需要为它们指定名字。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ screen -S name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切回指定 session</span></span><br><span class="line">$ screen -r name</span><br><span class="line">$ screen -r pid_number</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 session</span></span><br><span class="line">$ screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果要停掉某个 session，可以先切回它，然后按下<code>ctrl + c</code>和<code>ctrl + d</code>。</p>
<p>Tmux 比 Screen 功能更多、更强大，它的基本用法如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux</span><br><span class="line">$ node server.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回原来的session</span></span><br><span class="line">$ tmux detach</span><br></pre></td></tr></table></figure>
</blockquote>
<p>除了<code>tmux detach</code>，另一种方法是按下<code>Ctrl + B</code>和<code>d</code> ，也可以回到原来的 session。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下次登录时，返回后台正在运行服务session</span></span><br><span class="line">$ tmux attach</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果新建多个 session，就需要为每个 session 指定名字。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建 session</span></span><br><span class="line">$ tmux new -s session_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定 session</span></span><br><span class="line">$ tmux attach -t session_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 session</span></span><br><span class="line">$ tmux list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出当前 session，返回前一个 session </span></span><br><span class="line">$ tmux detach</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死指定 session</span></span><br><span class="line">$ tmux kill-session -t session-name</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="8-node-工具">8 Node 工具</span></h2><p>对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：<a href="https://github.com/foreverjs/forever">forever</a>，<a href="http://nodemon.io/">nodemon</a> 和 <a href="http://pm2.keymetrics.io/">pm2</a>。</p>
<p>forever 的功能很简单，就是保证进程退出时，应用会自动重启。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作为前台任务启动</span></span><br><span class="line">$ forever server.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为服务进程启动 </span></span><br><span class="line">$ forever start app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务进程</span></span><br><span class="line">$ forever stop Id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务进程</span></span><br><span class="line">$ forever restart Id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视当前目录的文件变动，一有变动就重启</span></span><br><span class="line">$ forever -w server.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># -m 参数指定最多重启次数</span></span><br><span class="line">$ forever -m 5 server.js </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有进程</span></span><br><span class="line">$ forever list</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>nodemon</code>一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认监视当前目录的文件变化</span></span><br><span class="line">$ nodemon server.js</span><br><span class="line"></span><br><span class="line">＃ 监视指定文件的变化   </span><br><span class="line">$ nodemon --watch app --watch libs server.js  </span><br></pre></td></tr></table></figure>
</blockquote>
<p>pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">$ pm2 start app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定同时起多少个进程（由CPU核心数决定），组成一个集群</span></span><br><span class="line">$ pm2 start app.js -i max</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有任务</span></span><br><span class="line">$ pm2 list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定任务</span></span><br><span class="line">$ pm2 stop 0</span><br><span class="line"></span><br><span class="line">＃ 重启指定任务</span><br><span class="line">$ pm2 restart 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定任务</span></span><br><span class="line">$ pm2 delete 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前的所有任务，以后可以恢复</span></span><br><span class="line">$ pm2 save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出每个进程的统计数据</span></span><br><span class="line">$ pm2 monit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有日志</span></span><br><span class="line">$ pm2 logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出数据</span></span><br><span class="line">$ pm2 dump</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有进程</span></span><br><span class="line">$ pm2 <span class="built_in">kill</span></span><br><span class="line">$ pm2 resurect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动web界面 http://localhost:9615</span></span><br><span class="line">$ pm2 web</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="9-systemd">9 Systemd</span></h2><p>除了专用工具以外，Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins中的环境变量</title>
    <url>/a5c52f2c/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#准备">准备</a></li>
<li><a href="#认识-jenkins-环境变量">认识 Jenkins 环境变量</a><ul>
<li><a href="#查看-jenkins-系统内置环境变量">查看 Jenkins 系统内置环境变量</a><ul>
<li><a href="#方式一">方式一：</a></li>
<li><a href="#方式二">方式二</a></li>
</ul>
</li>
<li><a href="#读取环境变量">读取环境变量</a></li>
</ul>
</li>
<li><a href="#自定义-jenkins-环境变量">自定义 Jenkins 环境变量</a></li>
<li><a href="#重写-jenkins-环境变量">重写 Jenkins 环境变量</a></li>
<li><a href="#jenkins-中使用-boolean-值">Jenkins 中使用 Boolean 值</a></li>
<li><a href="#shell-结果赋值给环境变量">Shell 结果赋值给环境变量</a></li>
</ul>
<!-- tocstop -->

<h2><span id="前言">前言</span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122156161.png" alt></p>
<h2><span id="准备">准备</span></h2><p>如果你想一边阅读本文，一边实践，但是没有 Jenkins 服务可用，又想快速尝试，可以应用 Docker 一个命令快速搭建 Jenkins 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container run --rm -p 8080:8080 -p 50000:50000 --name=jenkins -v $(pwd):/var/jenkins_home jenkins/jenkins</span><br></pre></td></tr></table></figure>



<blockquote>
<p>2021 年了，本地没有 Docker 说不过去了，过来瞧瞧 Docker 系列是否入得了你的法眼？</p>
</blockquote>
<p>打开浏览器输入：<code>localhost:8080</code></p>
<ol>
<li>找到终端的临时密码登陆</li>
<li>安装推荐的依赖</li>
<li>创建新的 Pipeline 类型的 Item</li>
<li>点击左侧 Config，然后在页面底部 Pipeline 部分输入我们接下来写的脚本进行测试就好了</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122157396.png" alt></p>
<p>就是这么简单…..</p>
<h2><span id="认识-jenkins-环境变量">认识 Jenkins 环境变量</span></h2><blockquote>
<p>Jenkins 环境变量就是通过 <code>env</code> 关键字暴露出来的<strong>全局变量</strong>，可以在 Jenkins 文件的<strong>任何位置使用</strong></p>
</blockquote>
<p>其实和你使用的编程语言中的全局变量没有实质差别</p>
<h3><span id="查看-jenkins-系统内置环境变量">查看 Jenkins 系统内置环境变量</span></h3><p>Jenkins 在系统内置了很多环境变量方便我们快速使用，查看起来有两种方式：</p>
<h4><span id="方式一">方式一：</span></h4><p>直接在浏览器中访问 <code>$&#123;YOUR_JENKINS_HOST&#125;/env-vars.html</code> 页面就可以，比如 <code>http://localhost:8080/env-vars.html</code> ，每个变量的用途写的都很清楚</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122157715.png" alt></p>
<h4><span id="方式二">方式二</span></h4><p>通过执行 <code>printenv</code> shell 命令来获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Env Variables&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &quot;printenv&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接 Save - Build, 在终端 log 中你会看到相应的环境变量，并且可以快速看到他们当前的值</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122157942.png" alt></p>
<p>通常这两种方式可以结合使用</p>
<h3><span id="读取环境变量">读取环境变量</span></h3><p>上面我们说了 <code>env</code> 是环境变量的关键字，但是读取 Jenkins 内置的这些环境变量，<code>env</code> 关键字是可有可无, 但不能没了底裤，都要使用 <code>$&#123;xxx&#125;</code> 包围起来。以 <code>BUILD_NUMBER</code> 这个内置环境变量举例来说明就是这样滴：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122157008.png" alt></p>
<p>如果你在 Jenkins 文件中使用 shell 命令，使用这些内置环境变量甚至可以不用 <code>&#123;&#125;</code>， 来看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Read Env Variables&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;带 env 的读取方式：$&#123;env.BUILD_NUMBER&#125;&quot;</span><br><span class="line">                echo &quot;不带 env 的读取方式：$&#123;BUILD_NUMBER&#125;&quot;</span><br><span class="line">                sh &#x27;echo &quot;shell 中读取方式 $BUILD_NUMBER&quot;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果是一样一样滴，<strong>不管有几种，记住第一种最稳妥</strong></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122157970.png" alt></p>
<p>内置的环境变量虽好，但也不能完全满足我们自定义的 pipeline 的执行逻辑，所以我们也得知道如何定义以及使用自定义环境变量</p>
<h2><span id="自定义-jenkins-环境变量">自定义 Jenkins 环境变量</span></h2><p>Jenkins pipeline 分声明式（Declarative）和 脚本式（imperative）写法，相应的环境变量定义方式也略有不同，归纳起来有三种方式：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122158337.png" alt></p>
<p>还是看个实际例子吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        FOO = &quot;bar&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Custom Env Variables&quot;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                NAME = &quot;RGYB&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;FOO = $&#123;env.FOO&#125;&quot;</span><br><span class="line">                echo &quot;NAME = $&#123;env.NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">                script &#123;</span><br><span class="line">                    env.SCRIPT_VARIABLE = &quot;Thumb Up&quot;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                echo &quot;SCRIPT_VARIABLE = $&#123;env.SCRIPT_VARIABLE&#125;&quot;</span><br><span class="line"></span><br><span class="line">                withEnv([&quot;WITH_ENV_VAR=Come On&quot;]) &#123;</span><br><span class="line">                    echo &quot;WITH_ENV_VAR = $&#123;env.WITH_ENV_VAR&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看运行结果：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122158815.png" alt></p>
<blockquote>
<p>注意：<code>withEnv([&quot;WITH_ENV_VAR=Come On&quot;]) &#123;&#125;</code> <strong>这里的 = 号两侧不能有空格</strong>，必须是 <code>key=value</code> 的形式</p>
</blockquote>
<p>一个完整的 pipeline 通常会有很多个 stage，环境变量在不同的 stage 有不同的值是很常见的，知道如何设置以及读取环境变量后，我们还得知道如何重写环境变量</p>
<h2><span id="重写-jenkins-环境变量">重写 Jenkins 环境变量</span></h2><p>Jenkins 让人相对困惑最多的地方就是重写环境变量，但是只要记住下面这三条规则，就可以搞定一切了</p>
<ol>
<li><code>withEnv([&quot;WITH_ENV_VAR=Come On&quot;]) &#123;&#125;</code> 内置函数的这种写法，可以重写任意环境变量</li>
<li>定义在 <code>environment &#123;&#125;</code> 的环境变量不能被脚本式定义的环境变量（<code>env.key=&quot;value&quot;</code>）重写</li>
<li>脚本式环境变量只能重写脚本式环境变量</li>
</ol>
<p>这三点是硬规则，没涵盖在这 3 点规则之内的也就是被允许的了</p>
<p>三条规则就有点让人头大了，农夫选豆种，举例为证吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        FOO = &quot;你当像鸟飞往你的山&quot;</span><br><span class="line">        NAME = &quot;Tan&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Env Variables&quot;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                  // 会重写第 6 行 变量</span><br><span class="line">                NAME = &quot;RGYB&quot; </span><br><span class="line">                  // 会重写系统内置的环境变量 BUILD_NUMBER</span><br><span class="line">                BUILD_NUMBER = &quot;10&quot; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            steps &#123;</span><br><span class="line">                  // 应该打印出 &quot;FOO = 你当像鸟飞往你的山&quot;</span><br><span class="line">                echo &quot;FOO = $&#123;env.FOO&#125;&quot; </span><br><span class="line">                  // 应该打印出 &quot;NAME = RGYB&quot;</span><br><span class="line">                echo &quot;NAME = $&#123;env.NAME&#125;&quot; </span><br><span class="line">                  // 应该打印出 &quot;BUILD_NUMBER = 10&quot;</span><br><span class="line">                echo &quot;BUILD_NUMBER =  $&#123;env.BUILD_NUMBER&#125;&quot; </span><br><span class="line"></span><br><span class="line">                script &#123;</span><br><span class="line">                      // 脚本式创建一个环境变量</span><br><span class="line">                    env.SCRIPT_VARIABLE = &quot;1&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&quot;Override Variables&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                      // 这里的 FOO 不会被重写，违背 Rule No.2</span><br><span class="line">                    env.FOO = &quot;Tara&quot;</span><br><span class="line">                      // SCRIPT_VARIABLE 变量会被重写，符合 Rule No.3</span><br><span class="line">                    env.SCRIPT_VARIABLE = &quot;2&quot; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                  // FOO 在第 37 行重写失败，还会打印出 &quot;FOO = 你当像鸟飞往你的山&quot;</span><br><span class="line">                echo &quot;FOO = $&#123;env.FOO&#125;&quot; </span><br><span class="line">                  // 会打印出 &quot;SCRIPT_VARIABLE = 2&quot;</span><br><span class="line">                echo &quot;SCRIPT_VARIABLE = $&#123;env.SCRIPT_VARIABLE&#125;&quot; </span><br><span class="line"></span><br><span class="line">                  // FOO 会被重写，符合 Rule No.1</span><br><span class="line">                withEnv([&quot;FOO=Educated&quot;]) &#123; </span><br><span class="line">                      // 应该打印 &quot;FOO = Educated&quot;</span><br><span class="line">                    echo &quot;FOO = $&#123;env.FOO&#125;&quot; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                  // 道理同上</span><br><span class="line">                withEnv([&quot;BUILD_NUMBER=15&quot;]) &#123;</span><br><span class="line">                      // 应该打印出 &quot;BUILD_NUMBER = 15&quot;</span><br><span class="line">                    echo &quot;BUILD_NUMBER = $&#123;env.BUILD_NUMBER&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来验证一下结果吧</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122158213.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122158747.png" alt></p>
<p>看到这，基本的设置应该就没有什么问题了，相信你也发现了，Jenkins 设置环境变量和编程语言的那种设置环境变量还是略有不同的，后者可以将变量赋值为对象，但 Jenkins 就不行，因为<strong>在 Jenkins 文件中，所有设置的值都会被当成 String</strong>， 难道没办法应用 Boolean 值吗？</p>
<h2><span id="jenkins-中使用-boolean-值">Jenkins 中使用 Boolean 值</span></h2><p>如果设置一个变量为 <code>false</code> ，Jenkins 就会将其转换为 <code>&quot;false&quot;</code>, 如果想使用 Boolean 来做条件判断，必须要调用 <code>toBoolean()</code> 方法做转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        IS_BOOLEAN = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Env Variables&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                      </span><br><span class="line">                    if (env.IS_BOOLEAN) &#123;</span><br><span class="line">                        echo &quot;Hello&quot;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                      </span><br><span class="line">                    if (env.IS_BOOLEAN.toBoolean() == false) &#123;</span><br><span class="line">                        echo &quot;日拱一兵&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  </span><br><span class="line">                      </span><br><span class="line">                    if (!env.IS_BOOLEAN.toBoolean()) &#123;</span><br><span class="line">                        echo &quot;RGYB&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看运行结果：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122159629.png" alt></p>
<p>如果你写过 Pipeline，你一定会知道，写 Pipeline 是离不开写 shell 的，有些时候，需要将 shell 的执行结果赋值给环境变量，Jenkins 也有方法支持</p>
<h2><span id="shell-结果赋值给环境变量">Shell 结果赋值给环境变量</span></h2><p>实现这种方式很简单，只需要记住一个格式：<code>sh(script: &#39;cmd&#39;, returnStdout:true)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">          </span><br><span class="line">        LS_RESULT = &quot;$&#123;sh(script:&#x27;ls -lah&#x27;, returnStdout: true).trim()&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Env Variables&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;LS_RESULT = $&#123;env.LS_RESULT&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202311122159489.png" alt></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中sh与bash的区别</title>
    <url>/9cfe95d9/</url>
    <content><![CDATA[<h2><span id="什么是shell">什么是Shell</span></h2><p>​    在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的<a href="https://baike.baidu.com/item/软件/12053?fromModule=lemma_inlink">软件</a>（command interpreter，命令解析器）。它类似于<a href="https://baike.baidu.com/item/DOS/32025?fromModule=lemma_inlink">DOS</a>下的<a href="https://baike.baidu.com/item/COMMAND.COM/8063418?fromModule=lemma_inlink">COMMAND.COM</a>和后来的<a href="https://baike.baidu.com/item/cmd.exe/8192925?fromModule=lemma_inlink">cmd.exe</a>。它接收用户命令，然后调用相应的<a href="https://baike.baidu.com/item/应用程序/5985445?fromModule=lemma_inlink">应用程序</a>。</p>
<p>​    同时它又是一种<a href="https://baike.baidu.com/item/程序设计语言?fromModule=lemma_inlink">程序设计语言</a>。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种<a href="https://baike.baidu.com/item/变量/3956968?fromModule=lemma_inlink">变量</a>和<a href="https://baike.baidu.com/item/参数/5934974?fromModule=lemma_inlink">参数</a>，并提供了许多在<a href="https://baike.baidu.com/item/高级语言?fromModule=lemma_inlink">高级语言</a>中才具有的控制结构，包括循环和分支。</p>
<h2><span id="sh介绍">sh介绍</span></h2><p>​    sh（Bourne Shell）是一个早期的重要shell，1978年由史蒂夫·伯恩编写，并同Version 7 Unix一起发布。</p>
<p>​    在一般的linux系统当中（如redhat，centos），使用sh调用执行脚本相当于打开了bash的POSIX标准模式（等效于bash的 –posix 参数）一般的，sh是bash的“子集”</p>
<h2><span id="bash介绍">bash介绍</span></h2><p>​    bash（Bourne-Again Shell）是一个为GNU计划编写的Unix shell。1987年由布莱恩·福克斯创造。主要目标是与POSIX标准保持一致，同时兼顾对sh的兼容，是各种Linux发行版标准配置的Shell，在Linux系统上/bin/sh往往是指向/bin/bash的符号链接。</p>
<h2><span id="sh与bash的区别">sh与bash的区别：</span></h2><p>​    sh 遵循POSIX规范：“当某行代码出错时，不继续往下解释”。bash 就算出错，也会继续向下执行。</p>
<p><strong>sh测试脚本</strong></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">source</span> 233</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>bash测试脚本</strong><br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> 233</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;error&quot;</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>查看结果：</strong></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="keyword">function</span>]# sh test2.sh</span><br><span class="line">test2.sh: 第 2 行:<span class="built_in">source</span>: 233: 没有找到文件</span><br><span class="line">[root@localhost <span class="keyword">function</span>]# bash test2.sh</span><br><span class="line">test2.sh:行2: 233: 没有那个文件或目录</span><br><span class="line">error</span><br></pre></td></tr></table></figure>

<p> <strong>小结：</strong></p>
<p>sh 跟bash的区别是bash是否开启POSIX模式。<br>sh是bash的一种特殊的模式，sh就是开启了POSIX标准的bash， <code>/bin/sh</code> 相当于 <code>/bin/bash --posix</code>。<br>在Linux系统上/bin/sh往往是指向<code>/bin/bash</code>的符号链接</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Lucene 查询语法</title>
    <url>/f8737bfa/</url>
    <content><![CDATA[<p>原文：<a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description">Query Parser Syntax</a></p>
<h2><span id="概览">概览</span></h2><p>Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（词法分析器，使用 JavaCC 将字符串翻译成 Lucene 查询语句）提供一种功能丰富的查询语言。</p>
<p>一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。本文档描述的是当前版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 <code>docs/queryparsersyntax.html</code> 文档。</p>
<p>在选择使用这个查询解析器之前，请考虑以下 3 点：</p>
<ol>
<li>如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。</li>
<li>没有被识别为token的域最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句。查询解析器所使用的分析器是专门用于将人类输入的文本转换成词（terms）的。由程序生成的值，如日期、关键字等等，也应该由程序添加到查询中。</li>
<li>从查询形式来看，如果域的值是普通文本，则应该使用查询解析器。所有其它值类型，比如：日期范围、关键字等等，最好通过查询 API 直接添加。如果一个域的值仅限于一个有限的集合（可以通过一个下拉菜单指定），则不应该添加到查询字符串（后续会被解析）中，而是应该作为一个 TermQuery 子句添加到查询中。</li>
</ol>
<h2><span id="词terms">词（Terms）</span></h2><p>一个查询语句可以拆解成 词（terms） 和 操作符（operators）。词又分为两种：单个词（single Terms）和短语（Phrases）。</p>
<p>单个词是指 ”test“ 或 ”Hello“ 这类单词。</p>
<p>短语是指以双引号包围起来的一组单词，比如：”hello dolly“。</p>
<p>多个词（Multiple terms）可以使用布尔操作符组合在一起，实现一个更加复杂的查询（如下文所示）。</p>
<p>备注：用于创建索引的解析器也会用于解析查询字符串中的词和短语。因此，选择合适的解析器很重要，否则解析器可能会被查询字符串中的词干扰。</p>
<h2><span id="域fields">域（Fields）</span></h2><p>Lucene 支持分多个字段/域的数据。搜索时，可以指定一个域，也可以使用默认域。域的名称以及默认域与具体实现相关。</p>
<p>输入域的名称，后跟一个冒号（:），再跟目标搜索词，即可对任意一个域进行搜索。</p>
<p>举例来说，假设一个 Lucene 索引包含 2 个域：title 和 text，text 是默认域。若想查找标题为 ”The Right Way“ 且文本内容包含 ”don’t go this way“ 的文档，可以输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title:&quot;The Right Way&quot; AND text:go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title:&quot;The Right Way&quot; AND go</span><br></pre></td></tr></table></figure>

<p>因为 text 是默认域，所以域标识符可以省略。</p>
<p>注意：指定的域仅对紧跟其后的词生效，因此，如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title:The Right Way</span><br></pre></td></tr></table></figure>



<p>将对 title 域仅查找 ”The“，并对默认域（当前这个例子中是指 text 域）查找 ”Right“ 和 ”Way“。</p>
<h2><span id="词修饰语term-modifiers">词修饰语（Term Modifiers）</span></h2><p>Lucene 支持修饰查询词（modifying query terms）来提供多种搜索方式。</p>
<h3><span id="通配符搜索"><em>通配符搜索</em></span></h3><p>Lucene 支持对单个词(single terms)（不是短语查询 phrase queries）进行单个字符和多个字符的通配搜索。</p>
<p>使用 <code>?</code> 符号进行单个字符的通配搜索。</p>
<p>使用 <code>*</code> 符号进行多个字符的通配搜索。</p>
<p>单字符通配搜索用于查找替换单个字符即可匹配的词。举例来说，若要搜索 ”text“ 或 ”test“，可以如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">te?t</span><br></pre></td></tr></table></figure>



<p>多字符通配搜索用于查找替换0个或多个字符即可匹配的词。举例来说，若要搜索 ”test“、”tests“ 或 ”tester“，可以如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test*</span><br></pre></td></tr></table></figure>



<p>也可以对词的中间部分进行通配搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">te*t</span><br></pre></td></tr></table></figure>



<p><strong>备注： <code>*</code> 或 <code>?</code> 符号不能用作搜索语句的第一个字符。</strong></p>
<h3><span id="正则表达式搜索"><em>正则表达式搜索</em></span></h3><p>Lucene 支持正则表达式搜索，匹配斜杠（<code>/</code>） 之间的模式。正则表达式的语法在不同的发布版本之间可能会有差异，目前支持的语法在 <a href="http://lucene.apache.org/core/8_2_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true">RegExp</a> 类文档中有说明。举例来说，查找包含 ”moat“ 或 ”boat“ 的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/[mb]oat/</span><br></pre></td></tr></table></figure>



<h3><span id="模糊搜索"><em>模糊搜索</em></span></h3><p>Lucene 支持基于 Damerau-Levenshtein 编辑距离的模糊搜索。在单个词的最后添加波浪符（~）即可进行模糊搜索。举例来说，使用模糊搜索查找在拼写上与 ”roam“ 近似的词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roam~</span><br></pre></td></tr></table></figure>



<p>这个查询语句会找到 foam 和 roams 这类词。</p>
<p>模糊搜索可以通过一个额外（可选）的参数来指定允许的最大编辑次数。这个参数值界于 0 和 2 之间，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roam~1</span><br></pre></td></tr></table></figure>



<p>如果未指定该参数，则默认使用 2 个编辑距离。</p>
<p><strong>以前，这里还允许使用浮点数。现在这个语法已被考虑弃用，将于 Lucene 5.0 中移除。</strong></p>
<h3><span id="邻近搜索"><em>邻近搜索</em></span></h3><p>Lucene 支持查找指定距离的邻近词。在短语的最后添加拨浪符（~）即可进行邻近搜索。举例来说，在文档中搜索 ”apache“ 和 ”jakarta“ 相距 10 个词的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot;~10</span><br></pre></td></tr></table></figure>



<h3><span id="范围搜索"><em>范围搜索</em></span></h3><p>范围查询可以匹配到域的值在范围查询语句指定的上下界之间的所有文档。对于上下界的值，范围查询可以包含也可以不包含。排序是按照字典序进行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mod_date:[20020101 TO 20030101]</span><br></pre></td></tr></table></figure>

<p>这个查询语句会查找 mod_date 域的值在 20020101 和 20030101 （包含上下界） 之间的文档。注意：范围查询对非日期的域也可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title:&#123;Aida TO Carmen&#125;</span><br></pre></td></tr></table></figure>



<p>这个查询语句能查找到 title 域的值在 Aida 和 Carmen （不包含上下界）之间的所有文档。</p>
<p>中括号表示范围查询包含上下界，花括号表示范围查询不包含上下界。</p>
<h3><span id="相关性查询boosting-a-term"><em>相关性查询（Boosting a term）</em></span></h3><p>Lucene 会基于文档中找到的词对匹配到的文档设置相关性的级别。可以在目标搜索词之后紧接一个脱字符 “^”，后跟一个加权系数（一个数字）来提升该搜索词的相关性权重。加权系数越高，查询命中的文档与该词的相关性越强。</p>
<p>你可以通过对某词进行加权来控制文档的相关性。例如，假设你正在搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jakarta apache</span><br></pre></td></tr></table></figure>



<p>然后希望搜索结果和词 ”jakarta“ 的相关性更强一些，则可以使用 ”^“ 符号后跟一个加权系数对这个词进行加权，即如下这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jakarta^4 apache</span><br></pre></td></tr></table></figure>



<p>这会使得查找到的文档和词 ”jakarta“ 看起来相关性更强一些。你也可以对短语进行加权，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot;^4 &quot;Apache Lucene&quot;</span><br></pre></td></tr></table></figure>

<p>默认加权系数是 1。加权系统可以小于 1（比如：0.2），但必须大于 0。</p>
<h2><span id="布尔操作符">布尔操作符</span></h2><p>布尔操作符允许使用逻辑操作符组合多个词。Lucene 支持的布尔操作符包含 <code>AND</code>、<code>+</code>、<code>OR</code>、<code>NOT</code> 及 <code>-</code></p>
<p><strong>（备注：布尔操作符必须全部是大写字母）。</strong></p>
<h3><span id="or"><em>OR</em></span></h3><p>“OR” 操作符是默认的连接操作符。这意味着如果两个词之间没有布尔操作符，则lucene会使用 “OR” 操作符。OR 操作符链接两个词，并匹配包含其中任意一个词的文档。这相当于集合的并集操作。“||” 符合可用于替代单词 “OR”。</p>
<p>比如，使用如下查询语句来搜索包含 “jakarta apache” 或仅是 “jakarta” 的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot; jakarta</span><br></pre></td></tr></table></figure>



<p>或：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot; OR jakarta</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="and">AND</span></h3><p>“AND” 操作符会匹配文本内容中同时存在两个要查询的词（因为 AND 是二元操作符）的文档。这相当于集合的交集操作。“&amp;&amp;” 符号可用于替代单词 “AND”。</p>
<p>比如，使用如下查询语句来搜索包含 “jakarta apache” 和 “Apache Lucene” 的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot; AND “Apache Lucene”</span><br></pre></td></tr></table></figure>

<h3><span id>+</span></h3><p>“+”（必需）操作符要求文档的某个域中包含 “+” 符号之后的词。</p>
<p>比如，使用如下查询语句来搜索（必须）包含 “jakarta” 以及可能包含 “lucene”（包不包含都可以）的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+jakarta lucene</span><br></pre></td></tr></table></figure>



<h3><span id="not">NOT</span></h3><p>”NOT“ 操作符会排除包含”NOT“之后的词的文档。这相当于集合的差集操作。也可以用”!“ 符号代替 ”NOT“。</p>
<p>比如，使用如下查询语句搜索包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot; NOT &quot;Apache Lucene&quot;</span><br></pre></td></tr></table></figure>

<p><strong>备注：“NOT” 操作符不可以用于单个词。例如，如下搜索不会返回任何结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOT &quot;jakarta apache&quot;</span><br></pre></td></tr></table></figure>



<h3><span id="-">-</span></h3><p>”-“（禁止）操作符会排除包含”-“符号之后的词的文档。</p>
<p>比如，使用如下查询语句来查询包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jakarta apache&quot; -&quot;Apache Lucene&quot;</span><br></pre></td></tr></table></figure>

<h2><span id="分组">分组</span></h2><p>Lucene 支持使用圆括号对子句进行分组，构成子查询。这对于控制一个查询语句的布尔逻辑非常有用。</p>
<p>比如，使用如下查询语句来搜索包含 “jakarta” 或 “apache”，同时包含 “website” 的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(jakarta OR apache) AND website</span><br></pre></td></tr></table></figure>

<p>这样查询语句就没有了歧义：必须包含 ”website“，同时包含“jakarta” 或 ”apache“其中之一。</p>
<h2><span id="域分组">域分组</span></h2><p>Lucene 支持使用圆括号对单个域的多个子句进行分组。</p>
<p>例如，若想搜索一个 title 中包含单词“return”同时包含短语“pink panther”，可以使用如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title:(+return +&quot;pink panther&quot;)</span><br></pre></td></tr></table></figure>

<h2><span id="特殊字符转义">特殊字符转义</span></h2><p>Lucene 支持对查询语法使用的特殊字符进行转义。目前这些特殊字符如下列表所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ - &amp;&amp; || ! ( ) &#123; &#125; [ ] ^ &quot; ~ * ? : \ /</span><br></pre></td></tr></table></figure>

<p>在特殊字符之前加 <code>\</code> 来转义。例如，使用如下查询语句来搜索 <code>(1+1):2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\(1\+1\)\:2</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS守护进程优化建议</title>
    <url>/62d417da/</url>
    <content><![CDATA[<p><strong>/sbin/launchd</strong><br>系统及用户进程管理器，它是内核装载成功后在OS环境下启动的第一个进程，是Mac OS最重要的进程之一。你无法禁用它。</p>
<p><strong>/usr/libexec/kextd</strong><br>内核扩展服务，响应内核或用户进程的请求，比如装载或卸载内核扩展或提供内核扩展信息给它们。这是Mac的关键守护进程，请不要去禁用它。</p>
<p><strong>/usr/sbin/notifyd</strong><br>消息服务，这是Mac OS消息系统的组成部分之一。我们知道，操作系统的很多组件需要依赖异步消息来通信，这个服务能保证它们正常工作。请不要去禁用它。</p>
<p><strong>/usr/sbin/diskarbitrationd</strong><br>磁盘仲裁服务，作用是为磁盘卷或其他存储部件进行挂载，取消挂载或弹出（比如光驱和dmg）。最常见的就是USB移动硬盘，MP3，IPHONE，IPAD等。<br>它的原理是当内核发现有新硬件插入时，内核先识别该硬件，如果能识别，则为硬件装载驱动，并通知 diskarbitrationd 挂载它。取消挂载同理。<br>如果这个服务被禁用，所有即插即用存储设备都会出现异常。建议不要禁用它。</p>
<p><strong>/usr/libexec/configd</strong><br>保存计算机和系统环境的动态配置信息。为需要用到这些信息的进程提供变更通知。比如网络服务（tcp/ip或wins更新等）。<br>如果这个服务被禁用，网络和一些需要动态配置信息的组件将会出现异常。建议不要禁用它。</p>
<p><strong>/usr/sbin/syslogd</strong><br>系统日志服务，用于记录系统或软件的消息日志，是系统或软件崩溃时查错的关键途径。某些工具也可能依赖与日志在提供服务。<br>如果这个服务被禁用，所有的消息日志都将停止记录，并可能导致某些软件工作异常。建议不要禁用它。</p>
<p><strong>/usr/sbin/DirectoryService</strong><br>目录信息收集中心，它会收集各种目录的用户，用户组，权限和路径信息，并在应用程序需要时，反馈给它们。目录的介质主要是指本地磁 盘，LDAP，Netinfo, Active Directory, NIS, Bonjour/Rendesvous/, AppleTalk, Samba FS(SMB)等。<br>如果这个服务被禁用，可能会导致部分程序性能降低或出现异常。建议不要禁用它。</p>
<p><strong>/usr/sbin/distnoted</strong><br>提供分布式的消息服务，类似notifyd，但它主要是处理系统外部的一些消息，比如 itune与iphone, ipad, itouch的连接及消息传递功能。<br>如果你有使用Apple的即插即用设备，为了保证其功能正常使用，建议你不要禁用它。如果没有apple设备，保险期间，还是留着它吧。</p>
<p><strong>/usr/sbin/ntpd</strong><br>时间同步服务，负责与time.apple.com同步操作系统的时间。这个是基础功能，请不要禁用它。</p>
<p><strong>/System/Library/PrivateFrameworks/MobileDevice.framework/Versions/A/Resources/usbmuxd</strong><br>USB多路传输服务，为iphone和itouch提供原生的传输支持（无需越狱）。如果你没有iphone或ipod touch，<strong>可以禁用这个服务</strong>。</p>
<p><strong>/usr/sbin/securityd</strong><br>Mac OS安全验证模块，它保存了系统的安全信息，可以仲裁一些加密操作，为软件提供安全验证。系统安全是大事，请不要禁用它。</p>
<p><strong>/usr/sbin/mDNSResponder</strong><br>DNS多播响应器，与DNS服务相关，附属作用是为你搜索局域网里的共享设备。包括mac, windows, ichat, ipad等等，并且会显示在finder的右侧菜单中。<br>请不要禁用它，否则你的DNS将失效，并导致无法访问网络。</p>
<p><strong>/System/Library/CoreServices/loginwindow.app/Contents/MacOS/loginwindow</strong><br>Mac OS用户登陆进程，展示登陆或注销界面，验证用户密码输入，启动Finder, Dock, 和一切需要启动时启动的第三方应用程序都是这个进程的责任。<br>请不要禁用它。</p>
<p><strong>/usr/sbin/KernelEventAgent</strong><br>处理文件系统的状态。比如“您的磁盘看上去已经满了，您是否需要删除一些数据，以保证系统正常启动”或“一个服务器已经很久没有响应，您是否想需要重新连接它”等。请不要禁用它。</p>
<p><strong>/usr/libexec/hidd</strong><br>人体学输入设备（HID）支持进程。比如键盘，鼠标，机密狗，蓝牙等。请不要禁用它。</p>
<p><strong>/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/Support/fseventsd</strong><br>文件系统事件系统，它可以广播文件的创建，删除等事件给Mac OS下的所有应用程序，届时，应用程序可以做出一些应对措施。请不要禁用它。</p>
<p><strong>/sbin/dynamic_pager</strong><br>Mac OS下的虚拟内存。当你的物理内存不够用时，就会使用虚拟内存，有的时候，密钥等一些使用频率不高的信息也会直接从物理内存中移除并存入虚拟内存。在 Unix系统（Mac）下，不论你的物理内存有多大，都不要尝试禁用虚拟内存。因为Unix的内存管理策略是尽可能多地使用内存，再大的内存都回随着时间 慢慢被耗光。</p>
<p><strong>autofsd</strong><br>自动挂载各种网络文件系统。比如NFS, SMB, AFS等。配置文件在 /etc/auto_master和/etc/auto_home，使用方式详见：<br><a href="http://commandlinemac.blogspot.com/2009/09/introduction-to-autofs-in-mac-os-x.html">http://commandlinemac.blogspot.com/2009/09/introduction-to-autofs-in-mac-os-x.html</a><br>如果你不使用任何网络文件系统，<strong>可以禁用这个服务</strong>。</p>
<p><strong>/System/Library/CoreServices/coreservicesd</strong><br>核心服务守护进程，禁用它可能导致系统停止运转或崩溃。请不要禁用它。</p>
<p><strong>/usr/sbin/coreaudiod</strong><br>音频服务，提供声音相关的支持。请不要禁用它。</p>
<p><strong>System/Library/Frameworks/ApplicationServices.framework/Frameworks/CoreGraphics.framework/Resources/WindowServer</strong><br>Mac OS的GUI界面系统。负责所有应用程序的窗口显示。请不要禁用它。</p>
<p><strong>/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/cvmsServ</strong><br>OPGL服务进程，用到高级图形API的程序需要用到它。比如游戏，支持滑动或谈出特效的软件。请不要禁用它。</p>
<p><strong>/System/Library/CoreServices/Dock.app/Contents/MacOS/Dock</strong><br>Mac OS经典的任务栏。请不要禁用它。</p>
<p><strong>/System/Library/CoreServices/SystemUIServer.app/Contents/MacOS/SystemUIServer</strong><br>Mac OS的菜单栏。请不要禁用它。</p>
<p><strong>/System/Library/CoreServices/Finder.app/Contents/MacOS/Finder</strong><br>Mac OS的资源管理器。请不要禁用它。</p>
<p><strong>/usr/sbin/pboard</strong><br>剪贴板支持。除非你不想用复制，黏贴。请不要禁用它。</p>
<p><strong>/System/Library/Frameworks/ApplicationServices.framework/Frameworks/ATS.framework/Support/fontd</strong><br>字体服务进程。请不要禁用它。</p>
<p><strong>/usr/libexec/UserEventAgent</strong><br>高级别的系统事件处理器。请不要禁用它。</p>
<p><strong>/System/Library/CoreServices/Menu Extras/TextInput.menu/Contents/SharedSupport/TISwitcher.app/Contents/MacOS/TISwitcher</strong><br>输入法切换服务。除非你不想使用中文输入法，否则，请不要禁用它。</p>
<p><strong>/usr/libexec/taskgated</strong><br>task_for_pid是用来帮助某些想控制其他进程的执行的进程实现功能的服务。taskgated会被内核呼叫，用来确认”控制“这个行为是否可以发生。它本身也有权限验证的功能。请不要禁用该服务。</p>
<p><strong>AirPortBaseStationAgent</strong><br>这个是Apple的无线基站设备搜索服务。如果你没有apple的无线基站设备，<strong>可以禁用它</strong>。</p>
<p><strong>Spotlight</strong><br>如果你不喜欢用spotlight，<strong>可以禁用它</strong>。详见文末给出的“Mac OS启动服务优化高级篇（launchd tuning）”里的优化方法。</p>
<p><strong>/usr/sbin/blued</strong><br>蓝牙支持服务。如果你不想使用蓝牙，<strong>可以禁用它</strong>。</p>
<p><strong>cupsd</strong><br>打印机支持。如果你不想用打印机，<strong>可以禁用该服务</strong>。</p>
<p><strong>SharedServices.Agent</strong><br>Apple的MobileMe服务，如果你不使用，<strong>可以禁用该服务</strong>。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 14.4 引发Java 应用崩溃</title>
    <url>/a520e262/</url>
    <content><![CDATA[<p>根据Java官方发布的文章，由于macOS上运行的进程可能会访问受保护内存区域中的内存。在 macOS 14.4 更新之前，在某些情况下，macOS 内核会通过向进程发送信号 SIGBUS 或 SIGSEGV 来响应这些受保护的内存访问。然后该进程可以选择处理该信号并继续执行。而在最新 macOS 14.4 中，当线程在写入模式下运行时，如果尝试对受保护的内存区域进行内存访问，macOS 将发送信号SIGKILL。该进程无法处理该信号，并且该进程将无条件终止。</p>
<p>目前该问题主要受影响的Mac机型和Java版本包括：</p>
<ul>
<li>Mac机型：M1、M2、M3（Apple Silicon m* 芯片）</li>
<li>Java版本：Java 8 - Java 22 所有版本</li>
</ul>
<p>如果还在使用Intel芯片的话，这次不受影响。</p>
<p>官方文章 <a href="https://blogs.oracle.com/java/post/java-on-macos-14-4">Java users on macOS 14 running on Apple silicon systems should skip macOS 14.4 and update directly to macOS 14.4.1 (oracle.com)</a></p>
<p>在x上，Java开发领域的一些大v们，也发现了这个问题，并提醒大家不要升级。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202405091709429.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202405091712272.png" alt></p>
<p>其他资料</p>
<p><a href="https://lobste.rs/s/onr9sb/java_users_on_macos_14_running_on_apple">Java users on macOS 14 running on Apple silicon systems should consider delaying the macOS 14.4 update | Lobsters</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上移除EasyConnect常驻后台进程</title>
    <url>/446d3604/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#禁用">禁用</a></li>
<li><a href="#启用">启用</a></li>
<li><a href="#mac-下禁用开机自启软件">Mac 下禁用开机自启软件</a></li>
</ul>
<!-- tocstop -->

<p>EasyConnect 会在后台强行添加名为 EasyMonitor 的开机自启守护进程，执行以下命令关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> launchctl unload /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</span><br></pre></td></tr></table></figure>

<p>可实际上 EasyConnect 还启动了另一个“杀不掉”的后台进程 ECAgent，活动频率很低，似乎不会造成内存泄漏，略显不起眼。但这无法作为它肆意常驻的理由。</p>
<h2><span id="禁用">禁用</span></h2><p>首先找到 plist 文件，在 <code>/Library/LaunchAgents/com.sangfor.ECAgentProxy.plist</code>。它无法被 launchctl unload，不过没关系，你可以直接把它挪走或删除，并且今后都不再需要它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /Library/LaunchAgents/com.sangfor.ECAgentProxy.plist ~</span><br></pre></td></tr></table></figure>

<p>当然这时候它还是不能被 kill 掉，要想从 launchctl 中删除而不重启电脑，可以采用 launchctl remove。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl remove com.sangfor.ECAgentProxy</span><br></pre></td></tr></table></figure>

<h2><span id="启用">启用</span></h2><p>关闭后台进程之后，启动 EasyConnect 会弹出警告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Alert</span><br><span class="line"></span><br><span class="line">Initialization failed. Please try reinstalling!</span><br></pre></td></tr></table></figure>

<p>所以 需要使用时，必须重新加载 EasyMonitor。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># EasyConnect v7.6.7 开始 EasyMonitor 必须在 root 权限下运行，此前版本可以不加 sudo</span></span><br><span class="line"><span class="built_in">sudo</span> launchctl load /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</span><br></pre></td></tr></table></figure>

<p>而 ECAgent 就没这么麻烦了，它根本不必后台常驻 —— EasyConnect 启动时会自己创建一个，并且会随着 EasyConnect 进程一起退出。最终我删掉了 <code>com.sangfor.ECAgentProxy.plist</code> 文件的备份。</p>
<h2><span id="mac-下禁用开机自启软件">Mac 下禁用开机自启软件</span></h2><p>有部分软件的开机启动项放在 <code>/Library/LaunchDaemons</code></p>
<p>使用 <code>sudo launchctl unload xxx.plist</code> 可以去掉某个软件的开机自启</p>
<p>深信服的 EasyConnect 有一个进程叫做 EasyMonitor 可以说是非常流氓了，开机自启 + 常驻内存 + 内存泄露，时间长了以后会占用 1g 以上的内存。<br>它的 plist 位于 <code>/Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</code> 使用上述命令可以干掉它。</p>
<p>干掉他这个进程非常开心，但是会遇到一个问题，再次启动 EasyConnect 的时候，它不乐意了，会提示初始化失败，请重新安装，这时候就得重新 load 这个 plist 了，执行 <code>sudo launchctl load /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac常用设置命令</title>
    <url>/ef867fbd/</url>
    <content><![CDATA[<h2><span id="取消-4-位数密码限制">取消 4 位数密码限制</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwpolicy -clearaccountpolicies</span><br></pre></td></tr></table></figure>

<h2><span id="允许安装任意来源的-app">允许安装任意来源的 App</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> spctl --master-disable</span><br></pre></td></tr></table></figure>

<h2><span id="xcode-命令行工具">xcode 命令行工具</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h2><span id="程序坞">程序坞</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置启动坞动画时间设置为 0.5 秒 </span></span><br><span class="line">defaults write com.apple.dock autohide-time-modifier -<span class="built_in">float</span> 0.5 &amp;&amp; killall Dock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动坞响应时间最短</span></span><br><span class="line">defaults write com.apple.dock autohide-delay -int 0 &amp;&amp; killall Dock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复启动坞默认动画时间</span></span><br><span class="line">defaults delete com.apple.dock autohide-time-modifier &amp;&amp; killall Dock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认启动坞响应时间</span></span><br><span class="line">defaults delete com.apple.Dock autohide-delay &amp;&amp; killall Dock</span><br></pre></td></tr></table></figure>

<h2><span id="启动台自定义行和列">启动台自定义行和列</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置列数</span></span><br><span class="line">defaults write com.apple.dock springboard-columns -int 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置行数</span></span><br><span class="line">defaults write com.apple.dock springboard-rows -int 6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Dock 生效</span></span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure>

<h2><span id="恢复默认的列数和行数">恢复默认的列数和行数</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows Default</span><br><span class="line">defaults write com.apple.dock springboard-columns Default</span><br></pre></td></tr></table></figure>

<h2><span id="重启-dock-生效">重启 Dock 生效</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行光标操作快捷键</title>
    <url>/9eb2da78/</url>
    <content><![CDATA[<ol>
<li><p>移动光标到行首：<code>Ctrl + a</code></p>
</li>
<li><p>移动光标到行尾：<code>Ctrl + e</code></p>
</li>
<li><p>移动光标到上一个单词的开头：<code>Ctrl + ←</code></p>
</li>
<li><p>移动光标到下一个单词的开头：<code>Ctrl + →</code></p>
</li>
<li><p>删除光标之前的单词：<code>Ctrl + w</code></p>
</li>
<li><p>恢复刚刚删除的字符：<code>Ctrl + y</code></p>
</li>
<li><p>清除光标到行尾的内容：<code>Ctrl + k</code></p>
</li>
<li><p>清除光标到行首的内容：<code>Ctrl + u</code></p>
</li>
<li><p>删除光标所在位置的字符：<code>Backspace</code> 或 <code>Ctrl + h</code></p>
</li>
<li><p>删除光标所在位置的字符：<code>Delete</code> 或 <code>Ctrl + d</code></p>
</li>
<li><p>光标向上滚动一页：<code>Shift + Page Up</code></p>
</li>
<li><p>光标向下滚动一页：<code>Shift + Page Down</code></p>
</li>
<li><p>移动光标到文本的开头：<code>Shift + Home</code></p>
</li>
<li><p>移动光标到文本的末尾：<code>Shift + End</code></p>
</li>
<li><p>交换光标所在位置的字符：<code>Ctrl + t</code></p>
</li>
<li><p>复制光标所在位置的字符：<code>Ctrl + Shift + c</code></p>
</li>
<li><p>粘贴复制的内容：<code>Ctrl + Shift + v</code></p>
</li>
<li><p>撤消最后的操作：<code>Ctrl + z</code></p>
</li>
<li><p>重做被撤消的操作：<code>Ctrl + Shift + z</code> 或 <code>Ctrl + y</code></p>
</li>
<li><p>在命令行历史记录中向上滚动：<code>Ctrl + p</code></p>
</li>
<li><p>在命令行历史记录中向下滚动：<code>Ctrl + n</code></p>
</li>
<li><p>在命令行历史记录中搜索命令：<code>Ctrl + r</code>，然后输入关键字进行搜索</p>
</li>
<li><p>在命令行历史记录中重复上一个命令：<code>Ctrl + o</code></p>
</li>
<li><p>在命令行历史记录中编辑上一个命令：<code>Ctrl + x + e</code></p>
</li>
<li><p>清除当前行的命令：<code>Ctrl + c</code></p>
</li>
<li><p>将光标置于当前行并清除：<code>Ctrl + l</code></p>
</li>
<li><p>切换到下一个终端会话：<code>Ctrl + Alt + →</code></p>
</li>
<li><p>切换到上一个终端会话：<code>Ctrl + Alt + ←</code></p>
</li>
<li><p>切换到下一个单词的开头：<code>Alt + f</code></p>
</li>
<li><p>切换到上一个单词的开头：<code>Alt + b</code></p>
</li>
<li><p>将光标移动到下一行的开头：<code>Ctrl + n</code></p>
</li>
<li><p>将光标移动到上一行的开头：<code>Ctrl + p</code></p>
</li>
<li><p>移动光标到下一屏的开头：<code>Ctrl + v</code></p>
</li>
<li><p>移动光标到上一屏的开头：<code>Ctrl + Shift + v</code></p>
</li>
<li><p>搜索命令历史记录中的下一个匹配项：<code>Ctrl + s</code></p>
</li>
<li><p>搜索命令历史记录中的上一个匹配项：<code>Ctrl + r</code></p>
</li>
<li><p>将当前行的命令追加到命令历史记录中：<code>Ctrl + Shift + ↑</code></p>
</li>
<li><p>将当前行的命令追加到命令历史记录中：<code>Ctrl + Shift + ↓</code></p>
</li>
<li><p>将当前命令行复制到剪贴板：<code>Ctrl + Shift + c</code></p>
</li>
<li><p>将剪贴板中的内容粘贴到命令行：<code>Ctrl + Shift + v</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习笔记</title>
    <url>/31dc5dc1/</url>
    <content><![CDATA[<p>关于Makefile怎么写,参考<a href="http://blog.csdn.net/haoel/article/details/2886">http://blog.csdn.net/haoel/article/details/2886</a></p>
<p>一 关于编译和链接</p>
<pre><code>一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</code></pre><p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p>
<pre><code>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。

总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</code></pre><p>二 Makefile的规则</p>
<p>三条:</p>
<pre><code>1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。     2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。     3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。

target ... : prerequisites ...             command             ...             ...

target也就是一个目标文件，可以是Object File，也可以是执行文件,还可以是一个标签（Label）.

prerequisites就是，要生成那个target所需要的东西(文件或是目标)。

command也就是make需要执行的命令。（任意的Shell命令）

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</code></pre><p>For example:</p>
<pre><code>edit : main.o kbd.o command.o display.o \            insert.o search.o files.o utils.o             cc -o edit main.o kbd.o command.o display.o \                        insert.o search.o files.o utils.o

main.o : main.c defs.h             cc -c main.c     kbd.o : kbd.c defs.h command.h             cc -c kbd.c     command.o : command.c defs.h command.h             cc -c command.c     display.o : display.c defs.h buffer.h             cc -c display.c     insert.o : insert.c defs.h buffer.h             cc -c insert.c     search.o : search.c defs.h buffer.h             cc -c search.c     files.o : files.c defs.h buffer.h command.h             cc -c files.c     utils.o : utils.c defs.h             cc -c utils.c     clean :             rm edit main.o kbd.o command.o display.o \                insert.o search.o files.o utils.o

在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个\[Tab\]键作为开头(在Makefile中的命令，必须要以\[Tab\]键开始)。make并不管命令是怎么工作的，它只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，make就会执行后续定义的命令。

clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，如果其冒号后什么也没有，那么make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</code></pre><p>三 Makefile里有什么</p>
<p>1 显示规则</p>
<p>2 隐晦规则</p>
<p>3 变量的定义</p>
<p>4 文件指示: 其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。</p>
<p>5 注释: Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。</p>
<p>四 Makefile的文件名</p>
<pre><code>默认情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了就解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</code></pre><p>当然，也可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，可以使用make的“-f”和“–file”参数，如：make -f Make.Linux或make –file Make.AIX。</p>
<p>五 引用其它的Makefile</p>
<p>include的语法是：</p>
<pre><code>include</code></pre><p>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p>
<pre><code>在include前面可以有一些空字符，但是绝不能是\[Tab\]键开始。include和可以用一个或多个空格隔开。例如,有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：

include foo.make *.mk $(bar)

等价于：

include foo.make a.mk b.mk c.mk e.mk f.mk</code></pre><p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<pre><code>1、如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。     2、如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</code></pre><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>
<pre><code>-include     其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</code></pre><p>六 环境变量 MAKEFILES</p>
<pre><code>如果当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。

但是在这里还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当使用make时，所有的Makefile都会受到它的影响，这绝不是想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。

当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明.</code></pre><p>七 关于命令</p>
<pre><code>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：

@echo 正在编译XXX模块......</code></pre><p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：</p>
<pre><code>echo 正在编译XXX模块......     正在编译XXX模块......</code></pre><p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于调试Makefile，看看书写的命令执行起来是什么样子的或是什么顺序的,而make参数“-s”或“–slient”则是全面禁止命令的显示。</p>
<pre><code>如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令。比如第一条命令是cd，希望第二条命令在cd之后的基础上运行，那么就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：

示例一：         exec:                 cd /home/hchen                 pwd

示例二：         exec:                 cd /home/hchen; pwd</code></pre><p>当执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<pre><code>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。

有些时候，命令的出错并不表示就是错误的。例如mkdir，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。之所以使用mkdir的意思就是一定要有这样的一个目录，只要这个目录存在了,就不希望mkdir出错而终止规则的运行。为了做到这一点，忽略命令的出错，可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</code></pre><p>   clean:             -rm -f *.o</p>
<p>还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<pre><code>在一些大的工程中，会把不同模块或是不同功能的源文件放在不同的目录中，这种情况可以在每个目录中都书写一个该目录的Makefile，例如，有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么总控的Makefile可以这样书写：

subsystem:             cd subdir &amp;&amp; $(MAKE)</code></pre><p>其等价于：</p>
<pre><code>subsystem:             $(MAKE) -C subdir</code></pre><p>这两个例子的意思都是先进入“subdir”目录，然后执行make命令。总控Makefile的变量可以传递到下级的Makefile中，但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p>
<p>如果要传递变量到下级Makefile中，那么可以使用这样的声明：</p>
<pre><code>export</code></pre><p>如果不想让某些变量传递到下级Makefile中，那么可以这样声明：</p>
<pre><code>unexport</code></pre><p>如：</p>
<pre><code>示例一：

    export variable = value

    其等价于：

    variable = value         export variable

    其等价于：

    export variable := value

    其等价于：

    variable := value         export variable

示例二：

    export variable += value

    其等价于：

    variable += value         export variable</code></pre><p>如果要传递所有的变量，那么，只要一个export就行了,后面什么也不用跟，表示传递所有的变量。</p>
<p>八 变量</p>
<p>两种高级用法:</p>
<pre><code>我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“$&#123;var:a=b&#125;”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</code></pre><p>示例：</p>
<pre><code>foo := a.o b.o c.o     bar := $(foo:.o=.c)</code></pre><p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有的“.o”字串“结尾”全部替换成“.c”，所以“$(bar)”的值就是“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<pre><code>x = y     y = z     a := $($(x))</code></pre><p>在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）</p>
<p>我们还可以使用更多的层次：</p>
<pre><code>x = y     y = z     z = u     a := $($($(x)))</code></pre><p>这里的$(a)的值是“u”.</p>
<pre><code>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令.定义是以endef关键字结束,其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。命令需要以\[Tab\]键开头，define定义的命令也不例外.</code></pre><p>下面的这个示例展示了define的用法：</p>
<p>define two-lines     echo foo     echo $(bar) endef</p>
<p>九 目标变量</p>
<pre><code>前面所有的在Makefile中定义的变量都是“全局变量”，在整个文件，都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。

当然，我们同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效,而不会影响规则链以外的全局变量的值。</code></pre><p>其语法是：</p>
<pre><code>:

: overide</code></pre><p>可以是各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<pre><code>prog : CFLAGS = -g     prog : prog.o foo.o bar.o             $(CC) $(CFLAGS) prog.o foo.o bar.o

prog.o : prog.c             $(CC) $(CFLAGS) prog.c

foo.o : foo.c             $(CC) $(CFLAGS) foo.c

bar.o : bar.c             $(CC) $(CFLAGS) bar.c</code></pre><p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”.</p>
<p>十 条件判断语法</p>
<p>条件表达式的语法为：</p>
<pre><code>else         endif</code></pre><p>其中表示条件关键字，如“ifeq”。这个关键字有四个。</p>
<p>第一个是我们前面所见过的“ifeq”</p>
<pre><code>ifeq (, )     ifeq &apos;&apos; &apos;&apos;     ifeq &quot;&quot; &quot;&quot;     ifeq &quot;&quot; &apos;&apos;     ifeq &apos;&apos; &quot;&quot;</code></pre><p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<pre><code>ifeq ($(strip $(foo)),)         endif</code></pre><p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么就生效。</p>
<p>第二个条件关键字是“ifneq”。</p>
<p>第三个条件关键字是“ifdef”。语法是：</p>
<pre><code>ifdef</code></pre><p>如果变量的值非空，那到表达式为真。否则，表达式为假。当然，同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>
<pre><code>示例一：     bar =     foo = $(bar)     ifdef foo     frobozz = yes     else     frobozz = no     endif

示例二：     foo =     ifdef foo     frobozz = yes     else     frobozz = no     endif</code></pre><p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p>
<p>第四个条件关键字是“ifndef”。</p>
<pre><code>在这一行上，多余的空格是被允许的，但是不能以\[Tab\]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以\[Tab\]键开始就行了。

特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</code></pre><p>十一 foreach 函数     foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，它的语法是：</p>
<pre><code>$(foreach ,

&lt;list&gt;,&lt;text&gt;)这个函数的意思是，把参数

&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。&amp;nbsp; &amp;nbsp;所以，&lt;var&gt;最好是一个变量名，&lt;/var&gt;

&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举
&lt;list&gt;中的单词。举个例子：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;names := a b c d


files := $(foreach n,$(names),$(n).o) </code></pre><p>  $(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。 </p>
<p>十二 检查规则</p>
<p>有时候，我们不想让我们的makefile中的规则执行起来，只想检查一下命令，或是执行的序列。可以使用make命令的下述参数：</p>
<pre><code>“-n”     “--just-print”     “--dry-run”</code></pre><p>------------------   </p>
<pre><code>“-t”     “--touch”     这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</code></pre><hr>
<pre><code>“-W ”     这个参数需要指定一个文件。一般是是源文件（或依赖文件），make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。假定目标需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。</code></pre><p>十三 make的其他参数</p>
<p>“-B” “–always-make” 认为所有的目标都需要更新（重编译）。</p>
<p>“-C</p>
<p>” “–directory=</p>
<p>” 指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p>
<p>“-i” “–ignore-errors” 在执行时忽略所有的错误。</p>
<p>“-k” “–keep-going” 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。 十四 隐含规则</p>
<pre><code>在使用Makefile时，有一些会经常使用，而且使用频率非常高的东西，比如，编译C/C++的源程序为中间目标文件（Unix下是\[.o\]文件，Windows下是\[.obj\]文件）,这些就是早先约定了的，不需要我们再写出来的规则。

“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，即使Makefile中没有书写这样的规则。例如，把\[.c\]文件编译成\[.o\]文件这一规则，根本就不用写出来，make会自动推导出这种规则，并生成需要的\[.o\]文件。

“隐含规则”会使用一些系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</code></pre><p>1 使用隐含规则</p>
<pre><code>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：

foo : foo.o bar.o             cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</code></pre><p>这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<pre><code>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把\[.o\]的目标的依赖文件置成\[.c\]，并使用C的编译命令“cc –c $(CFLAGS) \[.c\]”来生成\[.o\]的目标。也就是说，我们完全没有必要写下下面的两条规则：

foo.o : foo.c             cc –c foo.c $(CFLAGS)     bar.o : bar.c         cc –c bar.c $(CFLAGS)</code></pre><p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>
<pre><code>当然，如果我们为\[.o\]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。

还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：

foo.o : foo.p</code></pre><p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>1 编译C程序的隐含规则 “.o”的目标的依赖目标会自动推导为“.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”</p>
<p>2 编译C++程序的隐含规则 “.o”的目标的依赖目标会自动推导为“.cc”或是“.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</p>
<p>3 链接Object文件的隐含规则 “”目标依赖于“.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<pre><code>x : y.o z.o</code></pre><p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>
<pre><code>cc -c x.c -o x.o     cc -c y.c -o y.o     cc -c z.c -o z.o     cc x.o y.o z.o -o x     rm -f x.o     rm -f y.o     rm -f z.o</code></pre><p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的四种事务隔离级别</title>
    <url>/689978a2/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#一-事务的基本要素acid">一、事务的基本要素（ACID）</a></li>
<li><a href="#二-事务的并发问题">二、事务的并发问题</a></li>
<li><a href="#三-mysql事务隔离级别">三、MySQL事务隔离级别</a></li>
<li><a href="#四-用例子说明各个隔离级别的情况">四、用例子说明各个隔离级别的情况</a><ul>
<li><a href="#1-读未提交">1、读未提交：</a></li>
<li><a href="#2-读已提交">2、读已提交</a></li>
<li><a href="#3-可重复读">3、可重复读</a></li>
<li><a href="#4串行化">4.串行化</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="一-事务的基本要素acid">一、事务的基本要素（ACID）</span></h1><p>　　1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
<p>　　 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p>　　 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p>　　 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
<h1><span id="二-事务的并发问题">二、事务的并发问题</span></h1><p>　　1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
<p>　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>
<p>　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
<p>　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h1><span id="三-mysql事务隔离级别">三、MySQL事务隔离级别</span></h1><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>mysql默认的事务隔离级别为repeatable-read</p>
<h1><span id="四-用例子说明各个隔离级别的情况">四、用例子说明各个隔离级别的情况</span></h1><h2><span id="1-读未提交">1、读未提交：</span></h2><p>　　　　（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226132329.png" alt></p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226132440.png" alt></p>
<p>（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226132511.png" alt></p>
<p>（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226132642.png" alt></p>
<p>（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226132722.png" alt></p>
<h2><span id="2-读已提交">2、读已提交</span></h2><p>（1）打开一个客户端A，并设置当前事务模式为read committed（读已提交），查询表account的所有记录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226132916.png" alt></p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133127.png" alt></p>
<p>（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133227.png" alt></p>
<p>（4）客户端B的事务提交</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133253.png" alt></p>
<p>（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133509.png" alt></p>
<h2><span id="3-可重复读">3、可重复读</span></h2><p>（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133541.png" alt></p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133617.png" alt></p>
<p>（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133720.png" alt></p>
<p>（4）在客户端A，接着执行update balance = balance - 50 where id = 1，balance没有变成400-50=350，lilei的balance值用的是步骤（2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133747.png" alt></p>
<p>（5）重新打开客户端B，插入一条新数据后提交</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133806.png" alt></p>
<p><a name="待验证">（6）在客户端A查询表account的所有记录，没有 查出 新增数据，所以没有出现幻读</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226133936.png" alt></p>
<h2><span id="4串行化">4.串行化</span></h2><p>（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：</p>
<p>（2）打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。</p>
<p>　　<strong>补充：</strong></p>
<p>　　1、事务隔离级别为读提交时，写数据只会锁住相应的行</p>
<p>　　2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果****检索条件****没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。</p>
<p>　　3、事务隔离级别为串行化时，读写数据都会锁住整张表</p>
<p>　　4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p>
<p>　　5、MYSQL MVCC实现机制参考链接：<a href="https://blog.csdn.net/whoamiyang/article/details/51901888">https://blog.csdn.net/whoamiyang/article/details/51901888</a></p>
<p>　　 6、关于next-key 锁可以参考链接：<a href="https://blog.csdn.net/bigtree_3721/article/details/73731377">https://blog.csdn.net/bigtree_3721/article/details/73731377</a></p>
<p><strong>后注：</strong></p>
<p>关于 <a href="#待验证">四、3、可重复的的第(6)步</a>， 待验证</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP检测图片是否有木马</title>
    <url>/9a49b652/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-type: text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHex</span>(<span class="params"><span class="variable">$img</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$status</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable">$tips</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&quot;0&quot;</span> =&gt; <span class="string">&quot;文件没问题&quot;</span>,</span><br><span class="line">    <span class="string">&quot;5&quot;</span> =&gt; <span class="string">&quot;文件有毒&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-1&quot;</span> =&gt; <span class="string">&quot;文件没有上传&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$img</span>)) &#123;</span><br><span class="line">    <span class="variable">$resource</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$img</span>, <span class="string">&#x27;rb&#x27;</span>);</span><br><span class="line">    <span class="variable">$fileSize</span> = <span class="title function_ invoke__">filesize</span>(<span class="variable">$img</span>);</span><br><span class="line">    <span class="title function_ invoke__">fseek</span>(<span class="variable">$resource</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$fileSize</span> &gt; <span class="number">512</span>) &#123; <span class="comment">// 取头和尾</span></span><br><span class="line">      <span class="variable">$hexCode</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">fread</span>(<span class="variable">$resource</span>, <span class="number">512</span>));</span><br><span class="line">      <span class="title function_ invoke__">fseek</span>(<span class="variable">$resource</span>, <span class="variable">$fileSize</span> - <span class="number">512</span>);</span><br><span class="line">      <span class="variable">$hexCode</span> .= <span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">fread</span>(<span class="variable">$resource</span>, <span class="number">512</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 取全部</span></span><br><span class="line">      <span class="variable">$hexCode</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">fread</span>(<span class="variable">$resource</span>, <span class="variable">$fileSize</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$resource</span>);</span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;% ( ) %&gt; */</span></span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;? ( ) ?&gt; */</span></span><br><span class="line">    <span class="comment">/* 匹配16进制中的 &lt;script | /script&gt; 大小写亦可 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/(3c25.*?28.*?29.*?253e)|(3c3f.*?28.*?29.*?3f3e)|(3C534352495054)|(2F5343524950543E)|(3C736372697074)|(2F7363726970743E)/is&quot;</span>, <span class="variable">$hexCode</span>)) &#123;</span><br><span class="line">      <span class="variable">$status</span> = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$status</span> = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$tips</span>[<span class="variable">$status</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$rs</span> = <span class="title function_ invoke__">checkHex</span>(<span class="string">&quot;du.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$rs</span>);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>pic</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac iTerm2，使用rz和sz无效，解决方式</title>
    <url>/32451f0a/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1安装lrzsz要先安装brew">1.安装lrzsz（要先安装brew）</a></li>
<li><a href="#2配置">2.配置</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1安装lrzsz要先安装brew">1.安装lrzsz（要先安装brew）</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure>



<h2><span id="2配置">2.配置</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/bin</span><br></pre></td></tr></table></figure>



<p>在<code>/usr/loal/bin</code> 目录下创建两个文件</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi iterm2-recv-zmodem.sh</span><br><span class="line">vi iterm2-send-zmodem.sh</span><br></pre></td></tr></table></figure>


<p>创建好两个文件后分别添加内容：</p>
<ol>
<li><strong>iterm2-recv-zmodem.sh</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)</span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script</span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required </span></span><br><span class="line"><span class="comment"># Remainder of script public domain</span></span><br><span class="line"> </span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$NAME</span> = <span class="string">&quot;iTerm&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> = <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Cancelled.</span><br><span class="line">    <span class="comment"># Send ZModem cancel</span></span><br><span class="line">    <span class="built_in">echo</span> -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \# Cancelled transfer</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span></span><br><span class="line">    /usr/local/bin/rz -E -e -b</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \# Sent \-\&gt; <span class="variable">$FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>iterm2-send-zmodem.sh</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)</span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script</span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required </span></span><br><span class="line"><span class="comment"># Remainder of script public domain</span></span><br><span class="line"> </span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$NAME</span> = <span class="string">&quot;iTerm&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> = <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Cancelled.</span><br><span class="line">    <span class="comment"># Send ZModem cancel</span></span><br><span class="line">    <span class="built_in">echo</span> -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \# Cancelled transfer</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    /usr/local/bin/sz <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> -e -b</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \# Received <span class="variable">$FILE</span></span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>将文件写好后保存好，使用如下命令添加权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 iterm2-*</span><br></pre></td></tr></table></figure>



<p>配置好配置文件之后，开始对iTerm2进行配置</p>
<p>点击 iTerm2 的设置界面 <code>Perference-&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Triggers</code> 的 <code>Edit</code> 按钮，加入以下配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210513232741.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"> </span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure>



<p><strong>备注：</strong></p>
<p>rz 上传功能：在bash中，也就是iTerm2终端输入rz 就会弹出文件选择框，选择文件 choose 就开始上传，会上传到当前目录<br>sz 下载功能 ：sz fileName(你要下载的文件的名字) 回车，会弹出窗体 我们选择要保存的地方即可。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Pillow 库</title>
    <url>/ab6bf24d/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#pil中所涉及的基本概念">PIL中所涉及的基本概念</a></li>
<li><a href="#pil中有九种不同模式">PIL中有九种不同模式。</a></li>
<li><a href="#请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像">请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</a></li>
</ul>
<!-- tocstop -->

<p>Pillow(PIL) 库中的 Image 类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; im = Image.open(&quot;lena.ppm&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from __future__ import print_function</span><br><span class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</span><br><span class="line">PPM (512, 512) RGB</span><br></pre></td></tr></table></figure>

<p>format 这个属性代表图片文件的扩展名, 如果图片文件打开失败, 则其值为None. size 这个属性代表图片的大小, 以像素为单位, 使用包含两个元素的元组来返回. mode 这个属性代表图片的band属性, 一般情况(黑白)下为 “L”, 当图片是彩色的时候是 “RGB”, 如果图片经过压缩, 则是 “CMYK”.</p>
<h3><span id="pil中所涉及的基本概念">PIL中所涉及的基本概念</span></h3><p>通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。</p>
<h3><span id="pil中有九种不同模式">PIL中有九种不同模式。</span></h3><p>分别为1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。</p>
<p><strong>模式 1</strong><br>二值图像</p>
<p>模式“1”为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.mode</span><br><span class="line"> </span><br><span class="line">&#x27;RGB&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1 = lena.convert(&quot;1&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.mode</span><br><span class="line"> </span><br><span class="line">&#x27;1&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.size</span><br><span class="line"> </span><br><span class="line">(512, 512)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_1.getpixel((10,10))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((10,120))</span><br><span class="line"> </span><br><span class="line">0</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((130,120))</span><br><span class="line"> </span><br><span class="line">255</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>模式 L</strong></p>
<p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度</p>
<p><strong>模式 P</strong></p>
<p>模式“P”为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的</p>
<p><strong>模式“RGBA”</strong></p>
<p>模式“RGBA”为32位彩色图像，它的每个像素用32个bit表示，其中24bit表示红色、绿色和蓝色三个通道，另外8bit表示alpha通道，即透明通道。</p>
<p>从实例中可以看到，使用当前这个方式将“RGB”图像转为“RGBA”图像时，alpha通道全部设置为255，即完全不透明。</p>
<p><strong>模式“CMYK”</strong></p>
<p>模式“CMYK”为32位彩色图像，它的每个像素用32个bit表示。模式“CMYK”就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</p>
<p>四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：Key Plate(blacK) = 定位套版色（黑色）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;from PIL import Image</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena =Image.open(&quot;D:\\Code\\Python\\test\\img\\lena.jpg&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk =lena.convert(&quot;CMYK&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.mode</span><br><span class="line"> </span><br><span class="line">&#x27;CMYK&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena_cmyk.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(58, 144, 177, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; lena_cmyk.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(59, 145, 178, 0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,0))</span><br><span class="line"> </span><br><span class="line">(197, 111, 78)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((0,1))</span><br><span class="line"> </span><br><span class="line">(196, 110, 77)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从实例中可以得知PIL中“RGB”转换为“CMYK”的公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C = 255 - R</span><br><span class="line">M = 255 - G</span><br><span class="line">Y = 255 - B</span><br><span class="line">K = 0</span><br></pre></td></tr></table></figure>

<p>由于该转换公式比较简单，转换后的图像颜色有些失真。</p>
<p><strong>模式“YCbCr”</strong></p>
<p>模式“YCbCr”为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。</p>
<p>模式“RGB”转换为“YCbCr”的公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y= 0.257*R+0.504*G+0.098*B+16</span><br><span class="line">Cb = -0.148*R-0.291*G+0.439*B+128</span><br><span class="line">Cr = 0.439*R-0.368*G-0.071*B+128</span><br></pre></td></tr></table></figure>

<p><strong>模式“I”</strong></p>
<p>模式“I”为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“I”模式是按照下面的公式转换的：</p>
<p><code>I = R * 299/1000 + G * 587/1000 + B * 114/1000</code></p>
<p><strong>模式“F”</strong></p>
<p>模式“F”为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式“RGB”转换为“F”模式是按照下面的公式转换的：</p>
<p><code>F = R * 299/1000+ G * 587/1000 + B * 114/1000</code></p>
<h3><span id="请注意gif文件总是以灰度形式读取-l-或调色板模式-p-图像">请注意，GIF文件总是以灰度形式读取。（ L ）或调色板模式（ P ）图像。</span></h3>]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>pic</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman 自动填充 Header</title>
    <url>/3632d5ff/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#基本流程">基本流程</a></li>
<li><a href="#postman实现">Postman实现</a><ul>
<li><a href="#新增一个环境">新增一个环境</a></li>
<li><a href="#设置环境变量">设置环境变量</a></li>
<li><a href="#设置-tests">设置 Tests</a></li>
<li><a href="#设置自定义固定头部">设置自定义固定头部</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h3><span id="基本流程">基本流程</span></h3><pre class="mermaid">sequenceDiagram
participant c as Client
participant s as Server

c ->> s: request Head为空
s ->> c: token在response中

c ->> s: 取出token；设置Head</pre>



<h3><span id="postman实现">Postman实现</span></h3><h4><span id="新增一个环境">新增一个环境</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710185857.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710185930.png" alt></p>
<h4><span id="设置环境变量">设置环境变量</span></h4><p><code>VARIABLE</code> 名为为 <code>token</code>, <code>VALUE</code> 为空</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190008.png" alt></p>
<h4><span id="设置-tests">设置 Tests</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190305.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190344.png" alt></p>
<p>然后点击发送。如果请求正常，那值就会填充到你的环境中。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190423.png" alt></p>
<h4><span id="设置自定义固定头部">设置自定义固定头部</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190508.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190527.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20220710190547.png" alt></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 工程的几种文件</title>
    <url>/924904f6/</url>
    <content><![CDATA[<h4><span id="pro"><code>*.pro</code></span></h4><p>qmake的工程(project)文件 例子:</p>
<pre><code>TEMPLATE = app
CONFIG += QT
QT += core gui

TARGET = somename

SOURCES += main.cpp \
          widget.cpp
HEADERS += widget.h
FORMS += widget.ui</code></pre><ul>
<li>前三行是qmake的默认值, 都可以省略</li>
<li>TARGET 行指定工程名, 也可以省略</li>
</ul>
<h4><span id="pri"><code>*.pri</code></span></h4><p>include 文件 接上面的例子, 我们可以将源文件的设置独立处理, 放到somename.pri文件内:</p>
<pre><code>SOURCES += main.cpp \
          widget.cpp
HEADERS += widget.h
FORMS += widget.ui</code></pre><p>这时, pro 文件就可以简化为:</p>
<pre><code>TEMPLATE = app
CONFIG += QT
QT += core gui

TARGET = somename
include(somename.pri)</code></pre><h4><span id="prf"><code>*.prf</code></span></h4><p>特性(feature) 文件 和pri文件类似, prf文件也是要被包含进pro文件. 只是它更隐蔽.</p>
<p>在上面的例子中, 其实已经用到了prf, 就是 <code>CONFIG += QT</code></p>
<p>当在CONFIG 中指定一个值时, qmake就会尝试去加载相应的feature文件: - Qt安装目录下的<code>mkspecs/features/qt.prf</code> - features 文件的文件名必须小写</p>
<p>例子:</p>
<pre><code>win32:CONFIG += console // 为win32程序添加控制台</code></pre><p>把该文件命名为<code>a.prf</code>, 放到前面提到的目录中, 然后在pro文件内添加 <code>CONFIG += a</code></p>
<p>也可以使用load命令来加载prf文件 <code>load(a)</code></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Raycast 插件开发</title>
    <url>/be3b141a/</url>
    <content><![CDATA[<p>Raycast 插件使用 tsx+react 开发，可以使用 <code>Nodejs(&gt;=16.10)</code> 生态来完成各种功能，但是在界面绘制上，仅支持官方在 <code>@raycast/api</code> 包中提供的控件。<br>其新建项目的具体步骤可参考 <a href="https://developers.raycast.com/basics/create-your-first-extension">官方教程</a></p>
<h2><span id="command">Command</span></h2><p>在 Raycast 中，插件的核心是 “Command” 。这些 Command 会直接列举在呼出的面板上，并依旧你的使用习惯进行排序。Command 之间可以共享，传递数据，但是并不共享页面。 这点与 uTools 有较大的不同。在 uTools 中，一个插件往往就是一个界面，通过对界面进行各种控件的排布来直接完成对应功能。 但是由于 Raycast 目前并不提供自行绘制 UI 的能力，所以基本的 UI 控件只能单独占有一个页面，通过跳转页面来完成功能执行结果的输出。 所以将其分为两大类，控件与功能，同时控件又分为以下三种：</p>
<ul>
<li>界面主体控件：它会铺满整个页面，而你的发挥也会被限制在它可接受的子控件范围内。</li>
<li>命令面板： Raycast 中，无法自行放置按钮，而是统一通过右下角的命令面板来执行需要的功能。</li>
<li>其它 UI 相关：可在界面中进行组合使用的小控件。</li>
</ul>
<h3><span id="主体控件">主体控件</span></h3><p>目前官方提供的主体控件有三种：列表(List)，详情(Detail)，和表单(Form)。</p>
<h4><span id="列表-list">列表 List</span></h4><p>下图所示即为一个标准的列表页面。由顶部的输入框，页面中的列表，右下角的命令面板组成。 其中列表作为主体控件，其子控件为数个列表项(List.Item)</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262055350.png" alt></p>
<h4><span id="详情-detail">详情 Detail</span></h4><p>如图所示，其实它只是一个文本展示的界面。你可以靠它渲染一个 Markdown 文档，不过也仅此而已。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262055612.png" alt></p>
<h4><span id="表单-form">表单 Form</span></h4><p>较新添加的控件，可以让你在页面上完成更进一步的交互，子控件也最为丰富，支持输入框，区域输入，下拉框，多选，标签选择，日期选择等功能。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262056241.png" alt></p>
<h2><span id="命令面板">命令面板</span></h2><p>命令面板以 ActionPanel 为容器，以 Action 作为具体功能的执行入口，并且可以通过 Section 等将命令分组，达到更加直观高效的目的。 通过预设的 Action，你可以操作剪切板，打开浏览器，提交表单，开启访达，跳转页面等功能；当然亦可以自行编写函数来执行，可算得上 Raycast 的灵魂所在。 在主体控件(List,Detail,Form)中，均可以接受一个 actions 参数。而我们所编写的命令，也都是传入此处才可以被在当前页面访问到。</p>
<h2><span id="其它-ui-相关">其它 UI 相关</span></h2><p>目前有两点：Icon 和 Color。 前者可以在 ListItem，Action 等控件上作为参数传入，提供显示图标的能力。而且同时支持 Raycast 内置的图标库和外部图片资源（打包进插件的图片或者网络图片） 后者则是提供对 Icon 的统一着色功能，支持直接调用内置的色彩变量与自行传入色值。</p>
<h2><span id="功能性-api">功能性 API</span></h2><p>除了界面，作为一个效率工具，自然还需要和系统进行交互，来完成各种功能，绝大部分在 utilities 中提供。 包括但不限于：获取应用列表，获取默认应用，操作文件（打开、删除、显示），本地数据读写等。</p>
<h2><span id="preference">Preference</span></h2><p>从层级来讲，它与 Command 呈现并列关系。同样，使用此功能需要在 package.json 中进行声明。如果设定为 required=true，则在运行 Command 前，插件会先要求用户完成设定项。适用于指引用户完成填写用户名，API，token 等行为。</p>
<h2><span id="提交与发布">提交与发布</span></h2><p>目前来讲，插件的发布流程依旧不甚友好。在你构建的插件符合其官方的种种要求的基础上，你需要自行 fork 官方的插件仓库，补充你的插件代码以后提交一个 pr，经过审核后方才可以。值得注意的是，截止到本文写作，官方依旧仅支持英文插件，无论是插件指令还是操作说明，均需为英文（即使你的插件并不面向英文用户），否则无法通过审核。当然，即使不去发布，仅仅自用，也是完全可以的。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>raycast</tag>
      </tags>
  </entry>
  <entry>
    <title>React useEffect() Hook</title>
    <url>/42f8026c/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#side-effect-是什么">Side Effect 是什么</a></li>
<li><a href="#hook-的作用">Hook 的作用</a></li>
<li><a href="#useeffect-的用法">useEffect() 的用法</a></li>
<li><a href="#useeffect-的第二个参数">useEffect() 的第二个参数</a></li>
<li><a href="#useeffect-的用途">useEffect() 的用途</a></li>
<li><a href="#useeffect-的返回值">useEffect() 的返回值</a></li>
</ul>
<!-- tocstop -->

<h2><span id="side-effect-是什么">Side Effect 是什么</span></h2><p>函数式编程将那些跟数据计算无关的操作，都称为 <strong>side effect</strong> 。如果函数内部直接包含产生  side effect 的操作，就不再是纯函数了. 纯函数内部只有通过间接的手段（即通过其他函数调用），才能包含 side effect</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202502081529923.png" alt></p>
<h2><span id="hook-的作用">Hook 的作用</span></h2><p><strong>hook 就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。</strong> 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入。</p>
<p>由于副效应非常多，所以钩子有许多种。React 为许多常见的操作（副效应），都提供了专用的钩子。</p>
<ul>
<li><code>useState()</code>：保存状态</li>
<li><code>useContext()</code>：保存上下文</li>
<li><code>useRef()</code>：保存引用</li>
<li>……</li>
</ul>
<p>上面这些钩子，都是引入某种特定的副效应，而 <strong><code>useEffect()</code> 是通用的副效应钩子</strong> 。找不到对应的钩子时，就可以用它。</p>
<h2><span id="useeffect-的用法">useEffect() 的用法</span></h2><p>例如，希望组件加载以后，网页标题（<code>document.title</code>）会随之改变。那么，改变网页标题这个操作，就是组件的副效应，必须通过 <code>useEffect()</code> 来实现。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>useEffect()</code>的参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，React 就会执行这个函数。</p>
<h2><span id="useeffect-的第二个参数">useEffect() 的第二个参数</span></h2><p>如果不希望 <code>useEffect()</code> 每次渲染都执行，可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会重新渲染。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`Hello, <span class="subst">$&#123;props.name&#125;</span>`</span>;</span><br><span class="line">  &#125;, [props.<span class="property">name</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>的第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项（<code>props.name</code>）。只有该变量发生变化时，副效应函数才会执行。</p>
<p>如果第二个参数是一个空数组，就表明副效应参数没有任何依赖项。因此，副效应函数这时只会在组件加载进入 DOM 后执行一次，后面组件重新渲染，就不会再次执行。</p>
<h2><span id="useeffect-的用途">useEffect() 的用途</span></h2><p>只要是副效应，都可以使用<code>useEffect()</code>引入。它的常见用途有下面几种。</p>
<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
<p>下面是从远程服务器获取数据的例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">        <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useState()</code>用来生成一个状态变量（<code>data</code>），保存获取的数据；<code>useEffect()</code>的副效应函数内部有一个 async 函数，用来从服务器异步获取数据。拿到数据以后，再用<code>setData()</code>触发组件的重新渲染。</p>
<p>由于获取数据只需要执行一次，所以上例的<code>useEffect()</code>的第二个参数为一个空数组。</p>
<h2><span id="useeffect-的返回值">useEffect() 的返回值</span></h2><p>副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应。</p>
<p><code>useEffect()</code>允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，<code>useEffect()</code>就不用返回任何值。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.<span class="property">source</span>]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。</p>
<p>实际使用中，由于副效应函数默认是每次渲染都会执行，所以清理函数不仅会在组件卸载时执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。</p>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 笔记</title>
    <url>/9f188831/</url>
    <content><![CDATA[<h4><span id="数据类型">数据类型</span></h4><p>Redis 支持5中数据类型</p>
<h5><span id="字符串string">字符串(string)</span></h5><p>Redis 中字符串是一个字节序列. Redis 中的字符串是二进制安全的, 这意味着它们的长度不由任何特殊的终止字符决定。因此，可以在一个字符串中存储高达512兆字节的任何内容 <strong>例</strong></p>
<pre><code>redis 127.0.0.1:6379&gt; SET name &quot;value&quot;
OK
redis 127.0.0.1:6379&gt; GET name
&quot;value&quot;


Redis命令不区分大小写.字符串的最大长度为512M</code></pre><h5><span id="散列哈希hash">散列/哈希(Hash)</span></h5><p>Redis散列/哈希(Hashes)是键值对的集合。Redis散列/哈希是字符串字段和字符串值之间的映射。因此，它们用于表示对象。 <strong>例</strong></p>
<pre><code>redis 127.0.0.1:6379&gt; HMSET ukey username &quot;yiibai&quot; password &quot;passswd123&quot; points 200</code></pre><p>散列/哈希数据类型用于存储包含用户的基本信息的用户对象。这里HMSET，HGETALL是Redis的命令，而ukey是键的名称。</p>
<p>每个散列/哈希可以存储多达2^32 - 1个健-值对(超过40亿个)。</p>
<h5><span id="列表list">列表(List)</span></h5><p>Redis列表只是字符串列表，按插入顺序排序。可以向Redis列表的头部或尾部添加元素。 <strong>例</strong></p>
<pre><code>redis 127.0.0.1:6379&gt; lpush alist redis 
(integer) 1 
redis 127.0.0.1:6379&gt; lpush alist mongodb 
(integer) 2 
redis 127.0.0.1:6379&gt; lpush alist sqlite 
(integer) 3 
redis 127.0.0.1:6379&gt; lrange alist 0 10  

1) &quot;sqlite&quot; 
2) &quot;mongodb&quot; 
3) &quot;redis&quot;</code></pre><h5><span id="集合set">集合(Set)</span></h5><p>Redis集合是字符串的无序集合。在Redis中，可以添加，删除和测试成员存在的时间O(1)复杂性 <strong>例</strong></p>
<pre><code>redis 127.0.0.1:6379&gt; sadd yiibailist redis 
(integer) 1 
redis 127.0.0.1:6379&gt; sadd yiibailist mongodb 
(integer) 1 
redis 127.0.0.1:6379&gt; sadd yiibailist sqlite 
(integer) 1 
redis 127.0.0.1:6379&gt; sadd yiibailist sqlite 
(integer) 0 
redis 127.0.0.1:6379&gt; smembers yiibailist  

1) &quot;sqlite&quot; 
2) &quot;mongodb&quot; 
3) &quot;redis&quot;


注意 - 在上面的示例中，sqlite被添加了两次，但是由于集合的唯一属性，所以它只算添加一次</code></pre><h5><span id="可排序集合zset">可排序集合(ZSET)</span></h5><p>Redis可排序集合类似于Redis集合，是不重复的字符集合。 不同之处在于，排序集合的每个成员都与分数相关联，这个分数用于按最小分数到最大分数来排序的排序集合。虽然成员是唯一的，但分数值可以重复 <strong>例</strong></p>
<pre><code>redis 127.0.0.1:6379&gt; zadd yiibaiset 0 redis
(integer) 1 
redis 127.0.0.1:6379&gt; zadd yiibaiset 0 mongodb
(integer) 1 
redis 127.0.0.1:6379&gt; zadd yiibaiset 1 sqlite
(integer) 1 
redis 127.0.0.1:6379&gt; zadd yiibaiset 1 sqlite
(integer) 0 
redis 127.0.0.1:6379&gt; ZRANGEBYSCORE yiibaiset 0 1000  

1) &quot;mongodb&quot; 
2) &quot;redis&quot; 
3) &quot;sqlite&quot;


因为 ‘sqlite‘ 的排序值是 1 ，其它两个元素的排序值是 0 ，所以 ‘sqlite‘ 排在最后一个位置上</code></pre>]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】Redis 分布式锁使用不当事故记录</title>
    <url>/f17b426c/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#事故现场">事故现场</a></li>
<li><a href="#事故原因">事故原因</a></li>
<li><a href="#事故分析">事故分析</a></li>
<li><a href="#解决方案">解决方案</a></li>
<li><a href="#深度思考">深度思考</a></li>
</ul>
<!-- tocstop -->

<h2><span id="前言">前言</span></h2><p>某电商项目中，抢购订单采用的是分布式锁来解决的。某次茅台抢购活动，库存共 100 瓶，分布式锁设计不当，最终超卖。</p>
<h2><span id="事故现场">事故现场</span></h2><p>核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SeckillActivityRequestVO <span class="title function_">seckillHandle</span><span class="params">(SeckillActivityRequestVO request)</span> &#123;</span><br><span class="line">SeckillActivityRequestVO response;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key:&quot;</span> + request.getSeckillId;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lockFlag</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;val&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (lockFlag) &#123;</span><br><span class="line">            <span class="comment">// HTTP请求用户服务进行用户相关的校验</span></span><br><span class="line">            <span class="comment">// 用户活动校验</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 库存校验</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForHash().get(key+<span class="string">&quot;:info&quot;</span>, <span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="keyword">assert</span> stock != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(stock.toString()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 业务异常</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.opsForHash().increment(key+<span class="string">&quot;:info&quot;</span>, <span class="string">&quot;stock&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 生成订单</span></span><br><span class="line">                <span class="comment">// 发布订单创建成功事件</span></span><br><span class="line">                <span class="comment">// 构建响应VO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建响应VO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码，通过分布式锁过期时间有效期 10s 来保障业务逻辑有足够的执行时间；采用 try-finally 语句块保证锁一定会及时释放。</p>
<h2><span id="事故原因">事故原因</span></h2><p>飞天茅台抢购活动吸引了大量新用户下载注册我们的 APP，其中，不乏很多羊毛党，采用专业的手段来注册新用户来薅羊毛和刷单。正因如此，让用户服务一直处于较高的运行负载中。</p>
<p>抢购活动开始的一瞬间，大量的用户校验请求打到了用户服务。</p>
<p>导致用户服务网关出现了短暂的响应延迟，有些请求的响应时长超过了 10s，但由于 HTTP 请求的响应超时我们设置的是 30s。</p>
<p>这就导致接口一直阻塞在用户校验那里，10s 后，分布式锁已经失效了，此时有新的请求进来是可以拿到锁的，也就是说锁被覆盖了。</p>
<p>这些阻塞的接口执行完之后，又会执行释放锁的逻辑，这就把其他线程的锁释放了，导致新的请求也可以竞争到锁~这真是一个极其恶劣的循环。</p>
<p>这个时候只能依赖库存校验，但是偏偏库存校验不是非原子性的，采用的是 get and compare 的方式，超卖的悲剧就这样发生了<del>~</del></p>
<h2><span id="事故分析">事故分析</span></h2><p>仔细分析下来，可以发现，这个抢购接口在高并发场景下，是有严重的安全隐患的，主要集中在三个地方：</p>
<p><strong>①没有其他系统风险容错处理</strong></p>
<p>由于用户服务吃紧，网关响应延迟，但没有任何应对方式，这是超卖的导火索。</p>
<p><strong>②看似安全的分布式锁其实一点都不安全</strong></p>
<p>虽然采用了 set key value [EX seconds] [PX milliseconds] [NX|XX]的方式，但是如果线程 A 执行的时间较长没有来得及释放，锁就过期了，此时线程 B 是可以获取到锁的。</p>
<p>当线程 A 执行完成之后，释放锁，实际上就把线程 B 的锁释放掉了。这个时候，线程 C 又是可以获取到锁的，而此时如果线程 B 执行完释放锁实际上就是释放的线程 C 设置的锁。这是超卖的直接原因。</p>
<p><strong>③非原子性的库存校验</strong></p>
<p>非原子性的库存校验导致在并发场景下，库存校验的结果不准确。这是超卖的根本原因。</p>
<p>通过以上分析，问题的根本原因在于库存校验严重依赖了分布式锁。因为在分布式锁正常 set、del 的情况下，库存校验是没有问题的。</p>
<p>但是，当分布式锁不安全可靠的时候，库存校验就没有用了。</p>
<h2><span id="解决方案">解决方案</span></h2><p><strong>实现相对安全的分布式锁</strong></p>
<p>相对安全的定义：set、del 是一一映射的，不会出现把其他现成的锁 del 的情况。</p>
<p>从实际情况的角度来看，即使能做到 set、del一一映射，也无法保障业务的绝对安全。</p>
<p>因为锁的过期时间始终是有界的，除非不设置过期时间或者把过期时间设置的很长，但这样做也会带来其他问题。故没有意义。</p>
<p>要想实现相对安全的分布式锁，必须依赖 key 的 value 值。在释放锁的时候，通过 value 值的唯一性来保证不会勿删。</p>
<p><em>我们基于 LUA 脚本实现原子性的 get and compare</em>，如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">public void safedUnLock(String key, String val) &#123;</span><br><span class="line">    String luaScript = <span class="string">&quot;local in = ARGV[1] local curr=redis.call(&#x27;get&#x27;, KEYS[1]) if in==curr then redis.call(&#x27;del&#x27;, KEYS[1]) end return &#x27;OK&#x27;&quot;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    RedisScript&lt;String&gt; redisScript = RedisScript.of(luaScript);</span></span><br><span class="line"><span class="string">    redisTemplate.execute(redisScript, Collections.singletonList(key), Collections.singleton(val));</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们通过 LUA 脚本来实现安全地解锁。</p>
<p><strong>实现安全的库存校验</strong></p>
<p>如果我们对于并发有比较深入的了解的话，会发现想 get and compare/ read and save 等操作，都是非原子性的。如果要实现原子性，我们也可以借助 LUA 脚本来实现。</p>
<p>在公众号互联网架构师回复“2T”，获取惊喜礼包。</p>
<p>但就我们这个例子中，由于抢购活动一单只能下 1 瓶，因此可以不用基于 LUA 脚本实现而是基于 Redis 本身的原子性。</p>
<p>原因在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redis会返回操作之后的结果，这个过程是原子性的</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">currStock</span> <span class="operator">=</span> redisTemplate.opsForHash().increment(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;stock&quot;</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>发现没有，代码中的库存校验完全是“画蛇添足”。 </p>
<p><strong>改进之后的代码</strong></p>
<p>经过以上的分析之后，我们决定新建一个 DistributedLocker 类专门用于处理分布式锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SeckillActivityRequestVO <span class="title function_">seckillHandle</span><span class="params">(SeckillActivityRequestVO request)</span> &#123;</span><br><span class="line">SeckillActivityRequestVO response;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key:&quot;</span> + request.getSeckillId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lockFlag</span> <span class="operator">=</span> distributedLocker.lock(key, val, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="comment">// 业务异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户活动校验</span></span><br><span class="line">        <span class="comment">// 库存校验，基于redis本身的原子性来保证</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">currStock</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().increment(key + <span class="string">&quot;:info&quot;</span>, <span class="string">&quot;stock&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (currStock &lt; <span class="number">0</span>) &#123; <span class="comment">// 说明库存已经扣减完了。</span></span><br><span class="line">            <span class="comment">// 业务异常。</span></span><br><span class="line">            log.error(<span class="string">&quot;[抢购下单] 无库存&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 生成订单</span></span><br><span class="line">            <span class="comment">// 发布订单创建成功事件</span></span><br><span class="line">            <span class="comment">// 构建响应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        distributedLocker.safedUnLock(key, val);</span><br><span class="line">        <span class="comment">// 构建响应</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="深度思考">深度思考</span></h2><p><strong>①分布式锁有必要么</strong></p>
<p>改进之后，其实可以发现，我们借助于 Redis 本身的原子性扣减库存，也是可以保证不会超卖的。</p>
<p>对的。但是如果没有这一层锁的话，那么所有请求进来都会走一遍业务逻辑，由于依赖了其他系统，此时就会造成对其他系统的压力增大。</p>
<p>这会增加的性能损耗和服务不稳定性，得不偿失。基于分布式锁可以在一定程度上拦截一些流量。</p>
<p><strong>②分布式锁的选型</strong></p>
<p>有人提出用 RedLock 来实现分布式锁。RedLock 的可靠性更高，但其代价是牺牲一定的性能。</p>
<p>在本场景，这点可靠性的提升远不如性能的提升带来的性价比高。如果对于可靠性极高要求的场景，则可以采用 RedLock 来实现。</p>
<p><strong>③再次思考分布式锁有必要么</strong></p>
<p>由于 Bug 需要紧急修复上线，因此我们将其优化并在测试环境进行了压测之后，就立马热部署上线了。</p>
<p>实际证明，这个优化是成功的，性能方面略微提升了一些，并在分布式锁失效的情况下，没有出现超卖的情况。</p>
<p>然而，还有没有优化空间呢？有的！由于服务是集群部署，我们可以将库存均摊到集群中的每个服务器上，通过广播通知到集群的各个服务器。</p>
<p>网关层基于用户 ID 做 hash 算法来决定请求到哪一台服务器。这样就可以基于应用缓存来实现库存的扣减和判断。</p>
<p>性能又进一步提升了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过消息提前初始化好，借助ConcurrentHashMap实现高效线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Long, Boolean&gt; SECKILL_FLAG_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 通过消息提前设置好。由于AtomicInteger本身具备原子性，因此这里可以直接使用HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, AtomicInteger&gt; SECKILL_STOCK_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SeckillActivityRequestVO <span class="title function_">seckillHandle</span><span class="params">(SeckillActivityRequestVO request)</span> &#123;</span><br><span class="line">SeckillActivityRequestVO response;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">seckillId</span> <span class="operator">=</span> request.getSeckillId();</span><br><span class="line">    <span class="keyword">if</span>(!SECKILL_FLAG_MAP.get(requestseckillId)) &#123;</span><br><span class="line">        <span class="comment">// 业务异常</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 用户活动校验</span></span><br><span class="line">     <span class="comment">// 库存校验</span></span><br><span class="line">    <span class="keyword">if</span>(SECKILL_STOCK_MAP.get(seckillId).decrementAndGet() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SECKILL_FLAG_MAP.put(seckillId, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 业务异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成订单</span></span><br><span class="line">    <span class="comment">// 发布订单创建成功事件</span></span><br><span class="line">    <span class="comment">// 构建响应</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的改造，我们就完全不需要依赖 Redis 了。性能和安全性两方面都能进一步得到提升！</p>
<p>当然，此方案没有考虑到机器的动态扩容、缩容等复杂场景，如果还要考虑这些话，则不如直接考虑分布式锁的解决方案。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>事故</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Sorted-Set底层数据结构</title>
    <url>/f1113725/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#sortedset底层存储结构">Sortedset底层存储结构</a><ul>
<li><a href="#1-跳跃表">1 跳跃表</a></li>
<li><a href="#2-跳跃表的结构">2 跳跃表的结构</a></li>
<li><a href="#3-压缩列表">3 压缩列表</a><ul>
<li><a href="#连锁更新">连锁更新</a></li>
</ul>
</li>
<li><a href="#4-quicklist">4 quicklist</a><ul>
<li><a href="#数据压缩">数据压缩</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="sortedset底层存储结构">Sortedset底层存储结构</span></h1><p>sortedset同时会由两种数据结构支持,ziplist和skiplist.</p>
<p>只有同时满足如下条件是,使用的是ziplist,其他时候则是使用skiplist</p>
<ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素的长度小于64字节</li>
</ul>
<p>当ziplist作为存储结构时候,每个集合元素使用两个紧挨在一起的压缩列表结点来保存,第一个节点保存元素的成员,第二个元素保存元素的分值.</p>
<p>当使用skiplist作为存储结构时,使用skiplist按序保存元素分值,使用dict来保存元素和分值的对应关系</p>
<h2><span id="1-跳跃表">1 跳跃表</span></h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单。</p>
<p><strong>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</strong></p>
<p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p>
<p>Redis的配置文件中关于有序集合底层实现的两个配置。<br>1）zset-max-ziplist-entries 128:zset采用压缩列表时，元素个数最大值。默认值为128。<br>2）zset-max-ziplist-value 64:zset采用压缩列表时，每个元素的字符串长度最大值。默认值为64。<br>zset插入第一个元素时，会判断下面两种条件：</p>
<ul>
<li>zset-max-ziplist-entries的值是否等于0；</li>
<li>zset-max-ziplist-value小于要插入元素的字符串长度。满足任一条件Redis就会采用跳跃表作为底层实现，否则采用压缩列表作为底层实现方式。</li>
</ul>
<p>一般情况下，不会将zset-max-ziplist-entries配置成0，元素的字符串长度也不会太长，所以在创建有序集合时，默认使用压缩列表的底层实现。zset新插入元素时，会判断以下两种条件：</p>
<ul>
<li>zset中元素个数大于zset_max_ziplist_entries；</li>
<li>插入元素的字符串长度大于zset_max_ziplist_value。当满足任一条件时，Redis便会将zset的底层实现由压缩列表转为跳跃表。</li>
</ul>
<blockquote>
<p>zset在转为跳跃表之后，即使元素被逐渐删除，也不会重新转为压缩列表。</p>
</blockquote>
<h2><span id="2-跳跃表的结构">2 跳跃表的结构</span></h2><p>其c语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">	<span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="type">double</span> score;<span class="comment">//分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//回退指针</span></span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    	<span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1）obj：用于存储字符串类型的数据。<br>2）score：用于存储排序的分值。<br>3）backward：后退指针，只能指向当前节点最底层的前一个节点，头节点和第一个节点——backward指向NULL，从后向前遍历跳跃表时使用。<br>4）level：为柔性数组。每个节点的数组长度不一样，在生成跳跃表节点时，随机生成一个1～64的值，值越大出现的概率越低。<br>level数组的每项包含以下两个元素。</p>
<ul>
<li>forward：指向本层下一个节点，尾节点的forward指向NULL。</li>
<li>span:forward指向的节点与本节点之间的元素个数。span值越大，跳过的节点个数越多。</li>
</ul>
<p>除了跳跃表节点外，还需要一个跳跃表结构来管理节点，Redis使用zskiplist结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>



<p>1）header：指向跳跃表头节点。头节点是跳跃表的一个特殊节点，它的level数组元素个数为64。头节点在有序集合中不存储任何member和score值，ele值为NULL, score值为0；也不计入跳跃表的总长度。头节点在初始化时，64个元素的forward都指向NULL, span值都为0。<br>2）tail：指向跳跃表尾节点。<br>3）length：跳跃表长度，表示除头节点之外的节点总数。<br>4）level：跳跃表的高度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212210023.png" alt></p>
<blockquote>
<p>查找从最高层开始，如果本层的next节点大于要查找的值或next节点为NULL，则从本节点开始，降低一层继续向后查找，依次类推，如果找到则返回节点；否则返回NULL。采用该原理查找节点，在节点数量比较多时，可以跳过一些节点，查询效率大大提升，这就是跳跃表的基本思想。</p>
</blockquote>
<p>1）跳跃表由很多层构成。<br>2）跳跃表有一个头（header）节点，头节点中有一个64层的结构，每层的结构包含指向本层的下个节点的指针，指向本层下个节点中间所跨越的节点个数为本层的跨度（span）。<br>3）除头节点外，层数最多的节点的层高为跳跃表的高度（level）<br>4）每层都是一个有序链表，数据递增。<br>5）除header节点外，一个元素在上层有序链表中出现，则它一定会在下层有序链表中出现。<br>6）跳跃表每层最后一个节点指向NULL，表示本层有序链表的结束。<br>7）跳跃表拥有一个tail指针，指向跳跃表最后一个节点。<br>8）最底层的有序链表包含所有节点，最底层的节点个数为跳跃表的长度（length）（不包括头节点）。<br>9）每个节点包含一个后退指针，头节点和第一个节点指向NULL；其他节点指向最底层的前一个节点。</p>
<blockquote>
<p>Redis通过zslRandomLevel函数随机生成一个1～64的值作为新建节点的高度</p>
</blockquote>
<h2><span id="3-压缩列表">3 压缩列表</span></h2><p>压缩列表ziplist本质上就是一个字节数组，是Redis为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。</p>
<blockquote>
<p>Redis的有序集合、散列和列表都直接或者间接使用了压缩列表。当有序集合或散列表的元素个数比较少，且元素都是短字符串时，Redis便使用压缩列表作为其底层数据存储结构。列表使用快速链表（quicklist）数据结构存储，而快速链表就是双向链表与压缩列表的组合。</p>
</blockquote>
<p>一个压缩列表可以包含任意多个节点（entry），<strong>每个节点可以保存一个字节数组或者一个整数值。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212210219.png" alt></p>
<p>1）zlbytes：压缩列表的字节长度，占4个字节，因此压缩列表最多有232-1个字节。<br>2）zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节。3）zllen：压缩列表的元素个数，占2个字节。zllen无法存储元素个数超过65535（216-1）的压缩列表，必须遍历整个压缩列表才能获取到元素个数。4）entryX：压缩列表存储的元素，可以是字节数组或者整数，长度不限。entry的编码结构将在后面详细介绍。<br>5）zlend：压缩列表的结尾，占1个字节，恒为0xFF。</p>
<p>而压缩列表元素(entry)的编码结构：<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212210255.png" alt></p>
<ul>
<li>previous_entry_length字段表示前一个元素的字节长度<br>  占1个或者5个字节，当前一个元素的长度小于254字节时，用1个字节表示；当前一个元素的长度大于或等于254字节时，用5个字节来表示。</li>
<li>encoding字段表示当前元素的编码</li>
<li>数据内容存储在content字段</li>
</ul>
<p>其中包含了很多复杂的解码运算，想详细了解的可以找对应的书来看。</p>
<h3><span id="连锁更新">连锁更新</span></h3><p>每个节点的previous_entry_length属性都记录了前一个节点的长度，添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。<br>因为某个可能的结点previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将则个节点的previous_entry_length属性从原来的1字节长扩展为5字节长。进而引发后面的连锁更新。<br>其最坏复杂度是O（N 2）。</p>
<p>尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p>
<p>压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；<br>即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；</p>
<h2><span id="4-quicklist">4 quicklist</span></h2><p>quicklist是Redis底层最重要的数据结构之一，它是Redis对外提供的6种基本数据结构中List的底层实现，在Redis 3.2版本中引入。</p>
<p>在引入quicklist之前，Redis采用压缩链表（ziplist）以及双向链表（adlist）作为List的底层实现。当元素个数比较少并且元素长度比较小时，Redis采用ziplist作为其底层存储；当任意一个条件不满足时，Redis采用adlist作为底层存储结构。</p>
<p>这么做的主要原因是，当元素长度较小时，采用ziplist可以有效节省存储空间，但ziplist的存储空间是连续的，当元素个数比较多时，修改元素时，必须重新分配存储空间，这无疑会影响Redis的执行效率，故而采用一般的双向链表。</p>
<p>结构如下：<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212210432.png" alt></p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">	quicklistNode *head;</span><br><span class="line">	quicklistNode *tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> count;<span class="comment">//quicklist中元素总数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> len;<span class="comment">//quicklist Node（节点）个数</span></span><br><span class="line">	<span class="type">int</span> fill : <span class="number">16</span>;<span class="comment">//每个quicklistNode中ziplist长度</span></span><br><span class="line">&#125;quicklist;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *zl;<span class="comment">//zl指向该节点对应的ziplist结构；</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sz;<span class="comment">//整个ziplist结构的大小</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count:<span class="number">16</span>;<span class="comment">//ziplist的个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> coding：<span class="number">2</span>;<span class="comment">//1代表是原生的，2代表使用LZF进行压缩；</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> containnr：<span class="number">2</span>;<span class="comment">//container为quicklistNode节点zl指向的容器类型：1代表none,2代表使用ziplist存储数据；</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> recompress:<span class="number">1</span>;<span class="comment">//recompress代表这个节点之前是否是压缩节点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> extra:<span class="number">10</span>;<span class="comment">//extra为预留</span></span><br><span class="line">&#125;quicklistNode;</span><br></pre></td></tr></table></figure>



<h3><span id="数据压缩">数据压缩</span></h3><p>quicklist每个节点的实际数据存储结构为ziplist，这种结构的主要优势在于节省存储空间。为了进一步降低ziplist所占用的空间，Redis允许对ziplist进一步压缩，Redis采用的压缩算法是LZF，压缩过后的数据可以分成多个片段，每个片段有2部分：一部分是解释字段，另一部分是存放具体的数据字段。<br>解释字段可以占用1～3个字节，数据字段可能不存在。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sz;<span class="comment">//sz表示compressed所占字节大小</span></span><br><span class="line">	<span class="type">char</span> compress[];</span><br><span class="line">&#125;quicklistLZF;</span><br></pre></td></tr></table></figure>

<p>解释字段有3种:<br>1）字面型，解释字段占用1个字节，数据字段长度由解释字段后5位决定。<br>2）简短重复型，解释字段占用2个字节，没有数据字段，数据内容与前面数据内容重复，重复长度小于8。<br>3）批量重复型，解释字段占3个字节，没有数据字段，数据内容与前面内容重复。</p>
<p>压缩：<br>数据与前面重复的，记录重复位置以及重复长度，否则直接记录原始数据内容。压缩算法的流程如下：遍历输入字符串，对当前字符及其后面2个字符进行散列运算，如果在Hash表中找到曾经出现的记录，则计算重复字节的长度以及位置，反之直接输出数据。<br>解压：<br>可能存在重复数据与当前位置重叠的情况，例如在当前位置前的15个字节处，重复了20个字节，此时需要按位逐个复制。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt UI 编码规范</title>
    <url>/9c64b54d/</url>
    <content><![CDATA[<h5><span id="变量声明">变量声明</span></h5><ul>
<li><p>每行只声明一个变量</p>
</li>
<li><p>避免使用短的/无意义的命名</p>
</li>
<li><p>当一个变量被用到时再声明</p>
<pre><code>// Wrong
int a, b;
char* c, * d;

// Correct
int height;
int width;
char* nameOfOne;
char* nameOfOther;</code></pre></li>
</ul>
<h5><span id="变量命名">变量命名</span></h5><ul>
<li><p>变量名/函数名采用驼峰命名法(lowerCaseCamel), 首字母缩写词出现的命名中, 缩写也用驼峰命名</p>
<pre><code>// Wrong 
short Cntr;
char ITEM_DELIM = &apos;&apos;;

void myXMLStreamReader();

// Correct
short counter;
char itemDelimiter = &apos;&apos;;

void myXmlStreamReader();</code></pre></li>
</ul>
<h5><span id="空行空格">空行/空格</span></h5><ul>
<li><p>用一个且仅用一个空行在适当的地方划分代码块</p>
</li>
<li><p>在关键词和小括号之间总是只用一个空格符</p>
<pre><code>// Wrong
if(foo)
&#123;
&#125;

// Correct
if (foo)
&#123;
&#125;</code></pre></li>
</ul>
<h5><span id="指针引用">指针/引用</span></h5><ul>
<li><p>在类型名和<code>*</code>或<code>&amp;</code>之间没有空格, 在<code>*</code>或<code>&amp;</code>与变量名之间有一个空格</p>
<pre><code>char* someValue;
const QString&amp; myString;
const char* const WOR = &quot;hello&quot;;</code></pre></li>
</ul>
<h5><span id="符号与空格">符号与空格</span></h5><ul>
<li>二元操作符左右两边都有一个空格</li>
<li>一元操作符与变量之间不留空格</li>
<li>逗号左右没有空格, 右边一个空格</li>
<li>分号左边没有空格; 分号作为语句的结束符, 右边一般不再有内容</li>
<li><code>#</code>号右边没有空格</li>
<li>左引号的左边和右引号的各一个空格, 左引号的右边和右引号的左边没有空格</li>
<li>如果右引号右边是右括号, 它们之间没有空格</li>
</ul>
<h5><span id="cast">cast</span></h5><ul>
<li><p>避免C语言的cast, 尽量用C++的cast(static_cast, const_cast, reinterpret_cast). reinterpret_cast 和 C风格的cast用起来都是危险的，但至少 reinterpret_cast 不会把const修饰符去掉</p>
</li>
<li><p>涉及到QObjects或重构自己的代码时，不要使用dynamic_cast,而是用qobject_cast，例如在引进一个类型的方法时</p>
</li>
<li><p>用构造函数去cast简单类型,例如：用int(myFloat)代替(int)myFloat</p>
<pre><code>// Wrong
char* blockOfMemory = (char* ) malloc(data.size());

// Correct
char *blockOfMemory = reinterpret_cast&lt;char *&gt;(malloc(data.size()));</code></pre></li>
</ul>
<h5><span id="语句">语句</span></h5><ul>
<li>不要在一行写多条语句</li>
</ul>
<h5><span id="括号">括号</span></h5><ul>
<li><p>每个大括号单独一行</p>
</li>
<li><p>不论条件语句的执行部分有几行, 必须使用大括号</p>
</li>
<li><p>小括号用来给语句分组</p>
<p> // Wrong<br> if (address.isEmpty()) {</p>
<pre><code>return false;</code></pre><p> }</p>
<p> for (int i = 0; i &lt; 10; +’’i) {</p>
<pre><code>qDebug(&quot;%i&quot;, i);</code></pre><p> }</p>
<p> // Correct<br> if (address.isEmpty())<br> {</p>
<pre><code>return false;</code></pre><p> }<br> else<br> {</p>
<pre><code>return true;</code></pre><p> }</p>
<p> for (int i = 0; i &lt; 10;i)<br> {</p>
<pre><code>qDebug(&quot;%i&quot;, i);</code></pre><p> }</p>
</li>
</ul>
<pre><code>// Wrong
if (a &amp;&amp; b || c)

// Correct
if ((a &amp;&amp; b) || c)

// Wrong
a + b &amp; c

// Correct
(a + b) &amp; c</code></pre><h5><span id="switch语句">switch语句</span></h5><ul>
<li><p>case缩进</p>
</li>
<li><p>除enum外, 每组case最后都要加default;</p>
<p> switch (myEnum)<br> {</p>
<pre><code>case Value1:
    doSomething();
break;
case Value2:
case Value3:
    doSomethingElse();
    // fall through
break;
default:
    defaultHandling();
break;</code></pre><p> }</p>
</li>
</ul>
<h5><span id="goto">goto</span></h5><ul>
<li>禁止使用goto</li>
</ul>
<h5><span id="换行">换行</span></h5><ul>
<li><p>每行代码不多于120字符</p>
</li>
<li><p>逗号在行尾. 操作符在新行的开头位置</p>
</li>
<li><p>换行时尽量避免行与行之间看起来参差不齐</p>
<p> // Wrong<br> if (longExpression +</p>
<pre><code>otherLongExpression +
otherOtherLongExpression) &#123;</code></pre><p> }</p>
<p> // Correct<br> if (longExpression</p>
<pre><code>+ otherLongExpression
+ otherOtherLongExpression) &#123;</code></pre><p> }</p>
</li>
</ul>
<h5><span id="c特性"><code>C++</code>特性</span></h5><ul>
<li>不要使用异常处理</li>
<li>不要使用运行时类型识别</li>
<li>理智地使用模板</li>
</ul>
<h5><span id="qt源码中的规范">Qt源码中的规范</span></h5><ul>
<li>所有代码都是ascii，使用者如果不确定的话，只可能是7字节</li>
<li>每一个QObject的子类都必须有Q_OBJECT宏，即使这个类没用到信号或槽。否则qobject_cast将不能使用</li>
<li>在connect语句中，使信号和槽的参数规范化（参看 QMetaObject::normalizedSignature），可以加快信号/槽的查找速度。可以使用qtrepotools/util/normalize规范已有代码</li>
</ul>
<h5><span id="包含头文件顺序">包含头文件顺序</span></h5><ol>
<li>源文件对应的头文件</li>
<li>&lt;分隔&gt;</li>
<li>C系统文件</li>
<li>&lt;分隔&gt;</li>
<li>C++系统文件</li>
<li>&lt;分隔&gt;</li>
<li>Qt库文件</li>
<li>&lt;分隔&gt;</li>
<li>其他目录</li>
</ol>
<p>每组文件按字母升序排列</p>
<h5><span id="编译器平台">编译器/平台</span></h5><ol>
<li><p>使用三目运算符 ？时要特别小心，如果每次的返回值的类型可能不一样的话，一些编译器会在运行时生成冲突的代码（此时编译器甚至不会报错） <code>QString s; return condition ? s : &quot;nothing&quot;; // crash at runtime - QString vs. const char *</code></p>
</li>
<li><p>要特别小心对齐问题。无论何时，当一个指针被cast后的对齐数是增加的时候，它都可能会崩溃。例如一个const char 被cast成了cons int，当cast之后的数字不得不在2或4个字节之间对齐时，指针就会在机器上崩溃</p>
</li>
<li><p>任何需要需要执行构造函数或相关代码进行初始化的实例，都不能用作库代码中的全局实例。因为当构造函数或代码将要运行的时候，该实例还没有被定义（在第一次调用该实例时，在加载库时，在执行main()之前） <code>// global scope static const QString x; // Wrong - default constructor needs to be run to initialize x static const QString y = &quot;Hello&quot;; // Wrong - constructor that takes a const char * has to be run QString z; // super wrong static const int i = foo(); // wrong - call time of foo() undefined, might not be called at all</code> 可以使用下面方法: <code>// global scope static const char x[] = &quot;someText&quot;; // Works - no constructor must be run, x set at compile time static int y = 7; // Works - y will be set at compile time static MyStruct s = &#123;1, 2, 3&#125;; // Works - will be initialized statically, no code being run static QString *ptr = 0; // Pointers to objects are ok - no code needed to be run to initialize ptr</code></p>
</li>
<li><p>用Q_GLOBAL_STATIC定义全局实例</p>
<pre><code> Q_GLOBAL_STATIC(QString, s)

void foo()
&#123;
 s()-&gt;append(&quot;moo&quot;);
&#125;</code></pre></li>
</ol>
<ol start="5">
<li>char型变量是有符号的还是无符号的取决于它运行环境的架构。如果你明确地想使用一个signed或unsinged char，就使用signed char或unsigned char。以下代码运行在把char默认为无符号的平台上时，其条件判断恒为真 <code>char c; // c can&#39;t be negative if it is unsigned /********/ /*******/ if (c &gt; 0) &#123; … &#125; // WRONG - condition is always true on platforms where the default is unsigned</code></li>
<li>避免64位的枚举值<ul>
<li>嵌入式应用系统二进制接口将所有的枚举类型的值硬编码成32位int值</li>
<li>微软的编译器不支持64位的枚举值</li>
</ul>
</li>
</ol>
<h5><span id="编程偏好">编程偏好</span></h5><ul>
<li>用枚举值定义常量而非用const int或defines<ul>
<li>枚举值会在编译时被编译器用实际值替换掉，因而运行时得出结果的速度更快</li>
<li>defines不是命名空间安全的（并且看起来很丑）</li>
</ul>
</li>
<li>当重新实现一个虚方法时，在Qt5中，用 Q_DECL_OVERRIDE宏在函数声明之后，分号之前注解它</li>
<li>不要把const-iterator和none-const iterator搞混 <code>for (Container::const_iterator it = c.begin(); it != c.end(); ++it) // Wrong for (Container::const_iterator it = c.cbegin(); it != c.cend(); ++it) // Right</code></li>
</ul>
<h5><span id="命名空间">命名空间</span></h5><ul>
<li>除跟UI直接交互的类外, 其他类必须处在命名空间内</li>
</ul>
<h5><span id="float值">float值</span></h5><ul>
<li>用qFuzzyCompare去和delta比较其值</li>
<li>用qIsNull去判断float值是不是二进制0，而不是和0.0比较 <code>[static] bool qFuzzyCompare(double p1, double p2) // Instead of comparing with 0.0 qFuzzyCompare(0.0,1.0e-200); // This will return false // Compare adding 1 to both values will fix the problem qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true</code></li>
</ul>
<h5><span id="类的成员命名">类的成员命名</span></h5><ul>
<li><p>成员变量一般为名词</p>
</li>
<li><p>函数成员一般为动词/动词+名词，但是当动词为get时，get常常省略。当返回值为Bool型变量时，函数名一般以前缀’is’开头</p>
<pre><code>public:
    void setColor(const QColor&amp; c);
    QColor color() const;
    void setDirty(bool b);
    bool isDirty() const;

private Q_SLOTS:
    void onParentChanged();</code></pre></li>
</ul>
<h5><span id="构造函数">构造函数</span></h5><ul>
<li>为了使构造函数被错误使用的可能性降到最小，每一个构造函数（除了拷贝构函数）都应该检查自己是否需要加上explicit 符号</li>
</ul>
<h5><span id="注意代码陷阱">注意代码陷阱</span></h5><ul>
<li>不要为了图方便少些一些代码。因为代码是一次书写，后期不止一次地要去理解。例如 <code>QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, &quot;volume&quot;);</code></li>
<li>改成下面的方式会更容易理解 <code>QSlider *slider = new QSlider(Qt::Vertical); slider-&gt;setRange(12, 18); slider-&gt;setPageStep(3); slider-&gt;setValue(13); slider-&gt;setObjectName(&quot;volume&quot;);</code></li>
</ul>
<h5><span id="参考资料">参考资料</span></h5><ol>
<li><a href="https://wiki.qt.io/Qt\_Contribution\_Guidelines">https://wiki.qt.io/Qt\_Contribution\_Guidelines</a></li>
<li><a href="https://wiki.qt.io/Qt\_Coding\_Style">https://wiki.qt.io/Qt\_Coding\_Style</a></li>
<li><a href="https://wiki.qt.io/Coding_Conventions">https://wiki.qt.io/Coding_Conventions</a></li>
<li><a href="https://community.kde.org/Policies/Library\_Code\_Policy">https://community.kde.org/Policies/Library\_Code\_Policy</a></li>
<li><a href="https://wiki.qt.io/UI\_Text\_Conventions">https://wiki.qt.io/UI\_Text\_Conventions</a></li>
<li><a href="https://wiki.qt.io/API\_Design\_Principles">https://wiki.qt.io/API\_Design\_Principles</a></li>
<li><a href="http://doc.qt.io/qt-5/qml-codingconventions.html">http://doc.qt.io/qt-5/qml-codingconventions.html</a></li>
<li><a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化机制</title>
    <url>/f885fe0f/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#一-持久化流程">一、持久化流程</a></li>
<li><a href="#二-rdb机制">二、RDB机制</a></li>
<li><a href="#三-aof机制">三、AOF机制</a></li>
<li><a href="#四-rdb和aof到底该如何选择">四、RDB和AOF到底该如何选择</a></li>
<li><a href="#其他资料">其他资料</a></li>
</ul>
<!-- tocstop -->

<p>redis是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。幸好Redis还为我们提供了持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。</p>
<h3><span id="一-持久化流程">一、持久化流程</span></h3><p>既然redis的数据可以保存在磁盘上，那么这个流程是什么样的呢？</p>
<p>要有下面五个过程：</p>
<p>（1）客户端向服务端发送写操作(数据在客户端的内存中)。</p>
<p>（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。</p>
<p>（3）服务端调用write这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。</p>
<p>（4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。</p>
<p>（5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。</p>
<p>这5个过程是在理想条件下一个正常的保存流程，但是在大多数情况下，我们的机器等等都会有各种各样的故障，这里划分了两种情况：</p>
<p>（1）Redis数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成。</p>
<p>（2）操作系统发生故障，必须上面5步都完成才可以。</p>
<p>在这里只考虑了保存的过程可能发生的故障，其实保存的数据也有可能发生损坏，需要一定的恢复机制，不过在这里就不再延伸了。现在主要考虑的是redis如何来实现上面5个保存磁盘的步骤。它提供了两种策略机制，也就是RDB和AOF。</p>
<h3><span id="二-rdb机制">二、RDB机制</span></h3><p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。</p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p>
<p>在我们安装了redis之后，所有的配置都是在redis.conf文件中，里面保存了RDB和AOF两种持久化机制的各种配置。</p>
<p>既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于RDB来说，提供了三种机制：save、bgsave、自动化。我们分别来看一下</p>
<p><strong>1、save触发方式</strong></p>
<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212202507.png" alt></p>
<p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>
<p><strong>2、bgsave触发方式</strong></p>
<p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212202435.png" alt></p>
<p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p>
<p><strong>3、自动触发</strong></p>
<p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p>
<p><strong>①save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</p>
<p>默认如下配置：</p>
<p>#表示900 秒内如果至少有 1 个 key 的值变化，则保存save 900 1#表示300 秒内如果至少有 10 个 key 的值变化，则保存save 300 10#表示60 秒内如果至少有 10000 个 key 的值变化，则保存save 60 10000</p>
<p>不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</p>
<p><strong>②stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p>
<p><strong>③rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p>
<p><strong>④rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p>
<p><strong>⑤dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</p>
<p><strong>⑥dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p>
<p>我们可以修改这些配置来实现我们想要的效果。因为第三种方式是配置的，所以我们对前两种进行一个对比：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212202559.png" alt></p>
<p><strong>4、RDB 的优势和劣势</strong></p>
<p>①、优势</p>
<p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>
<p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>
<p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<p>②、劣势</p>
<p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p>
<h3><span id="三-aof机制">三、AOF机制</span></h3><p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。</p>
<p><strong>1、持久化原理</strong></p>
<p>他的原理看下面这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212202651.png" alt></p>
<p>每当有一个写命令过来时，就直接保存在我们的AOF文件中。</p>
<p><strong>2、文件重写原理</strong></p>
<p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212202823.png" alt></p>
<p>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p>
<p><strong>3、AOF也有三种触发机制</strong></p>
<p>（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p>
<p>（2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p>
<p>（3）不同no：从不同步</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212202930.png" alt></p>
<p><strong>4、优点</strong></p>
<p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>
<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>
<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
<p><strong>5、缺点</strong></p>
<p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>
<p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>
<p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p>
<h3><span id="四-rdb和aof到底该如何选择">四、RDB和AOF到底该如何选择</span></h3><p>选择的话，两者加一起才更好。因为两个持久化机制你明白了，剩下的就是看自己的需求了，需求不同选择的也不一定，但是通常都是结合使用。有一张图可供总结：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212203019.png" alt></p>
<h3><span id="其他资料">其他资料</span></h3><p><a href="[Redis持久化原理(RDB)_小麦大大博客-CSDN博客_rdb持久化](https://blog.csdn.net/qq_35433716/article/details/82191511)">Redis持久化原理(RDB)</a></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的底层数据结构 </title>
    <url>/abddb7fd/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-演示数据类型的实现">1、演示数据类型的实现</a></li>
<li><a href="#2-简单动态字符串">2、简单动态字符串</a></li>
<li><a href="#3-链表">3、链表</a></li>
<li><a href="#4-字典">4、字典</a></li>
<li><a href="#5-跳跃表">5、跳跃表</a></li>
<li><a href="#6-整数集合">6、整数集合</a></li>
<li><a href="#7-压缩列表">7、压缩列表</a></li>
<li><a href="#8-总结">8、总结</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- tocstop -->

<h3><span id="1-演示数据类型的实现">1、演示数据类型的实现</span></h3><p><code>OBJECT ENCODING    key</code> </p>
<p>该命令是用来显示五大数据类型的底层数据结构。</p>
<p>比如对于 string 数据类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312142322.png" alt></p>
<p>可以看到实现string数据类型的数据结构有 embstr 以及 int。</p>
<p>再比如 list 数据类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312142349.png" alt></p>
<h3><span id="2-简单动态字符串">2、简单动态字符串</span></h3><p> Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
<p><strong>SDS 定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">     <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">     <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line">     <span class="type">int</span> len;</span><br><span class="line">     <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line">     <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">     <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">     <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用SDS保存字符串 “Redis”具体图示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312142538.png" alt></p>
<p>我们看上面对于 SDS 数据类型的定义：</p>
<p>　　1、len 保存了SDS保存字符串的长度</p>
<p>　　2、buf[] 数组用来保存字符串的每个元素</p>
<p>　　3、free j记录了 buf 数组中未使用的字节数量</p>
<p>　　上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？</p>
<p>　　<strong>①、常数复杂度获取字符串长度</strong></p>
<p>　　由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>
<p>　　<strong>②、杜绝缓冲区溢出</strong></p>
<p>　　我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<p>　　<strong>③、减少修改字符串的内存重新分配次数</strong></p>
<p>　　C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>　　而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：</p>
<p>　　1、空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>　　2、惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>
<p>　　<strong>④、二进制安全</strong></p>
<p>　　因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<p>　　<strong>⑤、兼容部分 C 字符串函数</strong></p>
<p>　　虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p>
<p>　　<strong>⑥、总结</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312142712.png" alt></p>
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。后面在介绍Redis的持久化时会进行介绍。</p>
<h3><span id="3-链表">3、链表</span></h3><p>链表是一种常用的数据结构，C 语言内部是没有内置这种数据结构的实现，所以Redis自己构建了链表的实现。</p>
<p>　　链表定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="type">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure>

<p>通过多个 listNode 结构就可以组成链表，这是一个双向链表，Redis还提供了操作链表的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="type">int</span> (*match) (<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312143157.png" alt></p>
<p>Redis链表特性：</p>
<p>　　①、双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p>
<p>　　②、无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　</p>
<p>　　③、带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。</p>
<p>　　④、多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</p>
<h3><span id="4-字典">4、字典</span></h3><p>字典又称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。</p>
<p>　　Redis 的字典使用哈希表作为底层实现</p>
<p>　　哈希表结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">     <span class="comment">//哈希表数组</span></span><br><span class="line">     dictEntry **table;</span><br><span class="line">     <span class="comment">//哈希表大小</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">     <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">     <span class="comment">//总是等于 size-1</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">     <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"> </span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>

<p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="type">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="type">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure>

<p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p>
<p>　　注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决<strong>哈希冲突</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312143330.png" alt></p>
<p><strong>①、哈希算法：</strong>Redis计算哈希值和索引值方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">#<span class="number">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>



<p><strong>②、解决哈希冲突：</strong>这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>
<p>　　<strong>③、扩容和收缩：</strong>当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<p>　　　　　　1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p>
<p>　　　　　　2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p>
<p>　　　　　　3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p>
<p>　　<strong>④、触发扩容的条件：</strong></p>
<p>　　　　　　1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p>
<p>　　　　　　2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p>
<p>　　　　ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>
<p>　　<strong>⑤、渐近式 rehash</strong></p>
<p>　　　　什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p>
<h3><span id="5-跳跃表">5、跳跃表</span></h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：</p>
<p>　　1、由很多层结构组成；</p>
<p>　　2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p>
<p>　　3、最底层的链表包含了所有的元素；</p>
<p>　　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</p>
<p>　　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312143603.png" alt></p>
<p>Redis中跳跃表节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">     <span class="comment">//层</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">           <span class="comment">//前进指针</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">           <span class="comment">//跨度</span></span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">     &#125;level[];</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//后退指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">     <span class="comment">//分值</span></span><br><span class="line">     <span class="type">double</span> score;</span><br><span class="line">     <span class="comment">//成员对象</span></span><br><span class="line">     robj *obj;</span><br><span class="line"> </span><br><span class="line">&#125; zskiplistNode</span><br></pre></td></tr></table></figure>

<p>多个跳跃表节点构成一个跳跃表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">     structz skiplistNode *header, *tail;</span><br><span class="line">     <span class="comment">//表中节点的数量</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">     <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">     <span class="type">int</span> level;</span><br><span class="line"> </span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312143819.png" alt></p>
<p>①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p>
<p>　　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。</p>
<p>　　③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p>
<h3><span id="6-整数集合">6、整数集合</span></h3><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。</p>
<p>　　定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">     <span class="comment">//编码方式</span></span><br><span class="line">     <span class="type">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">//集合包含的元素数量</span></span><br><span class="line">     <span class="type">uint32_t</span> length;</span><br><span class="line">     <span class="comment">//保存元素的数组</span></span><br><span class="line">     <span class="type">int8_t</span> contents[];</span><br><span class="line"> </span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。</p>
<p>　　length 属性记录了 contents 数组的大小。</p>
<p>　　需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。</p>
<p>　　<strong>①、升级</strong></p>
<p>　　当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：</p>
<p>　　1、根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</p>
<p>　　2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。</p>
<p>　　3、将新元素添加到整数集合中（保证有序）。</p>
<p>　　升级能极大地节省内存。</p>
<p>　　<strong>②、降级</strong></p>
<p>　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<h3><span id="7-压缩列表">7、压缩列表</span></h3><p>压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<p>　　<strong>压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312144033.png" alt></p>
<p>　压缩列表的每个节点构成如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312144116.png" alt></p>
<p>①、previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。</p>
<p>②、encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。</p>
<p>③、content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。</p>
<h3><span id="8-总结">8、总结</span></h3><p>​        大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。</p>
<p>　　通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。</p>
<p>　　Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。</p>
<p>　　跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。</p>
<p>　　整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。</p>
<p>　　压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。</p>
<h3><span id="参考资料">参考资料</span></h3><p><a href="https://www.cnblogs.com/ysocean/p/9080940.html">Redis详解（三）—— redis的六大数据类型详细用法 - YSOcean - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>STL 的 erase( ) 陷阱-迭代器失效总结</title>
    <url>/b12cd95a/</url>
    <content><![CDATA[<p>STL中的容器按存储方式分为两类，一类是按以数组形式存储的容器（如：vector 、deque)；另一类是以不连续的节点形式存储的容器（如：list、set、map）。在使用erase方法来删除元素时，需要注意一些问题。</p>
<h4><span id="1listsetmap容器"><strong>1.list,set,map容器</strong></span></h4><p>在使用 list、set 或 map遍历删除某些元素时可以这样使用：</p>
<p><strong><del>1.1 正确写法 1</del></strong></p>
<pre><code>std::list&lt;int&gt; list;
std::list&lt;int&gt;::iterator it_list;
for (it_list = list.begin(); it_list != list.end();)
&#123;
if (willDelete(*it_list))
&#123;
it_list = list.erase(it_list);
&#125;
else
&#123;
++it_list;
&#125;
&#125;</code></pre><p><strong>Note:</strong> 以上方法仅适用于standard sequence container, 因为对于standard associative container, erase()的返回类型为void. (查阅Effective STL Item 9)以下为原文:</p>
<pre><code>This works wonderfully, but only for the standard sequence containers. Due to reasoning one might question, erase()&apos;s return type for the standard associative containers is void. For those containers, you have to use the postincrement-the-iterator-you-pass-to-erase technique.</code></pre><p><strong>1.2 正确写法2</strong> 查阅原版Effctive STL Item 9, 证实, 下面这种写法不能用于标准序列容器, 而适用于标准关联容器, 而List也可以使用这种方法.</p>
<pre><code>std::list&lt;int&gt; list;
std::list&lt;int&gt;::iterator it_list;
for (it_list = list.begin(); it_list != list.end();)
&#123;
if (willDelete(*it_list))
&#123;
list.erase(it_list++); // 必须使用后缀自增, 不能使用前缀自增
&#125;
else
&#123;
++it_list;
&#125;
&#125;
```&lt;/int&gt;&lt;/int&gt;

**1.3 错误写法 1**</code></pre><p>std::list&lt; int&gt; List; std::list&lt; int&gt;::iterator itList; for( itList = List.begin(); itList != List.end(); itList++) { if( WillDelete( *itList) ) { List.erase( itList); } }</p>
<pre><code>**1.4 错误写法 2**</code></pre><p>std::list&lt; int&gt; List; std::list&lt; int&gt;::iterator itList; for( itList = List.begin(); itList != List.end(); ) { if( WillDelete( *itList) ) { itList = List.erase( ++itList); } else itList++; }</p>
<pre><code>**1.5 分析**

正确方法1: 通过erase()方法的返回值来获取下一个元素的位置;
正确方法2: 在调用erase()方法之前先使用&quot;++&quot; 来获取下一个元素的位置;
错误使用方法1: 在调用erase()方法之后使用&quot;++&quot; 来获取下一个元素的位置, 由于在调用erase()方法之后, 该元素的位置已经被删除, 如果再根据这个旧的位置来获取下一个位置, 则会出现异常;
错误使用方法2: 同上

####**2. vector,deque 容器**
在使用 vector、deque遍历删除元素时，也可以通过erase的返回值来获取下一个元素的位置：

**2.1 正确写法:**</code></pre><p>std::vector vec; std::vector::iterator it_vec; for (it_vec = vec.begin(); it_vec != vec.end();) { if (willDelete(*it_vec)) { it_vec = vec.erase(it_vec); } else { ++it_vec; } } ```</p>
<p><strong>2.2 注意</strong></p>
<p>vector, deque 不能像上面的”正确方法2” 的办法来遍历删除. 原因请参考Effective STL条款9。摘录到下面： 1) 对于关联容器(如map, set, multimap, multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。</p>
<pre><code>for (iter = cont.begin(); it != cont.end();)
&#123;
(*iter)-&amp;gt;doSomething();
if (shouldDelete(*iter))
cont.erase(iter++);
else
++iter;
&#125;</code></pre><p>因为iter传给erase方法的是一个副本，iter++会指向下一个元素。</p>
<p>2) 对于序列式容器(如vector, deque)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor, deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase()方法可以返回下一个有效的iterator。</p>
<pre><code>for (iter = cont.begin(); iter != cont.end();)
&#123;
(*it)-&amp;gt;doSomething();
if (shouldDelete(*iter))
iter = cont.erase(iter);
else
++iter;
&#125;</code></pre><p>3)对于list来说，它使用了不连续分配的内存，并且它的erase()方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。</p>
<h4><span id="3-其他"><strong>3. 其他</strong></span></h4><p><strong>set</strong> 键和值相等。 键唯一。 元素默认按升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</p>
<p><strong>map</strong> 键唯一。 元素默认按键的升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</p>
<p><a href="http://mp.weixin.qq.com/s/qonNrKKZLladvIwvurQCTA">作成参考地址</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 中的冒号</title>
    <url>/9aa135a6/</url>
    <content><![CDATA[<p>冒号(:) 是一个空命令. 作用与true相同. “:”是一个bash内建命令, 返回值为0, 即与true相同. 例:</p>
<pre><code>:
echo $?  # 0</code></pre><p>死循环</p>
<pre><code>while :
do
    list_1
    list_2
done</code></pre><p>if/then 中的占位符</p>
<pre><code>if list
then : # 什么都不做, 引出分支
else
    take-some-action
fi</code></pre><p>在一个2元命令中, 提供一个占位符, 表明后面的表达式, 不是一个命令, 如</p>
<pre><code>:$((n=$n+1)</code></pre><p>如果没有:, bash会尝试把”$((n=$n+1))” 解释成一个命令</p>
<p>使用”参数替换” 来评估字符串变量</p>
<pre><code>:$&#123;HOSTNAME?&#125;$&#123;USER?&#125;$&#123;MAIL?&#125;
# 如果一个或多个环境变量没有设置, 则打印错误信息</code></pre><p>在和&gt;(重定向符号)结合使用时, 把一个文件截断到0长度, 不修改它的权限. 如果文件不存在, 则创建它</p>
<pre><code>: &gt; data.xxx # 文件&quot;data.xxx&quot; 被清空
# 与 cat /dev/null &gt; data.xxx 作用相同, 但是不会产生一个新的进程, 因为:是一个内建命令.</code></pre><p>只适用于普通文件, 不适用于管道, 符号链接, 和其他特殊文件.</p>
<p>也可以用作注释, :与#不同的是, :不会关闭剩余行的错误检查.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell数组笔记</title>
    <url>/21c4d609/</url>
    <content><![CDATA[<p>Bash shell 只支持一维数组. 初始化时不需要定义数组大小(与 PHP 类似). 数组元素的下标由0开始</p>
<p>shell 数组用括号来表示, 元素用”空格”符号分隔开, 语法: <code>array_name=(value1 value2 ...valuen)</code></p>
<h3><span id="实例">实例</span></h3><pre><code>#!/bin/bash
my_array=(A B &quot;C&quot; D)</code></pre><p>也可以用下标来定义数组</p>
<pre><code>array_name[0]=value0
array_name[1]=value1
array_name[2]=value2</code></pre><h3><span id="读取数组">读取数组</span></h3><p><code>$&#123;array_name[index]&#125;</code></p>
<h3><span id="实例">实例</span></h3><pre><code>#!/bin/bash

my_array=(A B &quot;C&quot; D)

echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;
echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;
echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;
echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</code></pre><h3><span id="获取数组中的所有元素">获取数组中的所有元素</span></h3><p>使用<code>@</code> 或 <code>*</code> 可以后去数组中的所有元素</p>
<pre><code>#!/bin/bash

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;
echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</code></pre><h3><span id="获取数组的长度">获取数组的长度</span></h3><p>获取数组长度的方法与获取字符串长度的方法相同</p>
<pre><code>#!/bin/bash

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo &quot;数组元素个数为: $</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol Names of Keyboard</title>
    <url>/2d9f52fc/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">符号	英文名	中文名</span><br><span class="line">~	tilde or swung dash	波浪字符或代字号</span><br><span class="line">!	exclamation mark	惊叹号</span><br><span class="line">@	at sign or commercial at	爱特或小老鼠</span><br><span class="line"><span class="comment">#	number sign	井号</span></span><br><span class="line">$	dollar sign	美元符</span><br><span class="line">%	percent sign	百分号</span><br><span class="line">^	caret	脱字符</span><br><span class="line">&amp;	ampersand	与和符</span><br><span class="line">*	asterisk	星号</span><br><span class="line">()	parentheses, round brackets, soft brackets, </span><br><span class="line">	or circle brackets 	小括号，圆括号</span><br><span class="line">[]	brackets (US), square brackets, </span><br><span class="line">	closed brackets or hard brackets	中括号，方括号</span><br><span class="line">&#123;&#125;	braces (UK and US), French brackets, </span><br><span class="line">	curly brackets	大括号，花括号</span><br><span class="line">&lt;&gt; 	angle brackets or chevrons	尖括号</span><br><span class="line">_	underscore	下划线</span><br><span class="line">+	plus sign	加号</span><br><span class="line">−	minus sign	减号</span><br><span class="line">=	equals sign	等号</span><br><span class="line">&lt; 	less-than sign	小于号</span><br><span class="line">&gt; 	greater-than sign	大于号</span><br><span class="line">.	period, full stop or dot	句号，点</span><br><span class="line">,	comma	逗号</span><br><span class="line">:	colon 	冒号</span><br><span class="line">;	semicolon	分号</span><br><span class="line">?	question mark	问号</span><br><span class="line">-	hyphen	连字符</span><br><span class="line">...	ellipsis	省略号</span><br><span class="line">–	dash	破折号</span><br><span class="line">/	slash, forward slash	斜线</span><br><span class="line">\	backslash	反斜线</span><br><span class="line">|	vertical bar	竖线</span><br><span class="line">“	quotation mark	双引号</span><br><span class="line">‘	apostrophe	单引号，省略符号</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的线程模型</title>
    <url>/9106c914/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#文件事件处理器">文件事件处理器</a></li>
<li><a href="#消息处理流程">消息处理流程</a></li>
<li><a href="#io-多路复用程序的实现">I/O 多路复用程序的实现</a></li>
<li><a href="#文件事件的类型">文件事件的类型</a></li>
<li><a href="#文件事件的处理器">文件事件的处理器</a><ul>
<li><a href="#连接应答处理器">连接应答处理器</a></li>
<li><a href="#命令请求处理器">命令请求处理器</a></li>
<li><a href="#命令回复处理器">命令回复处理器</a></li>
</ul>
</li>
<li><a href="#一次完整的客户端与服务器连接事件示例">一次完整的客户端与服务器连接事件示例</a></li>
<li><a href="#思考问题">思考问题</a></li>
</ul>
<!-- tocstop -->

<h2><span id="文件事件处理器">文件事件处理器</span></h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个<a href="https://so.csdn.net/so/search?q=套接字&spm=1001.2101.3001.7020">套接字</a>、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212203719.png" alt></p>
<h2><span id="消息处理流程">消息处理流程</span></h2><ul>
<li>文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都推到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p>
<h2><span id="io-多路复用程序的实现">I/O 多路复用程序的实现</span></h2><p>Redis的I/O多路复用程序的所有功能是通过包装select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c等。</p>
<p>因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212203919.png" alt></p>
<p>Redis在I/O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最好的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></span><br><span class="line"><span class="comment"> * The following should be ordered by performances, descending. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="文件事件的类型">文件事件的类型</span></h2><p>I/O 多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p>
<ul>
<li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE 事件</li>
<li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE 事件。这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</li>
</ul>
<h2><span id="文件事件的处理器">文件事件的处理器</span></h2><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通讯需求，常用的处理器如下：</p>
<p>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。<br>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。<br>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</p>
<h3><span id="连接应答处理器">连接应答处理器</span></h3><p>networking.c中acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p>
<p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候， 套接字就会产生AE_READABLE 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作，如图所示。<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212204113.png" alt></p>
<h3><span id="命令请求处理器">命令请求处理器</span></h3><p>networking.c中readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容， 具体实现为unistd.h/read函数的包装。</p>
<p>当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生 AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图所示。<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212204151.png" alt></p>
<p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p>
<h3><span id="命令回复处理器">命令回复处理器</span></h3><p>networking.c中sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p>
<p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作， 如图所示。<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212204231.png" alt></p>
<p>当命令回复发送完毕之后， 服务器就会解除命令回复处理器与客户端套接字的 AE_WRITABLE 事件之间的关联</p>
<h2><span id="一次完整的客户端与服务器连接事件示例">一次完整的客户端与服务器连接事件示例</span></h2><p>假设Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p>
<p>如果这时有一个Redis客户端向Redis服务器发起连接，那么监听套接字将产生AE_READABLE事件， 触发连接应答处理器执行：处理器会对客户端的连接请求进行应答， 然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p>
<p>之后，客户端向Redis服务器发送一个命令请求，那么客户端套接字将产生 AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容， 然后传给相关程序去执行。</p>
<p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联：当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件， 触发命令回复处理器执行， 当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220212204316.png" alt> </p>
<h2><span id="思考问题">思考问题</span></h2><p>Q：<br>Redis是单线程模型为什么效率还这么高？<br>A：</p>
<p>纯内存访问：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。<br>非阻塞I/O：Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。<br>单线程避免了线程切换和竞态产生的消耗。<br>Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议中的三次握手和四次挥手</title>
    <url>/5fa4c221/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-准备">1. 准备</a></li>
<li><a href="#2tcp三次握手简述">2.TCP三次握手简述</a><ul>
<li><a href="#21-第一次握手">2.1 第一次握手</a></li>
<li><a href="#23-第三次握手">2.3 第三次握手</a></li>
<li><a href="#24-实例观察">2.4 实例观察</a><ul>
<li><a href="#241-tcpdump">2.4.1 tcpdump</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3tcp三次握手详细解析过程">3.TCP三次握手详细解析过程：</a><ul>
<li><a href="#31-第一次握手">3.1 第一次握手</a><ul>
<li><a href="#311-半连接队列syn-queue未满">3.1.1 半连接队列(syn queue)未满</a></li>
<li><a href="#312-半连接队列syn-queue已满">3.1.2 半连接队列(syn queue)已满</a></li>
</ul>
</li>
<li><a href="#32-第二次握手">3.2 第二次握手</a></li>
<li><a href="#33-第三次握手">3.3 第三次握手</a><ul>
<li><a href="#331-全连接队列accept-queue未满">3.3.1 全连接队列(accept queue)未满</a></li>
<li><a href="#332-全连接队列accept-queue已满">3.3.2 全连接队列(accept queue)已满</a><ul>
<li><a href="#3321-tcp_abort_on_overflow-0">3.3.2.1 tcp_abort_on_overflow = 0</a></li>
<li><a href="#3322-tcp_abort_on_overflow-1">3.3.2.2 tcp_abort_on_overflow = 1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-四次挥手">4 四次挥手</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1-准备">1. 准备</span></h1><p>TCP是属于网络分层中的运输层(有的书也翻译为传输层)，<br>分层以及每层的协议，TCP是属于运输层(有的书也翻译为传输层)，如下两张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311145804.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311145821.png" alt></p>
<p>TCP<a href="https://so.csdn.net/so/search?q=三次握手&spm=1001.2101.3001.7020">三次握手</a>会涉及到状态转换所以这里贴出TCP的状态转换图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311145910.png" alt></p>
<h1><span id="2tcp三次握手简述">2.TCP三次握手简述</span></h1><p>要想简单了解TCP三次握手，我们首先要了解TCP头部结构，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311145957.png" alt></p>
<p>TCP传递给IP层的信息单位称为<strong>报文段或段</strong>，下面都用<strong>段</strong>做单位。</p>
<p>TCP三次握手如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311150026.png" alt></p>
<h2><span id="21-第一次握手">2.1 第一次握手</span></h2><p>客户端给服务器发送一个SYN段(在 TCP 标头中 SYN 位字段为 <strong>1</strong> 的 TCP/IP 数据包), 该段中也包含客户端的初始序列号(Sequence number = J)。</p>
<blockquote>
<p>SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接</p>
</blockquote>
<p>2.2 第二次握手<br>服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)， 该段中包含服务器的初始序列号(Sequence number = K)；同时使 Acknowledgment number = J + 1来表示确认已收到客户端的 SYN段(Sequence number = J)。</p>
<blockquote>
<p>ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包</p>
</blockquote>
<h2><span id="23-第三次握手">2.3 第三次握手</span></h2><p>客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 <strong>1</strong> 的 TCP/IP 数据包), 该段中使 Acknowledgment number = K + 1来表示确认已收到服务器的 SYN段(Sequence number = K)。</p>
<h2><span id="24-实例观察">2.4 实例观察</span></h2><h3><span id="241-tcpdump">2.4.1 tcpdump</span></h3><p>使用tcpdump观察如下：因为都是在本机同时运行client和server所以命令为：<code>tcpdump -i lo port 5555</code>, 只能监听回路lo接口，结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311150222.png" alt></p>
<p>如图用红色圈起来的就是3次握手，但是为什么最后一次握手，为什么ack = 1,而不是369535922 呢，<br>这是因为这里的第三次握手tcpdump显示的是相对的顺序号。但是为了便于观察我们需要把tcpdump的<br>顺序号变为绝对的顺序号。</p>
<p>命令只需要加-S(大写)便可，即：<code>tcpdump -i lo port 5555 -S</code></p>
<p>加上之后结果就正常了如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311150312.png" alt></p>
<p>从tcpdump的数据，可以明显的看到三次握手的过程是：<br>第一次握手：client SYN=1, Sequence number=2322326583 —&gt; server<br>第二次握手：server SYN=1,Sequence number=3573692787; ACK=1, Acknowledgment number=2322326583 + 1 —&gt; client<br>第三次握手：client ACK=1, Acknowledgment number=3573692787 + 1 –&gt;server</p>
<p>想简单了解一下TCP三次握手的话, 看到这里就可以了.</p>
<h1><span id="3tcp三次握手详细解析过程">3.TCP三次握手详细解析过程：</span></h1><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311151642.png" alt></p>
<h2><span id="31-第一次握手">3.1 第一次握手</span></h2><p>客户在socket() connect()后主动(active open)连接上服务器, 发送SYN ，这时客户端的状态是SYN_SENT<br>服务器在进行socket(),bind(),listen()后等待客户的连接，收到客户端的 SYN 后，</p>
<h3><span id="311-半连接队列syn-queue未满">3.1.1 半连接队列(syn queue)未满</span></h3><p>服务器将该连接的状态变为SYN_RCVD, 服务器把连接信息放到半连接队列(syn queue)里面。</p>
<h3><span id="312-半连接队列syn-queue已满">3.1.2 半连接队列(syn queue)已满</span></h3><p>服务器不会将该连接的状态变为SYN_RCVD，且将该连接丢弃(SYN flood攻击就是利用这个原理，<br>对于SYN foold攻击，应对方法之一是使syncookies生效，将其值置1即可，路径/proc/sys/net/ipv4/tcp_syncookies，<br>即使是半连接队列syn queue已经满了，也可以接收正常的非恶意攻击的客户端的请求，<br>但是这种方法只在无计可施的情况下使用，man tcp里面的解析是这样说的，<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311151743.png" alt></p>
<p>Centos6.9默认是置为1</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311151840.png" alt></p>
<p>半连接队列(syn queue)最大值 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311151858.png" alt></p>
<p><strong>SYN flood攻击</strong></p>
<blockquote>
<p>攻击方的客户端只发送SYN分节给服务器，然后对服务器发回来的SYN+ACK什么也不做，直接忽略掉，<br>不发送ACK给服务器；这样就可以占据着服务器的半连接队列的资源，导致正常的客户端连接无法连接上服务器。<a href="https://zh.wikipedia.org/wiki/SYN_flood">维基百科</a></p>
<p>(SYN flood攻击的方式其实也分两种，第一种，攻击方的客户端一直发送SYN，对于服务器回应的SYN+ACK什么也不做，不回应ACK, 第二种，攻击方的客户端发送SYN时，将源IP改为一个虚假的IP, 然后服务器将SYN+ACK发送到虚假的IP, 这样当然永远也得不到ACK的回应。)</p>
</blockquote>
<h2><span id="32-第二次握手">3.2 第二次握手</span></h2><p>服务器返回SYN+ACK段给到客户端，客户端收到SYN+ACK段后，客户端的状态从SYN_SENT变为ESTABLISHED，<br>也即是connect()函数的返回。</p>
<h2><span id="33-第三次握手">3.3 第三次握手</span></h2><p>全连接队列(accept queue)的最大值 /proc/sys/net/core/somaxconn (默认128)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152107.png" alt></p>
<p>全连接队列值 = min(backlog, somaxconn)<br>这里的backlog是listen(int sockfd, int backlog)函数里面的那个参数backlog</p>
<h3><span id="331-全连接队列accept-queue未满">3.3.1 全连接队列(accept queue)未满</span></h3><p>服务器收到客户端发来的ACK, 服务端该连接的状态从SYN_RCVD变为ESTABLISHED,<br>然后服务器将该连接从半连接队列(syn queue)里面移除，且将该连接的信息放到全连接队列(accept queue)里面。</p>
<h3><span id="332-全连接队列accept-queue已满">3.3.2 全连接队列(accept queue)已满</span></h3><p>服务器收到客户端发来的ACK, 不会将该连接的状态从SYN_RCVD变为ESTABLISHED。<br>当然全连接队列(accept queue)已满时，则根据 tcp_abort_on_overflow 的值来执行相应动作<br>/proc/sys/net/ipv4/tcp_abort_on_overflow 查看参数值<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152138.png" alt></p>
<h4><span id="3321-tcp_abort_on_overflow-0">3.3.2.1 tcp_abort_on_overflow = 0</span></h4><p>则服务器建立该连接的定时器，</p>
<blockquote>
<p>这个定时器是一个服务器的规则是从新发送syn+ack的时间间隔成倍的增加，<br>比如从新了第二次握手，进行了5次，这五次的时间分别是 1s, 2s,4s,8s,16s,<br>这种倍数规则叫“二进制指数退让”(binary exponential backoff)</p>
</blockquote>
<p>给客户端定时从新发回SYN+ACK即从新进行第二次握手，(如果客户端设定的超时时间比较短就很容易出现异常)<br><code>服务器从新进行第二次握手的次数/proc/sys/net/ipv4/tcp_synack_retries</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152221.png" alt></p>
<h4><span id="3322-tcp_abort_on_overflow-1">3.3.2.2 tcp_abort_on_overflow = 1</span></h4><p>关于tcp_abort_on_overflow的解析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152247.png" alt></p>
<p>意思应该是，当 tcp_abort_on_overflow 等于1 时,重置连接(一般是发送RST给客户端)，<br>至于怎么重置连接是系统的事情了。<br>不过我在查资料的过程发现，阿里中间件团队博客说并不是发送RST， —[阿里中间件团队博客]</p>
<p>这个博客跑的实例观察到的是服务器会忽略client传过来的包，然后client重传，一定次数后client认为异常，然后断开连接。<br>当然，我们写代码的都知道代码是第一手的注释，实践是检验真理的唯一标准，<br>最好还是自己以自己实践为准，因为可能你的环境跟别人的不一样。)</p>
<p>查看全连接队列(accept queue)的使用情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152314.png" alt></p>
<p>如上图，第二列Recv-Q是，全连接队列接收到达的连接，第三列是Send-Q全连接队列的所能容纳最大值，<br>如果，Recv-Q 大于 Send-Q 那么大于的那部分，是要溢出的即要被丢弃overflow掉的。</p>
<p>希望热心的网友帮忙提改进意见时可以直接指出哪一段第几句(比如 2.4.1 tcpdump 第一段第一句, 命令tcpdump -i lo port 5555 里参数 i 用错了，应该用 I)，这样比较快速找到好改正。</p>
<h1><span id="4-四次挥手">4 四次挥手</span></h1><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152407.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152602.png" alt></p>
<p><strong>【注意】中断连接端可以是Client端，也可以是Server端。</strong></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p>整个过程Client端所经历的状态如下：<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152636.png" alt></p>
<p>而Server端所经历的过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220311152709.png" alt></p>
<p><strong>【注意】</strong> 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<p>根据第三版《UNIX网络编程 卷1》2.7节，TIME_WAIT状态的主要目的有两个：</p>
<ul>
<li>优雅的关闭TCP连接，也就是尽量保证被动关闭的一端收到它自己发出去的FIN报文的ACK确认报文；</li>
<li>处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。</li>
</ul>
<p>　　很明显，要实现上述两个目标，TIME_WAIT状态需要持续一段时间，但这段时间应该是多长呢？</p>
<p>　　如果只考虑上述第一个目标，则TIME_WAIT状态需要持续的时间应该参考对端的RTO（重传超时时间）以及MSL（报文在网络中的最大生存时间）来计算而不是仅仅按MSL来计算，因为只要对端没有收到针对FIN报文的ACK，就会一直持续重传FIN报文直到重传超时，所以最能实现完美关闭连接的时长计算方式应该是从对端发送第一个FIN报文开始计时到它最后一次重传FIN报文这段时长加上MSL，但这个计算方式过于保守，只有在所有的ACK报文都丢失的情况下才需要这么长的时间；另外，第一个目标虽然重要，但并不十分关键，因为既然已经到了关闭连接的最后一步，说明在这个TCP连接上的所有用户数据已经完成可靠传输，所以要不要完美的关闭这个连接其实已经不是那么关键了。因此，（我猜）RFC标准的制定者才决定以网络丢包不太严重为前提条件，然后根据第二个目标来计算TIME_WAIT状态应该持续的时长。</p>
<p>对于刚才说的第二点，如何理解TIME_WAIT状态持续2MSL的时间就可以避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接呢？</p>
<p>首先我们需要了解如下要点：</p>
<ol>
<li>TCP连接中的一端发送了FIN报文之后如果收不到对端针对该FIN的ACK，则会反复多次重传FIN报文，大约持续几分钟；</li>
<li>被动关闭处于LAST_ACK状态的一端在收到最后一个ACK之后不会发送任何报文，立即进入CLOSED状态；</li>
<li>主动关闭的一端在收到被动关闭端发送过来的FIN报文并回复ACK之后进入TIME_WAIT状态；</li>
<li>之所以TIME_WAIT状态需要维持一段时间而不是进入CLOSED状态，是因为需要处理对端可能重传的FIN报文或其它一些因网络原因而延迟的数据报文，不处理这些报文可能导致前后两个使用相同四元组的连接中的后一个连接出现异常(详见UNIX网络编程卷1的2.7节 第三版)；</li>
<li>处于TIME_WAIT状态的一端在收到重传的FIN时会重新计时(rfc793 以及 linux kernel源代码tcp_timewait_state_process函数)。</li>
</ol>
<p>　　下面我们开始分析为什么在发送了最后一个ACK报文之后需要等待2MSL时长来确保没有任何属于当前连接的报文还存活于网络之中（前提是在这2MSL时间内不再收到对方的FIN报文，但即使收到了对端的FIN报文也并不影响我们的讨论，因为如果收到FIN则会回复ACK并重新计时）。</p>
<p>　　为了便于描述，我们设想有一个处于拆链过程中的TCP连接，这个连接的两端分别是A和B，其中A是主动关闭连接的一端，因为刚刚向对端发送了针对对端发送过来的FIN报文的ACK，此时正处于TIME_WAIT状态；而B是被动关闭的一端，此时正处于LAST_ACK状态，在收到最后一个ACK之前它会一直重传FIN报文直至超时。随着时间的流逝，A发送给B的ACK报文将会有两种结局：</p>
<ol>
<li>ACK报文在网络中丢失；如前所述，这种情况我们不需要考虑，因为除非多次重传失败，否则AB两端的状态不会发生变化直至某一个ACK不再丢失。</li>
<li>ACK报文被B接收到。我们假设A发送了ACK报文后过了一段时间t之后B才收到该ACK，则有 0 &lt; t &lt;= MSL。因为A并不知道它发送出去的ACK要多久对方才能收到，所以A至少要维持MSL时长的TIME_WAIT状态才能保证它的ACK从网络中消失。同时处于LAST_ACK状态的B因为收到了ACK，所以它直接就进入了CLOSED状态，而不会向网络发送任何报文。所以晃眼一看，A只需要等待1个MSL就够了，但仔细想一下其实1个MSL是不行的，因为在B收到ACK前的一刹那，B可能因为没收到ACK而重传了一个FIN报文，这个FIN报文要从网络中消失最多还需要一个MSL时长，所以A还需要多等一个MSL。</li>
</ol>
<p>　　综上所述，TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。另外，虽然说维持TIME_WAIT状态一段时间有2个目的，但这段时间具体应该多长主要是为了达成上述第二个目的而设计的。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>SLO 和 SLA 的区别</title>
    <url>/ee700d45/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#service">Service</a></li>
<li><a href="#sli">SLI</a><ul>
<li><a href="#1-常见的测量指标有以下几个方面">1. 常见的测量指标有以下几个方面：</a></li>
<li><a href="#2-测量时的系统状态在什么情况下测量会严重影响测量的结果">2. 测量时的系统状态，在什么情况下测量会严重影响测量的结果</a></li>
<li><a href="#3-如何汇总处理测量的指标">3. 如何汇总处理测量的指标？</a></li>
<li><a href="#4-测量指标能否准确描述服务质量">4. 测量指标能否准确描述服务质量？</a></li>
<li><a href="#5-测量指标的可靠度">5. 测量指标的可靠度</a></li>
</ul>
</li>
<li><a href="#slo">SLO</a></li>
<li><a href="#sla">SLA</a></li>
</ul>
<!-- tocstop -->

<h2><span id="前言">前言</span></h2><p><strong>SLO和SLA是大家常见的两个名词：服务等级目标和服务等级协议。</strong></p>
<p>云计算时代，各大云服务提供商都发布有自己服务的SLA条款，比如Amazon的EC2和S3服务都有相应的SLA条款。这些大公司的SLA看上去如此的高达上，一般是怎么定义出来的呢？本文就尝试从技术角度解剖一下SLA的制定过程。</p>
<p>说SLA不能不提SLO，这个是众所周知的，但是还有一个概念知道的人就不多了，那就是SLI（Service Level Indicator），<strong>定义一个可执行的SLA，好的SLO和SLI是必不可少的</strong>。</p>
<p>再有就是SLI/SLO/SLA都是和服务联系在一起的，脱离了服务这三个概念就没有什么意义了。</p>
<h2><span id="service">Service</span></h2><p><strong>什么是服务？</strong></p>
<p>简单说就是一切提供给客户的有用功能都可以称为服务。</p>
<p>服务一般会由服务提供者提供，提供这个有用功能的组织被称为服务提供者，通常是人加上软件，软件的运行需要计算资源，为了能对外提供有用的功能软件可能会有对其他软件系统的依赖。</p>
<p>客户是使用服务提供者提供的服务的人或公司。</p>
<h2><span id="sli">SLI</span></h2><p>SLI是经过仔细定义的测量指标，它根据不同系统特点确定要测量什么，SLI的确定是一个非常复杂的过程。</p>
<p><strong>SLI的确定需要回答以下几个问题：</strong></p>
<ol>
<li>要测量的指标是什么？</li>
<li>测量时的系统状态？</li>
<li>如何汇总处理测量的指标？</li>
<li>测量指标能否准确描述服务质量？</li>
<li>测量指标的可靠度(trustworthy)？</li>
</ol>
<h3><span id="1-常见的测量指标有以下几个方面">1. 常见的测量指标有以下几个方面：</span></h3><ul>
<li><p>性能</p>
</li>
<li><ul>
<li>响应时间(latency)<ul>
<li>吞吐量(throughput)</li>
<li>请求量(qps)</li>
<li>实效性(freshness)</li>
</ul>
</li>
</ul>
</li>
<li><p>可用性</p>
</li>
<li><ul>
<li>运行时间(uptime)<ul>
<li>故障时间/频率</li>
<li>可靠性</li>
</ul>
</li>
</ul>
</li>
<li><p>质量</p>
</li>
<li><ul>
<li>准确性(accuracy)<ul>
<li>正确性(correctness)</li>
<li>完整性(completeness)</li>
<li>覆盖率(coverage)</li>
<li>相关性(relevance)</li>
</ul>
</li>
</ul>
</li>
<li><p>内部指标</p>
</li>
<li><ul>
<li>队列长度(queue length)<ul>
<li>内存占用(RAM usage)</li>
</ul>
</li>
</ul>
</li>
<li><p>因素人</p>
</li>
<li><ul>
<li>响应时间(time to response)<ul>
<li>修复时间(time to fix)</li>
<li>修复率(fraction fixed)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>下面通过一个例子来说明一下：</strong>hotmail的downtime SLI</p>
<ul>
<li>错误率(error rate)计算的是服务返回给用户的error总数</li>
<li>如果错误率大于X%，就算是服务down了，开始计算downtime</li>
<li>如果错误率持续超过Y分钟，这个downtime就会被计算在内</li>
<li>间断性的小于Y分钟的downtime是不被计算在内的。</li>
</ul>
<h3><span id="2-测量时的系统状态在什么情况下测量会严重影响测量的结果">2. 测量时的系统状态，在什么情况下测量会严重影响测量的结果</span></h3><ul>
<li>测量异常(badly-formed)请求，还是失败(fail)请求还是超时请求(timeout)</li>
<li>测量时的系统负载（是否最大负载）</li>
<li>测量的发起位置，服务器端还是客户端</li>
<li>测量的时间窗口（仅工作日、还是一周7天、是否包括计划内的维护时间段）</li>
</ul>
<h3><span id="3-如何汇总处理测量的指标">3. 如何汇总处理测量的指标？</span></h3><ul>
<li>计算的时间区间是什么：是一个滚动时间窗口，还是简单的按照月份计算</li>
<li>使用平均值还是百分位值，比如：某服务X的ticket处理响应时间SLI的</li>
<li>测量指标：统计所有成功解决请求，从用户创建ticket到问题被解决的时间</li>
<li>怎么测量：用ticket自带的时间戳，统计所有用户创建的ticket</li>
<li>什么情况下的测量：只包括工作时间，不包含法定假日</li>
<li>用于SLI的数据指标：以一周为滑动窗口，95%分位的解决时间</li>
</ul>
<h3><span id="4-测量指标能否准确描述服务质量">4. 测量指标能否准确描述服务质量？</span></h3><ul>
<li>性能：时效性、是否有偏差</li>
<li>准确性：精度、覆盖率、数据稳定性</li>
<li>完整性：数据丢失、无效数据、异常(outlier)数据</li>
</ul>
<h3><span id="5-测量指标的可靠度">5. 测量指标的可靠度</span></h3><ul>
<li>是否服务提供者和客户都认可</li>
<li>是否可被独立验证，比如三方机构</li>
<li>客户端还是服务器端测量，取样间隔</li>
<li>错误请求是如何计算的</li>
</ul>
<h2><span id="slo">SLO</span></h2><p><strong>SLO(服务等级目标)</strong>指定了服务所提供功能的一种期望状态。SLO里面应该包含什么呢？所有能够描述服务应该提供什么样功能的信息。</p>
<p>服务提供者用它来指定系统的预期状态；开发人员编写代码来实现；客户依赖于SLO进行商业判断。SLO里没有提到，如果目标达不到会怎么样。</p>
<p><strong>SLO是用SLI来描述的，一般描述为：</strong><br>比如以下SLO：</p>
<ul>
<li>每分钟平均qps &gt; 100k/s</li>
<li>99% 访问延迟 &lt; 500ms</li>
<li>99% 每分钟带宽 &gt; 200MB/s</li>
</ul>
<p><strong>设置SLO时的几个最佳实践：</strong></p>
<ul>
<li>指定计算的时间窗口</li>
<li>使用一致的时间窗口(XX小时滚动窗口、季度滚动窗口)</li>
<li>要有一个免责条款，比如：95%的时间要能够达到SLO</li>
</ul>
<p>如果Service是第一次设置SLO，可以遵循以下原则</p>
<ul>
<li><p>测量系统当前状态</p>
</li>
<li><ul>
<li>设置预期(expectations)，而不是保证(guarantees)<ul>
<li>初期的SLO不适合作为服务质量的强化工具</li>
</ul>
</li>
</ul>
</li>
<li><p>改进SLO</p>
</li>
<li><ul>
<li>设置更低的响应时间、更改的吞吐量等</li>
</ul>
</li>
<li><p>保持一定的安全缓冲</p>
</li>
<li><ul>
<li>内部用的SLO要高于对外宣称的SLO</li>
</ul>
</li>
<li><p>不要超额完成</p>
</li>
<li><ul>
<li>定期的downtime来使SLO不超额完成</li>
</ul>
</li>
</ul>
<p>设置SLO时的目标依赖于系统的不同状态(conditions)，根据不同状态设置不同的SLO：<strong>总SLO = service1.SLO1 *weight1 service2.SLO2* weight2 …</strong></p>
<p>为什么要有SLO，设置SLO的好处是什么呢？</p>
<ul>
<li><p>对于客户而言，是可预期的服务质量，可以简化客户端的系统设计</p>
</li>
<li><p>对于服务提供者而言</p>
</li>
<li><ul>
<li>可预期的服务质量<ul>
<li>更好的取舍成本/收益</li>
<li>更好的风险控制(当资源受限的时候)</li>
<li>故障时更快的反应，采取正确措施</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SLO设好了，怎么保证能够达到目标呢？<br>需要一个控制系统来：</p>
<ul>
<li>监控/测量SLIs</li>
<li>对比检测到的SLIs值是否达到目标</li>
<li>如果需要，修证目标或者修正系统以满足目标需要</li>
<li>实施目标的修改或者系统的修改</li>
</ul>
<p>该控制系统需要重复的执行以上动作，以形成一个标准的反馈环路，不断的衡量和改进SLO/服务本身。</p>
<p>我们讨论了目标以及目标是怎么测量的，还讨论了控制机制来达到设置的目标，但是如果因为某些原因，设置的目标达不到该怎么办呢？</p>
<p>也许是因为大量的新增负载；也许是因为底层依赖不能达到标称的SLO而影响上次服务的SLO。这就需要SLA出场了。</p>
<h2><span id="sla">SLA</span></h2><p>SLA是一个涉及2方的合约，双方必须都要同意并遵守这个合约。当需要对外提供服务时，SLA是非常重要的一个服务质量信号，需要产品和法务部门的同时介入。</p>
<p>SLA用一个简单的公式来描述就是： <strong>SLA = SLO 后果</strong></p>
<ul>
<li><p>SLO不能满足的一系列动作，可以是部分不能达到</p>
</li>
<li><ul>
<li>比如：达到响应时间SLO 未达到可用性SLO</li>
</ul>
</li>
<li><p>对动作的具体实施</p>
</li>
<li><ul>
<li>需要一个通用的货币来奖励/惩罚，比如：钱</li>
</ul>
</li>
</ul>
<p>SLA是一个很好的工具，可以用来帮助合理配置资源。一个有明确SLA的服务最理想的运行状态是：<strong>增加额外资源来改进系统所带来的收益小于把该资源投给其他服务所带来的收益。</strong></p>
<p>一个简单的例子就是某服务可用性从99.9%提高到99.99%所需要的资源和带来的收益之比，是决定该服务是否应该提供4个9的重要依据。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux 使用教程</title>
    <url>/176a23be/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-tmux-是什么">1 Tmux 是什么？</a><ul>
<li><a href="#11-会话与进程">1.1 会话与进程</a></li>
<li><a href="#12-tmux-的作用">1.2 Tmux 的作用</a></li>
</ul>
</li>
<li><a href="#2-基本用法">2 基本用法</a><ul>
<li><a href="#21-安装">2.1 安装</a></li>
<li><a href="#22-启动与退出">2.2 启动与退出</a></li>
<li><a href="#23-前缀键">2.3 前缀键</a></li>
</ul>
</li>
<li><a href="#3-会话管理">3 会话管理</a><ul>
<li><a href="#31-新建会话">3.1 新建会话</a></li>
<li><a href="#32-分离会话">3.2 分离会话</a></li>
<li><a href="#33-接入会话">3.3 接入会话</a></li>
<li><a href="#34-杀死会话">3.4 杀死会话</a></li>
<li><a href="#35-切换会话">3.5 切换会话</a></li>
<li><a href="#36-重命名会话">3.6 重命名会话</a></li>
<li><a href="#37-会话快捷键">3.7 会话快捷键</a></li>
</ul>
</li>
<li><a href="#4-最简操作流程">4 最简操作流程</a></li>
<li><a href="#5-窗格操作">5 窗格操作</a><ul>
<li><a href="#51-划分窗格">5.1 划分窗格</a></li>
<li><a href="#52-移动光标">5.2 移动光标</a></li>
<li><a href="#53-交换窗格位置">5.3 交换窗格位置</a></li>
<li><a href="#54-窗格快捷键">5.4 窗格快捷键</a></li>
</ul>
</li>
<li><a href="#6-窗口管理">6 窗口管理</a><ul>
<li><a href="#61-新建窗口">6.1 新建窗口</a></li>
<li><a href="#62-切换窗口">6.2 切换窗口</a></li>
<li><a href="#63-重命名窗口">6.3 重命名窗口</a></li>
<li><a href="#64-窗口快捷键">6.4 窗口快捷键</a></li>
</ul>
</li>
<li><a href="#7-其他命令">7 其他命令</a></li>
<li><a href="#8-参考链接">8 参考链接</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-tmux-是什么">1 Tmux 是什么？</span></h2><h3><span id="11-会话与进程">1.1 会话与进程</span></h3><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p>
<p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://lxb.wiki/2e3ff18f/">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p>
<p>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p>
<p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p>
<h3><span id="12-tmux-的作用">1.2 Tmux 的作用</span></h3><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p>
<blockquote>
<p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p>
<p>（2） 它可以让新窗口”接入”已经存在的会话。</p>
<p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p>
<p>（4）它还支持窗口任意的垂直和水平拆分。</p>
</blockquote>
<p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p>
<h2><span id="2-基本用法">2 基本用法</span></h2><h3><span id="21-安装">2.1 安装</span></h3><p>Tmux 一般需要自己安装。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 或 Debian</span></span><br><span class="line">$ <span class="built_in">sudo</span> apt-get install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 或 Fedora</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac</span></span><br><span class="line">$ brew install tmux</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="22-启动与退出">2.2 启动与退出</span></h3><p>安装完成后，键入<code>tmux</code>命令，就进入了 Tmux 窗口。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201001437.png" alt></p>
<p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="23-前缀键">2.3 前缀键</span></h3><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p>
<p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p>
<p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p>
<h2><span id="3-会话管理">3 会话管理</span></h2><h3><span id="31-新建会话">3.1 新建会话</span></h3><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>
<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux new -s &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令新建一个指定名称的会话。</p>
<h3><span id="32-分离会话">3.2 分离会话</span></h3><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux detach</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ tmux list-session</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="33-接入会话">3.3 接入会话</span></h3><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号</span></span><br><span class="line">$ tmux attach -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称</span></span><br><span class="line">$ tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="34-杀死会话">3.4 杀死会话</span></h3><p><code>tmux kill-session</code>命令用于杀死某个会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号</span></span><br><span class="line">$ tmux kill-session -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称</span></span><br><span class="line">$ tmux kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="35-切换会话">3.5 切换会话</span></h3><p><code>tmux switch</code>命令用于切换会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号</span></span><br><span class="line">$ tmux switch -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称</span></span><br><span class="line">$ tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="36-重命名会话">3.6 重命名会话</span></h3><p><code>tmux rename-session</code>命令用于重命名会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将0号会话重命名。</p>
<h3><span id="37-会话快捷键">3.7 会话快捷键</span></h3><p>下面是一些会话相关的快捷键。</p>
<blockquote>
<ul>
<li><code>Ctrl+b d</code>：分离当前会话。</li>
<li><code>Ctrl+b s</code>：列出所有会话。</li>
<li><code>Ctrl+b $</code>：重命名当前会话。</li>
</ul>
</blockquote>
<h2><span id="4-最简操作流程">4 最简操作流程</span></h2><p>综上所述，以下是 Tmux 的最简操作流程。</p>
<blockquote>
<ol>
<li>新建会话<code>tmux new -s my_session</code>。</li>
<li>在 Tmux 窗口运行所需的程序。</li>
<li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li>
<li>下次使用时，重新连接到会话<code>tmux attach-session -t my_session</code>。</li>
</ol>
</blockquote>
<h2><span id="5-窗格操作">5 窗格操作</span></h2><p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。</p>
<h3><span id="51-划分窗格">5.1 划分窗格</span></h3><p><code>tmux split-window</code>命令用来划分窗格。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 划分上下两个窗格</span></span><br><span class="line">$ tmux split-window</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分左右两个窗格</span></span><br><span class="line">$ tmux split-window -h</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201002216.png" alt></p>
<h3><span id="52-移动光标">5.2 移动光标</span></h3><p><code>tmux select-pane</code>命令用来移动光标位置。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 光标切换到上方窗格</span></span><br><span class="line">$ tmux select-pane -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到下方窗格</span></span><br><span class="line">$ tmux select-pane -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到左边窗格</span></span><br><span class="line">$ tmux select-pane -L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标切换到右边窗格</span></span><br><span class="line">$ tmux select-pane -R</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="53-交换窗格位置">5.3 交换窗格位置</span></h3><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前窗格上移</span></span><br><span class="line">$ tmux swap-pane -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前窗格下移</span></span><br><span class="line">$ tmux swap-pane -D</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="54-窗格快捷键">5.4 窗格快捷键</span></h3><p>下面是一些窗格操作的快捷键。</p>
<blockquote>
<ul>
<li><code>Ctrl+b %</code>：划分左右两个窗格。</li>
<li><code>Ctrl+b &quot;</code>：划分上下两个窗格。</li>
<li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li>
<li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li>
<li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li>
<li><code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。</li>
<li><code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。</li>
<li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li>
<li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li>
<li><code>Ctrl+b x</code>：关闭当前窗格。</li>
<li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li>
<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>
<li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li>
<li><code>Ctrl+b q</code>：显示窗格编号。</li>
</ul>
</blockquote>
<h2><span id="6-窗口管理">6 窗口管理</span></h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p>
<h3><span id="61-新建窗口">6.1 新建窗口</span></h3><p><code>tmux new-window</code>命令用来创建新窗口。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux new-window</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个指定名称的窗口</span></span><br><span class="line">$ tmux new-window -n &lt;window-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="62-切换窗口">6.2 切换窗口</span></h3><p><code>tmux select-window</code>命令用来切换窗口。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到指定编号的窗口</span></span><br><span class="line">$ tmux select-window -t &lt;window-number&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定名称的窗口</span></span><br><span class="line">$ tmux select-window -t &lt;window-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="63-重命名窗口">6.3 重命名窗口</span></h3><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux rename-window &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="64-窗口快捷键">6.4 窗口快捷键</span></h3><p>下面是一些窗口操作的快捷键。</p>
<blockquote>
<ul>
<li><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li>
<li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li>
<li><code>Ctrl+b n</code>：切换到下一个窗口。</li>
<li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li>
<li><code>Ctrl+b w</code>：从列表中选择窗口。</li>
<li><code>Ctrl+b ,</code>：窗口重命名。</li>
</ul>
</blockquote>
<h2><span id="7-其他命令">7 其他命令</span></h2><p>下面是一些其他命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有快捷键，及其对应的 Tmux 命令</span></span><br><span class="line">$ tmux list-keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 Tmux 命令及其参数</span></span><br><span class="line">$ tmux list-commands</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前所有 Tmux 会话的信息</span></span><br><span class="line">$ tmux info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载当前的 Tmux 配置</span></span><br><span class="line">$ tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="8-参考链接">8 参考链接</span></h2><ul>
<li><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></li>
<li><a href="https://danielmiessler.com/study/tmux/">Tactical tmux: The 10 Most Important Commands</a></li>
<li><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>URL特殊字符处理</title>
    <url>/c587a198/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> hexVals[<span class="number">16</span>] = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">string CURLEncode::csUnsafeString= <span class="string">&quot;\&quot;&lt;&gt;%\\^[]`+$,@:;/!#?=&amp;&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(<span class="type">char</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string csRet;</span><br><span class="line">    csRet += <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    csRet += <span class="built_in">decToHex</span>(val, <span class="number">16</span>);   </span><br><span class="line">    <span class="keyword">return</span>  csRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">decToHex</span><span class="params">(<span class="type">char</span> num, <span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span>     temp=<span class="number">0</span>;   </span><br><span class="line">    string  csTmp;</span><br><span class="line">    <span class="type">int</span> num_char;</span><br><span class="line">    num_char = (<span class="type">int</span>) num;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// ISO-8859-1 </span></span><br><span class="line">    <span class="comment">// IF THE IF LOOP IS COMMENTED, THE CODE WILL FAIL TO GENERATE A </span></span><br><span class="line">    <span class="comment">// PROPER URL ENCODE FOR THE CHARACTERS WHOSE RANGE IN 127-255(DECIMAL)</span></span><br><span class="line">    <span class="keyword">if</span> (num_char &lt; <span class="number">0</span>)</span><br><span class="line">        num_char = <span class="number">256</span> + num_char;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (num_char &gt;= radix)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = num_char % radix;</span><br><span class="line">        num_char = (<span class="type">int</span>)<span class="built_in">floor</span>((num_char / radix) * <span class="number">1.0</span>);</span><br><span class="line">        csTmp = hexVals[temp];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    csTmp += hexVals[num_char];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(csTmp.<span class="built_in">length</span>() &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        csTmp += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    string strdecToHex = csTmp;</span><br><span class="line">    <span class="comment">// Reverse the String</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(strdecToHex.<span class="built_in">begin</span>(), strdecToHex.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> strdecToHex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUnsafe</span><span class="params">(<span class="type">char</span> compareChar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bcharfound = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> tmpsafeChar;</span><br><span class="line">    <span class="type">int</span> m_strLen = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    m_strLen = csUnsafeString.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ichar_pos = <span class="number">0</span>; ichar_pos &lt; m_strLen ;ichar_pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpsafeChar = csUnsafeString[ichar_pos]; </span><br><span class="line">        <span class="keyword">if</span>(tmpsafeChar == compareChar)</span><br><span class="line">        &#123; </span><br><span class="line">            bcharfound = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> char_ascii_value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//char_ascii_value = __toascii(compareChar);</span></span><br><span class="line">    char_ascii_value = (<span class="type">int</span>) compareChar;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(bcharfound == <span class="literal">false</span> &amp;&amp;  char_ascii_value &gt; <span class="number">32</span> &amp;&amp; char_ascii_value &lt; <span class="number">123</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// found no unsafe chars, return false       </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">URLEncode</span><span class="params">(string strEncode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string  strSrc;</span><br><span class="line">    string    strDest;   </span><br><span class="line"> </span><br><span class="line">    strSrc = strEncode;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strSrc.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = strSrc[i];</span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ch = ch;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isUnsafe</span>(ch))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Safe Character               </span></span><br><span class="line">            strDest += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get Hex Value of the Character</span></span><br><span class="line">            strDest += <span class="built_in">convert</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper总结</title>
    <url>/f07e16f1/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#一-什么是zookeeper">一、什么是ZooKeeper</a></li>
<li><a href="#二-为什么zookeeper能干这么多">二、为什么ZooKeeper能干这么多？</a><ul>
<li><a href="#21-监听器">2.1 监听器</a></li>
<li><a href="#31-统一配置管理">3.1 统一配置管理</a></li>
<li><a href="#32-统一命名服务">3.2 统一命名服务</a></li>
<li><a href="#33-分布式锁">3.3 分布式锁</a></li>
<li><a href="#34集群状态">3.4集群状态</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<p>ZooKeeper 可以作为<strong>注册中心</strong>，也可以作为<strong>分布式锁</strong>的一种实现。Kafka 使用 ZooKeeper <strong>管理自己的元数据配置</strong>。</p>
<h2><span id="一-什么是zookeeper">一、什么是ZooKeeper</span></h2><p>官网介绍</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105425.png" alt></p>
<p>官网还有另一段话：</p>
<blockquote>
<p>ZooKeeper: A Distributed Coordination Service for Distributed Applications</p>
</blockquote>
<p><strong>Wiki</strong>中对ZooKeeper的介绍：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105519.png" alt></p>
<p>概括：</p>
<ul>
<li>ZooKeeper主要<strong>服务于分布式系统</strong>，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。</li>
<li>使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够<strong>通用</strong>解决这些问题的中间件就应运而生了。</li>
</ul>
<h2><span id="二-为什么zookeeper能干这么多">二、为什么ZooKeeper能干这么多？</span></h2><p>Wiki 中提到：</p>
<blockquote>
<p>ZooKeeper nodes store their data in a hierarchical name space, much like a file system or a <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Tree_(data_structure)">tree</a> data structure</p>
</blockquote>
<p>ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗<strong>树</strong>，每个节点叫做<strong>ZNode</strong>。每一个节点可以通过<strong>路径</strong>来标识，结构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105632.png" alt></p>
<p>那ZooKeeper这颗”树”有什么特点呢？？ZooKeeper的节点我们称之为<strong>Znode</strong>，Znode分为<strong>两种</strong>类型：</p>
<ul>
<li><strong>短暂/临时(Ephemeral)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>会自动删除</strong></li>
<li><strong>持久(Persistent)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>不会删除</strong></li>
</ul>
<blockquote>
<p>ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105707.png" alt></p>
<h3><span id="21-监听器">2.1 监听器</span></h3><p>在上面我们已经简单知道了ZooKeeper的数据结构了，ZooKeeper还配合了<strong>监听器</strong>才能够做那么多事的。</p>
<p><strong>常见</strong>的监听场景有以下两项：</p>
<ul>
<li>监听Znode节点的<strong>数据变化</strong></li>
<li>监听子节点的<strong>增减变化</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105734.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105749.png" alt></p>
<p>没错，通过<strong>监听+Znode节点(持久/短暂[临时])</strong>，ZooKeeper就可以玩出这么多花样了。</p>
<h3><span id="31-统一配置管理">3.1 统一配置管理</span></h3><p>比如我们现在有三个系统A、B、C，他们有三份配置，分别是<code>ASystem.yml、BSystem.yml、CSystem.yml</code>，然后，这三份配置又非常类似，很多的配置项几乎都一样。</p>
<ul>
<li>此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息<strong>很可能就要重启系统</strong></li>
</ul>
<p>于是，我们希望把<code>ASystem.yml、BSystem.yml、CSystem.yml</code>相同的配置项抽取出来成一份<strong>公用</strong>的配置<code>common.yml</code>，并且即便<code>common.yml</code>改了，也不需要系统A、B、C重启。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105843.png" alt></p>
<p>做法：我们可以将<code>common.yml</code>这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，<strong>及时</strong>响应。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310105910.png" alt></p>
<p>参考资料：<a href="https://lxb.wiki/15475898/">基于zookeeper实现统一配置管理</a></p>
<h3><span id="32-统一命名服务">3.2 统一命名服务</span></h3><p>统一命名服务的理解其实跟<strong>域名</strong>一样，是我们为这某一部分的资源给它<strong>取一个名字</strong>，别人通过这个名字就可以拿到对应的资源。</p>
<p>比如说，现在我有一个域名<code>www.java3y.com</code>，但我这个域名下有多台机器：</p>
<ul>
<li>192.168.1.1</li>
<li>192.168.1.2</li>
<li>192.168.1.3</li>
<li>192.168.1.4</li>
</ul>
<p>别人访问<code>www.java3y.com</code>即可访问到我的机器，而不是通过IP去访问。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310110058.png" alt></p>
<h3><span id="33-分布式锁">3.3 分布式锁</span></h3><p>我们可以使用ZooKeeper来实现分布式锁，那是怎么做的呢？？下面来看看：</p>
<p>系统A、B、C都去访问<code>/locks</code>节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310110143.png" alt></p>
<p>访问的时候会创建<strong>带顺序号的临时/短暂</strong>(<code>EPHEMERAL_SEQUENTIAL</code>)节点，比如，系统A创建了<code>id_000000</code>节点，系统B创建了<code>id_000002</code>节点，系统C创建了<code>id_000001</code>节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310111211.png" alt></p>
<p>接着，拿到<code>/locks</code>节点下的所有子节点(id_000000,id_000001,id_000002)，<strong>判断自己创建的是不是最小的那个节点</strong></p>
<ul>
<li><p>如果是，则拿到锁。</p>
</li>
<li><ul>
<li>释放锁：执行完操作后，把创建的节点给删掉</li>
</ul>
</li>
<li><p>如果不是，则监听比自己要小1的节点变化</p>
</li>
</ul>
<p>举个例子：</p>
<ul>
<li>系统A拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000000</code>)，是所有子节点最小的。所以得到锁</li>
<li>系统B拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000002</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000001</code>的状态</li>
<li>系统C拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000001</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000000</code>的状态</li>
<li>……</li>
<li>等到系统A执行完操作以后，将自己创建的节点删除(<code>id_000000</code>)。通过监听，系统C发现<code>id_000000</code>节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁</li>
<li>….系统B如上</li>
</ul>
<h3><span id="34集群状态">3.4集群状态</span></h3><p>ZooKeeper是怎么”<strong>感知</strong>“节点的动态新增或者删除的</p>
<p>还是以三个系统A、B、C为例，在ZooKeeper中创建<strong>临时节点</strong>即可：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310111532.png" alt></p>
<p>只要系统A挂了，那<code>/groupMember/A</code>这个节点就会删除，通过<strong>监听</strong><code>groupMember</code>下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)</p>
<p>除了能够感知节点的上下线变化，ZooKeeper还可以实现<strong>动态选举Master</strong>的功能。(如果集群是主从架构模式下)</p>
<p>原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带<strong>顺序号的临时节点</strong>(<code>EPHEMERAL_SEQUENTIAL</code>)就好了。</p>
<ul>
<li>Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让<strong>新的最小编号作为Master</strong>，这样就可以实现动态选举的功能了。</li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 2.x 使用高德地图JS API 2.0加载起点终点路径轨迹</title>
    <url>/b7826aa4/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#需求">需求</a></li>
<li><a href="#在-html-文件中引入地图-js">在 html 文件中引入地图 js</a></li>
<li><a href="#主页面">主页面</a></li>
<li><a href="#地图组件">地图组件</a></li>
<li><a href="#代码解析">代码解析</a></li>
<li><a href="#调起地图h5-组件">调起地图H5 组件</a></li>
</ul>
<!-- tocstop -->

<h2><span id="需求">需求</span></h2><ol>
<li><p>在地图中显示行驶轨迹，自定义标记点图标<br>地图厂商使用高德地图，使用目前最新的高德地图JSAPI 2.0</p>
</li>
<li><p>在自己的 H5 中调起多个地图app，显示标记点位置<br>由于地图 APP 并不支持在自己的网页中直接打开，因此需要通过地图 URI API 调用厂商H5地图，在厂商H5地图调起地图app</p>
</li>
</ol>
<h2><span id="在-html-文件中引入地图-js">在 html 文件中引入地图 js</span></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://webapi.amap.com/maps?v=2.0&amp;key=申请的key值&amp;plugin=AMap.Driving&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="主页面">主页面</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;index&quot;&gt;</span><br><span class="line">    &lt;template &gt;</span><br><span class="line">      &lt;v-map :data=&quot;dataList&quot;&gt;&lt;/v-map&gt;</span><br><span class="line">      &lt;v-detail :statrLocation=&quot;statrLocation&quot; :endLocation=&quot;endLocation&quot;/&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Map from &#x27;./mMap.vue&#x27;  // 地图</span><br><span class="line">import Detail from &#x27;./detail.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;index&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dataList: [],</span><br><span class="line">      statrLocation: &#123;&#125;,</span><br><span class="line">      endLocation: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;v-map&quot;: Map,</span><br><span class="line">    &quot;v-detail&quot;: Detail</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">  this.dataList = [</span><br><span class="line">      &#123;</span><br><span class="line">        longitude: 116.478346,</span><br><span class="line">        latitude: 39.997361</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        longitude: 116.402796,</span><br><span class="line">        latitude: 39.936915</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">    this.statrLocation = this.dataList[0]</span><br><span class="line">    this.endLocation = this.dataList[this.dataList.length-1]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">.index &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background: #fcf9f2;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="地图组件">地图组件</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mMap.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;m-map&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;map-box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;data&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      map: &#123;&#125;,</span><br><span class="line">      lineArr: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.initMap()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    initMap() &#123;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.map = new AMap.Map(&#x27;map-box&#x27;, &#123;</span><br><span class="line">          resizeEnable: true, //是否监控地图容器尺寸变化</span><br><span class="line">          zoom: 14, //初始化地图层级</span><br><span class="line">          center: [116.397428, 39.90923], //初始化地图中心点</span><br><span class="line">          animateEnable: true// 地图平移过程中是否使用动画</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        if(this.lineArr.length) &#123;</span><br><span class="line">          this.drawLine()  //绘制路线</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    drawLine()&#123;</span><br><span class="line">      AMap.convertFrom(this.lineArr, &#x27;gps&#x27;, (status, result) =&gt; &#123;</span><br><span class="line">        if (result.info === &#x27;ok&#x27;) &#123;</span><br><span class="line">          const paths = result.locations;</span><br><span class="line"></span><br><span class="line">          this.map.clearMap()</span><br><span class="line"></span><br><span class="line">          this.startMarker = new AMap.Marker(&#123;</span><br><span class="line">            map: this.map,</span><br><span class="line">            position: paths[0],  //起点经纬度</span><br><span class="line">            icon: new AMap.Icon(&#123;            </span><br><span class="line">              image: require(&#x27;@/assets/img/icon/icon-start.png&#x27;),</span><br><span class="line">              size: new AMap.Size(120, 120),  //图标所处区域大小</span><br><span class="line">              imageSize: new AMap.Size(120,120) //图标大小</span><br><span class="line">            &#125;),   //起点ico</span><br><span class="line">            offset: new AMap.Pixel(-60, -60),</span><br><span class="line">            autoRotation: true,</span><br><span class="line">            // angle:-90,</span><br><span class="line">          &#125;);</span><br><span class="line">          </span><br><span class="line">          this.endMarker = new AMap.Marker(&#123;</span><br><span class="line">            map: this.map,</span><br><span class="line">            position: paths[paths.length-1], //终点经纬度</span><br><span class="line">            icon: new AMap.Icon(&#123;            </span><br><span class="line">              image: require(&#x27;@/assets/img/icon/icon-end.png&#x27;),</span><br><span class="line">              size: new AMap.Size(60, 60),  //图标所处区域大小</span><br><span class="line">              imageSize: new AMap.Size(60,60) //图标大小</span><br><span class="line">            &#125;),   //终点ico</span><br><span class="line">            offset: new AMap.Pixel(-30, -30),</span><br><span class="line">            autoRotation: true,</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          // 绘制轨迹</span><br><span class="line">          var polyline = new AMap.Polyline(&#123;</span><br><span class="line">            map: this.map,</span><br><span class="line">            path: paths,</span><br><span class="line">            showDir: true,</span><br><span class="line">            strokeColor: &#x27;#28F&#x27;, //线颜色</span><br><span class="line">            // strokeOpacity: 1,     //线透明度</span><br><span class="line">            strokeWeight: 6, //线宽</span><br><span class="line">            // strokeStyle: &quot;solid&quot;  //线样式</span><br><span class="line">          &#125;);</span><br><span class="line">          this.map.add([this.startMarker, this.endMarker]);</span><br><span class="line">          this.map.setFitView();  //自适应缩放级别</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      handler(newValue, oldValue) &#123;</span><br><span class="line">        this.lineArr = [];</span><br><span class="line">        if(newValue.length) &#123;</span><br><span class="line">          newValue.map((item, index) =&gt; &#123;</span><br><span class="line">            if( item.longitude != null &amp;&amp; item.latitude != null ) &#123;</span><br><span class="line">              this.lineArr.push(new AMap.LngLat(item.longitude,item.latitude));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          this.drawLine();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang =&quot;scss&quot;&gt;</span><br><span class="line">@import &#x27;@/assets/scss/mixin.scss&#x27;;</span><br><span class="line">.m-map &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  #map-box &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="代码解析">代码解析</span></h2><p>在使用中发现标记点位置显示不对，存在一定的偏移，需要将其他坐标转为高德坐标方法. 在绘制轨迹之前先转换为高德坐标，然后再删除地图上所有的覆盖物，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">AMap</span>.<span class="title function_">convertFrom</span>(<span class="variable language_">this</span>.<span class="property">lineArr</span>, <span class="string">&#x27;gps&#x27;</span>, <span class="function">(<span class="params">status, result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (result.<span class="property">info</span> === <span class="string">&#x27;ok&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> paths = result.<span class="property">locations</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">clearMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以使用专门处理地理坐标系的js库<a href="https://github.com/hujiulong/gcoord">gcoord</a>，用来修正百度地图、高德地图及其它互联网地图坐标系不统一的问题。</p>
<h2><span id="调起地图h5-组件">调起地图H5 组件</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// detail.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;m-detail-box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;m-btn-wrapper&quot;&gt;</span><br><span class="line">      &lt;van-button class=&quot;open-btn&quot; round  @click=&quot;openShow = true&quot;&gt;导航至车辆当前位置&lt;/van-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;van-action-sheet </span><br><span class="line">      class=&quot;m-sheet-box&quot;</span><br><span class="line">      v-model=&quot;openShow&quot; </span><br><span class="line">      :actions=&quot;actions&quot; </span><br><span class="line">      cancel-text=&quot;取消&quot;</span><br><span class="line">      close-on-click-action</span><br><span class="line">      @select=&quot;onSelect&quot; </span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  Toast</span><br><span class="line">&#125; from &#x27;vant&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    statrLocation: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    endLocation: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      openShow: false,</span><br><span class="line">      actions: [</span><br><span class="line">      &#123; name: &#x27;使用苹果地图导航&#x27;, value: &#x27;iosamap&#x27;, color: &#x27;#007AFF&#x27; &#125;, </span><br><span class="line">        &#123; name: &#x27;使用百度地图导航&#x27;, value: &#x27;bmap&#x27;, color: &#x27;#007AFF&#x27; &#125;, </span><br><span class="line">        &#123; name: &#x27;使用高德地图导航&#x27;, value: &#x27;amap&#x27;, color: &#x27;#007AFF&#x27; &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onSelect(item) &#123;</span><br><span class="line">      this.openShow = false;</span><br><span class="line">      let startLocation = this.startLocation</span><br><span class="line">      let endLocation = this.endLocation</span><br><span class="line">      </span><br><span class="line">      if (endLocation.longitude &amp;&amp; endLocation.latitude) &#123;</span><br><span class="line">        let url = &#x27;&#x27;</span><br><span class="line">        switch (item.value) &#123;</span><br><span class="line">          case &#x27;iosamap&#x27;:</span><br><span class="line">            url = `iosamap://navi?sourceApplication=applicationName&amp;backScheme=applicationScheme&amp;poiname=$&#123;location&#125;&amp;poiid=BGVIS&amp;lat=$&#123;endLocation.latitude&#125;&amp;lon=$&#123;endLocation.longitude&#125;&amp;dev=1&amp;style=2`</span><br><span class="line">            break;</span><br><span class="line">          case &#x27;bmap&#x27;:</span><br><span class="line">            // 单点标注</span><br><span class="line">            url = `http://api.map.baidu.com/marker?location=$&#123;endLocation.latitude&#125;,$&#123;endLocation.longitude&#125;&amp;title=车辆位置&amp;content=实时定位&amp;output=html&amp;coord_type=wgs84&amp;src=webapp.baidu.openAPIdemo`</span><br><span class="line">            </span><br><span class="line">            // 路径规划</span><br><span class="line">            // url = `http://api.map.baidu.com/direction?origin=latlng:$&#123;startLocation.latitude&#125;,$&#123;startLocation.longitude&#125;|name:我的位置&amp;destination=latlng:$&#123;endLocation.latitude&#125;,$&#123;endLocation.longitude&#125;|name:实时定位&amp;mode=driving&amp;coord_type=wgs84&amp;src=webapp.baidu.openAPIdemo`</span><br><span class="line">            break;</span><br><span class="line">          case &#x27;amap&#x27;:</span><br><span class="line">            // 单点标注</span><br><span class="line">            url = `https://uri.amap.com/marker?position=$&#123;endLocation.longitude&#125;,$&#123;endLocation.latitude&#125;&amp;name=实时定位&amp;src=mypage&amp;coordinate=wgs84&amp;callnative=1`</span><br><span class="line"></span><br><span class="line">            // 路径规划</span><br><span class="line">            // url = `https://uri.amap.com/navigation?from=$&#123;startLocation.longitude&#125;,$&#123;startLocation.latitude&#125;,我的位置&amp;to=$&#123;endLocation.longitude&#125;,$&#123;endLocation.latitude&#125;,实时定位&amp;mode=car&amp;policy=1&amp;coordinate=wgs84&amp;callnative=1`</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        window.open(url)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Toast(&#123;</span><br><span class="line">          message: &#x27;暂无车辆定位&#x27;,</span><br><span class="line">          type: &#x27;fail&#x27;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    clearInterval(this.timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">@import &quot;@/assets/scss/mixin.scss&quot;;</span><br><span class="line"></span><br><span class="line">.m-detail-box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  padding: 20px 0 0;</span><br><span class="line">  border-radius: 20px 20px 0px 0px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: #FEFFFE;</span><br><span class="line">  box-shadow: 0 4px 40px 4px rgba(135, 119, 145, 0.36);</span><br><span class="line">  z-index: 160;</span><br><span class="line"></span><br><span class="line">  .van-cell-group &#123;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">      border: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .van-cell &#123;</span><br><span class="line">    padding: 12px 24px;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    font-weight: 600;</span><br><span class="line"></span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">      left: 24px;</span><br><span class="line">      right: 24px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-cell__title &#123;</span><br><span class="line">      flex: none;</span><br><span class="line">      color: #757AB5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-cell__value &#123;</span><br><span class="line">      color: #292929;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .m-btn-wrapper &#123;</span><br><span class="line">    border-top: 1px solid #EFF2F9;</span><br><span class="line">    background: #FFF;</span><br><span class="line"></span><br><span class="line">    .open-btn &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      margin: 10px auto;</span><br><span class="line">      padding: 14px;</span><br><span class="line">      width: 90%;</span><br><span class="line">      font-size: 18px;</span><br><span class="line">      color: #FEFFFE;</span><br><span class="line">      background: #85D4D9;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /deep/.van-overlay &#123;</span><br><span class="line">    background: rgba(33, 34, 51, 0.5);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .m-sheet-box &#123;</span><br><span class="line">    padding: 0 8px;</span><br><span class="line">    background: transparent;</span><br><span class="line"></span><br><span class="line">    .van-action-sheet__content &#123;</span><br><span class="line">      border-radius: 14px;</span><br><span class="line">      background: rgba(255, 255, 255, 0.92);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-action-sheet__gap &#123;</span><br><span class="line">      height: 20px;</span><br><span class="line">      background: transparent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .van-action-sheet__cancel &#123;</span><br><span class="line">      margin-bottom: 20px;</span><br><span class="line">      border-radius: 14px;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">      color: #007AFF;</span><br><span class="line">      background: rgba(255, 255, 255, 0.92);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>amap</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>c++代码优化建议</title>
    <url>/8e72ff9a/</url>
    <content><![CDATA[<ol>
<li>记住阿姆达尔定律： Ahmdal’s rule $$Speedup =\dfrac{ time_{old}}{time_{new}} = \dfrac{1}{(1-func_{cost})+func_{cost}/func_{speedup}}$$</li>
</ol>
<ul>
<li>func_cost是函数func运行时间百分比，func_speedup是你优化函数的运行的系数。</li>
<li>所以，如果你优化了函数TriangleIntersect执行40%的运行时间，使它运行快了近两倍，而你的程序会运行快25%。</li>
<li>这意味着不经常使用的代码不需要做较多优化考虑（或者完全不优化）。</li>
<li>这里有句俗语：让经常执行的路径运行更加高效，而运行稀少的路径正确运行。</li>
</ul>
<ol>
<li><p>代码先保证正确，然后再考虑优化 这并不意味着用8周时间写一个全功能的射线追踪算法，然后用8周时间去优化它。 分多步来做性能优化。 先写正确的代码，当你意识到这个函数可能会被经常调用，进行明显的优化。 然后再寻找算法的瓶颈，并解决（通过优化或者改进算法）。通常，改进算法能显著地改进瓶颈——也许是采用一个你还没有预想到的方法。所有频繁调用的函数，都需要优化。</p>
</li>
<li><p>我所了解的那些写出非常高效代码的人说，他们优化代码的时间，是写代码时间的两倍。</p>
</li>
<li><p>跳转和分支执行代价高，如果可能，尽量少用。</p>
</li>
</ol>
<p>函数调用需要两次跳转，外加栈内存操作。 优先使用迭代而不是递归。 使用内联函数处理短小的函数来消除函数调用开销。 将循环内的函数调用移动到循环外(例如，将for(i=0;i&lt;100;i++) DoSomething();改为DoSomething() { for(i=0;i&lt;100;i++) { … }})。 if…else if…else if…else if…很长的分支链执行到最后的分支需要很多的跳转。如果可能，将其转换为一个switch声明语句，编译器有时候会将其转换为一个表查询单次跳转。如果switch声明不可行，将最常见的场景放在if分支链的最前面。 5. 仔细思考函数下标的顺序。</p>
<pre><code>两阶或更高阶的数组在内存中还是以一维的方式在存储在内存中，这意味着（对于C/C++数组）array[i][j] 和 array[i][j+1]是相邻的，但是array[i][j] 和array[i+1][j]可能相距很远。</code></pre><p>以适当的方式访问存储实际内存中的数据，可以显著地提升你代码的执行效率（有时候可以提升一个数量级甚至更多）。 现代处理器从主内存中加载数据到处理器cache，会加载比单个值更多的数据。该操作会获取请求数据和相邻数据（一个cache行大小）的整块数据。这意味着，一旦array[i][j]已经在处理器cache中，array[i][j+1]很大可能也已经在cache中了，而array[i+1][j]可能还在内存中。 6. 使用指令层的并行机制</p>
<pre><code>尽管许多程序还是依赖单线程的执行，现代处理器在单核中也提供了不少的并行性。例如：单个CPU可以同时执行4个浮点数乘，等待4个内存请求并执行一个分支预判。</code></pre><p>为了最大化利用这种并行性，代码块（在跳转之间的）需要足够的独立指令来允许处理器被充分利用。 考虑展开循环来改进这一点。 这也是使用内联函数的一个好理由。 7. 避免或减少使用本地变量。</p>
<pre><code>本地变量通常都存储在栈上。不过如果数量比较少，它们可以存储在CPU寄存器中。在这种情况下，函数不但得到了更快访问存储在寄存器中的数据的好处，也避免了初始化一个栈帧的开销。</code></pre><p>不要将大量数据转换为全局变量。 8. 减少函数参数的个数。</p>
<pre><code>和减少使用本地变量的理由一样——它们也是存放在栈上。</code></pre><p>9. 通过引用传递结构体而不是传值</p>
<pre><code>我在射线追踪中还找不到一个场景需要将结构体使用传值方式（包括一些简单结构如：Vector，Point和Color）。</code></pre><p>10. 如果你的函数不需要返回值，不要定义。</p>
<ol>
<li><p>尽量避免数据转换。</p>
<p>整数和浮点数指令通常操作不同的寄存器，所以转换需要进行一次拷贝操作。 短整型（char和short）仍然使用一整个寄存器，并且它们需要被填充为32/64位，然后在存储回内存时需要再次转换为小字节（不过，这个开销一定比一个更大的数据类型的内存开销要多一点）。</p>
</li>
<li><p>定义C++对象时需要注意。</p>
<p>使用类初始化而不是使用赋值（Color c(black); 比Color c; c = black;更快）</p>
</li>
<li><p>使类构造函数尽可能轻量。 尤其是常用的简单类型（比如，color，vector，point等等），这些类经常被复制。 这些默认构造函数通常都是在隐式执行的，这或许不是你所期望的。 使用类初始化列表(Use Color::Color() : r(0), g(0), b(0) {}，而不是初始化函数Color::Color() { r= g = b = 0; } .)</p>
</li>
<li><p>如果可以的话，使用位移操作&gt;&gt;和&lt;&lt;来代替整数乘除法</p>
</li>
<li><p>小心使用表查找函数</p>
<p>许多人都鼓励将复杂的函数（比如：三角函数）转化为使用预编译的查找表。对于射线追踪功能来说，这通常导致了不必要的内存查找，这很昂贵（并不断增长），并且这和计算一个三角函数并从内存中获取值一样快（尤其你考虑到三角查找打乱了cpu的cache存取）。 在其他情况下，查找表会很有用。对于GPU编程通常优先使用表查找而不是复杂函数。</p>
</li>
<li><p>对大多数类，优先使用+= 、 -= 、 *= 和 /=，而不是使用+ 、 – 、 * 、 和?/</p>
<p>这些简单操作需要创建一个匿名临时中间变量。 例如：Vector v = Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1);?创建了五个匿名临时Vector: Vector(1,0,0), Vector(0,1,0), Vector(0,0,1), Vector(1,0,0) + Vector(0,1,0), 和 Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1). 对上述代码进行简单转换：Vector v(1,0,0); v+= Vector(0,1,0); v+= Vector(0,0,1);仅仅创建了两个临时Vector: Vector(0,1,0) 和 Vector(0,0,1)。这节约了6次函数调用（3次构造函数和3次析构函数）。</p>
</li>
<li><p>对于基本数据类型，优先使用+?、?-?、?<em>?、?和?/，而不是+=?、?-=?、?</em>= 和 /=</p>
</li>
<li><p>推迟定义本地变量</p>
<p>定义一个对象变量通常需要调用一次函数（构造函数）。 如果一个变量只在某些情况下需要（例如在一个if声明语句内），仅在其需要的时候定义，这样，构造函数仅在其被使用的时候调用。</p>
</li>
<li><p>对于对象，使用前缀操作符（++obj），而不是后缀操作符（obj++）</p>
<p>这在你的射线追踪算法中可能不是一个问题 使用后缀操作符需要执行一次对象拷贝（这也导致了额外的构造和析构函数调用），而前缀的构造函数不需要一个临时的拷贝。</p>
</li>
<li><p>小心使用模板</p>
<p>对不同的是实例实现进行不同的优化。 标准模板库已经经过良好的优化，不过我建议你在实现一个交互式射线追踪算法时避免使用它。 使用自己的实现，你知道它如何使用算法，所以你知道如何最有效的实现它。 最重要的是，我的经历告诉我：调试STL库非常低效。通常这也不是一个问题，除非你使用debug版本做性能分析。你会发现STL的构造函数，迭代器和其他一些操作，占用了你15%的运行时间，这会导致你分析性能输出更加费劲。</p>
</li>
<li><p>避免在计算时进行动态内存分配</p>
<p>动态内存对于存储场景和运行期间其他数据都很有用。 但是，在许多（大多数）的系统动态内存分配需要获取控制访问分配器的锁。对于多线程应用程序，现实中使用动态内存由于额外的处理器导致了性能下降，因为需要等待分配器锁和释放内存。 即便对于单线程应用，在堆上分配内存也比在栈上分配内存开销大得多。操作系统还需要执行一些操作来计算并找到适合尺寸的内存块。</p>
</li>
<li><p>找到你系统内存cache的信息并利用它们</p>
<p>如果一个是数据结构正好适合一个cache行，处理整个类从内存中只需要做一次获取操作。 确保所有的数据结构都是cache行大小对齐（如果你的数据结构和一个cache行大小都是128字节，仍有可能因为你的结构体中的一个字节在一个cache行中，而其他127字节在另外一个cahce行中）。</p>
</li>
<li><p>避免不需要的数据初始化</p>
<p>如果你需要初始化一大段的内存，考虑使用memset。</p>
</li>
<li><p>尽早结束循环和尽早返回函数调用</p>
<p>考虑一个射线和三角形交叉，通常的情况是射线会越过三角，所以这里可以优化。 如果你决定将射线和三角面板交叉。如果射线和面板交叉t值是负数，你可以立即返回。这允许你跳过射线三角交叉一大半的质心坐标计算。这是一个大的节约，一旦你知道这个交叉不存在，你就应该立即返回交叉计算函数。 同样的，一些循环也应该尽早结束。例如，当设置阴影射线，对于近处的交叉通常都是不必须的，一旦有类似的的交叉，交叉计算就应该尽早返回。（这里的交叉含义不太明白，可能是专业词汇，译者注）</p>
</li>
<li><p>在稿纸上简化你的方程式</p>
<p>许多方程式中，通常都可以或者在某些条件中取消计算。 编译器不能发现这些简化，但是你可以。取消一个内部循环的一些昂贵操作可以抵消你在其他地方的好几天的优化工作。</p>
</li>
<li><p>整数、定点数、32位浮点数和64位双精度数字的数学运算差异，没有你想象的那么大</p>
<p>在现代CPU，浮点数运算和整数运算差不多拥有同样的效率。在计算密集型应用（比如射线追踪），这意味这可以忽略整数和浮点数计算的开销差异。这也就是说，你不必要对算数进行整数处理优化。 双精度浮点数运算也不比单精度浮点数运算更慢，尤其是在64位机器上。我在同一台机器测试射线追踪算法全部使用double比全部使用floats运行有时候更快，反过来测试也看到了一样的现象（这里的原文是：I have seen ray tracers run faster using all doubles than all floats on the same machine. I have also seen the reverse）。</p>
</li>
<li><p>不断改进你的数学计算，以消除昂贵的操作</p>
<p>sqrt()经常可以被优化掉，尤其是在比较两个值的平方根是否一致时。 如果你重复地需要处理 除x 操作，考虑计算1/x的值，乘以它。这在向量规范化（3次除法）运算中赢得了大的改进，不过我最近发现也有点难以确定的。不过，这仍然有所改进，如果你要进行三次或更多除法运算。 如果你在执行一个循环，那些在循环中执行不发生变化的部分，确保提取到循环外部。 考虑看看你的计算值是否可以在循环中修改得到（而不每次都重新开始循环计算）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】C++11 sort using function objects</title>
    <url>/e754bcbe/</url>
    <content><![CDATA[<p>如果你用C++编码， 需要对容器内的元素进行排序， 这个容器提供任意访问的迭代器， 比如<code>std::vector</code>， 那么简单快捷的方法是使用里的<code>std::sort</code> 函数.</p>
<p><strong>Basic sorting</strong> <code>std::sort</code> 函数需要两个参数, 这两个参数分别指向你要排序的序列容器的开始(initial)和终点(final). 这个序列容易内除final指向的那个元素外 所有元素都会被排序. 下面是一个简单的排序例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span><span class="string">&lt;/vector&gt;</span><span class="string">&lt;/algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> array[] &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(array, array + <span class="number">5</span>)</span></span>;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>


<p>输出: <code>0 5 10 15 20</code></p>
<p><strong>More complex sorting</strong> 在某些时候, 根据数值升序排序已经足够解决问题了, 但是当我们需要按某个特定的参数进行排序, 或者降序排列时, 就需要一些其他的东西了. 对于这种需求, <code>std::sort</code> 需要引入第三个参数: 比较函数. 这个比较函数有两个参数, 分别是序列容器的两个元素, 返回值可以隐式地转为bool. 如果第一个参数应该排在第二个参数前面, 则返回true.</p>
<p>例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span><span class="string">&lt;/vector&gt;</span><span class="string">&lt;/algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DescOrderInt</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> array[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(array, array + <span class="number">5</span>)</span></span>;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), DescOrderInt);</span><br></pre></td></tr></table></figure>


<p>DescOrderInt的实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DescOrderInt</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &amp;gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出: <code>20 15 10 5 0</code></p>
<p><strong>C++11 sort using function objects</strong> 网上很多例子说, 为了排列元素, 可以使用<code>std::binary_function</code> 定义比较函数, 但不幸的是, <code>std::binary_function</code> 在C++11 中已经被标为 “将被弃用的”, 在C++17中会被完全移除, 所以写新的C++代码时, 最好不要用这个.</p>
<p>我们可以使用C++11中引入的<code>std::function</code> 来定义这个函数指针. 例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;function&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span><span class="string">&lt;/vector&gt;</span><span class="string">&lt;/function&gt;</span><span class="string">&lt;/algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StrDescOrderInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &amp;gt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> array[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(array, array + <span class="number">5</span>)</span></span>;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)=&quot;&quot;&gt; sorter = <span class="built_in">StrDescOrderInt</span>();&lt;/<span class="built_in">bool</span>(<span class="type">int</span>,&gt;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), sorter);</span><br></pre></td></tr></table></figure>


<p>输出: <code>20 15 10 5 0</code></p>
<p><strong>A real-life example: providing multiple sorting options</strong> 我们假设有一队足球运动员, 我们想让用户按他们自己的意愿去排列这些运动员. 有一个图表的UI, 上面有几个按钮, 每个按钮对应不用的排序规则.</p>
<p>Plaer 类的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -- Player.h --</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span><span class="string">&lt;/string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> caps, <span class="type">int</span> goals);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string &amp;amp; <span class="built_in">GetName</span>() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetCaps</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetGoals</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string mName;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mCaps;</span><br><span class="line"><span class="type">int</span> mGoals;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>​    </p>
<p>现在我们新写一个类或结构体来列出所有的比较函数. 比较函数是一个结构体并实现操作符<code>()</code>, 操作符<code>()</code> 带有两个参数, 分别为两个指向Player的指针, 返回bool值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerSorting</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortPlayerByNameAsc</span> (<span class="type">bool</span> <span class="built_in">operator</span>()(Player* p1, Player* p2) <span class="type">const</span>;);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortPlayerByNameDes</span> (<span class="type">bool</span> <span class="built_in">operator</span>()(Player* p1, Player* p2) <span class="type">const</span>;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// caps</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortPlayerByCapsAsc</span> (<span class="type">bool</span> <span class="built_in">operator</span>()(Player* p1, Player* p2) <span class="type">const</span>;);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortPlayerByCapsDes</span> (<span class="type">bool</span> <span class="built_in">operator</span>()(Player* p1, Player* p2) <span class="type">const</span>;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// goals</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortPlayerByGoalsAsc</span> (<span class="type">bool</span> <span class="built_in">operator</span>()(Player* p1, Player* p2) <span class="type">const</span>;);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortPlayerByGoalsDes</span> (<span class="type">bool</span> <span class="built_in">operator</span>()(Player* p1, Player* p2) <span class="type">const</span>;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后, 在调用它的地方, 我们可以先把所有的<code>std::function</code> 存在一个<code>std::vector</code> 里, 使用的时候, 用索引访问vector的元素.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt; std::function&lt;<span class="type">bool</span>(player *,=&quot;&quot; player=&quot;&quot; *)=&quot;&quot;&gt; &gt; sorters;</span><br><span class="line">sorters.<span class="built_in">push_back</span>(PlayerSorting::<span class="built_in">SortPlayerByNameAsc</span>());</span><br><span class="line">sorters.<span class="built_in">push_back</span>(PlayerSorting::<span class="built_in">SortPlayerByCapsAsc</span>());</span><br><span class="line">sorters.<span class="built_in">push_back</span>(PlayerSorting::<span class="built_in">SortPlayerByGoalsAsc</span>());</span><br><span class="line">sorters.<span class="built_in">push_back</span>(PlayerSorting::<span class="built_in">SortPlayerByNameDes</span>());</span><br><span class="line">sorters.<span class="built_in">push_back</span>(PlayerSorting::<span class="built_in">SortPlayerByCapsDes</span>());</span><br><span class="line">sorters.<span class="built_in">push_back</span>(PlayerSorting::<span class="built_in">SortPlayerByGoalsDes</span>());&lt;/<span class="built_in">bool</span>(player&gt;</span><br></pre></td></tr></table></figure>


<p>​    </p>
<p>例如, 根据得分降序排列:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;player *=&quot;&quot;&gt; players;&lt;/player&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...init players...</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(players.<span class="built_in">begin</span>(), players.<span class="built_in">end</span>(), sorters[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>


<p>输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME                     CAPS  GOALS</span><br><span class="line">Lionel Messi             21    20</span><br><span class="line">David Villa              13    16</span><br><span class="line">Asamoah Gyan             22    15</span><br><span class="line">Arjen Robben             11    12</span><br><span class="line">Mesut Oezil              19    10</span><br><span class="line">Diego Forlan             20    10</span><br><span class="line">Andres Iniesta           15    9</span><br><span class="line">Wesley Sneijder          24    6</span><br><span class="line">Xavi                     17    5</span><br><span class="line">Bastian Schweinsteiger   23    4</span><br></pre></td></tr></table></figure>


<p>假如需要实现一种新的排序方式, 我们只需要在PlayerSorting类中添加一个新的仿函数即可.</p>
<p>原文地址: <a href="http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/">http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>date 命令转换时间戳</title>
    <url>/7b4019ad/</url>
    <content><![CDATA[<p>给定时间戳, 转换成日期<br>网上所有的命令都是<br><code>date -d @$stamp &quot;+%Y-%m-%d&quot;</code><br> 但是一直提示<br> <code>date: invalid date</code>@stamp’<code>带上&quot;@&quot; 符号, 就参数错误 正确使用方法:</code>date -d “1970-01-01 UTC 1287331200 seconds” +%F<code>或者使用awk</code>awk ‘{print strftime(“%Y%m”, 1287331200)}’<code>调用外部命令耗时比较长, 更高效的方法:</code>printf “%(%Y%m)T\n” “$str” &gt;&gt; file<code>如果bash 版本低于4, printf 不支持打印日期格式, 因此使用 下面这个bash</code>/opt/compiler/gcc-4.8.2/bin/bash`</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>core文件被截断问题的解决办法</title>
    <url>/d12416f0/</url>
    <content><![CDATA[<p><strong>现象</strong><br>通过gdb打开core，但看不到core的内容，信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb XXX core.XXX</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux ( 7.0.1-32.el5)</span><br><span class="line">Copyright (C) 2009 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /home/XXX/XXX...done.</span><br><span class="line">BFD: Warning: /home/XXX/core.XXX is truncated: expected core file size &gt;= 747175936, found: 1236992.</span><br><span class="line"> </span><br><span class="line">warning: core file may not match specified executable file.</span><br><span class="line">Cannot access memory at address 0x344201cc88</span><br></pre></td></tr></table></figure>

<p><strong>调查</strong><br>ulimit -a的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">core file size          (blocks, -c) 1000</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 40960</span><br><span class="line">max locked memory       (kbytes, -l) 32</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65000</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 536870912</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 1024000</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 40960</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>
<p>经别人指点，说是“core file size”的值太小了。</p>
<p><strong>修改core file size的方法</strong><br>1 使用root用户登录，在<code>/etc/security/limits.conf</code>文件中，添加了“* hard core   unlimited”行，添加后此文件的内容大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/security/limits.conf</span><br><span class="line">#</span><br><span class="line"># Each line describes a limit for a user in the form:</span><br><span class="line">#</span><br><span class="line"># &lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;</span><br><span class="line">#</span><br><span class="line">* - msgqueue 536870912</span><br><span class="line">* soft nofile 65000</span><br><span class="line">* hard nofile 65000</span><br><span class="line">* soft core   unlimited</span><br><span class="line">* hard core   unlimited</span><br></pre></td></tr></table></figure>

<p>2 修改这个文件后，退出root用户<br>3 退出自己的账户的全部登录的终端，然后关闭telnet工具，重新使用自己的账户登录系统，键入下面的命令，都会返回unlimited</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ulimit -S -c</span><br><span class="line">unlimited</span><br><span class="line">$ ulimit -H -c</span><br><span class="line">unlimited</span><br></pre></td></tr></table></figure>
<p>此时core文件就不会被截断了。</p>
<p><strong>参考资料</strong><br>How do I enable core dumps for everybody<br><a href="http://www.akadia.com/services/ora_enable_core.html">http://www.akadia.com/services/ora_enable_core.html</a></p>
<p>原文地址: <a href="http://blog.sina.com.cn/s/blog_537f4d9b0100wi88.html">http://blog.sina.com.cn/s/blog_537f4d9b0100wi88.html</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>docker挂载目录失败/权限拒绝</title>
    <url>/498654c2/</url>
    <content><![CDATA[<p>把宿主机的一个目录挂载到容器中的一个目录，当访问容器中的这个目录时，出现如下问题：<br> <code>ls: cannot open directory .: Permission denied</code><br>无法访问目录，权限拒绝。<br>该问题通常在centos7下出现。或者一个容器启动成功后，里面的服务无法成功访问，这是因为centos7中的安全模块selinux把权限禁掉了，一般的解决方案有以下两种：<br>（1）临时关闭selinux<br>直接在centos服务器上执行以下命令即可。执行完成以后建议重新<code>docker run</code>。 <code>setenforce 0</code><br>（2）给容器加权限<br>在<code>docker run</code>时给该容器加权限，加上以下参数即可：<br> <code>--privileged=true</code><br> 一般都推荐使用这种方式。<br> 按上述方法修改后, 如果执行下面命令失败<br> <code>docker run --name rookie-nginx-test -d -p 8082:80 -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx -v ~/nginx/conf/conf.d:/etc/nginx/conf.d --link php7-fpm:php nginx</code><br>则是因为<code>~/nginx/www/</code> 目录下没有index 文件导致. 手动创建<code>index.php</code> 文件解决</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch元数据</title>
    <url>/afde4b9b/</url>
    <content><![CDATA[<h2><span id="meta-fields元数据">Meta-Fields(元数据)</span></h2><blockquote>
<p>本文基于 Elasticsearch 6.6.0</p>
</blockquote>
<h3><span id="_all">_all</span></h3><p>_all字段是把其它字段拼接在一起的超级字段，所有的字段用空格分开，_all字段会被解析和索引，但是不存储。当你只想返回包含某个关键字的文档但是不明确地搜某个字段的时候就需要使用_all字段。<br>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/blog/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>:    <span class="string">&quot;Master Java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>:     <span class="string">&quot;learn java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Tom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_all字段包含:[ “Master”, “Java”, “learn”, “Tom” ]</p>
<p>搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_all&quot;</span>: <span class="string">&quot;Java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>: 0.39063013,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>: 0.39063013,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Master Java&quot;</span>,</span><br><span class="line">          <span class="string">&quot;content&quot;</span>: <span class="string">&quot;learn java&quot;</span>,</span><br><span class="line">          <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Tom&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用copy_to自定义_all字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT myindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mytype&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:    <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_content&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:    <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_content&quot;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;full_content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>:    <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT myindex/mytype/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Master Java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;learn Java&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET myindex/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;full_content&quot;</span>: <span class="string">&quot;java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_field_names">_field_names</span></h3><p>_field_names字段用来存储文档中的所有非空字段的名字，这个字段常用于exists查询。例子如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2?refresh=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;This is another document&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;This document has a body&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_field_names&quot;</span>: [ <span class="string">&quot;body&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果会返回第二条文档，因为第一条文档没有title字段。<br>同样，可以使用exists查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;exists&quot;</span> : &#123; <span class="string">&quot;field&quot;</span> : <span class="string">&quot;body&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_id">_id</span></h3><p>每条被索引的文档都有一个_type和_id字段，_id可以用于term查询、temrs查询、match查询、query_string查询、simple_query_string查询，但是不能用于聚合、脚本和排序。例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_id&quot;</span>: [ <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_index">_index</span></h3><p>多索引查询时，有时候只需要在特地索引名上进行查询，_index字段提供了便利，也就是说可以对索引名进行term查询、terms查询、聚合分析、使用脚本和排序。</p>
<p><code>_index</code>是一个虚拟字段，不会真的加到索引中，对_index进行term、terms查询(也包括match、query_string、simple_query_string)，但是不支持prefix、wildcard、regexp和fuzzy查询。</p>
<p>举例，2个索引2条文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT index_1/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document in index 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index_2/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document in index 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对索引名做查询、聚合、排序并使用脚本新增字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET index_1,index_2/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: [<span class="string">&quot;index_1&quot;</span>, <span class="string">&quot;index_2&quot;</span>] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;indices&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;_index&quot;</span>, </span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index_name&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">        <span class="string">&quot;inline&quot;</span>: <span class="string">&quot;doc[&#x27;_index&#x27;]&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_meta">_meta</span></h3><h3><span id="_parent">_parent</span></h3><p>_parent用于指定同一索引中文档的父子关系。下面例子中现在mapping中指定文档的父子关系，然后索引父文档，索引子文档时指定父id，最后根据子文档查询父文档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_parent&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;my_child&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_parent&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;my_parent&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT my_index/my_parent/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is a parent document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_child/2?parent=1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is a child document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_child/3?parent=1&amp;refresh=<span class="literal">true</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;This is another child document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET my_index/my_parent/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;has_child&quot;</span>: &#123; </span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;my_child&quot;</span>,</span><br><span class="line">      <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;child document&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_routing">_routing</span></h3><p>路由参数，ELasticsearch通过以下公式计算文档应该分到哪个分片上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shard_num = <span class="built_in">hash</span>(_routing) % num_primary_shards</span><br></pre></td></tr></table></figure>

<p>默认的_routing值是文档的_id或者_parent，通过_routing参数可以设置自定义路由。例如，想把user1发布的博客存储到同一个分片上，索引时指定routing参数，查询时在指定路由上查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/1?routing=user1&amp;refresh=<span class="literal">true</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;This is a document&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/my_type/1?routing=user1</span><br></pre></td></tr></table></figure>

<p>在查询的时候通过routing参数查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_routing&quot;</span>: [ <span class="string">&quot;user1&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search?routing=user1,user2 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;document&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Mapping中指定routing为必须的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_routing&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;required&quot;</span>: <span class="literal">true</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index2/my_type/1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;No routing value provided&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_source">_source</span></h3><p>存储的文档的原始值。默认_source字段是开启的，也可以关闭：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT tweets</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般情况下不要关闭，除非你不想做以下操作：</p>
<ul>
<li>使用update、update_by_query、reindex</li>
<li>使用高亮</li>
<li>数据备份、改变mapping、升级索引</li>
<li>通过原始字段debug查询或者聚合</li>
</ul>
<h3><span id="_type">_type</span></h3><p>每条被索引的文档都有一个_type和_id字段，可以根据_type进行查询、聚合、脚本和排序。例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/type_1/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with type 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/type_2/2?refresh=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with type 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_type&quot;</span>: [ <span class="string">&quot;type_1&quot;</span>, <span class="string">&quot;type_2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;_type&quot;</span>, </span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_type&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">        <span class="string">&quot;inline&quot;</span>: <span class="string">&quot;doc[&#x27;_type&#x27;]&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="_uid">_uid</span></h3><p><code>_uid</code> 即 <code>_type</code> + <code>_id</code> 的组合，可用于查询、聚合、脚本和排序。例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/my_type/2?refresh=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Document with ID 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;_uid&quot;</span>: [ <span class="string">&quot;my_type#1&quot;</span>, <span class="string">&quot;my_type#2&quot;</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;UIDs&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;_uid&quot;</span>, </span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_uid&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;UID&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">         <span class="string">&quot;inline&quot;</span>: <span class="string">&quot;doc[&#x27;_uid&#x27;]&quot;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch的数据类型</title>
    <url>/ce28e9ad/</url>
    <content><![CDATA[<blockquote>
<p>本文基于 Elasticsearch 6.6.0</p>
</blockquote>
<h2><span id="1-核心数据类型">1 核心数据类型</span></h2><h2><span id="11-字符串类型-string不再支持">1.1 字符串类型 - string(不再支持)</span></h2><p>(1) 使用示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>&#125;, 	// 全文本</span><br><span class="line">                <span class="string">&quot;tags&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span>&#125;	// 关键字, 不分词</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) ES 5.6.10中的响应信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! Deprecation: The [string] field is deprecated, please use [text] or [keyword] instead on [tags]</span></span><br><span class="line"><span class="comment">#! Deprecation: The [string] field is deprecated, please use [text] or [keyword] instead on [title]</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;shards_acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;index&quot;</span>: <span class="string">&quot;website&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) ES 6.6.0中的响应信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">        <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;No handler for type [string] declared on field [title]&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;Failed to parse mapping [blog]: No handler for type [string] declared on field [title]&quot;</span>,</span><br><span class="line">    <span class="string">&quot;caused_by&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">      <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;No handler for type [string] declared on field [title]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可知string类型的field已经被移除了, 我们需要用text或keyword类型来代替string.</strong></p>
<h3><span id="111-文本类型-text">1.1.1 文本类型 - text</span></h3><p>在Elasticsearch 5.4 版本开始, text取代了需要分词的string.</p>
<p>—— <strong>当一个字段需要用于全文搜索(会被分词), 比如产品名称、产品描述信息, 就应该使用text类型.</strong></p>
<blockquote>
<p>text的内容会被分词, 可以设置是否需要存储: <code>&quot;index&quot;: &quot;true|false&quot;</code>.<br>text类型的字段不能用于排序, 也很少用于聚合.</p>
</blockquote>
<p>使用示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        		<span class="string">&quot;summary&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="112-关键字类型-keyword">1.1.2 关键字类型 - keyword</span></h3><p>在Elasticsearch 5.4 版本开始, keyword取代了不需要分词的string.</p>
<p>—— <strong>当一个字段需要按照精确值进行过滤、排序、聚合等操作时, 就应该使用keyword类型.</strong></p>
<blockquote>
<p>keyword的内容不会被分词, 可以设置是否需要存储: <code>&quot;index&quot;: &quot;true|false&quot;</code>.</p>
</blockquote>
<p>使用示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        		<span class="string">&quot;tags&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="12-数字类型-8种">1.2 数字类型 - 8种</span></h2><p>数字类型有如下分类:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>有符号的8位整数, 范围: [-128 ~ 127]</td>
</tr>
<tr>
<td>short</td>
<td>有符号的16位整数, 范围: [-32768 ~ 32767]</td>
</tr>
<tr>
<td>integer</td>
<td>有符号的32位整数, 范围: [−231 ~ 231-1]</td>
</tr>
<tr>
<td>long</td>
<td>有符号的64位整数, 范围: [−263 ~ 263-1]</td>
</tr>
<tr>
<td>float</td>
<td>32位单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>64位双精度浮点数</td>
</tr>
<tr>
<td>half_float</td>
<td>16位半精度IEEE 754浮点类型</td>
</tr>
<tr>
<td>scaled_float</td>
<td>缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734</td>
</tr>
</tbody></table>
<p>使用注意事项:</p>
<blockquote>
<p>尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;<br>优先考虑使用带缩放因子的浮点类型.</p>
</blockquote>
<p>使用示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT shop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;book&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;quantity&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>&#125;,  // <span class="built_in">integer</span>类型</span><br><span class="line">                <span class="string">&quot;price&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;</span>,       // scaled_float类型</span><br><span class="line">                    <span class="string">&quot;scaling_factor&quot;</span>: 100</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="13-日期类型-date">1.3 日期类型 - date</span></h2><p>JSON没有日期数据类型, 所以在ES中, 日期可以是:</p>
<ul>
<li>包含格式化日期的字符串, “2018-10-01”, 或”2018/10/01 12:10:30”.</li>
<li>代表时间毫秒数的长整型数字.</li>
<li>代表时间秒数的整数.</li>
</ul>
<blockquote>
<p>如果时区未指定, 日期将被转换为UTC格式, 但存储的却是长整型的毫秒值.<br>可以自定义日期格式, 若未指定, 则使用默认格式: <code>strict_date_optional_time||epoch_millis</code></p>
</blockquote>
<p>(1) 使用日期格式示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加映射</span><br><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;pub_date&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>&#125;   // 日期类型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加数据</span><br><span class="line">PUT website/blog/11</span><br><span class="line">&#123; <span class="string">&quot;pub_date&quot;</span>: <span class="string">&quot;2018-10-10&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT website/blog/12</span><br><span class="line">&#123; <span class="string">&quot;pub_date&quot;</span>: <span class="string">&quot;2018-10-10T12:00:00Z&quot;</span> &#125;	// Solr中默认使用的日期格式</span><br><span class="line"></span><br><span class="line">PUT website/blog/13</span><br><span class="line">&#123; <span class="string">&quot;pub_date&quot;</span>: <span class="string">&quot;1589584930103&quot;</span> &#125;			// 时间的毫秒值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 多种日期格式:</p>
<blockquote>
<p>多个格式使用双竖线<code>||</code>分隔, 每个格式都会被依次尝试, 直到找到匹配的.<br>第一个格式用于将时间毫秒值转换为对应格式的字符串.</p>
</blockquote>
<p>使用示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加映射</span><br><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,  // 可以接受如下类型的格式</span><br><span class="line">                    <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="14-布尔类型-boolean">1.4 布尔类型 - boolean</span></h2><p>可以接受表示真、假的字符串或数字:</p>
<ul>
<li>真值: true, “true”, “on”, “yes”, “1”…</li>
<li>假值: false, “false”, “off”, “no”, “0”, “”(空字符串), 0.0, 0</li>
</ul>
<h2><span id="15-二进制型-binary">1.5 二进制型 - binary</span></h2><p>二进制类型是Base64编码字符串的二进制值, 不以默认的方式存储, 且不能被搜索. 有2个设置项:</p>
<blockquote>
<p>(1) <code>doc_values</code>: 该字段是否需要存储到磁盘上, 方便以后用来排序、聚合或脚本查询. 接受<code>true</code>和<code>false</code>(默认);<br>(2) <code>store</code>: 该字段的值是否要和<code>_source</code>分开存储、检索, 意思是除了<code>_source</code>中, 是否要单独再存储一份. 接受<code>true</code>或<code>false</code>(默认).</p>
</blockquote>
<p>使用示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加映射</span><br><span class="line">PUT website</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;blob&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;binary&quot;</span>&#125;   // 二进制</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 添加数据</span><br><span class="line">PUT website/blog/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Some binary blog&quot;</span>,</span><br><span class="line">    <span class="string">&quot;blob&quot;</span>: <span class="string">&quot;hED903KSrA084fRiD5JLgY==&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: Base64编码的二进制值不能嵌入换行符<code>\n</code>, 逗号(<code>0x2c</code>)等符号.</p>
</blockquote>
<h2><span id="16-范围类型-range">1.6 范围类型 - range</span></h2><p>range类型支持以下几种:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>integer_range</td>
<td>−231 ~ 231−1</td>
</tr>
<tr>
<td>long_range</td>
<td>−263 ~ 263−1</td>
</tr>
<tr>
<td>float_range</td>
<td>32位单精度浮点型</td>
</tr>
<tr>
<td>double_range</td>
<td>64位双精度浮点型</td>
</tr>
<tr>
<td>date_range</td>
<td>64位整数, 毫秒计时</td>
</tr>
<tr>
<td>ip_range</td>
<td>IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在</td>
</tr>
</tbody></table>
<p>(1) 添加映射:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT company</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;department&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;expected_number&quot;</span>: &#123;  // 预期员工数</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer_range&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;time_frame&quot;</span>: &#123;       // 发展时间线</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date_range&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;ip_whitelist&quot;</span>: &#123;     // ip白名单</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ip_range&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 添加数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT company/department/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;expected_number&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;gte&quot;</span> : 10,</span><br><span class="line">        <span class="string">&quot;lte&quot;</span> : 20</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;time_frame&quot;</span> : &#123; </span><br><span class="line">        <span class="string">&quot;gte&quot;</span> : <span class="string">&quot;2018-10-01 12:00:00&quot;</span>, </span><br><span class="line">        <span class="string">&quot;lte&quot;</span> : <span class="string">&quot;2018-11-01&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&quot;ip_whitelist&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 查询数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET company/department/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;expected_number&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: 12</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET company/department/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;time_frame&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;gte&quot;</span>: <span class="string">&quot;208-08-01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;lte&quot;</span>: <span class="string">&quot;2018-12-01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;relation&quot;</span>: <span class="string">&quot;within&quot;</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;company&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;department&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;expected_number&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;time_frame&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-10-01 12:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-11-01&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ip_whitelist&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="2-复杂数据类型">2 复杂数据类型</span></h2><h2><span id="21-数组类型-array">2.1 数组类型 - array</span></h2><p>ES中没有专门的数组类型, 直接使用[]定义即可;</p>
<p><strong>数组中所有的值必须是同一种数据类型, 不支持混合数据类型的数组</strong>:</p>
<blockquote>
<p>① 字符串数组: [“one”, “two”];<br>② 整数数组: [1, 2];<br>③ 由数组组成的数组: [1, [2, 3]], 等价于[1, 2, 3];<br>④ 对象数组: [{“name”: “Tom”, “age”: 20}, {“name”: “Jerry”, “age”: 18}].</p>
</blockquote>
<p>注意:</p>
<blockquote>
<ul>
<li>动态添加数据时, 数组中第一个值的类型决定整个数组的类型;</li>
<li>不支持混合数组类型, 比如[1, “abc”];</li>
<li>数组可以包含null值, 空数组[]会被当做missing field —— 没有值的字段.</li>
</ul>
</blockquote>
<h2><span id="22-对象类型-object">2.2 对象类型 - object</span></h2><p>JSON文档是分层的: 文档可以包含内部对象, 内部对象也可以包含内部对象.</p>
<p>(1) 添加示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee/developer/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ma_shoufeng&quot;</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;region&quot;</span>: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">        <span class="string">&quot;location&quot;</span>: &#123;<span class="string">&quot;province&quot;</span>: <span class="string">&quot;GuangDong&quot;</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;GuangZhou&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 存储方式:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>                       <span class="string">&quot;ma_shoufeng&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address.region&quot;</span><span class="punctuation">:</span>             <span class="string">&quot;China&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address.location.province&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;GuangDong&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;address.location.city&quot;</span><span class="punctuation">:</span>      <span class="string">&quot;GuangZhou&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 文档的映射结构类似为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;developer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;, </span><br><span class="line">                <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;region&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;,</span><br><span class="line">                        <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                                <span class="string">&quot;province&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;,</span><br><span class="line">                                <span class="string">&quot;city&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="23-嵌套类型-nested">2.3 嵌套类型 - nested</span></h2><p>嵌套类型是对象数据类型的一个特例, 可以让array类型的对象被独立索引和搜索.</p>
<h3><span id="231-对象数组是如何存储的">2.3.1 对象数组是如何存储的</span></h3><p>① 添加数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT game_of_thrones/role/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;stark&quot;</span>,</span><br><span class="line">	<span class="string">&quot;performer&quot;</span>: [</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Snow&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;Sansa&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Stark&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>② 内部存储结构:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> 	         <span class="string">&quot;stark&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;performer.first&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;john&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sansa&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;performer.last&quot;</span><span class="punctuation">:</span>  <span class="punctuation">[</span> <span class="string">&quot;snow&quot;</span><span class="punctuation">,</span> <span class="string">&quot;stark&quot;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ 存储分析:</p>
<p>可以看出, user.first和user.last会被平铺为多值字段, 这样一来, John和Snow之间的关联性就丢失了.</p>
<p>在查询时, 可能出现John Stark的结果.</p>
<h3><span id="232-用nested类型解决object类型的不足">2.3.2 用nested类型解决object类型的不足</span></h3><p>如果需要对以最对象进行索引, 且保留数组中每个对象的独立性, 就应该使用嵌套数据类型.</p>
<p>—— 嵌套对象实质是将每个对象分离出来, 作为隐藏文档进行索引.</p>
<p>① 创建映射:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT game_of_thrones</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;performer&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;nested&quot;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>② 添加数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT game_of_thrones/role/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;group&quot;</span> : <span class="string">&quot;stark&quot;</span>,</span><br><span class="line">    <span class="string">&quot;performer&quot;</span> : [</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Snow&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;first&quot;</span>: <span class="string">&quot;Sansa&quot;</span>, <span class="string">&quot;last&quot;</span>: <span class="string">&quot;Stark&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ 检索数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET game_of_thrones/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;nested&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;path&quot;</span>: <span class="string">&quot;performer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">                        &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;performer.first&quot;</span>: <span class="string">&quot;John&quot;</span> &#125;&#125;,</span><br><span class="line">                        &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;performer.last&quot;</span>:  <span class="string">&quot;Snow&quot;</span> &#125;&#125; </span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="string">&quot;inner_hits&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;fields&quot;</span>: &#123;<span class="string">&quot;performer.first&quot;</span>: &#123;&#125;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="3-地理数据类型">3 地理数据类型</span></h2><h2><span id="31-地理点类型-geo-point">3.1 地理点类型 - geo point</span></h2><p>地理点类型用于存储地理位置的经纬度对, 可用于:</p>
<blockquote>
<ul>
<li>查找一定范围内的地理点;</li>
<li>通过地理位置或相对某个中心点的距离聚合文档;</li>
<li>将距离整合到文档的相关性评分中;</li>
<li>通过距离对文档进行排序.</li>
</ul>
</blockquote>
<p>(1) 添加映射:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;developer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;location&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 存储地理位置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 方式一: 纬度 + 经度键值对</span><br><span class="line">PUT employee/developer/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;小蛮腰-键值对地理点参数&quot;</span>, </span><br><span class="line">    <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lat&quot;</span>: 23.11, <span class="string">&quot;lon&quot;</span>: 113.33		// 纬度: latitude, 经度: longitude</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二: <span class="string">&quot;纬度, 经度&quot;</span>的字符串参数</span><br><span class="line">PUT employee/developer/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;小蛮腰-字符串地理点参数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: <span class="string">&quot;23.11, 113.33&quot;</span> 			// 纬度, 经度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式三: [<span class="string">&quot;经度, 纬度&quot;</span>] 数组地理点参数</span><br><span class="line">PUT employee/developer/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;小蛮腰-数组参数&quot;</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: [ 113.33, 23.11 ] 		// 经度, 纬度</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 查询示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;geo_bounding_box&quot;</span>: &#123; </span><br><span class="line">            <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;top_left&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 24, <span class="string">&quot;lon&quot;</span>: 113 &#125;,		// 地理盒子模型的上-左边</span><br><span class="line">                <span class="string">&quot;bottom_right&quot;</span>: &#123; <span class="string">&quot;lat&quot;</span>: 22, <span class="string">&quot;lon&quot;</span>: 114 &#125;	// 地理盒子模型的下-右边</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="32-地理形状类型-geo_shape">3.2 地理形状类型 - geo_shape</span></h2><p>是多边形的复杂形状. 使用较少, 这里省略.</p>
<h2><span id="4-专门数据类型">4 专门数据类型</span></h2><h2><span id="41-ip类型">4.1 IP类型</span></h2><p>IP类型的字段用于存储IPv4或IPv6的地址, 本质上是一个长整型字段.</p>
<p>(1) 添加映射:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;customer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;ip_addr&quot;</span>: &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ip&quot;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 添加数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee/customer/1</span><br><span class="line">&#123; <span class="string">&quot;ip_addr&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 查询数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET employee/customer/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;ip_addr&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="42-计数数据类型-token_count">4.2 计数数据类型 - token_count</span></h2><p>token_count类型用于统计字符串中的单词数量.</p>
<p>本质上是一个整数型字段, 接受并分析字符串值, 然后索引字符串中单词的个数.</p>
<p>(1) 添加映射:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;customer&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: &#123; </span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;length&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;token_count&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 添加数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT employee/customer/1</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Snow&quot;</span> &#125;</span><br><span class="line">PUT employee/customer/2</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tyrion Lannister&quot;</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 查询数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET employee/customer/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;name.length&quot;</span>: 2 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.6/mapping-types.html">Elasticsearch 6.6 官方文档 - Field datatypes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell编程中select用法</title>
    <url>/53b3b0c1/</url>
    <content><![CDATA[<p>select提供了一个构建交互式菜单程序的方式, 语法结构: <code>select name [ in word ] ; do list ; done</code></p>
<p>例:</p>
<pre><code>#!/bin/bash
select i in a b c d
do
    echo $i
done</code></pre><p>执行结果</p>
<pre><code>$ ./select.sh 
1) a
2) b
3) c
4) d
#? </code></pre><p>选择索引</p>
<pre><code>$ ./select.sh 
1) a
2) b
3) c
4) d
#? 1
a
#? 2
b
#? 3
c
#? 4
d
#? 6

#? 
1) a
2) b
3) c
4) d
#? 
1) a
2) b
3) c
4) d
#? </code></pre><p>如果输入的不是菜单描述的范围就会echo一个空行，如果直接输入回车，就会再显示一遍菜单本身。当然我们会发现这样一个菜单程序似乎没有什么意义，实际程序中，select大多数情况是跟case配合使用的。</p>
<pre><code>#!/bin/bash
select i in a b c d
do
    case $i in 
        a)
            echo &quot;Your choice is a&quot;
        ;;
        b)
            echo &quot;Your choice is b&quot;
        ;;
        c)
            echo &quot;Your choice is c&quot;
        ;;
        d)
            echo &quot;Your choice is d&quot;
        ;;
        *)
            echo &quot;Wrong choice! exit!&quot;
        ;;
    esac
done</code></pre><p>执行结果</p>
<pre><code>$ ./select.sh 
1) a
2) b
3) c
4) d
#? 1
Your choice is a
#? 2
Your choice is b
#? 3
Your choice is c
#? 4
Your choice is d
#? 5
Wrong choice! exit!</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg 推流工具</title>
    <url>/b3ed22dc/</url>
    <content><![CDATA[<p>SRR测试网址 <code>http://www.ossrs.net/srs.release/trunk/research/players/srs_player.html</code> 获取 <code>git clone https://github.com/ossrs/srs.git</code></p>
<p>configure make <code>cd srs/trunk</code> <code>./configure &amp;&amp; make</code></p>
<p>开启服务器 <code>./objs/srs -c conf/srs.conf</code></p>
<p>列出设备 <code>./ffmpeg.exe -list_devices true -f dshow -i dummy</code> ffmpeg采集摄像头推流 <code>ffmpeg.exe -f dshow -i video=&quot;EasyCamera&quot; -q 4 -s 640*480 -aspect 4:3 -r 10 -vcodec flv -ar 22050 -ab 64k -ac 1 -acodec libmp3lame -threads 4 -f flv rtmp://192.168.1.102/RTMP/RtmpVideo</code></p>
<p>ffmpeg采集摄像头和麦克风推流 <code>ffmpeg -f dshow -i video=&quot;USB2.0 PC CAMERA&quot; -f dshow -i audio=&quot;麦克风 (2- USB2.0 MIC)&quot; -b:a 600k -ab 128k -f flv rtmp://192.168.1.102/RTMP/RtmpVideo</code></p>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg 推流报错</title>
    <url>/eaddfbfe/</url>
    <content><![CDATA[<p>在使用dshow设备推流时，经常会报出real time buffer too full dropping frames的错误信息，其原因在<a href="https://trac.ffmpeg.org/wiki/DirectShow">这篇文章</a>里有写到，可以通过添加rtbufsize参数来解决，码率越高对应的rtbufsize就需要越高，但过高的rtbufsize会带来视频的延时，若要保持同步，可能就需要对音频人为增加一定的延时。而根据我的测试，即使不添加rtbufszie参数，虽然会报出错误信息，但并不影响直播流的观看或录制，而且可以保持同步。这就是一个trade off的问题了。</p>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>gif图片文件信息</title>
    <url>/2bf7952d/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#文件头">文件头</a></li>
<li><a href="#帧信息描述">帧信息描述</a></li>
</ul>
<!-- tocstop -->

<p>一个GIF文件主要由以下几部分组成。</p>
<ul>
<li>文件头</li>
<li>图像帧信息</li>
<li>注释</li>
</ul>
<h4><span id="文件头">文件头</span></h4><p>GIF格式文件头和一般文件头差别不大，也包含有</p>
<ul>
<li>格式声明</li>
<li>逻辑屏幕描述块</li>
<li>全局调色盘</li>
</ul>
<p><strong>格式声明</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005159.png" alt></p>
<p>Signature 为“GIF”3 个字符；Version 为“87a”或“89a”3 个字符。</p>
<p><strong>逻辑屏幕描述块</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005303.png" alt></p>
<p>前两字节为像素单位的宽、高，用以标识图片的视觉尺寸。</p>
<p>Packet里是调色盘信息，分别来看——</p>
<p>Global Color Table Flag 为全局颜色表标志，即为1时表明全局颜色表有定义。</p>
<p>Color Resolution 代表颜色表中每种基色位长（需要+1），为111时，每个颜色用8bit表示，即我们熟悉的RGB表示法，一个颜色三字节。</p>
<p>Sort Flag 表示是否对颜色表里的颜色进行优先度排序，把常用的排在前面，这个主要是为了适应一些颜色解析度低的早期渲染器，现在已经很少使用了。</p>
<p>Global Color Table 表示颜色表的长度，计算规则是值+1作为2的幂，得到的数字就是颜色表的项数，取最大值111时，项数=256，也就是说GIF格式最多支持256色的位图，再乘以Color Resolution算出的字节数，就是调色盘的总长度。</p>
<p>这四个字段一起定义了调色盘的信息。</p>
<p>Background color Index 定义了图像透明区域的背景色在调色盘里的索引。</p>
<p>Pixel Aspect Ratio 定义了像素宽高比，一般为0。</p>
<h4><span id="帧信息描述">帧信息描述</span></h4><p>帧信息描述就是每一帧的图像信息和相关标志位</p>
<p>大部分GIF存储时采用了公共区域排除和透明区域叠加的优化</p>
<p><strong>帧数据说明</strong></p>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>gif</tag>
      </tags>
  </entry>
  <entry>
    <title>github 博客绑定域名</title>
    <url>/e9fbcad9/</url>
    <content><![CDATA[<p>某篇文章说, CNAME 解析只支持 www 不支持@<br>所以@ 只能 解析到一个一个的 IP</p>
<h4><span id="1-source-添加-cname-文件">1. source 添加 CNAME 文件</span></h4><p>在源码的<code>source</code> 目录下, 添加一个<code>CNAME</code>文件<br>文件内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lxb.wiki</span><br></pre></td></tr></table></figure>

<h4><span id="2-dns-设置">2. DNS 设置</span></h4><table>
<thead>
<tr>
<th>记录类型</th>
<th>主机记录</th>
<th>解析路线(isp)</th>
<th>记录值</th>
<th>MX优先级</th>
<th>TTL</th>
<th>状态</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>CNAME</td>
<td>www</td>
<td>默认</td>
<td>lxbwolf.github.io</td>
<td>–</td>
<td>10 分钟</td>
<td>正常</td>
<td>修改暂停删除备注</td>
</tr>
<tr>
<td>A</td>
<td>@</td>
<td>默认</td>
<td>185.199.108.153</td>
<td>–</td>
<td>10 分钟</td>
<td>正常</td>
<td>修改暂停删除备注</td>
</tr>
<tr>
<td>A</td>
<td>@</td>
<td>默认</td>
<td>185.199.111.153</td>
<td>–</td>
<td>10 分钟</td>
<td>正常</td>
<td>修改暂停删除备注</td>
</tr>
<tr>
<td>A</td>
<td>@</td>
<td>默认</td>
<td>185.199.110.153</td>
<td>–</td>
<td>10 分钟</td>
<td>正常</td>
<td>修改暂停删除备注</td>
</tr>
<tr>
<td>A</td>
<td>@</td>
<td>默认</td>
<td>185.199.109.153</td>
<td>–</td>
<td>10 分钟</td>
<td>正常</td>
<td>修改暂停删除备注</td>
</tr>
</tbody></table>
<h4><span id="3-hexo-部署">3. hexo 部署</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang select 的用法</title>
    <url>/e353ee8e/</url>
    <content><![CDATA[<h4><span id="基本使用">基本使用</span></h4><p>select 是 Go 中的一个控制结构, 类似于switch 语句, 用于处理异步 IO 操作. select 语句会监听 case语句中channel 的读写操作, 当case 中 channel 读写操作为非阻塞状态(即能读写)时, 将会触发相应的动作.</p>
<pre><code>select 中的 case 语句必须是一个 channel 操作
select 中的 default 子句总是可运行的</code></pre><ol>
<li>如果有多个 case 都可以运行, select 会随机公平地选出一个执行, 其他不会执行</li>
<li>如果没有可运行的 case 语句, 且有 default 语句, 则会执行 default 的动作</li>
<li>如果没有可运行的 case 语句, 且没有 default 语句, select 将阻塞, 知道某个 case 通信可以运行</li>
</ol>
<p><strong>例</strong></p>
<pre><code>package main

import &quot;fmt&quot;

func main() &#123;
   var c1, c2, c3 chan int
   var i1, i2 int
   select &#123;
      case i1 = &lt;-c1:
         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)
      case c2 &lt;- i2:
         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)
      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
         if ok &#123;
            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)
         &#125; else &#123;
            fmt.Printf(&quot;c3 is closed\n&quot;)
         &#125;
      default:
         fmt.Printf(&quot;no communication\n&quot;)
   &#125;    
&#125;

//输出：no communication</code></pre><h4><span id="典型用法">典型用法</span></h4><h5><span id="1-超时判断">1. 超时判断</span></h5><pre><code>//比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行
var resChan = make(chan int)
// do request
func test() &#123;
    select &#123;
    case data := &lt;-resChan:
        doData(data)
    case &lt;-time.After(time.Second * 3):
        fmt.Println(&quot;request time out&quot;)
    &#125;
&#125;

func doData(data int) &#123;
    //...
&#125;</code></pre><h5><span id="2-退出">2. 退出</span></h5><pre><code>//主线程（协程）中如下：
var shouldQuit=make(chan struct&#123;&#125;)
fun main()&#123;
    &#123;
        //loop
    &#125;
    //...out of the loop
    select &#123;
        case &lt;-c.shouldQuit:
            cleanUp()
            return
        default:
        &#125;
    //...
&#125;

//再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行
close(shouldQuit)</code></pre><h5><span id="3-判断-channel-是否阻塞">3. 判断 channel 是否阻塞</span></h5><pre><code>//在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断
ch := make (chan int, 5)
//...
data：=0
select &#123;
case ch &lt;- data:
default:
    //做相应操作，比如丢弃data。视需求而定
&#125;</code></pre>]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go匿名函数和闭包</title>
    <url>/e2c91def/</url>
    <content><![CDATA[<h3><span id="函数变量函数值">函数变量(函数值)</span></h3><p>在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func square(x int) &#123;</span><br><span class="line">	println(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>直接调用：square(1)</li>
<li>把函数当成变量一样赋值：<code>s := square</code>；接着可以调用这个函数变量：s(1)。 注意：这里 square 后面没有圆括号，调用才有。</li>
</ol>
<ul>
<li>调用 <code>nil</code> 的函数变量会导致 panic。</li>
<li>函数变量的零值是 nil，这意味着它可以跟 nil 比较，但两个函数变量之间不能比较。</li>
</ul>
<h3><span id="匿名函数">匿名函数</span></h3><p>作用: 在go语言中目前了解的作用就是用于构成闭包</p>
<h3><span id="闭包">闭包</span></h3><p>闭包通过引用的方式使用外部函数的变量<br>函数与 与其(直接)相关的环境形成闭包</p>
<p>简单来说: 因为把返回的函数赋给了一个变量, 虽然函数在执行完一瞬间会销毁其执行环境, 但是如果有闭包的话, 闭包会保存外部函数的活动对象(变量), 所以如果不对闭包的引用消除掉, 闭包会一直存在内存中, 垃圾收集器不会销毁闭包占用的内存</p>
<h4><span id="实例1">实例1</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数A是一个不带参数，返回值是一个匿名函数，且该函数</span><br><span class="line">//带有一个int类型参数，返回值为一个int类型</span><br><span class="line">func A() func(int) int &#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	return func(bb int) int &#123;</span><br><span class="line">		sum += bb</span><br><span class="line">		fmt.Println(&quot;bb=&quot;, bb, &quot;\tsum=&quot;, sum)</span><br><span class="line">		return sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	a := A()//定义变量a,并将函数A的返回值赋给a // 这个时候, 虽然有小括号, 但是func A()还未真正执行, 只是赋值给了变量a</span><br><span class="line">	b := a(4) //真正执行func A()</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：   </span><br><span class="line">**    bb= 4   sum= 4</span><br><span class="line">**    4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>调用2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	a := A()</span><br><span class="line">	a(0)</span><br><span class="line">	a(1)</span><br><span class="line">	a(5)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 	sum= 0</span><br><span class="line">**　　bb= 1 	sum= 1</span><br><span class="line">**　　bb= 5 	sum= 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>以上调用通过闭包实现了sum的累加</p>
<p>调用3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	a := A()</span><br><span class="line">	c := A()</span><br><span class="line">	a(0)</span><br><span class="line">	a(5)</span><br><span class="line">	c(10)</span><br><span class="line">	c(20)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　bb= 0 	sum= 0</span><br><span class="line">**　　bb= 5 	sum= 5</span><br><span class="line">**　　bb= 10 	sum= 10</span><br><span class="line">**　　bb= 20 	sum= 30   </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>　可以看出，上例中调用了两次函数A，构成了两个闭包，这两个闭包维护的变量sum不是同一个变量。
　
　</p>
<h4><span id="实例2">实例2</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">	b := make([]func(), 3, 3)</span><br><span class="line">	for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">		b[i] = func() &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := B() // 这个时候并未真正执行函数, 只是定义, 所以不会print</span><br><span class="line">	c[0]() // 这个时候真正执行, 但是由于闭包, c[0] 中拿的i的引用</span><br><span class="line">	c[1]()</span><br><span class="line">	c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**　　输出：</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">**　　3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>闭包通过引用的方式使用外部函数的变量。</p>
<p>　　上例中只调用了一次函数B,构成一个闭包(<code>func() &#123;fmt.Println(i)&#125;</code> 与它的环境<code>func B() []func()&#123;&#125;</code> 构成闭包)，i 在外部函数B中定义，所以闭包维护该变量 i ，c[0]、c[1]、c[2]中的 i 都是闭包中 i 的引用。</p>
<p>　　因此执行<code>c:=B()</code>后，i 的值已经变为3，故再调用c<a href>0</a>时的输出是3而不是0。<br>　　<br>可作如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func B() []func() &#123;</span><br><span class="line">	b := make([]func(), 3, 3)</span><br><span class="line">	for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">		b[i] = (func(j int) func() &#123;</span><br><span class="line">			return func() &#123;</span><br><span class="line">				fmt.Println(j)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)(i) // 这个地方的小括号是真正执行了</span><br><span class="line">	&#125;</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := B()</span><br><span class="line">	c[0]()</span><br><span class="line">	c[1]()</span><br><span class="line">	c[2]()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：</span><br><span class="line">**        0</span><br><span class="line">**        1</span><br><span class="line">**        2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>函数<code>func() &#123;fmt.Println(j)&#125;</code> 与它的环境<code>func(j int) func() &#123;&#125;</code> 构成闭包, 变量<code>i</code>(实参) 并没有在它的环境范围内, 且 <code>j</code>是形参<br>以上修改可能没有什么实际意义，此处仅为说明问题使用。</p>
<p>在使用defer的时候可能出现类似问题，需要注意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for j := 0; j &lt; 2; j++ &#123;</span><br><span class="line">	defer (func() &#123;</span><br><span class="line">		fmt.Println(j)</span><br><span class="line">	&#125;)()</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">**    输出：    </span><br><span class="line">**    2    </span><br><span class="line">**    2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4><span id="实例3">实例3:</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func incr() func() int &#123;</span><br><span class="line">	var x int</span><br><span class="line">	return func() int &#123;</span><br><span class="line">		x++</span><br><span class="line">		return x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个函数会返回一个函数变量。<br><code>i := incr()</code> : 通过把这个函数变量赋值给<code>i</code>, <code>i</code> 就成为了一个闭包<br>所以<code>i</code> 保存着对<code>x</code> 的引用, 可以想象<code>i</code> 中有着一个指针指向<code>x</code> 或者 <code>i</code> 中有<code>x</code> 的地址</p>
<p>由于<code>i</code> 有着指向<code>x</code> 的指针, 所以可以修改<code>x</code> , 且保持着状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println(i()) // 1</span><br><span class="line">println(i()) // 2</span><br><span class="line">println(i()) // 3</span><br></pre></td></tr></table></figure>
<p>也就是说, <code>x</code> 逃逸了, 它的声明周期没有随着它的作用域结束而结束<br>但是这段代码却不会递增：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br><span class="line">println(incr()()) // 1</span><br></pre></td></tr></table></figure>

<p>这是因为这里调用了三次 <code>incr()</code>，返回了三个闭包，这三个闭包引用着三个不同的 <code>x</code>，它们的状态是各自独立的。</p>
<h4><span id="实例4-闭包引用产生的问题">实例4: 闭包引用产生的问题</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x := 1</span><br><span class="line">f := func() &#123;</span><br><span class="line">	println(x)</span><br><span class="line">&#125;</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br><span class="line">f() // 3</span><br></pre></td></tr></table></figure>
<p>因为闭包对外层词法域变量是引用的，所以这段代码会输出 3。<br>可以想象 f 中保存着 x 的地址，它使用 x 时会直接解引用，所以 x 的值改变了会导致 f 解引用得到的值也会改变。<br>但是，这段代码却会输出 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">	println(x) // 1</span><br><span class="line">&#125;()</span><br><span class="line">x = 2</span><br><span class="line">x = 3</span><br></pre></td></tr></table></figure>
<p>这是因为 f 调用时就已经解引用取值了，这之后的修改就与它无关了。</p>
<p>不过如果再次调用 f 还是会输出 3，这也再一次证明了 f 中保存着 x 的地址。<br>可以通过在闭包内外打印所引用变量的地址来证明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x := 1</span><br><span class="line">func() &#123;</span><br><span class="line">	println(&amp;x) // 0xc0000de790</span><br><span class="line">&#125;()</span><br><span class="line">println(&amp;x) // 0xc0000de790</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到引用的是同一个地址。</p>
<h4><span id="实例51-循环闭包引用">实例5.1: 循环闭包引用</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">	func() &#123;</span><br><span class="line">		println(i) // 0, 1, 2</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">	f := func() &#123;</span><br><span class="line">		println(i) // 0, 1, 2</span><br><span class="line">	&#125;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次迭代后都对 i 进行了解引用并使用得到的值且不再使用，所以这段代码会正常输出。</p>
<h4><span id="实例52">实例5.2</span></h4><p>正常代码：输出 0, 1, 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">	println(i) // 0, 1, 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而这段代码会输出 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var dummy [3]int</span><br><span class="line">var f func()</span><br><span class="line">for i := 0; i &lt; len(dummy); i++ &#123;</span><br><span class="line">	f = func() &#123;</span><br><span class="line">		println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() // 3 这个地方i最后的值是3, 而不是2, 因为只有i的值是3时, 才会跳出循环</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="实例53">实例5.3</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">	funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">		println(i)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">	funcSlice[j]() // 3, 3, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了解决上面这种情况, 可以声明新的匿名函数并传参:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var funcSlice []func()</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">	func(k int) &#123;</span><br><span class="line">		funcSlice = append(funcSlice, func() &#123;</span><br><span class="line">			println(k)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for j := 0; j &lt; 3; j++ &#123;</span><br><span class="line">	funcSlice[j]() // 0, 1, 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在 <code>println(k)</code> 使用的 <code>k</code> 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。(把<code>k</code>换成<code>i</code>也没有问题, 即使它与for条件的中的<code>i</code> 和func的入参<code>i</code> 重名也能正常运行)</p>
<p>所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p>
<p>这里的解决方法可以用在大多数跟闭包引用有关的问题上，不局限于第三个例子。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll高效运行的原理</title>
    <url>/3bdc8aea/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#io">I/O</a></li>
<li><a href="#事件">事件</a></li>
<li><a href="#通知机制">通知机制</a></li>
<li><a href="#epoll-的通俗解释">epoll 的通俗解释</a><ul>
<li><a href="#1-int-epoll_createint-size">1. int epoll_create(int size)</a></li>
<li><a href="#2-int-epoll_ctlint-epfd-int-op-int-fd-struct-epoll_event-event">2. int epoll_ctl(int epfd， int op， int fd， struct epoll_event *event)</a></li>
<li><a href="#3-int-epoll_waitint-epfd-struct-epoll_event-events-int-maxevents-int-timeout">3. int epoll_wait(int epfd， struct epoll_event *events， int maxevents， int timeout)</a></li>
</ul>
</li>
<li><a href="#epoll的两种触发方式">epoll的两种触发方式</a><ul>
<li><a href="#1水平触发的时机">1.水平触发的时机</a></li>
<li><a href="#2边缘触发的时机">2.边缘触发的时机</a></li>
</ul>
</li>
<li><a href="#epoll与select-poll的对比">epoll与select、poll的对比</a><ul>
<li><a href="#1-用户态将文件描述符传入内核的方式">1. 用户态将文件描述符传入内核的方式</a></li>
<li><a href="#2-内核态检测文件描述符读写状态的方式">2. 内核态检测文件描述符读写状态的方式</a></li>
<li><a href="#3-找到就绪的文件描述符并传递给用户态的方式">3. 找到就绪的文件描述符并传递给用户态的方式</a></li>
<li><a href="#4-重复监听的处理方式">4. 重复监听的处理方式</a></li>
</ul>
</li>
<li><a href="#epoll更高效的原因">epoll更高效的原因</a></li>
</ul>
<!-- tocstop -->

<h1><span id="概念">概念</span></h1><p>epoll是一种I/O事件通知机制，是linux 内核实现IO多路复用的一个实现。<br>IO多路复用是指，在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p>
<h1><span id="io">I/O</span></h1><p>输入输出(input/output)的对象可以是文件(file)， 网络(socket)，进程之间的管道(pipe)。在linux系统中，都用文件描述符(fd)来表示。</p>
<h1><span id="事件">事件</span></h1><ul>
<li>可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。(可读：内核缓冲区非空，有数据可以读取)</li>
<li>可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。(可写：内核缓冲区不满，有空闲空间可以写入）</li>
</ul>
<h1><span id="通知机制">通知机制</span></h1><p>通知机制，就是当事件发生的时候，则主动通知。通知机制的反面，就是轮询机制。</p>
<h1><span id="epoll-的通俗解释">epoll 的通俗解释</span></h1><p>结合以上三条，epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制</p>
<p>epoll 的 API</p>
<p>epoll的核心是3个API，核心数据结构是：1个红黑树和1个链表</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220211152245.png" alt></p>
<h2><span id="1-int-epoll_createint-size">1. int epoll_create(int size)</span></h2><p>功能：</p>
<ul>
<li>内核会产生一个epoll 实例数据结构并返回一个文件描述符，这个特殊的描述符就是epoll实例的句柄，后面的两个接口都以它为中心（即epfd形参）。</li>
</ul>
<blockquote>
<p>size参数表示所要监视文件描述符的最大值，不过在后来的Linux版本中已经被弃用（同时，size不要传0，会报invalid argument错误）</p>
</blockquote>
<h2><span id="2-int-epoll_ctlint-epfd-int-op-int-fd-struct-epoll_event-event">2. int epoll_ctl(int epfd， int op， int fd， struct epoll_event *event)</span></h2><p>功能：</p>
<ul>
<li>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">/* 指向用户自定义数据 */</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 注册的文件描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> u32; <span class="comment">/* 32-bit integer */</span></span><br><span class="line">    <span class="type">uint64_t</span> u64; <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">/* 描述epoll事件 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* 见上面的结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于需要监视的文件描述符集合，epoll_ctl对红黑树进行管理，红黑树中每个成员由描述符值和所要监控的文件描述符指向的文件表项的引用等组成。</p>
<p>op参数说明操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：向interest list添加一个需要监视的描述符</li>
<li>EPOLL_CTL_DEL：从interest list中删除一个描述符</li>
<li>EPOLL_CTL_MOD：修改interest list中一个描述符</li>
</ul>
<p>struct epoll_event结构描述一个文件描述符的epoll行为。在使用epoll_wait函数返回处于ready状态的描述符列表时，</p>
<ul>
<li>data域是唯一能给出描述符信息的字段，所以在调用epoll_ctl加入一个需要监测的描述符时，一定要在此域写入描述符相关信息</li>
<li>events域是bit mask，描述一组epoll事件，在epoll_ctl调用中解释为：描述符所期望的epoll事件，可多选。</li>
</ul>
<p>常用的epoll事件描述如下：</p>
<ul>
<li>EPOLLIN：描述符处于可读状态</li>
<li>EPOLLOUT：描述符处于可写状态</li>
<li>EPOLLET：将epoll event通知模式设置成edge triggered</li>
<li>EPOLLONESHOT：第一次进行通知，之后不再监测</li>
<li>EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件</li>
<li>EPOLLRDHUP：对端描述符产生一个挂断事件</li>
<li>EPOLLPRI：由带外数据触发</li>
<li>EPOLLERR：描述符产生错误时触发，默认检测事件</li>
</ul>
<h2><span id="3-int-epoll_waitint-epfd-struct-epoll_event-events-int-maxevents-int-timeout">3. int epoll_wait(int epfd， struct epoll_event *events， int maxevents， int timeout)</span></h2><p>功能：</p>
<ul>
<li>阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中。</li>
<li>events: 用来记录被触发的events，其大小应该和maxevents一致</li>
<li>maxevents: 返回的events的最大个数</li>
</ul>
<p>处于ready状态的那些文件描述符会被复制进ready list中，epoll_wait用于向用户进程返回ready list。events和maxevents两个参数描述一个由用户分配的struct epoll event数组，调用返回时，内核将ready list复制到这个数组中，并将实际复制的个数作为返回值。注意，如果ready list比maxevents长，则只能复制前maxevents个成员；反之，则能够完全复制ready list。<br>另外，struct epoll event结构中的events域在这里的解释是：在被监测的文件描述符上实际发生的事件。<br>参数timeout描述在函数调用中阻塞时间上限，单位是ms：</p>
<ul>
<li>timeout = -1表示调用将一直阻塞，直到有文件描述符进入ready状态或者捕获到信号才返回；</li>
<li>timeout = 0用于非阻塞检测是否有描述符处于ready状态，不管结果怎么样，调用都立即返回；</li>
<li>timeout &gt; 0表示调用将最多持续timeout时间，如果期间有检测对象变为ready状态或者捕获到信号则返回，否则直到超时。</li>
</ul>
<h1><span id="epoll的两种触发方式">epoll的两种触发方式</span></h1><p>epoll监控多个文件描述符的I/O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通过epoll_wait等待I/O事件，如果当前没有可用的事件则阻塞调用线程。</p>
<blockquote>
<p>select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。</p>
</blockquote>
<h2><span id="1水平触发的时机">1.水平触发的时机</span></h2><ol>
<li>对于读操作，只要缓冲内容不为空，LT模式返回读就绪。</li>
<li>对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</li>
</ol>
<p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。</p>
<h2><span id="2边缘触发的时机">2.边缘触发的时机</span></h2><ul>
<li>对于读操作</li>
</ul>
<ol>
<li>当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。</li>
<li>当有新数据到达时，即缓冲区中的待读数据变多的时候。</li>
<li>当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。</li>
</ol>
<ul>
<li>对于写操作</li>
</ul>
<ol>
<li>当缓冲区由不可写变为可写时。</li>
<li>当有旧数据被发送走，即缓冲区中的内容变少的时候。</li>
<li>当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。</li>
</ol>
<p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p>
<blockquote>
<p>在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。</p>
</blockquote>
<p>举例1：</p>
<ol>
<li>读缓冲区刚开始是空的</li>
<li>读缓冲区写入2KB数据</li>
<li>水平触发和边缘触发模式此时都会发出可读信号</li>
<li>收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据</li>
<li>水平触发会再次进行通知，而边缘触发不会再进行通知</li>
</ol>
<p>举例2：（以脉冲的高低电平为例）</p>
<ul>
<li>水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。</li>
<li>边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</li>
</ul>
<blockquote>
<p>JDK并没有实现边缘触发，Netty重新实现了epoll机制，采用边缘触发方式；另外像Nginx也采用边缘触发。</p>
</blockquote>
<p>JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式，netty epoll transport 暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；另外像Nginx也采用边缘触发。</p>
<h1><span id="epoll与select-poll的对比">epoll与select、poll的对比</span></h1><h2><span id="1-用户态将文件描述符传入内核的方式">1. 用户态将文件描述符传入内核的方式</span></h2><ul>
<li>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。</li>
<li>poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。</li>
<li>epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</li>
</ul>
<h2><span id="2-内核态检测文件描述符读写状态的方式">2. 内核态检测文件描述符读写状态的方式</span></h2><ul>
<li>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。</li>
<li>poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。</li>
<li>epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</li>
</ul>
<h2><span id="3-找到就绪的文件描述符并传递给用户态的方式">3. 找到就绪的文件描述符并传递给用户态的方式</span></h2><ul>
<li>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</li>
<li>poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</li>
<li>epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</li>
</ul>
<h2><span id="4-重复监听的处理方式">4. 重复监听的处理方式</span></h2><ul>
<li>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。</li>
<li>poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。</li>
<li>epoll：无需重新构建红黑树，直接沿用已存在的即可。</li>
</ul>
<h1><span id="epoll更高效的原因">epoll更高效的原因</span></h1><ol>
<li>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。</li>
<li>select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。</li>
<li>select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。</li>
<li>select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。</li>
<li>epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符</li>
</ol>
<blockquote>
<p>虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>go map数据结构</title>
    <url>/aaf3975f/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-前言">1. 前言</a></li>
<li><a href="#2-go-map的数据结构">2. go map的数据结构</a><ul>
<li><a href="#21-核心结体体">2.1 核心结体体</a></li>
<li><a href="#22-数据结构图">2.2 数据结构图</a></li>
</ul>
</li>
<li><a href="#3-go-map的常用操作">3. go map的常用操作</a><ul>
<li><a href="#31-创建">3.1 创建</a></li>
<li><a href="#32-插入或更新">3.2 插入或更新</a></li>
<li><a href="#33-删除">3.3 删除</a></li>
<li><a href="#34-查找">3.4 查找</a></li>
<li><a href="#35-range迭代">3.5 range迭代</a><ul>
<li><a href="#351-初始化迭代器mapiterinit">3.5.1 初始化迭代器mapiterinit()</a></li>
<li><a href="#352-迭代过程mapiternext">3.5.2 迭代过程mapiternext()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-go-map的扩容缩容">4. go map的扩容缩容</a><ul>
<li><a href="#41-扩容缩容的基本原理">4.1 扩容缩容的基本原理</a></li>
<li><a href="#42-为什么叫伪缩容如何实现真缩容">4.2 为什么叫“伪缩容”？如何实现“真缩容”？</a></li>
</ul>
</li>
<li><a href="#5-qa关键知识点">5 Q&amp;A关键知识点</a><ul>
<li><a href="#51-基本原理">5.1 基本原理</a></li>
<li><a href="#52-时间复杂度和空间复杂度分析">5.2 时间复杂度和空间复杂度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="1-前言">1. 前言</span></h1><p>go的map底层实现方式是hash表（C++的map是红黑树实现，而C++ 11新增的unordered_map则与go的map类似，都是hash实现）。go map的数据被置入一个由桶组成的有序数组中，每个桶最多可以存放8个key/value对。key的hash值(32位)的低阶位用于在该数组中定位到桶，而高8位则用于在桶中区分key/value对。<br>go map的hash表中的基本单位是桶，每个桶最多存8个键值对，超了，则会链接到额外的溢出桶。所以go map是基本数据结构是hash数组+桶内的key-value数组+溢出的桶链表<br>当hash表超过阈值需要扩容增长时，会分配一个新的数组，新数组的大小一般是旧数组的2倍。这里从旧数组将数据迁移到新数组，不会一次全量拷贝，go会在每次读写Map时以桶为单位做动态搬迁疏散。</p>
<h1><span id="2-go-map的数据结构">2. go map的数据结构</span></h1><h2><span id="21-核心结体体">2.1 核心结体体</span></h2><p>map主要由两个核心的结构，即基础结构和桶实现：</p>
<ul>
<li>hmap：map的基础结构</li>
<li>bmap：严格来说hmap.buckets指向桶组成的数组，每个桶的头部是bmap，之后是8个key，再是8个value，最后是1个溢出指针。溢出指针指向额外的桶链表，用于存储溢出的数据</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ( <span class="comment">// 关键的变量</span></span><br><span class="line">    bucketCntBits = <span class="number">3</span></span><br><span class="line">	bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits  <span class="comment">// 一个桶最多存储8个key-value对</span></span><br><span class="line">	loadFactorNum = <span class="number">13</span> <span class="comment">// 扩散因子：loadFactorNum / loadFactorDen = 6.5。</span></span><br><span class="line">	loadFactorDen = <span class="number">2</span>  <span class="comment">// 即元素数量 &gt;= (hash桶数量(2^hmp.B) * 6.5 / 8) 时，触发扩容</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// map的基础数据结构</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>	 <span class="comment">// map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1)</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">// 记录几个特殊的位标记，如当前是否有别的线程正在写map、当前是否为相同大小的增长（扩容/缩容？）</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// hash桶buckets的数量为2^B个</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出的桶的数量的近似值</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash种子</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 指向2^B个桶组成的数组的指针，数据存在这里</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 指向扩容前的旧buckets数组，只在map增长时有效</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 计数器，标示扩容后搬迁的进度</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// 保存溢出桶的链表和未使用的溢出桶数组的首地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶的实现结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash存储桶内每个key的hash值的高字节</span></span><br><span class="line">	<span class="comment">// tophash[0] &lt; minTopHash表示桶的疏散状态</span></span><br><span class="line">	<span class="comment">// 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对</span></span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">	<span class="comment">// 特别注意：</span></span><br><span class="line">	<span class="comment">// 实际分配内存时会申请一个更大的内存空间A，A的前8字节为bmap</span></span><br><span class="line">	<span class="comment">// 后面依次跟8个key、8个value、1个溢出指针</span></span><br><span class="line">	<span class="comment">// map的桶结构实际指的是内存空间A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map.go里很多函数的第1个入参是这个结构，从成员来看很明显，此结构标示了键值对和桶的大小等必要信息</span></span><br><span class="line"><span class="comment">// 有了这个结构的信息，map.go的代码就可以与键值对的具体数据类型解耦</span></span><br><span class="line"><span class="comment">// 所以map.go用内存偏移量和unsafe.Pointer指针来直接对内存进行存取，而无需关心key或value的具体类型</span></span><br><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ        _type</span><br><span class="line">	key        *_type</span><br><span class="line">	elem       *_type</span><br><span class="line">	bucket     *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	valuesize  <span class="type">uint8</span>  <span class="comment">// size of value slot</span></span><br><span class="line">	bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++使用模板可以根据不同的类型生成map的代码。<br>golang则通过上述maptype结构体传递键值对的类型大小等信息，从而map.go直接用指针操作对应大小的内存来实现全局一份map代码同时适用于不同类型的键值对。这点上可以认为相比C++用模板实现map的方式，go map的目标文件的代码量会更小。</p>
<h2><span id="22-数据结构图">2.2 数据结构图</span></h2><p>map底层创建时，会初始化一个hmap结构体，同时分配一个足够大的内存空间A。其中A的前段用于hash数组，A的后段预留给溢出的桶。于是hmap.buckets指向hash数组，即A的首地址；hmap.extra.nextOverflow初始时指向内存A中的后段，即hash数组结尾的下一个桶，也即第1个预留的溢出桶。所以当hash冲突需要使用到新的溢出桶时，会优先使用上述预留的溢出桶，hmap.extra.nextOverflow依次往后偏移直到用完所有的溢出桶，才有可能会申请新的溢出桶空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226143452.png" alt></p>
<p>上图中，当需要分配一个溢出桶时，会优先从预留的溢出桶数组里取一个出来链接到链表后面，这时不需要再次申请内存。但当预留的桶被用完了，则需要申请新的内存给溢出桶。</p>
<h1><span id="3-go-map的常用操作">3. go map的常用操作</span></h1><h2><span id="31-创建">3.1 创建</span></h2><p>使用make(map[k]v, hint)创建map时会调用makemap()函数，代码逻辑比较简单。<br>值得注意的是，makemap()创建的hash数组，数组的前面是hash表的空间，当hint &gt;= 4时后面会追加2^(hint-4)个桶，之后再内存页帧对齐又追加了若干个桶（参见2.2章节结构图的hash数组部分）<br>所以创建map时一次内存分配既分配了用户预期大小的hash数组，又追加了一定量的预留的溢出桶，还做了内存对齐，一举多得。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make(map[k]v, hint), hint即预分配大小</span></span><br><span class="line"><span class="comment">// 不传hint时，如用new创建个预设容量为0的map时，makemap只初始化hmap结构，不分配hash数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	<span class="comment">// 省略部分代码</span></span><br><span class="line">	<span class="comment">// 随机hash种子</span></span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2^h.B 为大于hint*6.5(扩容因子)的最小的2的幂</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// overLoadFactor(hint, B)只有一行代码：return hint &gt; bucketCnt &amp;&amp; uintptr(hint) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span></span><br><span class="line">	<span class="comment">// 即B的大小应满足 hint &lt;= (2^B) * 6.5</span></span><br><span class="line">	<span class="comment">// 一个桶能存8对key-value，所以这就表示B的初始值是保证这个map不需要扩容即可存下hint个元素对的最小的B值</span></span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里分配hash数组</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="comment">// makeBucketArray()会在hash数组后面预分配一些溢出桶，</span></span><br><span class="line">		<span class="comment">// h.extra.nextOverflow用来保存上述溢出桶的首地址</span></span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配hash数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">	base := bucketShift(b) <span class="comment">// base代表用户预期的桶的数量，即hash数组的真实大小</span></span><br><span class="line">	nbuckets := base <span class="comment">// nbuckets表示实际分配的桶的数量，&gt;= base，这就可能会追加一些溢出桶作为溢出的预留</span></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		<span class="comment">// 这里追加一定数量的桶，并做内存对齐</span></span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)</span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后面的代码就是申请内存空间了，此处省略</span></span><br><span class="line">	<span class="comment">// 这里大家可以思考下这个数组空间要怎么分配，其实就是n*sizeof(桶)，所以：</span></span><br><span class="line">		<span class="comment">// 每个桶前面是8字节的tophash数组，然后是8个key，再是8个value，最后放一个溢出指针</span></span><br><span class="line">		<span class="comment">// sizeof(桶) = 8 + 8*sizeof(key) + 8*sizeof(value) + 8</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="32-插入或更新">3.2 插入或更新</span></h2><p>go map的插入操作，调用mapassign()函数。<br>同学们或许在某些资料上了解过：</p>
<ul>
<li>go map需要初始化才能使用，对空map插入会panic。hmap指针传递的方式，决定了map在使用前必须初始化</li>
<li>go map不支持并发读写，会panic。如果一定要并发，请用sync.Map或自己解决冲突</li>
</ul>
<p>上述两个限制，在mapassign()函数开头能找到答案：</p>
<p>1 参数合法性检测，计算hash值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 不熟悉指针操作的同学，用指针传参往往会踩空指针的坑</span></span><br><span class="line">    <span class="comment">// 这里大家可以思考下，为什么h要非空判断？</span></span><br><span class="line">    <span class="comment">// 如果一定要在这里支持空map并检测到map为空时自动初始化，应该怎么写？</span></span><br><span class="line">    <span class="comment">// 提示：指针的指针</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在这里做并发判断，检测到并发写时，抛异常</span></span><br><span class="line">	<span class="comment">// 注意：go map的并发检测是伪检测，并不保证所有的并发都会被检测出来。而且这玩意是在运行期检测。</span></span><br><span class="line">	<span class="comment">// 所以对map有并发要求时，应使用sync.map来代替普通map，通过加锁来阻断并发冲突</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0)) <span class="comment">// 这里得到uint32的hash值</span></span><br><span class="line">	h.flags ^= hashWriting <span class="comment">// 置Writing标志，key写入buckets后才会清除标志</span></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123; <span class="comment">// map不能为空，但hash数组可以初始是空的，这里会初始化</span></span><br><span class="line">		h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 定位key在hash表中的位置</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B) <span class="comment">// 这里用hash值的低阶位定位hash数组的下标偏移量</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket) <span class="comment">// 这里是map的扩容缩容操作，我们在第4章单独讲</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过下标bucket，偏移定位到具体的桶</span></span><br><span class="line">	b := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(h.buckets) + bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash) <span class="comment">// 这里取高8位用于在桶内定位键值对</span></span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 进一步定位key可以插入的桶及桶中的位置</p>
<ul>
<li>两轮循环，外层循环遍历hash桶及其指向的溢出链表，内层循环则在桶内遍历（一个桶最多8个key-value对）</li>
<li>有可能正好链表上的桶都满了，这时inserti为nil，第4步会链接一个新的溢出桶进来</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="type">uint8</span>          <span class="comment">// tophash插入位置</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer  <span class="comment">// key插入位置</span></span><br><span class="line">	<span class="keyword">var</span> val unsafe.Pointer      <span class="comment">// value插入位置</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">				    <span class="comment">// 找到个空位，先记录下tophash、key、value的插入位置</span></span><br><span class="line">				    <span class="comment">// 但要遍历完才能确定要不要插入到这个位置，因为后面有可能有重复的元素</span></span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop <span class="comment">// 遍历完整个溢出链表，退出循环</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 走到这里说明map里找到一个重复的key，更新key-value，跳到第5步</span></span><br><span class="line">			<span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">				typedmemmove(t.key, k, key)</span><br><span class="line">			&#125;</span><br><span class="line">			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">			<span class="keyword">goto</span> done <span class="comment">// 更新Key后跳到第5步</span></span><br><span class="line">		&#125;</span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// 遍历完整个溢出链表，没找到能插入的空位，结束循环，下一步再追加一个溢出桶进来</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf <span class="comment">// 继续遍历下一个溢出桶</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4 插入 key</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里判断要不要扩容，我们第4章再讲</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123; <span class="comment">// inserti == nil说明上1步没找到空位，整个链表是满的，这里添加一个新的溢出桶上去</span></span><br><span class="line">		newb := h.newoverflow(t, b) <span class="comment">// 分配新溢出桶，优先用3.1章节预留的溢出桶，用完了则分配一个新桶内存</span></span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		val = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当key或value的类型大小超过一定值时，桶只存储key或value的指针。这里分配空间并取指针</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">		kmem := newobject(t.key)</span><br><span class="line">		*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">		insertk = kmem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">		vmem := newobject(t.elem)</span><br><span class="line">		*(*unsafe.Pointer)(val) = vmem</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(t.key, insertk, key) <span class="comment">// 在桶中对应位置插入key</span></span><br><span class="line">	*inserti = top <span class="comment">// 插入tophash，hash值高8位</span></span><br><span class="line">	h.count++ <span class="comment">// 插入了新的键值对，h.count数量+1</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5 结束插入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.flags &amp;^= hashWriting <span class="comment">// 释放hashWriting标志位</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">		val = *((*unsafe.Pointer)(val))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val <span class="comment">// 返回value可插入位置的指针，注意，value还没插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只插入了tophash和key，就结束了吗？value还没插入呢</li>
<li>是的，mapassign()只插入tophash和key，并返回val指针，编译器会在调用mapassign()后用汇编往val插入value</li>
<li>google大佬这么骚气的操作，是为了减少value值传递的次数吗？</li>
</ul>
<h2><span id="33-删除">3.3 删除</span></h2><ol>
<li>删除与插入类似，前面的步骤都是参数和状态判断、定位key-value位置，然后clear对应的内存。不展开说。以下是几个关键点：</li>
</ol>
<ul>
<li>删除过程中也会置hashWriting标志</li>
<li>当key/value过大时，hash表里存储的是指针，这时候用软删除，置指针为nil，数据交给gc去删。当然，这是map的内部处理，外层是无感知的，拿到的都是值拷贝</li>
<li>无论Key/value是值类型还是指针类型，删除操作都只影响hash表，外层已经拿到的数据不受影响。尤其是指针类型，外层的指针还能继续使用</li>
</ul>
<ol>
<li>由于定位key位置的方式是查找tophash，所以删除操作对tophash的处理是关键：</li>
</ol>
<ul>
<li>map首先将对应位置的tophash[i]置为emptyOne，表示该位置已被删除</li>
<li>如果tophash[i]不是整个链表的最后一个，则只置emptyOne标志，该位置被删除但未释放，后续插入操作不能使用此位置</li>
<li>如果tophash[i]是链表最后一个有效节点了，则把链表最后面的所有标志为emptyOne的位置，都置为emptyRest。置为emptyRest的位置可以在后续的插入操作中被使用。</li>
<li>这种删除方式，以少量空间来避免桶链表和桶内的数据移动。事实上，go 数据一旦被插入到桶的确切位置，map是不会再移动该数据在桶中的位置了。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">            b.tophash[i] = emptyOne <span class="comment">// 先标记删除</span></span><br><span class="line">			<span class="comment">// 如果b.tophash[i]不是最后一个元素，则暂时先占着坑。emptyOne标记的位置暂时不能被插入新元素(见3.2章节插入函数)</span></span><br><span class="line">			<span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> &#123; <span class="comment">// 如果b.tophash[i]是最后一个元素，则把末尾的emptyOne全部清除置为emptyRest</span></span><br><span class="line">				b.tophash[i] = emptyRest</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">						<span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">					c := b</span><br><span class="line">					<span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					i = bucketCnt - <span class="number">1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					i--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="34-查找">3.4 查找</span></h2><p>查找操作由mapaccess开头的一组函数实现。前面的章节在插入和删除之前都得先定位查找到元素，逻辑是类似的，也比较简单，就不细说了：</p>
<ul>
<li>mapaccess1()：通过Key查找，返回value指针，用于val := map[key]。未找到时返回value类型的0值。</li>
<li>mapaccess2()：通过key查找，返回value指针，以及bool类型的是否查找成功的标志，用于val, ok := map[key]。未找到时返回value类型的0值。</li>
<li>mapaccessK()：通过key查找，返回key和value指针，用于迭代器(range)。未找到时返回空指针</li>
<li>mapaccess1_fat()，对mapaccess1()的封装，区别是mapaccess1_fat()多了个zero参数，未找到时返回zero</li>
<li>mapaccess2_fat()，也是对mapaccess1()的封装。相比mapaccess1_fat()，本函数增加一个是否查找成功的标志</li>
</ul>
<h2><span id="35-range迭代">3.5 range迭代</span></h2><p>map的迭代是通过hiter结构和对应的两个辅助函数实现的。hiter结构由编译器在调用辅助函数之前创建并传入，每次迭代结果也由hiter结构传回。下方的it即是hiter结构体的指针变量。</p>
<h3><span id="351-初始化迭代器mapiterinit">3.5.1 初始化迭代器mapiterinit()</span></h3><p>mapiterinit()函数主要是决定我们从哪个位置开始迭代，为什么是从哪个位置，而不是直接从hash数组头部开始呢？《go程序设计语言》好像提到过，hash表中数据每次插入的位置是变化的（其实是因为实现的原因，一方面hash种子是随机的，这导致相同的数据在不同的map变量内的hash值不同；另一方面即使同一个map变量内，数据删除再添加的位置也有可能变化，因为在同一个桶及溢出链表中数据的位置不分先后），所以为了防止用户错误的依赖于每次迭代的顺序，map作者干脆让相同的map每次迭代的顺序也是随机的。<br>迭代顺序随机的实现方式也简单，直接从随机的一个位置开始就行了：</p>
<ul>
<li>it.startBucket：这个是hash数组的偏移量，表示遍历从这个桶开始</li>
<li>it.offset：这个是桶内的偏移量，表示每个桶的遍历都从这个偏移量开始</li>
</ul>
<p>于是，map的遍历过程如下：</p>
<ul>
<li>从hash数组中第it.startBucket个桶开始，先遍历hash桶，然后是这个桶的溢出链表。</li>
<li>之后hash数组偏移量+1，继续前一步动作。</li>
<li>遍历每一个桶，无论是hash桶还是溢出桶，都从it.offset偏移量开始。（如果只是随机一个开始的桶，range结果还是有序的；但每个桶都加it.offset偏移，这个输出结果就有点扑朔迷离，大家可以亲手试下，对同一个map多次range）</li>
<li>当迭代器经过一轮循环回到it.startBucket的位置，结束遍历。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机一个偏移量来开始</span></span><br><span class="line">    r := <span class="type">uintptr</span>(fastrand())</span><br><span class="line">    <span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">		r += <span class="type">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">    &#125;</span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">	it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	mapiternext(it) <span class="comment">// 初始化迭代器的同时也返回第1对key/value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="352-迭代过程mapiternext">3.5.2 迭代过程mapiternext()</span></h3><p>上一节迭代循环的过程很清晰了，这里我们说明几个重要的参数：</p>
<ul>
<li>it.startBucket：开始的桶</li>
<li>it.offset：每个桶开始的偏移量</li>
<li>it.bptr：当前遍历的桶</li>
<li>it.i：it.bptr已经遍历的键值对数量，i初始为0，当i=8时表示这个桶遍历完了，将it.bptr移向下一个桶</li>
<li>it.key：每次迭代的结果</li>
<li>it.value：每次迭代的结果</li>
</ul>
<p>此外，迭代还需要关注扩容缩容的情况：</p>
<ul>
<li>如果是在迭代开始后才growing，这种情况当前的逻辑没处理，迭代有可能异常。呃，go map不支持并发。</li>
<li>如果是先growing，再开始迭代，这是有可能的。这种情况下，会先到旧hash表中检查key对应的桶有没有被疏散，未疏散则遍历旧桶，已疏散则遍历新hash表里对应的桶。</li>
</ul>
<h1><span id="4-go-map的扩容缩容">4. go map的扩容缩容</span></h1><h2><span id="41-扩容缩容的基本原理">4.1 扩容缩容的基本原理</span></h2><p>go map的扩容缩容都是grow相关的函数，这里扩容是真的，缩容是伪缩容，后面我会解释。我们先看下触发条件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overLoadFactor()返回true则触发扩容，即map的count大于hash桶数量(2^B)*6.5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets()，顾名思义，溢出桶太多了触发缩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">		B = <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map只在插入元素即mapassign()函数中对是否扩容缩容进行触发，条件即是上面这段代码：</p>
<ul>
<li>条件1：当前不处在growing状态</li>
<li>条件2-1：触发扩容：map的数据量count大于hash桶数量(2B)*6.5。注意这里的(2B)只是hash数组大小，不包括溢出的桶</li>
<li>条件2-2：触发缩容：溢出的桶数量noverflow&gt;=32768(1&lt;&lt;15)或者&gt;=hash数组大小。</li>
</ul>
<p>仔细观察触发的代码，扩容和缩容是同一个函数，这是怎么做到的呢？在hashGrow()开始，会先判断是否满足扩容条件，如果满足就表明这次是扩容，不满足就一定是缩容条件触发了。扩容和缩容剩下的逻辑，主要区别就在于容量变化，就是hmap.B参数，扩容时B+1则hash表容量扩大1倍，缩容时hash表容量不变。</p>
<ul>
<li>h.oldbuckets：指向旧的hash数组，即当前的h.buckets</li>
<li>h.buckets：指向新创建的hash数组</li>
</ul>
<p>到这里触发的主要工作已经完成，接下来就是怎么把元素搬迁到新hash表里了。如果现在就一次全量搬迁过去，显然接下来会有比较长的一段时间map被占用（不支持并发）。所以搬迁的工作是异步增量搬迁的。<br>在插入和删除的函数内都有下面一段代码用于在每次插入和删除操作时，执行一次搬迁工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.growing() &#123; <span class="comment">// 当前处于搬迁状态</span></span><br><span class="line">		growWork(t, h, bucket) <span class="comment">// 调用搬迁函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将当前需要处理的桶搬迁</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123; <span class="comment">// 再多搬迁一个桶</span></span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每执行一次插入或删除，都会调用growWork搬迁0~2个hash桶（有可能这次需要搬迁的2个桶在此之前都被搬过了）</li>
<li>搬迁是以hash桶为单位的，包含对应的hash桶和这个桶的溢出链表</li>
<li>被delete掉的元素(emptyone标志)会被舍弃（这是缩容的关键）</li>
</ul>
<h2><span id="42-为什么叫伪缩容如何实现真缩容">4.2 为什么叫“伪缩容”？如何实现“真缩容”？</span></h2><p>现在可以解释为什么我把map的缩容叫做伪缩容了：因为缩容仅仅针对溢出桶太多的情况，触发缩容时hash数组的大小不变，即hash数组所占用的空间只增不减。也就是说，如果我们把一个已经增长到很大的map的元素挨个全部删除掉，hash表所占用的内存空间也不会被释放。</p>
<p>所以如果要实现“真缩容”，需自己实现缩容搬迁，即创建一个较小的map，将需要缩容的map的元素挨个搬迁过来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go map缩容代码示例</span></span><br><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里我们对bigMap做了很多次插入，之后又做了很多次删除，此时bigMap的元素数量远小于hash表大小</span></span><br><span class="line"><span class="comment">// 接下来我们开始缩容</span></span><br><span class="line">smallMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="built_in">len</span>(myMap))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    smallMap[k] = v</span><br><span class="line">&#125;</span><br><span class="line">myMap = smallMap <span class="comment">// 缩容完成，原来的map被我们丢弃，交给gc去清理</span></span><br></pre></td></tr></table></figure>

<h1><span id="5-qampa关键知识点">5 Q&amp;A关键知识点</span></h1><h2><span id="51-基本原理">5.1 基本原理</span></h2><ul>
<li>底层是hash实现，数据结构为hash数组 + 桶 + 溢出的桶链表，每个桶存储最多8个key-value对</li>
<li>查找和插入的原理：key的hash值（低阶位）与桶数量相与，得到key所在的hash桶，再用key的高8位与桶中的tophash[i]对比，相同则进一步对比key值，key值相等则找到</li>
<li>go map不支持并发。插入、删除、搬迁等操作会置writing标志，检测到并发直接panic</li>
<li>每次扩容hash表增大1倍，hash表只增不减</li>
<li>支持有限缩容，delete操作只置删除标志位，释放溢出桶的空间依靠触发缩容来实现。</li>
<li>map在使用前必须初始化，否则panic：已初始化的map是make(map[key]value)或make(map[key]value, hint)这两种形式。而new或var xxx map[key]value这两种形式是未初始化的，直接使用会panic。</li>
</ul>
<h2><span id="52-时间复杂度和空间复杂度分析">5.2 时间复杂度和空间复杂度分析</span></h2><p>时间复杂度，go map是hash实现，我们先不管具体原理，江湖套路hash实现的就叫它O(1)的时间复杂度：</p>
<ul>
<li>正常情况，且不考虑扩容状态，复杂度O(1)：通过hash值定位桶是O(1)，一个桶最多8个元素，合理的hash算法应该能把元素相对均匀散列，所以溢出链表（如果有）也不会太长，所以虽然在桶和溢出链表上定位key是遍历，考虑到数量小也可以认为是O(1)</li>
<li>正常情况，处于扩容状态时，复杂度也是O(1)：相比于上一种状态，扩容会增加搬迁最多2个桶和溢出链表的时间消耗，当溢出链表不太长时，复杂度也可以认为是O(1)</li>
<li>极端情况，散列极不均匀，大部分数据被集中在一条散列链表上，复杂度退化为O(n)。</li>
</ul>
<p>go采用的hash算法应是很成熟的算法，极端情况暂不考虑。所以综合情况下go map的时间复杂度应为O(1)</p>
<p>空间复杂度分析：<br>首先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在go是留给程序员自己解决），只考虑一个持续增长状态的map的一个空间使用率：<br>由于溢出桶数量超过hash桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash表基本是空的，这时空间浪费O(n)。<br>最好的情况下，数据均匀散列在hash表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前go的扩散因子由全局变量决定，即loadFactorNum/loadFactorDen = 6.5。即平均每个hash桶被分配到6.5个元素以上时，开始扩容。所以最小的空间浪费是(8-6.5)/8 = 0.1875，即O(0.1875n)</p>
<p>结论：go map的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是O(0.1875n) ~ O(n)之间。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用hexo-toc锚点失效问题</title>
    <url>/b4c41686/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#现象">现象</a></li>
<li><a href="#原因">原因</a></li>
<li><a href="#修复方法">修复方法</a></li>
</ul>
<!-- tocstop -->

<h4><span id="现象">现象</span></h4><p>使用 hexo-toc 生成文章目录时，点击某个目录，url 变成 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/690c8418/#null</span><br></pre></td></tr></table></figure>



<h4><span id="原因">原因</span></h4><p>插件在把 markdown 编译成 HTML 时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## title</span><br></pre></td></tr></table></figure>

<p>会编译为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&lt;span id=&quot;title&quot;&gt;title&lt;/span&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p>而在插件源码的<a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/helper/toc.js#L27">这次提交</a>之前，是会编译成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2 id=&quot;title&quot;&gt;title&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p>因此新版本的 <code>hexo-toc</code> 生成 TOC 时，元素没有 <code>id</code> 这个属性，进而导致 TOC 中的锚点失效。</p>
<h4><span id="修复方法">修复方法</span></h4><p>修改 <code>node_modules/hexo-toc/lib/filter.js</code></p>
<p>把 28 行的 <code>$title.attr(&#39;id&#39;, id);</code> 注释打开</p>
<p>把 31 行的 <code>$title.removeAttr(&#39;id&#39;);</code> 注释掉</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo支持mermaid</title>
    <url>/6541b31d/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#安装插件">安装插件</a></li>
<li><a href="#编辑配置文件">编辑配置文件</a></li>
<li><a href="#在-ejs-中引入-mermaidjs">在 ejs 中引入 mermaid.js</a></li>
<li><a href="#qa">Q&amp;A</a></li>
</ul>
<!-- tocstop -->

<h2><span id="前言">前言</span></h2><p>一定要参考[官网](<a href="https://mermaid-js.github.io/mermaid/#/">mermaid - Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs. (mermaid-js.github.io)</a>)</p>
<p>不要相信垃圾 CSDN</p>
<h2><span id="安装插件">安装插件</span></h2><p>npm 安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>



<p>项目 [GitHub 主页]<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">webappdevelp/hexo-filter-mermaid-diagrams: mermaid diagrams for hexo (github.com)</a></p>
<h2><span id="编辑配置文件">编辑配置文件</span></h2><p>修改文件 <code>themes/pure/_config.yml</code></p>
<p>文件最好添加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>



<h2><span id="在-ejs-中引入-mermaidjs">在 ejs 中引入 mermaid.js</span></h2><p>修改 <code>themes/pure/layout/_common/footer.ejs</code></p>
<p>添加以下内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.<span class="property">mermaid</span>.<span class="property">enable</span>) &#123; %&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">mermaid</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      mermaid.<span class="title function_">initialize</span>(&#123;<span class="attr">theme</span>: <span class="string">&#x27;forest&#x27;</span>&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>



<h2><span id="qampa">Q&amp;A</span></h2><p>如果加载完后，显示的图不正确，那么很有可能是因为引入 <code>mermaid.min.js</code> 的链接不正确</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg 视音频同步</title>
    <url>/aeb01c06/</url>
    <content><![CDATA[<p>原文地址: <a href="https://blog.csdn.net/nonmarking/article/details/50522413">https://blog.csdn.net/nonmarking/article/details/50522413</a></p>
<p>对于直播流来说, 只考虑发送端的同步问题, 原理如下: 1. 解析视音频, 讲视频流和音频流的时间戳用同样的时间基准表示 2. 比较转换后的两个时间戳, 找出较小值, 对应发送偏慢的流 3. 读取, 转码, 发送相应的流, 同时, 若该流的转码时间很快, 超前于wall clock, 则还需要进行相应的延时 4. 重复以上过程</p>
<p>下文包括两部分, 一是音频转码部分, 二是视音频同步</p>
<h6><span id="音频转码基本流程">音频转码基本流程</span></h6><p>首先是一些音频输入输出的基本设置</p>
<pre><code>//Set own audio device&apos;s name
    if (avformat_open_input(&amp;ifmt_ctx_a, device_name_a, ifmt, &amp;device_param) != 0)&#123;

        printf(&quot;Couldn&apos;t open input audio stream.（无法打开输入流）\n&quot;);
        return -1;
    &#125;
……
//input audio initialize
    if (avformat_find_stream_info(ifmt_ctx_a, NULL) &lt; 0)
    &#123;
        printf(&quot;Couldn&apos;t find audio stream information.（无法获取流信息）\n&quot;);
        return -1;
    &#125;
    audioindex = -1;
    for (i = 0; i &lt; ifmt_ctx_a-&gt;nb_streams; i++)
    if (ifmt_ctx_a-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
    &#123;
        audioindex = i;
        break;
    &#125;
    if (audioindex == -1)
    &#123;
        printf(&quot;Couldn&apos;t find a audio stream.（没有找到视频流）\n&quot;);
        return -1;
    &#125;
    if (avcodec_open2(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec, avcodec_find_decoder(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;codec_id), NULL) &lt; 0)
    &#123;
        printf(&quot;Could not open audio codec.（无法打开解码器）\n&quot;);
        return -1;
    &#125;
……
 //output audio encoder initialize
    pCodec_a = avcodec_find_encoder(AV_CODEC_ID_AAC);
    if (!pCodec_a)&#123;
        printf(&quot;Can not find output audio encoder! (没有找到合适的编码器！)\n&quot;);
        return -1;
    &#125;
    pCodecCtx_a = avcodec_alloc_context3(pCodec_a);
    pCodecCtx_a-&gt;channels = 2;
    pCodecCtx_a-&gt;channel_layout = av_get_default_channel_layout(2);
    pCodecCtx_a-&gt;sample_rate = ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate;
    pCodecCtx_a-&gt;sample_fmt = pCodec_a-&gt;sample_fmts[0];
    pCodecCtx_a-&gt;bit_rate = 32000;
    pCodecCtx_a-&gt;time_base.num = 1;
    pCodecCtx_a-&gt;time_base.den = pCodecCtx_a-&gt;sample_rate;
    /** Allow the use of the experimental AAC encoder */
    pCodecCtx_a-&gt;strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
    /* Some formats want stream headers to be separate. */
    if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)
        pCodecCtx_a-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;
    if (avcodec_open2(pCodecCtx_a, pCodec_a, NULL) &lt; 0)&#123;
        printf(&quot;Failed to open ouput audio encoder! (编码器打开失败！)\n&quot;);
        return -1;
    &#125;

    //Add a new stream to output,should be called by the user before avformat_write_header() for muxing
    audio_st = avformat_new_stream(ofmt_ctx, pCodec_a);
    if (audio_st == NULL)&#123;
        return -1;
    &#125;
    audio_st-&gt;time_base.num = 1;
    audio_st-&gt;time_base.den = pCodecCtx_a-&gt;sample_rate;
    audio_st-&gt;codec = pCodecCtx_a;</code></pre><p>接下来, 考虑到输入音频的sample format 可能需要进行转换, 需要用到swresample库的功能 先做好相应的初始化</p>
<pre><code>// Initialize the resampler to be able to convert audio sample formats
    aud_convert_ctx = swr_alloc_set_opts(NULL,
        av_get_default_channel_layout(pCodecCtx_a-&gt;channels),
        pCodecCtx_a-&gt;sample_fmt,
        pCodecCtx_a-&gt;sample_rate,
        av_get_default_channel_layout(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;channels),
        ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_fmt,
        ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate,
        0, NULL);
swr_init(aud_convert_ctx);</code></pre><p>此外, 参照transcode_aac.c的做法, 使用FIFO buffer存储从输入端解码得到的音频采样数据, 这些数据在后续将转换sample format并进行编码, 由此即完成了一个音频转码功.</p>
<p>此外, 还需要另外的一个buffer来存储转换合适之后的音频数据</p>
<pre><code>//Initialize the FIFO buffer to store audio samples to be encoded. 
    AVAudioFifo *fifo = NULL;
    fifo = av_audio_fifo_alloc(pCodecCtx_a-&gt;sample_fmt, pCodecCtx_a-&gt;channels, 1);

    //Initialize the buffer to store converted samples to be encoded.
    uint8_t **converted_input_samples = NULL;
    /**
    * Allocate as many pointers as there are audio channels.
    * Each pointer will later point to the audio samples of the corresponding
    * channels (although it may be NULL for interleaved formats).
    */
    if (!(converted_input_samples = (uint8_t**)calloc(pCodecCtx_a-&gt;channels,
        sizeof(**converted_input_samples)))) &#123;
        printf(&quot;Could not allocate converted input sample pointers\n&quot;);
        return AVERROR(ENOMEM);
    &#125;</code></pre><p>至此, 一些基本的初始化工作完成.</p>
<p>音频计算pts的方法和视频类似. 即先通过sample rate算出每两个音频sample之间的时间间隔, 再通过计数当前已编码的音频sample总数(nb_samples变量的作用) 来算出当前编码音频帧的时间戳. 如果和视频的流程做类比, 大概为: framerate 相当于sample rate, framecnt相当于nb_samples.</p>
<pre><code>//audio trancoding here
        const int output_frame_size = pCodecCtx_a-&gt;frame_size;

        /**
        * Make sure that there is one frame worth of samples in the FIFO
        * buffer so that the encoder can do its work.
        * Since the decoder&apos;s and the encoder&apos;s frame size may differ, we
        * need to FIFO buffer to store as many frames worth of input samples
        * that they make up at least one frame worth of output samples.
        */
        while (av_audio_fifo_size(fifo) &lt; output_frame_size) &#123;
            /**
            * Decode one frame worth of audio samples, convert it to the
            * output sample format and put it into the FIFO buffer.
            */
            AVFrame *input_frame = av_frame_alloc();
            if (!input_frame)
            &#123;
                ret = AVERROR(ENOMEM);
                return ret;
            &#125;           

            /** Decode one frame worth of audio samples. */
            /** Packet used for temporary storage. */
            AVPacket input_packet;
            av_init_packet(&amp;input_packet);
            input_packet.data = NULL;
            input_packet.size = 0;

            /** Read one audio frame from the input file into a temporary packet. */
            if ((ret = av_read_frame(ifmt_ctx_a, &amp;input_packet)) &lt; 0) &#123;
                /** If we are at the end of the file, flush the decoder below. */
                if (ret == AVERROR_EOF)
                &#123;
                    encode_audio = 0;
                &#125;
                else
                &#123;
                    printf(&quot;Could not read audio frame\n&quot;);
                    return ret;
                &#125;                   
            &#125;

            /**
            * Decode the audio frame stored in the temporary packet.
            * The input audio stream decoder is used to do this.
            * If we are at the end of the file, pass an empty packet to the decoder
            * to flush it.
            */
            if ((ret = avcodec_decode_audio4(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec, input_frame,
                &amp;dec_got_frame_a, &amp;input_packet)) &lt; 0) &#123;
                printf(&quot;Could not decode audio frame\n&quot;);
                return ret;
            &#125;
            av_packet_unref(&amp;input_packet);
            /** If there is decoded data, convert and store it */
            if (dec_got_frame_a) &#123;
                /**
                * Allocate memory for the samples of all channels in one consecutive
                * block for convenience.
                */
                if ((ret = av_samples_alloc(converted_input_samples, NULL,
                    pCodecCtx_a-&gt;channels,
                    input_frame-&gt;nb_samples,
                    pCodecCtx_a-&gt;sample_fmt, 0)) &lt; 0) &#123;
                    printf(&quot;Could not allocate converted input samples\n&quot;);
                    av_freep(&amp;(*converted_input_samples)[0]);
                    free(*converted_input_samples);
                    return ret;
                &#125;

                /**
                * Convert the input samples to the desired output sample format.
                * This requires a temporary storage provided by converted_input_samples.
                */
                /** Convert the samples using the resampler. */
                if ((ret = swr_convert(aud_convert_ctx,
                    converted_input_samples, input_frame-&gt;nb_samples,
                    (const uint8_t**)input_frame-&gt;extended_data, input_frame-&gt;nb_samples)) &lt; 0) &#123;
                    printf(&quot;Could not convert input samples\n&quot;);
                    return ret;
                &#125;

                /** Add the converted input samples to the FIFO buffer for later processing. */
                /**
                * Make the FIFO as large as it needs to be to hold both,
                * the old and the new samples.
                */
                if ((ret = av_audio_fifo_realloc(fifo, av_audio_fifo_size(fifo) + input_frame-&gt;nb_samples)) &lt; 0) &#123;
                    printf(&quot;Could not reallocate FIFO\n&quot;);
                    return ret;
                &#125;

                /** Store the new samples in the FIFO buffer. */
                if (av_audio_fifo_write(fifo, (void **)converted_input_samples,
                    input_frame-&gt;nb_samples) &lt; input_frame-&gt;nb_samples) &#123;
                    printf(&quot;Could not write data to FIFO\n&quot;);
                    return AVERROR_EXIT;
                &#125;               
            &#125;
        &#125;

        /**
        * If we have enough samples for the encoder, we encode them.
        * At the end of the file, we pass the remaining samples to
        * the encoder.
        */
        if (av_audio_fifo_size(fifo) &gt;= output_frame_size)
            /**
            * Take one frame worth of audio samples from the FIFO buffer,
            * encode it and write it to the output file.
            */
        &#123;
            /** Temporary storage of the output samples of the frame written to the file. */
            AVFrame *output_frame=av_frame_alloc();
            if (!output_frame)
            &#123;
                ret = AVERROR(ENOMEM);
                return ret;
            &#125;
            /**
            * Use the maximum number of possible samples per frame.
            * If there is less than the maximum possible frame size in the FIFO
            * buffer use this number. Otherwise, use the maximum possible frame size
            */
            const int frame_size = FFMIN(av_audio_fifo_size(fifo),
                pCodecCtx_a-&gt;frame_size);

            /** Initialize temporary storage for one output frame. */
            /**
            * Set the frame&apos;s parameters, especially its size and format.
            * av_frame_get_buffer needs this to allocate memory for the
            * audio samples of the frame.
            * Default channel layouts based on the number of channels
            * are assumed for simplicity.
            */
            output_frame-&gt;nb_samples = frame_size;
            output_frame-&gt;channel_layout = pCodecCtx_a-&gt;channel_layout;
            output_frame-&gt;format = pCodecCtx_a-&gt;sample_fmt;
            output_frame-&gt;sample_rate = pCodecCtx_a-&gt;sample_rate;

            /**
            * Allocate the samples of the created frame. This call will make
            * sure that the audio frame can hold as many samples as specified.
            */
            if ((ret = av_frame_get_buffer(output_frame, 0)) &lt; 0) &#123;
                printf(&quot;Could not allocate output frame samples\n&quot;);
                av_frame_free(&amp;output_frame);
                return ret;
            &#125;

            /**
            * Read as many samples from the FIFO buffer as required to fill the frame.
            * The samples are stored in the frame temporarily.
            */
            if (av_audio_fifo_read(fifo, (void **)output_frame-&gt;data, frame_size) &lt; frame_size) &#123;
                printf(&quot;Could not read data from FIFO\n&quot;);
                return AVERROR_EXIT;
            &#125;

            /** Encode one frame worth of audio samples. */
            /** Packet used for temporary storage. */
            AVPacket output_packet;
            av_init_packet(&amp;output_packet);
            output_packet.data = NULL;
            output_packet.size = 0;

            /** Set a timestamp based on the sample rate for the container. */
            if (output_frame) &#123;
                nb_samples += output_frame-&gt;nb_samples;
            &#125;

            /**
            * Encode the audio frame and store it in the temporary packet.
            * The output audio stream encoder is used to do this.
            */
            if ((ret = avcodec_encode_audio2(pCodecCtx_a, &amp;output_packet,
                output_frame, &amp;enc_got_frame_a)) &lt; 0) &#123;
                printf(&quot;Could not encode frame\n&quot;);
                av_packet_unref(&amp;output_packet);
                return ret;
            &#125;

            /** Write one audio frame from the temporary packet to the output file. */
            if (enc_got_frame_a) &#123;

                output_packet.stream_index = 1;

                AVRational time_base = ofmt_ctx-&gt;streams[1]-&gt;time_base;
                AVRational r_framerate1 = &#123; ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate, 1 &#125;;// &#123; 44100, 1&#125;;  
                int64_t calc_duration = (double)(AV_TIME_BASE)*(1 / av_q2d(r_framerate1));  //内部时间戳  

                output_packet.pts = av_rescale_q(nb_samples*calc_duration, time_base_q, time_base);
                output_packet.dts = output_packet.pts;
                output_packet.duration = output_frame-&gt;nb_samples;

                //printf(&quot;audio pts : %d\n&quot;, output_packet.pts);
                aud_next_pts = nb_samples*calc_duration;

                int64_t pts_time = av_rescale_q(output_packet.pts, time_base, time_base_q);
                int64_t now_time = av_gettime() - start_time;

                if ((pts_time &gt; now_time) &amp;&amp; ((aud_next_pts + pts_time - now_time)&lt;vid_next_pts))
                    av_usleep(pts_time - now_time);

                if ((ret = av_interleaved_write_frame(ofmt_ctx, &amp;output_packet)) &lt; 0) &#123;
                    printf(&quot;Could not write frame\n&quot;);
                    av_packet_unref(&amp;output_packet);
                    return ret;
                &#125;

                av_packet_unref(&amp;output_packet);
            &#125;           
            av_frame_free(&amp;output_frame);       
        &#125;     </code></pre><h6><span id="视音频同步">视音频同步</span></h6><p>首先定义几个变量</p>
<pre><code>int aud_next_pts = 0;//视频流目前的pts,可以理解为目前的进度
int vid_next_pts = 0;//音频流目前的pts
int encode_video = 1, encode_audio = 1;//是否要编码视频、音频</code></pre><p>则相应的视音频同步方法如下: 1. 确定视频, 音频二者中至少有一个是需要进行转码的 2. 比较两个流的进度, 使用av_compare_ts函数, 注意：此时的vid_next_pts和aud_next_pts的time base都是ffmpeg内部基准，即<code>AVRational time_base_q = &#123; 1, AV_TIME_BASE &#125;;</code> 3. 对进度落后的流进行转码, 并相应地对进度进行更新. 对于视频，有 vid_next_pts=framecnt_calc_duration;，对于音频，有 aud_next_pts = nb_samples_calc_duration;这里framecnt和nb_samples都相当于计数器，而calc_duration是对应流每两个frame或sample之间的时间间隔，也是以ffmpeg内部时间基准为单位的 4. 若转码进度很快完成, 则不能急于写入输出流, 而是需要先进行延时, 但是也要保证延时后的时间不会超过另一个流的进度</p>
<p>综上, 流程如下:</p>
<pre><code> //start decode and encode
    int64_t start_time = av_gettime();
    while (encode_video || encode_audio)
    &#123;
        if (encode_video &amp;&amp;
            (!encode_audio || av_compare_ts(vid_next_pts, time_base_q,
            aud_next_pts, time_base_q) &lt;= 0))
        &#123;
              进行视频转码；
              转码完成后；
              vid_next_pts=framecnt*calc_duration; //general timebase

                        //Delay
                        int64_t pts_time = av_rescale_q(enc_pkt.pts, time_base, time_base_q);
                        int64_t now_time = av_gettime() - start_time;                       
                        if ((pts_time &gt; now_time) &amp;&amp; ((vid_next_pts + pts_time - now_time)&lt;aud_next_pts))
                            av_usleep(pts_time - now_time);
              写入流；
&#125;
else
&#123;
              进行音频转码；
              转码完成后；
          aud_next_pts = nb_samples*calc_duration;

                int64_t pts_time = av_rescale_q(output_packet.pts, time_base, time_base_q);
                int64_t now_time = av_gettime() - start_time;
                if ((pts_time &gt; now_time) &amp;&amp; ((aud_next_pts + pts_time - now_time)&lt;vid_next_pts))
                    av_usleep(pts_time - now_time);
              写入流；
&#125;</code></pre><p>至此, 视音频同步完成. 最后再完成一些flush_encoder的工作即可.</p>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】How to (std::)find something efficiently with the STL</title>
    <url>/56dc57bb/</url>
    <content><![CDATA[<p>本文分3部分: 1. 怎么使用STL进行高效的查找: 借用传统STL算法对元素进行范围搜索 2. 搜索STL容器: 当你有直接读取STL容器里元素的权限时, 怎么进行高效准确的搜索(与简单的范围搜索相比较) 3. STL搜索算法的秘密: 向公众展示不为人知的算法, 这些算法在已经学习过的人眼里确实是很有用的</p>
<p>STL根据查看方式的不同, 一共分为两种: 排序的和不排序的. * 排序集合的遍历, 通常需要对数时长, 而乱序集合的遍历, 需要线性时长 * 排序容器中比较元素大小的函数根据equivalence(comparing with &lt;), 而乱序容器中的函数根据equality(comparing with ==).</p>
<p>本文将展示对于在一个范围内搜索一个给定的值, C++怎么样去阐述下面3个问题: * 它存在否 * 它在哪 * 它应该在什么位置(排序容器)</p>
<h3><span id="is-it-there">Is it there?</span></h3><h4><span id="乱序容器的元素">乱序容器的元素</span></h4><p>这个问题可以用std::find来表达(需要和与范围的终点值的比较相结合):</p>
<pre><code>vector&lt;int&gt; v = ... // v filled with values
if (std::find(v.begin(), v.end(), 42) != v.end())
&#123;
...</code></pre><p>“Is it there”这个问题也可以用std::count来表达:</p>
<pre><code>vector&lt;int&gt; v = ... // v filled with values
if (std::count(v.begin(), v.end(), 42))
&#123;
...</code></pre><p>std::count()的返回值会被隐式地转换成if条件里的bool值: 如果该范围里有至少一个值为42, 则返回true.</p>
<p>与std::find相比, std::count的优劣: 优势:</p>
<ul>
<li>std::count避免了与范围的end值相比较</li>
</ul>
<p>弊端:</p>
<ul>
<li>std::count遍历整个集合, 而std::find在第一个与要查找的值相等的位置停下</li>
<li>可以证明, 对于”想要查找某个值”这件事, std::find 表达得更明确 基于以上, std::find用得更多.</li>
</ul>
<p><strong>Note</strong> 若要确认某个值存在而非是与要搜索的值相等, 请使用<code>std::count_if, std::find_if, std::find_if_not</code></p>
<h4><span id="排序容器的元素">排序容器的元素</span></h4><p>使用的算法是<code>std::binary_search</code>, 此函数返回一个bool值, 此bool值表示在集合中是否存在与搜索的值相等的元素.</p>
<pre><code>std::set&lt;int&gt; numbers = // sorted elements
bool is42InThere = std::binary_search(numbers.begin(), numbers.end(), 42);
```&lt;/int&gt;

### Where is it?
(当确定了要搜索的值存在后,) 我们想更进一步, 得到指向那个元素的迭代器.

#### 乱序容器的元素

使用std::find. 返回指向第一个与搜索的值相等的元素的迭代器, 如果找不到, 则返回集合的终点.</code></pre><p>​    </p>
<p>std::vector numbers = … auto searchResult = std::find(numbers.begin(), numbers.end(), 42);</p>
<p>if (searchResult != numbers.end()) { …</p>
<pre><code>#### 排序容器的元素

对于排序集合, STL并没有像std::find一样直接的算法. std::find并不是为排序容器设计的, 因为它依据的是&quot;==&quot;而不是&quot;&amp;lt;&quot;, 消耗的时间为线性时长而不是对数时长.
对于一个给定的容器, 如果容器内元素的&quot;equality&quot;和&quot;equivalence&quot;是相同的, 且你能接受消耗的线性时长, 那么std::find会为你返回正确的结果, 你也能从它简单直接的接口中获益. **但是,** 不能忘记, std::find并不是为排序容器设计的.

这里推荐使用`std::equal_range`. (并非`std::lower_bound`)
函数原型: </code></pre><p>​    </p>
<p>template&lt; class ForwardIt, class T &gt; std::pair&lt;forwardit,forwardit&gt; equal_range( ForwardIt first, ForwardIt last, const T&amp; value );</p>
<pre><code>`std::equal_range` 返回与搜索值相等的元素的范围, 这个范围用一对集合内的迭代器表示. 这两个迭代器分别指向 与搜索值相等的范围里第一个元素和最后一个元素的下一个位置.&lt;/forwardit,forwardit&gt;

然而, 它的接口有些笨重:
例A:</code></pre><p>std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());</p>
<p>// equal_range, attempt 1: natively clumsy std::pair&lt;std::vector::iterator, std::vector::iterator&gt; range1 = equal_range(v.begin(), v.end(), 3); std::for_each(range1.first, range1.second, doSomething);</p>
<pre><code>用一个`typedef` 或者`using`让它更简洁:
例B:</code></pre><p>std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&lt;/std::vector</p>
<p>using IteratorPair = std::pair&lt;std::vector::iterator, std::vector::iterator&gt;;&lt;/std::vector</p>
<p>// equal_range, attempt 2: with the classical typedef IteratorPair range2 = equal_range(v.begin(), v.end(), 3); std::for_each(range2.first, range2.second, doSomething);</p>
<pre><code>例B确实简洁了很多, 但是仍有一个根本问题: 没有考虑 抽象等级.
尽管返回的是一个范围, 但这对迭代器强迫我们在操作返回的范围时必须按照&quot;第一&quot;&quot;第二&quot;这种方式来写代码. 范围就应该用&quot;首&quot;&quot;尾&quot;这种方式来表达. 这不仅给我们在其他地方使用这个返回值时造成很大的麻烦, 而且使代码很别扭.

为了解决这个问题, 我么可以把`std::equal_range` 返回的迭代器对封装进一个有&quot;范围&quot;这种语义的`object`</code></pre><p>​    </p>
<p>template</p>
<p>class Range</p>
<p>{</p>
<p>public:</p>
<p>Range(std::pair range)</p>
<p>m_begin(range.first), m_end(range.second) {} typename Container::iterator begin() { return m_begin; } typename Container::iterator end() { return m_end; }</p>
<p>private: typename Container::iterator m_begin; typename Container::iterator m_end; };</p>
<pre><code>注意: 尽管`std::equal_range` 返回的结果是一个&quot;范围&quot;, 但是`std::begin` 和 `std::end` 不能用在这个结果上. 而上面的封装解决了这个问题.
可以像下面这样使用:</code></pre><p>​    </p>
<p>std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());</p>
<p>// equal_range, attempt 3: natural al last Range<a href="std::vector\">std::vector\</a> range3 = equal_range(v.begin(), v.end(), 3); std::for_each(range3.begin(), range3.end(), doSomething);</p>
<pre><code>不管你使用上面的哪种方式, `std::equal_range` 都会返回一个范围, 要确定它是否为空, 可以通过检查那两个迭代器(是否相等)或者使用`std::distance` 检查它的大小. &lt;/std::vector&lt;int&gt;</code></pre><p>​    </p>
<p>bool noElementFound = range3.begin() == range3.end(); size_t numberOfElementFound = std::distance(range3.begin(), range3.end()) ```</p>
<h3><span id="where-should-it-be">Where should it be?</span></h3><p>这个问题仅仅针对排序的范围, 因为对于乱序的范围, 某个元素可能会存在任何位置.</p>
<p>对于排序的范围, 这个问题可以简化为: 如果它存在, 那么它在哪儿? 如果它不存在, 那么它应该在哪儿?</p>
<p>这个问题可以用算法<code>std::lower_bound</code> 和<code>std::upper_bound</code> 来解释.</p>
<p>当你理解了<code>std::equal_range</code> 后, 上面这句话就很容易理解了: <code>std::lower_bound</code> 和<code>std::upper_bound</code> 都会返回 <code>std::equal_range</code> 返回的那个迭代器对的第一个和第二个迭代器.</p>
<p>要插入某个值x, 使用<code>std::lower_bound</code> 得到指向 在范围里与x相等的元素之前的位置的迭代器, 使用<code>std::upper_bound</code> 得到指向 在范围里与x相等的元素之后的位置的迭代器.</p>
<p>注意: 如果仅仅是搜索某个元素, 永远不要使用<code>std::lower_bound</code></p>
<p>与<code>std::find</code> 相反, 你不能根据 判断<code>std::lower_bound</code> 返回的迭代器是否与终点的迭代器相等 来判断要搜索的值是否存在于这个集合. 事实上, 如果这个值在集合里不存在, 则<code>std::lower_bound</code> 返回它应该在的位置, 而不是终点的迭代器. 所以, 你不仅需要确认返回的迭代器不是终点的迭代器, 还要确认它指向的元素跟要搜索的值是相等的.</p>
<h3><span id="总结">总结</span></h3><p>Question to express in C++</p>
<p>NOT SORTED</p>
<p>SORTED</p>
<p>Is it there?</p>
<p>std::find != end</p>
<p>std::binary_search</p>
<p>Where is it?</p>
<p>std::find</p>
<p>std::equal_range</p>
<p>Where should it be?</p>
<p>-</p>
<p>std::lower_bound / std::upper_bound</p>
<p>原文地址: <a href="http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm\_medium=toutiao.io&amp;utm\_source=toutiao.io">http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm\_medium=toutiao.io&amp;utm\_source=toutiao.io</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>jq命令</title>
    <url>/5380c2ad/</url>
    <content><![CDATA[<p>一个灵活的轻量级命令行JSON处理器</p>
<h3><span id="补充说明">补充说明</span></h3><p>jq 是 stedolan 开发的一个轻量级的和灵活的命令行JSON处理器，源码请参考 <a href="https://github.com/stedolan/jq">jq 项目主页</a></p>
<p>jq 用于处理JSON输入，将给定过滤器应用于其JSON文本输入并在标准输出上将过滤器的结果生成为JSON。</p>
<p>最简单的过滤器是<code>.</code>，它将jq的输入未经修改地复制到其输出中（格式设置除外）。</p>
<p>请注意，jq 当前仅支持64位双精度浮点数（IEEE754）。</p>
<h3><span id="安装">安装</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian系，如 Ubuntu sudo apt-get install jq # RedHat系, 如 CentOS yum install jq</span></span><br></pre></td></tr></table></figure>

<h3><span id="语法">语法</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jq [options] &lt;jq filter&gt; [file...] jq [options] --args &lt;jq filter&gt; [strings...] jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]</span><br></pre></td></tr></table></figure>

<h3><span id="选项">选项</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-c 紧凑而不是漂亮的输出; -n 使用`null`作为单个输入值; -e 根据输出设置退出状态代码; -s 将所有输入读取（吸取）到数组中；应用过滤器; -r 输出原始字符串，而不是JSON文本; -R 读取原始字符串，而不是JSON文本; -C 为JSON着色; -M 单色（不要为JSON着色）; -S 在输出上排序对象的键; --tab 使用制表符进行缩进; --arg a v 将变量<span class="variable">$a</span>设置为value&lt;v&gt;; --argjson a v 将变量<span class="variable">$a</span>设置为JSON value&lt;v&gt;; --slurpfile a f 将变量<span class="variable">$a</span>设置为从&lt;f&gt;读取的JSON文本数组; --rawfile a f 将变量<span class="variable">$a</span>设置为包含&lt;f&gt;内容的字符串; --args 其余参数是字符串参数，而不是文件; --jsonargs 其余的参数是JSON参数，而不是文件; -- 终止参数处理;</span><br></pre></td></tr></table></figure>

<h3><span id="例子">例子</span></h3><p><code>.</code>: 以漂亮的方式输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;foo&quot;: &#123; &quot;bar&quot;: &#123; &quot;baz&quot;: 123 &#125; &#125; &#125;&#x27;</span> | jq <span class="string">&#x27;.&#x27;</span> &#123; <span class="string">&quot;foo&quot;</span>: &#123; <span class="string">&quot;bar&quot;</span>: &#123; <span class="string">&quot;baz&quot;</span>: 123 &#125; &#125; &#125; </span><br></pre></td></tr></table></figure>

<p><code>.foo, .foo.bar, .foo?</code>: 获取一个键的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27;</span> | jq <span class="string">&#x27;.foo&#x27;</span> 42</span><br></pre></td></tr></table></figure>

<p><code>.[], .[]?, .[2], .[10:15]</code>: 数组运算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]&#x27;</span> | jq <span class="string">&#x27;.[1]&#x27;</span> &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;XML&quot;</span>, <span class="string">&quot;good&quot;</span>: <span class="literal">false</span> &#125; </span><br></pre></td></tr></table></figure>

<p><code>[], &#123;&#125;</code>: 构造一个数组/对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ Primer&quot;, &quot;More JQ&quot;]&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;user, title: .titles[]&#125;&#x27;</span> &#123; <span class="string">&quot;user&quot;</span>: <span class="string">&quot;stedolan&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;JQ Primer&quot;</span> &#125; &#123; <span class="string">&quot;user&quot;</span>: <span class="string">&quot;stedolan&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;More JQ&quot;</span> &#125; </span><br></pre></td></tr></table></figure>

<p><code>length</code>: 计算一个值的长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[[1,2], &quot;string&quot;, &#123;&quot;a&quot;:2&#125;, null]&#x27;</span> | jq <span class="string">&#x27;.[] | length&#x27;</span> 2 6 1 0 </span><br></pre></td></tr></table></figure>

<p><code>keys</code>: 取出数组中的键</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;: 3&#125;&#x27;</span> | jq <span class="string">&#x27;keys&#x27;</span> [ <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span> ] </span><br></pre></td></tr></table></figure>

<p><code>,</code>: 使用多个过滤器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;foo&quot;: 42, &quot;bar&quot;: &quot;something else&quot;, &quot;baz&quot;: true&#125;&#x27;</span> | jq <span class="string">&#x27;.foo, .bar&#x27;</span> 42 <span class="string">&quot;something else&quot;</span> </span><br></pre></td></tr></table></figure>

<p><code>|</code>: 通过管道将一个过滤器的输出当做下一个过滤器的输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]&#x27;</span> | jq <span class="string">&#x27;.[] | .name&#x27;</span> <span class="string">&quot;JSON&quot;</span> <span class="string">&quot;XML&quot;</span> </span><br></pre></td></tr></table></figure>

<p><code>select(foo)</code>: 如果foo返回true，则输入保持不变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[1,5,3,0,7]&#x27;</span> | jq <span class="string">&#x27;map(select(. &gt;= 2))&#x27;</span> [ 5, 3, 7 ] </span><br></pre></td></tr></table></figure>

<p><code>map(foo)</code>: 每个输入调用过滤器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[1,2,3]&#x27;</span> | jq <span class="string">&#x27;map(.+1)&#x27;</span> [ 2, 3, 4 ] </span><br></pre></td></tr></table></figure>

<p><code>if-then-else-end</code>: 条件判断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;2&#x27;</span> | jq <span class="string">&#x27;if . == 0 then &quot;zero&quot; elif . == 1 then &quot;one&quot; else &quot;many&quot; end&#x27;</span> <span class="string">&quot;many&quot;</span> </span><br></pre></td></tr></table></figure>

<p><code>\(foo)</code>: 在字符串中插入值并进行运算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;42&#x27;</span> | jq <span class="string">&#x27;&quot;The input was \(.), which is one less than \(.+1)&quot;&#x27;</span> <span class="string">&quot;The input was 42, which is one less than 43&quot;</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装bashmarks</title>
    <url>/472d58f/</url>
    <content><![CDATA[<h6><span id="下载源码">下载源码</span></h6><p><code>git clone https://github.com/lxbwolf/bashmarks.git</code> 把<code>bashmarks.sh</code>复制到<code>~/bin/</code></p>
<h6><span id="添加环境变量">添加环境变量</span></h6><p>在环境变量文件里, 添加 <code>. ~/bin/bashmarks.sh</code></p>
<h6><span id="相关命令">相关命令</span></h6><pre><code>s &lt;bookmark_name&gt; - Saves the current directory as &quot;bookmark_name&quot;
g &lt;bookmark_name&gt; - Goes (cd) to the directory associated with &quot;bookmark_name&quot;
p &lt;bookmark_name&gt; - Prints the directory associated with &quot;bookmark_name&quot;
d &lt;bookmark_name&gt; - Deletes the bookmark
l                 - Lists all available bookmarks</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装thefuck</title>
    <url>/42c1114f/</url>
    <content><![CDATA[<h6><span id="下载源码">下载源码</span></h6><p><code>git clone https://github.com/lxbwolf/thefuck.git</code></p>
<h6><span id="配置环境变量">配置环境变量</span></h6><ol>
<li>把<code>thefuck/**/libexec/bin</code> 添加进环境变量</li>
<li><code>eval $(thefuck --alias fuck)</code></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装thefuck</title>
    <url>/42c1114f/</url>
    <content><![CDATA[<h6><span id="下载源码">下载源码</span></h6><p><code>git clone https://github.com/lxbwolf/thefuck.git</code></p>
<h6><span id="配置环境变量">配置环境变量</span></h6><ol>
<li>把<code>thefuck/**/libexec/bin</code> 添加进环境变量</li>
<li><code>eval $(thefuck --alias fuck)</code></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 禁止普通用户su切换root</title>
    <url>/e5131675/</url>
    <content><![CDATA[<p>一般情况下, 普通用户执行”su -“命令, 可以登录为root. 为了加强系统的安全性, 有必要建立一个管理员的组, 只允许这个组的用户执行”su -“ 命令登录为root, 而让其他组的用户即使执行”su -“ 输入了正确的密码, 也无法登录为root用户. 在Unix 和Linux 下, 这个组的名称通常为”wheel”.</p>
<p>1 添加一个用户, 把这个用户加入wheel组 2 修改/etc/pam.d/su <code>#auth required pam_wheel.so use_uid</code> 这行注释打开 3 修改/etc/login.defs 在文件末添加一行 <code>SU_WHEEL_ONLY yes</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议笔记</title>
    <url>/4e7c79/</url>
    <content><![CDATA[<p>HTTP协议的特点: 1. 支持客户端/服务器模式 2. 简单快速: 客户端向服务器请求服务时, 只需传送请求方法和路径. 请求方法常用的有GET, HEAD, POST. 每种方法规定了客户端与服务器联系的类型. 由于HTTP协议简单, 使得HTTP服务器的程序规模小, 因而通信速度很快. 3. 灵活: HTTP 允许传输任意类型的数据对象. 正在传输的类型由Content-Type加以标记. 4. 无连接: 限制每次连接只处理一个请求. 服务器处理完客户端的请求, 并收到客户端的应答后, 即断开连接. 采用着用方式可以节省传输时间. 5. 无状态: 无状态是指协议对于事务处理没有记忆能力. 缺少状态意味着如果后续处理需要前面的信息, 则它必须重传, 这样可能导致每次传送的数据量增大. 另一方面, 在服务器不需要先前信息时, 它的应答就较快.</p>
<h5><span id="url">URL</span></h5><p>HTTP是一种基于请求与响应模式的, 无状态的, 应用层的协议, 常基于TCP的连接方式, HTTP1.1版本中给出一种持续连接的机制, 绝大多数的web开发, 都是构建在HTTP协议之上的web应用.</p>
<p>HTTP URL(URL是一种特殊类型的URI, 包含了用于查找某个资源的足够的信息)的格式如下: <code>http://host[:port][abs_path]</code></p>
<ul>
<li>http 表示要通过HTTP协议来定位网络资源</li>
<li>host 表示合法的Internet主机域名或者IP地址</li>
<li>port 指定端口号, 缺省端口为80</li>
<li>abs_path 指定请求资源的URI</li>
<li>若URI 中没有给出abs_path, 那当它作为请求URI时, 必须以”/“ 的形式给出, 通常这个工作浏览器会自动完成</li>
</ul>
<h5><span id="请求">请求</span></h5><p>HTTP请求由三部分组成: 请求行, 消息报头, 请求正文</p>
<h6><span id="请求行">请求行</span></h6><p>以一个方法符号开头, 以空格分开, 后面跟请求的URI和协议的版本, 格式如下: <code>Method Request-URI HTTP-Version CRLF</code></p>
<p>请求方法有以下几种 - GET 请求获取Request-URI 所标识的资源 - POST 在Request-URI 表标识的资源后附加新的数据 - HEAD 请求获取由Request-URI 所标识的资源的响应消息报头 - PUT 请求服务器存储一个资源, 并用Request-URI 作为其标识 - DELETE 请求服务器删除Request-URI 所标识的资源 - TRACE 请求服务器会送收到的请求信息, 主要用于测试或诊断 - CONNECT 保留将来使用 - OPTIONS 请求查询服务器的性能, 或查询与资源相关的选项和需求</p>
<h5><span id="响应">响应</span></h5><p>HTTP响应由三部分组成: 状态行, 消息报头, 响应正文</p>
<h6><span id="状态行">状态行</span></h6><p>格式: <code>HTTP-Version Status-Code Reason-Phrase CRLF</code></p>
<p>状态码由三位数字组成, 第一个数字定义了响应的类别: - 1xx: 指示信息 – 表示请求已接受, 继续处理 - 2xx: 成功 – 表示请求已被成功接收, 理解, 接受 - 3xx: 重定向 – 要完成请求必须进行更进一步的操作 - 4xx: 客户端错误 – 请求有语法错误或请求无法实现 - 5xx: 服务器端错误 – 服务器未能实现合法的请求</p>
<h5><span id="报头">报头</span></h5><p>HTTP 消息由客户端到服务器的请求和服务器到客户端的响应组成. 请求消息和相应消息都是由开始行(对于请求消息, 开始行就是请求行, 对于响应消息, 开始行就是状态行), 消息报头(可选), 空行(只有CRLF的行), 消息正文(可选) 组成</p>
<p>HTTP 消息报头包括 普通报头, 请求报头, 响应报头, 实体报头 每一个报头域都是由<code>名字 + &quot;:&quot; + 空格 + 值</code> 组成, 消息报头域的名字是大小写无关的.</p>
<h6><span id="普通报头">普通报头</span></h6><p>在普通报头中, 有少数报头域用于所有的请求和响应消息, 但并用于被传输的实体, 只用于传输的消息 <strong>例:</strong> Cache-Control 用于指定缓存指令, 缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现), 且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制), HTTP1.0使用类似的报头域为Pragma. 请求时的缓存指令包括: no-cache(用于指示请求或相应消息不能缓存), no-store, max-age, max-stale, min-fresh, only-if-cached; 响应时的缓存指令包括: public, private, no-cache, no-store, no-transform, must-revalidate, proxy-revalidate, max-age, s-maxage <strong>eg:</strong> 为了指示IE浏览器(客户端)不要缓存页面, 服务器端的JSP程序可以编写如下: <code>response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</code> 或 <code>response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</code> 两者作用相同, 在发送的响应消息中设置普通报头域: Cache-Control: no-cache.</p>
<h6><span id="请求报头">请求报头</span></h6><p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息.</p>
<p>常用的请求报头域: <em>Accept</em> Accept 请求报头域用于指定客户端接收哪些类型的信息. 如: <code>Accept:image/gif</code>, 表明客户端希望接收GIF图像格式的资源; <code>Accept:text/html</code>, 表明客户端希望接受html 文本</p>
<p><em>Accept-Charset</em> 指定客户端接受的字符集. 如: <code>Accept-Charset:iso-8859-1,GB2312</code>. 如果请求消息中没有设置这个域, 缺省是任何字符集都可以接受.</p>
<p><em>Accept-Encoding</em> 指定可接受的内容编码. 如<code>Accept-Encoding:gzip.deflate</code> 缺省是任何内容编码都可以接受</p>
<p><em>Accept-Language</em> 指定一种自然语言. 如 <code>Accept-Language:zh-cn</code> 缺省是任何语言都可以接受</p>
<p><em>Authorization</em> 用于证明客户端有权查看某个资源. 当浏览器访问一个页面时, 如果收到服务器的响应代码为401, 可以发送一个包含Authorization请求报头域的请求, 要求服务器对其进行验证</p>
<p><em>Host</em>(发送请求时, 该报头域是必需的) 指定被请求资源的Internet主机和端口号, 通常从HTTP URL中提取出来</p>
<p><em>User-Agent</em> 允许客户端将它的操作系统, 浏览器和其他属性告诉服务器. 不过这个报头域不是必需的, 如果我们自己写一个浏览器, 不使用User-Agent 请求报头域, 那么服务器端就无法得知我们的信息了.</p>
<p><em>请求报头示例</em></p>
<pre><code>GET /form.html HTTP/1.1 (CRLF)
Accept:image/gif,image/x-xbigmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)
Accept-Language:zh-cn (CRLF)
Acdept-Encoding:gzip,deflate (CRLF)
If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)
If-None-Match:Mozilla/4.0(compatible;MSIE6.0,Windows NT 5.0) (CRLF)
Host:www.guet.edu.cn (CRLF)
Connection:Keep-Alive (CRLF)
(CRLF)</code></pre><h6><span id="响应报头">响应报头</span></h6><p>响应报头允许服务器传递不能放在状态行中的附加响应信息, 以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息</p>
<p><em>Location</em> 重定向接受者到一个新的位置. Location响应报头域常用在更换域名的时候</p>
<p><em>Server</em> 包含了服务器用来处理请求的软件信息. 与<code>User-Agent</code> 请求报头域是相对应的 例: <code>Server:Apache-Coyote/1.1</code></p>
<p><em>WWW-Authenticate</em> WWW-Authenticate 响应报头域必须包含在401响应消息中, 客户端收到401响应消息的时候, 并发送Authorization报头域请求服务器对其进行验证时, 服务端响应报头就包含该报头域 例: <code>WWW-Authenticate:Basic realm=&quot;Basic Auth Test!</code></p>
<h6><span id="实体报头">实体报头</span></h6><p>请求和响应消息都可以传送一个实体. 一个实体由实体报头域和实体正文组成, 但并不是实体报头域和实体正文要在一起发送, 可以只发送实体报头域. 实体报头定义了关于实体正文(如: 有无实体正文) 和请求所标识的资源的元信息.</p>
<p><em>Content-Encoding</em> 被用作媒体类型的修饰符, 它的值指示了已经被应用到实体正文的附加内容的编码, 因而要获得Content-Type 报头域中所引用的媒体类型, 必须采用相应的解码机制.</p>
<p><em>Content-Language</em> 描述了资源所用的自然语言. 没有设置该域则认为实体内容将提供给所有的语言阅读</p>
<p><em>Content-Length</em> 指明实体正文的长度, 以字节方式存储的十进制数字来表示</p>
<p><em>Content-Type</em> 指明发送给接受者的实体正文的媒体类型 例: <code>Content-Type:text/html;charset=ISO-8859-1</code> <code>Content-Type:text/html;charset=GB2312</code></p>
<p><em>Last-Modified</em> 指示资源的最后修改日期和时间</p>
<p><em>Expires</em> 给出响应国企的日期和时间. 为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时, 直接从缓存中加载, 缩短响应时间和降低服务器负载) 的页面, 我们可以使用Expires 实体报头域指定页面过期的时间. 例: <code>Expires:Thu, 15 Sep 2006 16:23:12 GMT</code></p>
<p>HTTP1.1 的客户端和缓存必须将其他非法的日期格式(包括0) 看作已经过期 为了让浏览器不要缓存页面, 我们也可以利用Expires 实体报头域设置为0, jsp中程序如下: <code>response.setDateHeader(&quot;Expires&quot;, &quot;0&quot;);</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene 二: Lucene 的总体架构</title>
    <url>/1c70c347/</url>
    <content><![CDATA[<p>Lucene总的来说是：</p>
<ul>
<li>一个高效的，可扩展的，全文检索库。</li>
<li>全部用Java实现，无须配置。</li>
<li>仅支持纯文本文件的索引(Indexing)和搜索(Search)。</li>
<li>不负责由其他格式的文件抽取纯文本文件，或从网络中抓取文件的过程。</li>
</ul>
<p>在Lucene in action中，Lucene 的架构和过程如下图，</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252200930.png" alt></p>
<p><strong>说明Lucene是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。</strong></p>
<p>让我们更细一些看Lucene的各组件：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252202412.png" alt></p>
<ul>
<li><strong>被索引的文档用Document对象表示。</strong></li>
<li><strong>IndexWriter通过函数addDocument将文档添加到索引中，实现创建索引的过程。</strong></li>
<li><strong>Lucene的索引是应用反向索引。</strong></li>
<li><strong>当用户有请求时，Query代表用户的查询语句。</strong></li>
<li><strong>IndexSearcher通过函数search搜索Lucene Index。</strong></li>
<li><strong>IndexSearcher计算term weight和score并且将结果返回给用户。</strong></li>
<li><strong>返回给用户的文档集合用TopDocsCollector表示。</strong></li>
</ul>
<p>那么如何应用这些组件呢？</p>
<p>让我们再详细到对Lucene API 的调用实现索引和搜索过程。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252203512.png" alt></p>
<ul>
<li>索引过程如下：<ul>
<li><strong>创建一个IndexWriter用来写索引文件，它有几个参数，INDEX_DIR就是索引文件所存放的位置，Analyzer便是用来对文档进行词法分析和语言处理的。</strong></li>
<li><strong>创建一个Document代表我们要索引的文档。</strong></li>
<li><strong>将不同的Field加入到文档中。我们知道，一篇文档有多种信息，如题目，作者，修改时间，内容等。不同类型的信息用不同的Field来表示，在本例子中，一共有两类信息进行了索引，一个是文件路径，一个是文件内容。其中FileReader的SRC_FILE就表示要索引的源文件。</strong></li>
<li><strong>IndexWriter调用函数addDocument将索引写到索引文件夹中。</strong></li>
</ul>
</li>
<li>搜索过程如下：<ul>
<li><strong>IndexReader将磁盘上的索引信息读入到内存，INDEX_DIR就是索引文件存放的位置。</strong></li>
<li><strong>创建IndexSearcher准备进行搜索。</strong></li>
<li><strong>创建Analyer用来对查询语句进行词法分析和语言处理。</strong></li>
<li><strong>创建QueryParser用来对查询语句进行语法分析。</strong></li>
<li><strong>QueryParser调用parser进行语法分析，形成查询语法树，放到Query中。</strong></li>
<li><strong>IndexSearcher调用search对查询语法树Query进行搜索，得到结果TopScoreDocCollector。</strong></li>
</ul>
</li>
</ul>
<p>以上便是Lucene API函数的简单调用。</p>
<p>然而当进入Lucene的源代码后，发现Lucene有很多包，关系错综复杂。</p>
<p>然而通过下图，我们不难发现，Lucene的各源码模块，都是对普通索引和搜索过程的一种实现。</p>
<p>此图是上一节介绍的全文检索的流程对应的Lucene实现的包结构。(参照<a href="http://www.lucene.com.cn/about.htm中文章《开放源代码的全文检索引擎Lucene》">http://www.lucene.com.cn/about.htm中文章《开放源代码的全文检索引擎Lucene》</a>)</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252206421.png" alt></p>
<ul>
<li><strong>Lucene的analysis模块主要负责词法分析及语言处理而形成Term。</strong></li>
<li><strong>Lucene的index模块主要负责索引的创建，里面有IndexWriter。</strong></li>
<li><strong>Lucene的store模块主要负责索引的读写。</strong></li>
<li><strong>Lucene的QueryParser主要负责语法分析。</strong></li>
<li><strong>Lucene的search模块主要负责对索引的搜索。</strong></li>
<li><strong>Lucene的similarity模块主要负责对相关性打分的实现。</strong></li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene 概述</title>
    <url>/6ddc4d41/</url>
    <content><![CDATA[<p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎</p>
<h2><span id="全文检索概述">全文检索概述</span></h2><p>比如，我们一个文件夹中，或者一个磁盘中有很多的文件，记事本、world、Excel、pdf，我们想根据其中的关键词搜索包含的文件。例如，我们输入Lucene，所有内容含有Lucene的文件就会被检查出来。这就是所谓的全文检索。</p>
<p>因此，很容易的我们想到，应该建立一个关键字与文件的相关映射，盗用ppt中的一张图，很明白的解释了这种映射如何实现。</p>
<h3><span id="倒排索引">倒排索引</span></h3><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252056096.png" alt></p>
<p>有了这种映射关系，我们就来看看Lucene的架构设计。 下面是Lucene的资料必出现的一张图，但也是其精髓的概括。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252056599.png" alt></p>
<p>可以看到，Lucene的使用主要体现在两个步骤：</p>
<p>1 创建索引，通过IndexWriter对不同的文件进行索引的创建，并将其保存在索引相关<a href="https://cloud.tencent.com/product/cfs?from_column=20065&from=20065">文件存储</a>的位置中。</p>
<p>2 通过索引查寻关键字相关文档。</p>
<p>在Lucene中，就是使用这种“倒排索引”的技术，来实现相关映射。</p>
<h2><span id="lucene数学模型">Lucene数学模型</span></h2><p>文档、域、词元</p>
<p>文档是Lucene搜索和索引的原子单位，文档为包含一个或者多个域的<a href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065">容器</a>，而域则是依次包含“真正的”被搜索的内容，域值通过分词技术处理，得到多个词元。</p>
<p>For Example，一篇小说（斗破苍穹）信息可以称为一个文档，小说信息又包含多个域，例如：标题（斗破苍穹）、作者、简介、最后更新时间等等，对标题这个域采用分词技术又可以得到一个或者多个词元（斗、破、苍、穹）。</p>
<h2><span id="lucene文件结构">Lucene文件结构</span></h2><h3><span id="层次结构">层次结构</span></h3><p><strong>index</strong> 一个索引存放在一个目录中</p>
<p><strong>segment</strong> 一个索引中可以有多个段，段与段之间是独立的，添加新的文档可能产生新段，不同的段可以合并成一个新段</p>
<p><strong>document</strong> 文档是创建索引的基本单位，不同的文档保存在不同的段中，一个段可以包含多个文档</p>
<p><strong>field</strong> 域，一个文档包含不同类型的信息，可以拆分开索引</p>
<p><strong>term</strong> 词，索引的最小单位，是经过词法分析和语言处理后的数据。</p>
<h3><span id="正向信息">正向信息</span></h3><p>按照层次依次保存了从索引到词的包含关系：index–&gt;segment–&gt;document–&gt;field–&gt;term。</p>
<h3><span id="反向信息">反向信息</span></h3><p>反向信息保存了词典的倒排表映射：term–&gt;document</p>
<p><strong>IndexWriter</strong> lucene中最重要的的类之一，它主要是用来将文档加入索引，同时控制索引过程中的一些参数使用。</p>
<p><strong>Analyzer</strong> 分析器,主要用于分析搜索引擎遇到的各种文本。常用的有StandardAnalyzer分析器,StopAnalyzer分析器,WhitespaceAnalyzer分析器等。</p>
<p><strong>Directory</strong> 索引存放的位置;lucene提供了两种索引存放的位置，一种是磁盘，一种是内存。一般情况将索引放在磁盘上；相应地lucene提供了FSDirectory和RAMDirectory两个类。</p>
<p><strong>Document</strong> 文档;Document相当于一个要进行索引的单元，任何可以想要被索引的文件都必须转化为Document对象才能进行索引。</p>
<p><strong>Field</strong> 字段。</p>
<p><strong>IndexSearcher</strong> 是lucene中最基本的检索工具，所有的检索都会用到IndexSearcher工具;</p>
<p><strong>Query</strong> 查询，lucene中支持模糊查询，语义查询，短语查询，组合查询等等,如有TermQuery,BooleanQuery,RangeQuery,WildcardQuery等一些类。</p>
<p><strong>QueryParser</strong> 是一个解析用户输入的工具，可以通过扫描用户输入的字符串，生成Query对象。</p>
<p><strong>Hits</strong> 在搜索完成之后，需要把搜索结果返回并显示给用户，只有这样才算是完成搜索的目的。在lucene中，搜索的结果的集合是用Hits类的实例来表示的。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 后台执行命令</title>
    <url>/be78f922/</url>
    <content><![CDATA[<p>当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用</p>
<ul>
<li>&amp;</li>
<li>nohup</li>
<li>ctrl + z</li>
<li>ctrl + c</li>
<li>jobs</li>
<li>bg</li>
<li>fg</li>
</ul>
<h4><span id="amp">&amp;</span></h4><p>当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh test.sh &amp; 适合在后台运行的命令有f i n d、费时的排序及一些s h e l l脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：</p>
<pre><code>command  &gt;  out.file  2&gt;&amp;1  &amp; </code></pre><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。(<code>ps -ef | grep 进程号</code> 或者 <code>kill -9 进程号</code>）</p>
<h4><span id="nohup">nohup</span></h4><p>使用<code>&amp;</code>命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p>
<pre><code>nohup command &amp;</code></pre><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p>
<pre><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></pre><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，<strong>需要使用exit正常退出当前账户</strong>，这样才能保证命令一直在后台运行</p>
<h4><span id="ctrl-z">ctrl + z</span></h4><p>可以将一个正在前台执行的命令放到后台，并且处于暂停状态</p>
<h4><span id="ctrl-c">ctrl + c</span></h4><p>终止前台命令</p>
<h4><span id="jobs">jobs</span></h4><p>查看当前有多少在后台运行的命令。 <code>jobs -l</code>选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识</p>
<h4><span id="bg">bg</span></h4><p>将一个在后台暂停的命令，变成继续执行 （在后台执行） 如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid) 将任务转移到后台运行： 先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。</p>
<h4><span id="fg">fg</span></h4><p>将后台中的命令调至前台继续运行 如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene 一: 全文检索的基本原理</title>
    <url>/5e159a30/</url>
    <content><![CDATA[<h2><span id="一-总论">一、总论</span></h2><p>根据<a href="http://lucene.apache.org/java/docs/index.html">http://lucene.apache.org/java/docs/index.html</a>定义：</p>
<p><strong>Lucene 是一个高效的，基于Java 的全文检索库。</strong></p>
<p>所以在了解Lucene之前要费一番工夫了解一下全文检索。</p>
<p>那么什么叫做全文检索呢？这要从我们生活中的数据说起。</p>
<p>我们生活中的数据总体分为两种：<strong>结构化数据</strong>和<strong>非结构化数据</strong>。</p>
<ul>
<li><strong>结构化数据：</strong> 指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li><strong>非结构化数据：</strong> 指不定长或无固定格式的数据，如邮件，word文档等。</li>
</ul>
<p>当然有的地方还会提到第三种，半结构化数据，如XML，HTML等，当根据需要可按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。</p>
<p><strong>非结构化数据又一种叫法叫全文数据。</strong></p>
<p>按照数据的分类，搜索也分为两种：</p>
<ul>
<li><strong>对结构化数据的搜索</strong>：如对数据库的搜索，用SQL语句。再如对元数据的搜索，如利用windows搜索对文件名，类型，修改时间进行搜索等。</li>
<li><strong>对非结构化数据的搜索</strong>：如利用windows的搜索也可以搜索文件内容，Linux下的grep命令，再如用Google和百度可以搜索大量内容数据。</li>
</ul>
<p>对非结构化数据也即对全文数据的搜索主要有两种方法：</p>
<p>一种是<strong>顺序扫描法(Serial Scanning)：</strong> 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。如果你有一个80G硬盘，如果想在上面找到一个内容包含某字符串的文件，不花他几个小时，怕是做不到。Linux下的grep命令也是这一种方式。大家可能觉得这种方法比较原始，但对于小数据量的文件，这种方法还是最直接，最方便的。但是对于大量的文件，这种方法就很慢了。</p>
<p>有人可能会说，对非结构化数据顺序扫描很慢，对结构化数据的搜索却相对较快（由于结构化数据有一定的结构可以采取一定的搜索算法加快速度），那么把我们的非结构化数据想办法弄得有一定结构不就行了吗？</p>
<p>这种想法很天然，却构成了全文检索的基本思路，也即将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</p>
<p>这部分从非结构化数据中提取出的然后重新组织的信息，我们称之<strong>索引</strong>。</p>
<p>这种说法比较抽象，举几个例子就很容易明白，比如字典，字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。</p>
<p><strong>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</strong></p>
<p>下面这幅图来自《Lucene in action》，但却不仅仅描述了Lucene的检索过程，而是描述了全文检索的一般过程。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252124676.png" alt></p>
<p>全文检索大体分两个过程，<strong>索引创建(Indexing)</strong>和<strong>搜索索引(Search)</strong>。</p>
<ul>
<li>索引创建：将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。</li>
<li>搜索索引：就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。</li>
</ul>
<p>于是全文检索就存在三个重要问题：</p>
<p><strong>1.</strong> <strong>索引里面究竟存些什么？(Index)</strong></p>
<p><strong>2.</strong> <strong>如何创建索引？(Indexing)</strong></p>
<p><strong>3.</strong> <strong>如何对索引进行搜索？(Search)</strong></p>
<p>下面我们顺序对每个个问题进行研究。</p>
<h2><span id="二-索引里面究竟存些什么">二、索引里面究竟存些什么</span></h2><p>索引里面究竟需要存些什么呢？</p>
<p>首先我们来看为什么顺序扫描的速度慢：</p>
<p>其实是由于我们想要搜索的信息和非结构化数据中所存储的信息不一致造成的。</p>
<p>非结构化数据中所存储的信息是每个文件包含哪些字符串，也即已知文件，欲求字符串相对容易，也即是从文件到字符串的映射。而我们想搜索的信息是哪些文件包含此字符串，也即已知字符串，欲求文件，也即从字符串到文件的映射。两者恰恰相反。于是如果索引总能够保存从字符串到文件的映射，则会大大提高搜索速度。</p>
<p>由于从字符串到文件的映射是文件到字符串映射的反向过程，于是保存这种信息的索引称为<strong>反向索引</strong>。</p>
<p>反向索引的所保存的信息一般如下：</p>
<p>假设我的文档集合里面有100篇文档，为了方便表示，我们为文档编号从1到100，得到下面的结构</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252127189.png" alt></p>
<p>左边保存的是一系列字符串，称为<strong>词典</strong>。</p>
<p>每个字符串都指向包含此字符串的文档(Document)链表，此文档链表称为<strong>倒排表</strong>(Posting List)。</p>
<p>有了索引，便使保存的信息和要搜索的信息一致，可以大大加快搜索的速度。</p>
<p>比如说，我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档，我们只需要以下几步：</p>
<p>1. 取出包含字符串“lucene”的文档链表。</p>
<p>2. 取出包含字符串“solr”的文档链表。</p>
<p>3. 通过合并链表，找出既包含“lucene”又包含“solr”的文件。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252128442.png" alt></p>
<p>看到这个地方，有人可能会说，全文检索的确加快了搜索的速度，但是多了索引的过程，两者加起来不一定比顺序扫描快多少。的确，加上索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个很大量的数据创建索引也是一个很慢的过程。</p>
<p>然而两者还是有区别的，顺序扫描是每次都要扫描，而创建索引的过程仅仅需要一次，以后便是一劳永逸的了，每次搜索，创建索引的过程不必经过，仅仅搜索创建好的索引就可以了。</p>
<p><strong>这也是全文搜索相对于顺序扫描的优势之一：一次索引，多次使用。</strong></p>
<h2><span id="三-如何创建索引">三、如何创建索引</span></h2><p>全文检索的索引创建过程一般有以下几步：</p>
<h3><span id="第一步一些要索引的原文档document"><strong>第一步：一些要索引的原文档(Document)。</strong></span></h3><p>为了方便说明索引创建过程，这里特意用两个文件为例：</p>
<p>文件一：Students should be allowed to go out with their friends, but not allowed to drink beer.</p>
<p>文件二：My friend Jerry went to school to see his students but found them drunk which is not allowed.</p>
<h3><span id="第二步将原文档传给分词组件tokenizer"><strong>第二步：将原文档传给分词组件(Tokenizer)。</strong></span></h3><p><strong>分词组件(Tokenizer)会做以下几件事情(此过程称为Tokenize)：</strong></p>
<p><strong>1.</strong> <strong>将文档分成一个一个单独的单词。</strong></p>
<p><strong>2.</strong> <strong>去除标点符号。</strong></p>
<p><strong>3.</strong> <strong>去除停词(Stop word)。</strong></p>
<p>所谓停词(Stop word)就是一种语言中最普通的一些单词，由于没有特别的意义，因而大多数情况下不能成为搜索的关键词，因而创建索引时，这种词会被去掉而减少索引的大小。</p>
<p>英语中挺词(Stop word)如：“the”,“a”，“this”等。</p>
<p>对于每一种语言的分词组件(Tokenizer)，都有一个停词(stop word)集合。</p>
<p><strong>经过分词(Tokenizer)后得到的结果称为词元(Token)。</strong></p>
<p>在我们的例子中，便得到以下词元(Token)：</p>
<p>“Students”，“allowed”，“go”，“their”，“friends”，“allowed”，“drink”，“beer”，“My”，“friend”，“Jerry”，“went”，“school”，“see”，“his”，“students”，“found”，“them”，“drunk”，“allowed”。</p>
<h3><span id="第三步将得到的词元token传给语言处理组件linguistic-processor"><strong>第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。</strong></span></h3><p>语言处理组件(linguistic processor)主要是对得到的词元(Token)做一些同语言相关的处理。</p>
<p><strong>对于英语，语言处理组件(Linguistic Processor)一般做以下几点：</strong></p>
<p><strong>1.</strong> <strong>变为小写(Lowercase)。</strong></p>
<p><strong>2.</strong> <strong>将单词缩减为词根形式，如“cars”到“car”等。这种操作称为：stemming。</strong></p>
<p><strong>3.</strong> <strong>将单词转变为词根形式，如“drove”到“drive”等。这种操作称为：lemmatization。</strong></p>
<p><strong>Stemming 和 lemmatization的异同：</strong></p>
<ul>
<li>相同之处：Stemming和lemmatization都要使词汇成为词根形式。</li>
<li>两者的方式不同：<ul>
<li>Stemming采用的是“缩减”的方式：“cars”到“car”，“driving”到“drive”。</li>
<li>Lemmatization采用的是“转变”的方式：“drove”到“drove”，“driving”到“drive”。</li>
</ul>
</li>
<li>两者的算法不同：<ul>
<li>Stemming主要是采取某种固定的算法来做这种缩减，如去除“s”，去除“ing”加“e”，将“ational”变为“ate”，将“tional”变为“tion”。</li>
<li>Lemmatization主要是采用保存某种字典的方式做这种转变。比如字典中有“driving”到“drive”，“drove”到“drive”，“am, is, are”到“be”的映射，做转变时，只要查字典就可以了。</li>
</ul>
</li>
<li>Stemming和lemmatization不是互斥关系，是有交集的，有的词利用这两种方式都能达到相同的转换。</li>
</ul>
<p><strong>语言处理组件(linguistic processor)的结果称为词(Term)。</strong></p>
<p>在我们的例子中，经过语言处理，得到的词(Term)如下：</p>
<p>“student”，“allow”，“go”，“their”，“friend”，“allow”，“drink”，“beer”，“my”，“friend”，“jerry”，“go”，“school”，“see”，“his”，“student”，“find”，“them”，“drink”，“allow”。</p>
<p>也正是因为有语言处理的步骤，才能使搜索drove，而drive也能被搜索出来。</p>
<h3><span id="第四步将得到的词term传给索引组件indexer"><strong>第四步：将得到的词(Term)传给索引组件(Indexer)。</strong></span></h3><p><strong>索引组件(Indexer)主要做以下几件事情：</strong></p>
<p><strong>1. 利用得到的词(Term)创建一个字典。</strong></p>
<p>在我们的例子中字典如下：</p>
<table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14">Term</td><td zoompage-fontsize="14">Document ID</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">their</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">beer</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">my</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">jerry</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">school</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">see</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">his</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">find</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">them</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">2</td></tr></tbody></table>

<p><strong>2.</strong> <strong>对字典按字母顺序进行排序。</strong></p>
<table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14">Term</td><td zoompage-fontsize="14">Document ID</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">allow</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">beer</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">drink</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">find</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">friend</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">go</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">his</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">jerry</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">my</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">school</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">see</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">student</td><td zoompage-fontsize="14">2</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">their</td><td zoompage-fontsize="14">1</td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14">them</td><td zoompage-fontsize="14">2</td></tr></tbody></table>

<p><strong>3.</strong> <strong>合并相同的词(Term)成为文档倒排(Posting List)链表。</strong></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252135690.png" alt></p>
<p>在此表中，有几个定义：</p>
<ul>
<li>Document Frequency 即文档频次，表示总共有多少文件包含此词(Term)。</li>
<li>Frequency 即词频率，表示此文件中包含了几个此词(Term)。</li>
</ul>
<p>所以对词(Term) “allow”来讲，总共有两篇文档包含此词(Term)，从而词(Term)后面的文档链表总共有两项，第一项表示包含“allow”的第一篇文档，即1号文档，此文档中，“allow”出现了2次，第二项表示包含“allow”的第二个文档，是2号文档，此文档中，“allow”出现了1次。</p>
<p>到此为止，索引已经创建好了，我们可以通过它很快的找到我们想要的文档。</p>
<p>而且在此过程中，我们惊喜地发现，搜索“drive”，“driving”，“drove”，“driven”也能够被搜到。因为在我们的索引中，“driving”，“drove”，“driven”都会经过语言处理而变成“drive”，在搜索时，如果您输入“driving”，输入的查询语句同样经过我们这里的一到三步，从而变为查询“drive”，从而可以搜索到想要的文档。</p>
<h2><span id="三-如何对索引进行搜索">三、如何对索引进行搜索？</span></h2><p>到这里似乎我们可以宣布“我们找到想要的文档了”。</p>
<p>然而事情并没有结束，找到了仅仅是全文检索的一个方面。不是吗？如果仅仅只有一个或十个文档包含我们查询的字符串，我们的确找到了。然而如果结果有一千个，甚至成千上万个呢？那个又是您最想要的文件呢？</p>
<p>打开Google吧，比如说您想在微软找份工作，于是您输入“Microsoft job”，您却发现总共有22600000个结果返回。好大的数字呀，突然发现找不到是一个问题，找到的太多也是一个问题。在如此多的结果中，如何将最相关的放在最前面呢？</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252137104.png" alt></p>
<p>当然Google做的很不错，您一下就找到了jobs at Microsoft。想象一下，如果前几个全部是“Microsoft does a good job at software industry…”将是多么可怕的事情呀。</p>
<p>如何像Google一样，在成千上万的搜索结果中，找到和查询语句最相关的呢？</p>
<p>如何判断搜索出的文档和查询语句的相关性呢？</p>
<p>这要回到我们第三个问题：如何对索引进行搜索？</p>
<p>搜索主要分为以下几步：</p>
<h3><span id="第一步用户输入查询语句"><strong>第一步：用户输入查询语句。</strong></span></h3><p>查询语句同我们普通的语言一样，也是有一定语法的。</p>
<p>不同的查询语句有不同的语法，如SQL语句就有一定的语法。</p>
<p>查询语句的语法根据全文检索系统的实现而不同。最基本的有比如：AND, OR, NOT等。</p>
<p>举个例子，用户输入语句：lucene AND learned NOT hadoop。</p>
<p>说明用户想找一个包含lucene和learned然而不包括hadoop的文档。</p>
<h3><span id="第二步对查询语句进行词法分析语法分析及语言处理"><strong>第二步：对查询语句进行词法分析，语法分析，及语言处理。</strong></span></h3><p>由于查询语句有语法，因而也要进行语法分析，语法分析及语言处理。</p>
<p><strong>1. 词法分析主要用来识别单词和关键字。</strong></p>
<p>如上述例子中，经过词法分析，得到单词有lucene，learned，hadoop, 关键字有AND, NOT。</p>
<p>如果在词法分析中发现不合法的关键字，则会出现错误。如lucene AMD learned，其中由于AND拼错，导致AMD作为一个普通的单词参与查询。</p>
<p><strong>2. 语法分析主要是根据查询语句的语法规则来形成一棵语法树。</strong></p>
<p>如果发现查询语句不满足语法规则，则会报错。如lucene NOT AND learned，则会出错。</p>
<p>如上述例子，lucene AND learned NOT hadoop形成的语法树如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252139825.png" alt></p>
<p><strong>3. 语言处理同索引过程中的语言处理几乎相同。</strong></p>
<p>如learned变成learn等。</p>
<p>经过第二步，我们得到一棵经过语言处理的语法树。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252139377.png" alt></p>
<h3><span id="第三步搜索索引得到符合语法树的文档"><strong>第三步：搜索索引，得到符合语法树的文档。</strong></span></h3><p>此步骤有分几小步：</p>
<ol>
<li>首先，在反向索引表中，分别找出包含lucene，learn，hadoop的文档链表。</li>
<li>其次，对包含lucene，learn的链表进行合并操作，得到既包含lucene又包含learn的文档链表。</li>
<li>然后，将此链表与hadoop的文档链表进行差操作，去除包含hadoop的文档，从而得到既包含lucene又包含learn而且不包含hadoop的文档链表。</li>
<li>此文档链表就是我们要找的文档。</li>
</ol>
<h3><span id="第四步根据得到的文档和查询语句的相关性对结果进行排序"><strong>第四步：根据得到的文档和查询语句的相关性，对结果进行排序。</strong></span></h3><p>虽然在上一步，我们得到了想要的文档，然而对于查询结果应该按照与查询语句的相关性进行排序，越相关者越靠前。</p>
<p>如何计算文档和查询语句的相关性呢？</p>
<p>不如我们把查询语句看作一片短小的文档，对文档与文档之间的相关性(relevance)进行打分(scoring)，分数高的相关性好，就应该排在前面。</p>
<p>那么又怎么对文档之间的关系进行打分呢？</p>
<p><strong>这可不是一件容易的事情，首先我们看一看判断人之间的关系吧。</strong></p>
<p><strong>首先</strong>看一个人，往往有很多<strong>要素</strong>，如性格，信仰，爱好，衣着，高矮，胖瘦等等。</p>
<p><strong>其次</strong>对于人与人之间的关系，<strong>不同的要素重要性不同</strong>，性格，信仰，爱好可能重要些，衣着，高矮，胖瘦可能就不那么重要了，所以具有相同或相似性格，信仰，爱好的人比较容易成为好的朋友，然而衣着，高矮，胖瘦不同的人，也可以成为好的朋友。</p>
<p>因而判断人与人之间的关系，<strong>首先要找出哪些要素对人与人之间的关系最重要</strong>，比如性格，信仰，爱好。<strong>其次要判断两个人的这些要素之间的关系</strong>，比如一个人性格开朗，另一个人性格外向，一个人信仰佛教，另一个信仰上帝，一个人爱好打篮球，另一个爱好踢足球。我们发现，两个人在性格方面都很积极，信仰方面都很善良，爱好方面都爱运动，因而两个人关系应该会很好。</p>
<p><strong>我们再来看看公司之间的关系吧。</strong></p>
<p><strong>首先</strong>看一个公司，有很多人组成，如总经理，经理，首席技术官，普通员工，保安，门卫等。</p>
<p><strong>其次对于公司与公司之间的关系，不同的人重要性不同</strong>，总经理，经理，首席技术官可能更重要一些，普通员工，保安，门卫可能较不重要一点。所以如果两个公司总经理，经理，首席技术官之间关系比较好，两个公司容易有比较好的关系。然而一位普通员工就算与另一家公司的一位普通员工有血海深仇，怕也难影响两个公司之间的关系。</p>
<p>因而判断公司与公司之间的关系，<strong>首先要找出哪些人对公司与公司之间的关系最重要</strong>，比如总经理，经理，首席技术官。<strong>其次要判断这些人之间的关系</strong>，不如两家公司的总经理曾经是同学，经理是老乡，首席技术官曾是创业伙伴。我们发现，两家公司无论总经理，经理，首席技术官，关系都很好，因而两家公司关系应该会很好。</p>
<p>分析了两种关系，下面看一下<strong>如何判断文档之间的关系</strong>了。</p>
<p><strong>首先，一个文档有很多词(Term)组成</strong>，如search, lucene, full-text, this, a, what等。</p>
<p><strong>其次对于文档之间的关系，不同的Term重要性不同</strong>，比如对于本篇文档，search, Lucene, full-text就相对重要一些，this, a , what可能相对不重要一些。所以如果两篇文档都包含search, Lucene，fulltext，这两篇文档的相关性好一些，然而就算一篇文档包含this, a, what，另一篇文档不包含this, a, what，也不能影响两篇文档的相关性。</p>
<p>因而判断文档之间的关系，首先找出哪些词(Term)对文档之间的关系最重要，如search, Lucene, fulltext。然后判断这些词(Term)之间的关系。</p>
<p><strong>找出词(Term)对文档的重要性的过程称为计算词的权重(Term weight)的过程。</strong></p>
<p>计算词的权重(term weight)有两个参数，第一个是词(Term)，第二个是文档(Document)。</p>
<p>词的权重(Term weight)表示此词(Term)在此文档中的重要程度，越重要的词(Term)有越大的权重(Term weight)，因而在计算文档之间的相关性中将发挥更大的作用。</p>
<p><strong>判断词(Term)之间的关系从而得到文档相关性的过程应用一种叫做向量空间模型的算法(Vector Space Model)。</strong></p>
<p>下面仔细分析一下这两个过程：</p>
<h4><span id="1-计算权重term-weight的过程"><strong>1. 计算权重(Term weight)的过程。</strong></span></h4><p>影响一个词(Term)在一篇文档中的重要性主要有两个因素：</p>
<ul>
<li>Term Frequency (tf)：即此Term在此文档中出现了多少次。tf 越大说明越重要。</li>
<li>Document Frequency (df)：即有多少文档包含次Term。df 越大说明越不重要。</li>
</ul>
<p>容易理解吗？词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“搜索”这个词，在本文档中出现的次数很多，说明本文档主要就是讲这方面的事的。然而在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，这是由第二个因素进行调整，第二个因素说明，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。</p>
<p>这也如我们程序员所学的技术，对于程序员本身来说，这项技术掌握越深越好（掌握越深说明花时间看的越多，tf越大），找工作时越有竞争力。然而对于所有程序员来说，这项技术懂得的人越少越好（懂得的人少df小），找工作越有竞争力。人的价值在于不可替代性就是这个道理。</p>
<p>道理明白了，我们来看看公式：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252144198.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252145148.png" alt></p>
<p>这仅仅只term weight计算公式的简单典型实现。实现全文检索系统的人会有自己的实现，Lucene就与此稍有不同。</p>
<h4><span id="2-判断term之间的关系从而得到文档相关性的过程也即向量空间模型的算法vsm"><strong>2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。</strong></span></h4><p>我们把文档看作一系列词(Term)，每一个词(Term)都有一个权重(Term weight)，不同的词(Term)根据自己在文档中的权重来影响文档相关性的打分计算。</p>
<p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量。</p>
<p>Document = {term1, term2, …… ,term N}</p>
<p>Document Vector = {weight1, weight2, …… ,weight N}</p>
<p>同样我们把查询语句看作一个简单的文档，也用向量来表示。</p>
<p>Query = {term1, term 2, …… , term N}</p>
<p>Query Vector = {weight1, weight2, …… , weight N}</p>
<p>我们把所有搜索出的文档向量及查询向量放到一个N维空间中，每个词(term)是一维。</p>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252148225.png" alt></p>
<p>我们认为两个向量之间的夹角越小，相关性越大。</p>
<p>所以我们计算夹角的余弦值作为相关性的打分，夹角越小，余弦值越大，打分越高，相关性越大。</p>
<p>有人可能会问，查询语句一般是很短的，包含的词(Term)是很少的，因而查询向量的维数很小，而文档很长，包含词(Term)很多，文档向量维数很大。你的图中两者维数怎么都是N呢？</p>
<p>在这里，既然要放到相同的向量空间，自然维数是相同的，不同时，取二者的并集，如果不含某个词(Term)时，则权重(Term Weight)为0。</p>
<p>相关性打分公式如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252151747.png" alt></p>
<p>举个例子，查询语句有11个Term，共有三篇文档搜索出来。其中各自的权重(Term weight)，如下表格。</p>
<table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><br></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t1</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t2</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t3</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t4</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t5</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t6</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t7</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t8</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t9</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t10</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">t11</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">D1</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">D2</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.954</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">D3</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">Q</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.477</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">0</p></td><td zoompage-fontsize="14"><p zoompage-fontsize="14">.176</p></td></tr></tbody></table>

<p>于是计算，三篇文档同查询语句的相关性打分分别为：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252152826.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252152014.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252153180.png" alt></p>
<p>于是文档二相关性最高，先返回，其次是文档一，最后是文档三。</p>
<p>到此为止，我们可以找到我们最想要的文档了。</p>
<p>说了这么多，其实还没有进入到Lucene，而仅仅是信息检索技术(Information retrieval)中的基本理论，然而当我们看过Lucene后我们会发现，Lucene是对这种基本理论的一种基本的的实践。所以在以后分析Lucene的文章中，会常常看到以上理论在Lucene中的应用。</p>
<p>在进入Lucene之前，对上述索引创建和搜索过程所一个总结，如图：</p>
<p>此图参照<a href="http://www.lucene.com.cn/about.htm">http://www.lucene.com.cn/about.htm</a>中文章《开放源代码的全文检索引擎Lucene》</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402252155722.png" alt></p>
<p><strong>1. 索引过程：</strong></p>
<p><strong>1)</strong> <strong>有一系列被索引文件</strong></p>
<p><strong>2)</strong> <strong>被索引文件经过语法分析和语言处理形成一系列词(Term)。</strong></p>
<p><strong>3)</strong> <strong>经过索引创建形成词典和反向索引表。</strong></p>
<p><strong>4)</strong> <strong>通过索引存储将索引写入硬盘。</strong></p>
<p><strong>2. 搜索过程：</strong></p>
<p><strong>a)</strong> <strong>用户输入查询语句。</strong></p>
<p><strong>b)</strong> <strong>对查询语句经过语法分析和语言分析得到一系列词(Term)。</strong></p>
<p><strong>c)</strong> <strong>通过语法分析得到一个查询树。</strong></p>
<p><strong>d)</strong> <strong>通过索引存储将索引读入到内存。</strong></p>
<p><strong>e)</strong> <strong>利用查询树搜索索引，从而得到每个词(Term)的文档链表，对文档链表进行交，差，并得到结果文档。</strong></p>
<p><strong>f)</strong> <strong>将搜索到的结果文档对查询的相关性进行排序。</strong></p>
<p><strong>g)</strong> <strong>返回查询结果给用户。</strong></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>mermaid画流程图语法</title>
    <url>/62afdbe0/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#流程图分类">流程图分类</a><ul>
<li><a href="#示例">示例</a></li>
</ul>
</li>
<li><a href="#方向">方向</a></li>
<li><a href="#节点">节点</a><ul>
<li><a href="#形状">形状</a></li>
<li><a href="#名称">名称</a></li>
</ul>
</li>
<li><a href="#连接线">连接线</a><ul>
<li><a href="#线的定义">线的定义</a></li>
<li><a href="#线的形状">线的形状</a></li>
<li><a href="#箭头形状">箭头形状</a></li>
<li><a href="#多个节点连接">多个节点连接</a></li>
<li><a href="#连接线上的文字注释">连接线上的文字注释</a></li>
</ul>
</li>
<li><a href="#注释">注释</a></li>
<li><a href="#子图分组">子图（分组）</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>Mermaid 是一个基于 Javascript 的图表绘制工具，通过解析类 Markdown 的文本语法来实现图表的创建和动态修改。Mermaid 诞生的主要目的是让文档的更新能够及时跟上开发进度。</p>
</blockquote>
<h3><span id="流程图分类">流程图分类</span></h3><p>有两种流程图</p>
<ul>
<li>flowchart</li>
<li>graph</li>
</ul>
<p>flowchart 语法过于复杂，不赘述。下面内容只保留 graph 语法。</p>
<h4><span id="示例">示例</span></h4><pre class="mermaid">graph TD

start(程序开始)
--> 随机选取K个样本作为均值向量
--> id1([划分簇开始])
--> 计算样本与各均值向量之间的距离
--> 根据距离最近的均值向量确定每个样本的簇标记
--> 将样本划入相应的簇
--> id2{遍历完成?}
id2 -- NO --> id1
id2 -- YES --> id3([更新簇均值向量开始])
--> id4[计算各簇新均值向量μ]
--> id5{所有计算完成?}
id5 -- YES --> 保留μ集合为簇新中心点 --> id6{所有μ是否更新?}
id5 -- NO --> id3
id6 -- NO --> endd(结束, 输出均值向量)
id6 == YES ==>id1</pre>

<h3><span id="方向">方向</span></h3><p>在 <code>graph</code> 之后加上空格可以传入参数，可以定义流程图方向。</p>
<table>
<thead>
<tr>
<th>参数值</th>
<th>TB</th>
<th>TD</th>
<th>BT</th>
<th>RL</th>
<th>LR</th>
</tr>
</thead>
<tbody><tr>
<td>说明</td>
<td>从上到下</td>
<td>从上到下</td>
<td>从下到上</td>
<td>从右到左</td>
<td>从左到右</td>
</tr>
</tbody></table>
<h3><span id="节点">节点</span></h3><p>每一行输入任意字符都会被识别为一个新节点。输入的字符将被作为节点的ID，同时默认作为节点名称显示。默认形状是矩形。</p>
<h4><span id="形状">形状</span></h4><p>除了矩形还有多种形状可选，在节点后面增加符号对即可。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230320000056.png" alt></p>
<h4><span id="名称">名称</span></h4><p>形状符号中输入字符作为展示的名称。</p>
<p>默认可以不用引号，但如果需要使用转义符、或者括号，则需要用引号包裹。</p>
<h3><span id="连接线">连接线</span></h3><p>语法结构大致是：<code>节点ID 连接线符号 节点ID</code>（<br>例如 <code>NodeA &lt;--&gt; NodeB</code>）。</p>
<p>如果一行末尾没有节点ID，则会找到下一行第一个节点ID连接，也就意味着连接线的语法是可以换行的。</p>
<p>如果节点ID是前文没有出现过的，会当做一个新的节点处理。所以节点的创建与连接是可以一次性书写的。</p>
<h4><span id="线的定义">线的定义</span></h4><p>连接线由三个字符组成，末尾符号代表端点图形，第一二个符号代表线的样式。</p>
<p>绘制双向箭头的话，需要在头部增加一个符号，一共是四个字符。</p>
<p>中间符号可以重复，重复会渲染出更长的连接线。</p>
<p>如<code>NodeA &lt;--&gt; NodeB</code>就是双箭头符号，中间代表线段形状，头尾代表箭头形状。</p>
<h4><span id="线的形状">线的形状</span></h4><p>线条有三种：<br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230320000338.png" alt></p>
<h4><span id="箭头形状">箭头形状</span></h4><p>箭头形状有三种：<br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230320000410.png" alt></p>
<p>双向箭头：<br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230320000438.png" alt></p>
<h4><span id="多个节点连接">多个节点连接</span></h4><p><code>&amp;</code> 符号可以让图形一次性连接多个节点：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230320000522.png" alt></p>
<h4><span id="连接线上的文字注释">连接线上的文字注释</span></h4><p>可以在连接线上增加连接线的注释。注释有两种写法：</p>
<p>写在末尾：||符号，只需要在连接线符号末尾增加—&gt;|文字|即可展示。</p>
<p>写在中间：类似—文字—&gt;、-. 文字 .-&gt;，等于是重复连接符号，前半部分是定义上一个图形到文字的连接线样式，后半部分是定义文字到图形的连接线样式。</p>
<p>通常来说写在末尾会比较方便点。<br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230320000703.png" alt></p>
<h3><span id="注释">注释</span></h3><p><code>%%</code> 号为注释符，会将符号之后到此行结束都视为注释。</p>
<h3><span id="子图分组">子图（分组）</span></h3><p>子图实际上就是给图形分组，增加一个背景色块，使用subgraph ID、end包裹，中间图语法与此前一样。</p>
<p>subgraph ID之后用方括号包裹可以定义显示名称。其中元素可以任意连接，用子图ID可以定义子图与子图的连接线。</p>
<pre class="mermaid">graph TB

subgraph one
a --> b
end

subgraph tow
c --> d
end

c --> b</pre>

<p>另一种用法：</p>
<pre class="mermaid">graph LR
subgraph submo
D["DDD"]
E["EEE"]
F["FFF"]
end

Start --> D
D --> E
D --> F

E & F --> End</pre>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>Move semantics of RapidJSON</title>
    <url>/e5a4892c/</url>
    <content><![CDATA[<p>RapidJSON 的设计有一个特性, 进行赋值操作时, 不是把源value复制(copy)到目的 value, 而是转移(move)到目的value. 例如</p>
<pre><code>Value a(123);
Value b(456);
b = a; // a becomes a Null value, b becomes number 123.</code></pre><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207003749.png" alt></p>
<p>这样的设计的目的是 为了提高性能. 对于固定大小的JSON类型(Number, True, False, Null), 复制很简单快捷. 而对于可变大小的类型(String, Array, Object), 复制时会产生大量不容易被察觉的开销. 尤其是当我们需要创建一个临时的值, 把它复制给另一个变量, 然后析构它. 若使用正常的<strong>复制</strong> 语义:</p>
<pre><code>Document d;
Value o(kObjectType);
&#123;
    Value contacts(kArrayType);
    // Adding elements to contacts array.
    // ...
    o.AddMember(&quot;contacts&quot;, contacts, d.GetAllocator(); // deep clone contacts(may be with lots of allocations)
    // destruct contact
&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207003815.png" alt></p>
<p><code>o</code> 需要分配跟<code>contacts</code> 大小一样的缓冲区, 做深度复制, 然后析构<code>contacts</code> . 这样会产生大量不必要的内存分配/释放 和内存复制. 有一些方案可以避免实质的复制这些数据, 如引用计数, 垃圾回收等等. 为了使RapidJSON简单和快速, 我们选择使用转移语义来进行赋值. 这与<code>std::auto_ptr</code>类似, 都是在赋值时转移拥有权. 转移比复制简捷地多, 它只需 析构原来的值, 把源值<code>memcpy()</code> 到目的值, 最后再把源值 设为Null类型.</p>
<p>使用转移语义, 上面的例子变成:</p>
<pre><code>Document d;
Value o(kObjectType);
&#123;
    Value contacts(kArraryType);
    // Adding elements to contacts array.
    o.AddMember(&quot;contacts&quot;, contacts, d.GetAllocator()); // Just memcpy() of contacts itself to the value of new member(16 bytes)
    // contacts became Null here. Its destructiong is trivial.
&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207003854.png" alt></p>
<p><strong>转移语义和临时值</strong> 有时, 我们想直接构造一个临时变量传给”转移”函数, 如<code>PushBack()</code> , <code>AddMember()</code> . 由于临时对象不能直接转化成正常的值引用, 我们可以调用<code>Move()</code> 函数</p>
<pre><code>Value a(kArrayType);
Document::AllocatorType&amp; allocator = document.GetAllocator();
// a.PushBack(Value(42), allocator); // Compiling error
a.PushBack(Value().SetInt(42), allocator); // fluent API
a.PushBack(Value(42).Move(), allocator); // same as above</code></pre><p>翻译原文: <a href="http://rapidjson.org/md\_doc\_tutorial.html#MoveSemantics">http://rapidjson.org/md\_doc\_tutorial.html#MoveSemantics</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldump: Got error: 1044: Access denied for user</title>
    <url>/a333bc04/</url>
    <content><![CDATA[<p><code>mysqldump -u username -p dbname &gt; dbname.sql</code> mysqldump: Got error: 1044: Access denied for user XXX to database XXX when using LOCK TABLES 解决方法: <code>mysqldump -u dbuser -ppass db --skip-lock-tables &gt; db.sql</code></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene 三: Lucene 的索引文件格式</title>
    <url>/552b0416/</url>
    <content><![CDATA[<p>Lucene的索引里面存了些什么，如何存放的，也即Lucene的索引文件格式，是读懂Lucene源代码的一把钥匙。</p>
<p>当我们真正进入到Lucene源代码之中的时候，我们会发现:</p>
<ul>
<li>Lucene的索引过程，就是按照全文检索的基本过程，将倒排表写成此文件格式的过程。</li>
<li>Lucene的搜索过程，就是按照此文件格式将索引进去的信息读出来，然后计算每篇文档打分(score)的过程。</li>
</ul>
<p>参考官网 <a href="http://lucene.apache.org/java/2_9_0/fileformats.html">Apache Lucene - Index File Formats</a>。</p>
<h2><span id="一-基本概念"><strong>一、基本概念</strong></span></h2><p>下图就是Lucene生成的索引的一个实例：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262111476.png" alt></p>
<p>Lucene的索引结构是有层次结构的，主要分以下几个层次：</p>
<ul>
<li>索引(Index)：<ul>
<li>在Lucene中一个索引是放在一个文件夹中的。</li>
<li>如上图，同一文件夹中的所有的文件构成一个Lucene索引。</li>
</ul>
</li>
<li>段(Segment)：<ul>
<li>一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。</li>
<li>如上图，具有相同前缀文件的属同一个段，图中共两个段 “_0” 和 “_1”。</li>
<li>segments.gen和segments_5是段的元数据文件，也即它们保存了段的属性信息。</li>
</ul>
</li>
<li>文档(Document)：<ul>
<li>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。</li>
<li>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。</li>
</ul>
</li>
<li>域(Field)：<ul>
<li>一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。</li>
<li>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。</li>
</ul>
</li>
<li>词(Term)：<ul>
<li>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</li>
</ul>
</li>
</ul>
<p>Lucene的索引结构中，即保存了正向信息，也保存了反向信息。</p>
<p>所谓正向信息：</p>
<ul>
<li>按层次保存了从索引，一直到词的包含关系：索引(Index) –&gt; 段(segment) –&gt; 文档(Document) –&gt; 域(Field) –&gt; 词(Term)</li>
<li>也即此索引包含了那些段，每个段包含了那些文档，每个文档包含了那些域，每个域包含了那些词。</li>
<li>既然是层次结构，则每个层次都保存了本层次的信息以及下一层次的元信息，也即属性信息，比如一本介绍中国地理的书，应该首先介绍中国地理的概况，以及中国包含多少个省，每个省介绍本省的基本概况及包含多少个市，每个市介绍本市的基本概况及包含多少个县，每个县具体介绍每个县的具体情况。</li>
<li>如上图，包含正向信息的文件有：<ul>
<li>segments_N保存了此索引包含多少个段，每个段包含多少篇文档。</li>
<li>XXX.fnm保存了此段包含了多少个域，每个域的名称及索引方式。</li>
<li>XXX.fdx，XXX.fdt保存了此段包含的所有文档，每篇文档包含了多少域，每个域保存了那些信息。</li>
<li>XXX.tvx，XXX.tvd，XXX.tvf保存了此段包含多少文档，每篇文档包含了多少域，每个域包含了多少词，每个词的字符串，位置等信息。</li>
</ul>
</li>
</ul>
<p>所谓反向信息：</p>
<ul>
<li>保存了词典到倒排表的映射：词(Term) –&gt; 文档(Document)</li>
<li>如上图，包含反向信息的文件有：<ul>
<li>XXX.tis，XXX.tii保存了词典(Term Dictionary)，也即此段包含的所有的词按字典顺序的排序。</li>
<li>XXX.frq保存了倒排表，也即包含每个词的文档ID列表。</li>
<li>XXX.prx保存了倒排表中每个词在包含此词的文档中的位置。</li>
</ul>
</li>
</ul>
<p>在了解Lucene索引的详细结构之前，先看看Lucene索引中的基本数据类型。</p>
<h2><span id="二-基本类型"><strong>二、基本类型</strong></span></h2><p>Lucene索引文件中，用以下基本类型来保存信息：</p>
<ul>
<li>Byte：是最基本的类型，长8位(bit)。</li>
<li>UInt32：由4个Byte组成。</li>
<li>UInt64：由8个Byte组成。</li>
<li>VInt：<ul>
<li>变长的整数类型，它可能包含多个Byte，对于每个Byte的8位，其中后7位表示数值，最高1位表示是否还有另一个Byte，0表示没有，1表示有。</li>
<li>越前面的Byte表示数值的低位，越后面的Byte表示数值的高位。</li>
<li>例如130化为二进制为 1000, 0010，总共需要8位，一个Byte表示不了，因而需要两个Byte来表示，第一个Byte表示后7位，并且在最高位置1来表示后面还有一个Byte，所以为(1) 0000010，第二个Byte表示第8位，并且最高位置0来表示后面没有其他的Byte了，所以为(0) 0000001。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262118850.png" alt></p>
<ul>
<li>Chars：是UTF-8编码的一系列Byte。</li>
<li>String：一个字符串首先是一个VInt来表示此字符串包含的字符的个数，接着便是UTF-8编码的字符序列Chars。</li>
</ul>
<h2><span id="三-基本规则"><strong>三、基本规则</strong></span></h2><p>Lucene为了使的信息的存储占用的空间更小，访问速度更快，采取了一些特殊的技巧，然而在看Lucene文件格式的时候，这些技巧却容易使我们感到困惑，所以有必要把这些特殊的技巧规则提取出来介绍一下。</p>
<h3><span id="1-前缀后缀规则prefixsuffix"><strong>1. 前缀后缀规则(Prefix+Suffix)</strong></span></h3><p>Lucene在反向索引中，要保存词典(Term Dictionary)的信息，所有的词(Term)在词典中是按照字典顺序进行排列的，然而词典中包含了文档中的几乎所有的词，并且有的词还是非常的长的，这样索引文件会非常的大，所谓前缀后缀规则，即当某个词和前一个词有共同的前缀的时候，后面的词仅仅保存前缀在词中的偏移(offset)，以及除前缀以外的字符串(称为后缀)。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262121854.png" alt></p>
<p>比如要存储如下词:term，termagancy，termagant，terminal，</p>
<p>如果按照正常方式来存储，需要的空间如下：</p>
<p>[VInt = 4] [t][e][r][m]，</p>
<p>[VInt = 10][t][e][r][m][a][g][a][n][c][y]，</p>
<p>[VInt = 9][t][e][r][m][a][g][a][n][t]，</p>
<p>[VInt = 8][t][e][r][m][i][n][a][l]</p>
<p>共需要35个Byte.</p>
<p>如果应用前缀后缀规则，需要的空间如下：</p>
<p>[VInt = 4] [t][e][r][m]，</p>
<p>[VInt = 4 (offset)][VInt = 6][a][g][a][n][c][y]，</p>
<p>[VInt = 8 (offset)][VInt = 1][t]，</p>
<p>[VInt = 4 (offset)][VInt = 4][i][n][a][l]</p>
<p>共需要22个Byte。</p>
<p>大大缩小了存储空间，尤其是在按字典顺序排序的情况下，前缀的重合率大大提高。</p>
<h3><span id="2-差值规则delta"><strong>2. 差值规则(Delta)</strong></span></h3><p>在Lucene的反向索引中，需要保存很多整型数字的信息，比如文档ID号，比如词(Term)在文档中的位置等等。</p>
<p>由上面介绍，我们知道，整型数字是以VInt的格式存储的。随着数值的增大，每个数字占用的Byte的个数也逐渐的增多。所谓差值规则(Delta)就是先后保存两个整数的时候，后面的整数仅仅保存和前面整数的差即可。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262129662.png" alt></p>
<p>比如要存储如下整数：16386，16387，16388，16389</p>
<p>如果按照正常方式来存储，需要的空间如下：</p>
<p>[(1) 000, 0010][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(1) 000, 0011][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(1) 000, 0100][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(1) 000, 0101][(1) 000, 0000][(0) 000, 0001]</p>
<p>供需12个Byte。</p>
<p>如果应用差值规则来存储，需要的空间如下：</p>
<p>[(1) 000, 0010][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(0) 000, 0001]，</p>
<p>[(0) 000, 0001]，</p>
<p>[(0) 000, 0001]</p>
<p>共需6个Byte。</p>
<p>大大缩小了存储空间，而且无论是文档ID，还是词在文档中的位置，都是按从小到大的顺序，逐渐增大的。</p>
<h3><span id="3-或然跟随规则a-b"><strong>3. 或然跟随规则(A, B?)</strong></span></h3><p>Lucene的索引结构中存在这样的情况，某个值A后面可能存在某个值B，也可能不存在，需要一个标志来表示后面是否跟随着B。</p>
<p>一般的情况下，在A后面放置一个Byte，为0则后面不存在B，为1则后面存在B，或者0则后面存在B，1则后面不存在B。</p>
<p>但这样要浪费一个Byte的空间，其实一个Bit就可以了。</p>
<p>在Lucene中，采取以下的方式：A的值左移一位，空出最后一位，作为标志位，来表示后面是否跟随B，所以在这种情况下，A/2是真正的A原来的值。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262134351.png" alt></p>
<p>如果去读Apache Lucene - Index File Formats这篇文章，会发现很多符合这种规则的：</p>
<ul>
<li>.frq文件中的DocDelta[, Freq?]，DocSkip,PayloadLength?</li>
<li>.prx文件中的PositionDelta,Payload? (但不完全是，如下表分析)</li>
</ul>
<p>当然还有一些带?的但不属于此规则的：</p>
<ul>
<li>.frq文件中的SkipChildLevelPointer?，是多层跳跃表中，指向下一层表的指针，当然如果是最后一层，此值就不存在，也不需要标志。</li>
<li>.tvf文件中的Positions?, Offsets?。<ul>
<li>在此类情况下，带?的值是否存在，并不取决于前面的值的最后一位。</li>
<li>而是取决于Lucene的某项配置，当然这些配置也是保存在Lucene索引文件中的。</li>
<li>如Position和Offset是否存储，取决于.fnm文件中对于每个域的配置(TermVector.WITH_POSITIONS和TermVector.WITH_OFFSETS)</li>
</ul>
</li>
</ul>
<p>为什么会存在以上两种情况，其实是可以理解的：</p>
<ul>
<li>对于符合或然跟随规则的，是因为对于每一个A，B是否存在都不相同，当这种情况大量存在的时候，从一个Byte到一个Bit如此8倍的空间节约还是很值得的。</li>
<li>对于不符合或然跟随规则的，是因为某个值的是否存在的配置对于整个域(Field)甚至整个索引都是有效的，而非每次的情况都不相同，因而可以统一存放一个标志。</li>
</ul>
<blockquote>
<p> 文章中对如下格式的描述令人困惑：</p>
</blockquote>
<blockquote>
<p> Positions –&gt; &lt;PositionDelta,Payload?&gt; <sup zoompage-fontsize="12">Freq</sup></p>
</blockquote>
<blockquote>
<p> Payload –&gt; &lt;PayloadLength?,PayloadData&gt;</p>
</blockquote>
<blockquote>
<p> PositionDelta和Payload是否适用或然跟随规则呢？如何标识PayloadLength是否存在呢？</p>
</blockquote>
<blockquote>
<p> 其实PositionDelta和Payload并不符合或然跟随规则，Payload是否存在，是由.fnm文件中对于每个域的配置中有关Payload的配置决定的(FieldOption.STORES_PAYLOADS) 。</p>
</blockquote>
<blockquote>
<p> 当Payload不存在时，PayloadDelta本身不遵从或然跟随原则。</p>
</blockquote>
<blockquote>
<p> 当Payload存在时，格式应该变成如下：Positions –&gt; &lt;PositionDelta,PayloadLength?,PayloadData&gt; <sup zoompage-fontsize="12">Freq</sup></p>
</blockquote>
<blockquote>
<p> 从而PositionDelta和PayloadLength一起适用或然跟随规则。</p>
</blockquote>
<h3><span id="4-跳跃表规则skip-list"><strong>4. 跳跃表规则(Skip list)</strong></span></h3><p>为了提高查找的性能，Lucene在很多地方采取的跳跃表的数据结构。</p>
<p>跳跃表(Skip List)是如图的一种数据结构，有以下几个基本特征：</p>
<ul>
<li>元素是按顺序排列的，在Lucene中，或是按字典顺序排列，或是按从小到大顺序排列。</li>
<li>跳跃是有间隔的(Interval)，也即每次跳跃的元素数，间隔是事先配置好的，如图跳跃表的间隔为3。</li>
<li>跳跃表是由层次的(level)，每一层的每隔指定间隔的元素构成上一层，如图跳跃表共有2层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262141098.png" alt></p>
<p>需要注意一点的是，在很多数据结构或算法书中都会有跳跃表的描述，原理都是大致相同的，但是定义稍有差别：</p>
<ul>
<li>对间隔(Interval)的定义： 如图中，有的认为间隔为2，即两个上层元素之间的元素数，不包括两个上层元素；有的认为是3，即两个上层元素之间的差，包括后面上层元素，不包括前面的上层元素；有的认为是4，即除两个上层元素之间的元素外，既包括前面，也包括后面的上层元素。Lucene是采取的第二种定义。</li>
<li>对层次(Level)的定义：如图中，有的认为应该包括原链表层，并从1开始计数，则总层次为3，为1，2，3层；有的认为应该包括原链表层，并从0计数，为0，1，2层；有的认为不应该包括原链表层，且从1开始计数，则为1，2层；有的认为不应该包括链表层，且从0开始计数，则为0，1层。Lucene采取的是最后一种定义。</li>
</ul>
<p>跳跃表比顺序查找，大大提高了查找速度，如查找元素72，原来要访问2，3，7，12，23，37，39，44，50，72总共10个元素，应用跳跃表后，只要首先访问第1层的50，发现72大于50，而第1层无下一个节点，然后访问第2层的94，发现94大于72，然后访问原链表的72，找到元素，共需要访问3个元素即可。</p>
<p>然而Lucene在具体实现上，与理论又有所不同，在具体的格式中，会详细说明。</p>
<h2><span id="四-具体格式"><strong>四、具体格式</strong></span></h2><p>上面曾经交代过，Lucene保存了从Index到Segment到Document到Field一直到Term的正向信息，也包括了从Term到Document映射的反向信息，还有其他一些Lucene特有的信息。下面对这三种信息一一介绍。</p>
<h3><span id="41-正向信息"><strong>4.1. 正向信息</strong></span></h3><p><code>Index –&gt; Segments (segments.gen, segments_N) –&gt; Field(fnm, fdx, fdt) –&gt; Term (tvx, tvd, tvf)</code></p>
<p>上面的层次结构不是十分的准确，因为segments.gen和segments_N保存的是段(segment)的元数据信息(metadata)，其实是每个Index一个的，而段的真正的数据信息，是保存在域(Field)和词(Term)中的。</p>
<h4><span id="411-段的元数据信息segments_n"><strong>4.1.1. 段的元数据信息(segments_N)</strong></span></h4><p>一个索引(Index)可以同时存在多个segments_N(至于如何存在多个segments_N，在描述完详细信息之后会举例说明)，然而当我们要打开一个索引的时候，我们必须要选择一个来打开，那如何选择哪个segments_N呢？</p>
<p>Lucene采取以下过程：</p>
<ul>
<li><p>其一，在所有的segments_N中选择N最大的一个。基本逻辑参照SegmentInfos.getCurrentSegmentGeneration(File[] files)，其基本思路就是在所有以segments开头，并且不是segments.gen的文件中，选择N最大的一个作为genA。</p>
</li>
<li><p>其二，打开segments.gen，其中保存了当前的N值。其格式如下，读出版本号(Version)，然后再读出两个N，如果两者相等，则作为genB。</p>
</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272228421.png" alt></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IndexInput</span> <span class="variable">genInput</span> <span class="operator">=</span> directory.openInput(IndexFileNames.SEGMENTS_GEN);<span class="comment">//&quot;segments.gen&quot;  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> genInput.readInt();<span class="comment">//读出版本号  </span></span><br><span class="line"><span class="keyword">if</span> (version == FORMAT_LOCKLESS) &#123;<span class="comment">//如果版本号正确  </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">gen0</span> <span class="operator">=</span> genInput.readLong();<span class="comment">//读出第一个N  </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">gen1</span> <span class="operator">=</span> genInput.readLong();<span class="comment">//读出第二个N  </span></span><br><span class="line">    <span class="keyword">if</span> (gen0 == gen1) &#123;<span class="comment">//如果两者相等则为genB  </span></span><br><span class="line">        genB = gen0;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>其三，在上述得到的genA和genB中选择最大的那个作为当前的N，方才打开segments_N文件。其基本逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (genA &gt; genB)  </span><br><span class="line">    gen = genA;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    gen = genB;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<p>如下图是segments_N的具体格式：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272230529.png" alt></p>
<ul>
<li>Format：<ul>
<li>索引文件格式的版本号。</li>
<li>由于Lucene是在不断开发过程中的，因而不同版本的Lucene，其索引文件格式也不尽相同，于是规定一个版本号。</li>
<li>Lucene 2.1此值-3，Lucene 2.9时，此值为-9。</li>
<li>当用某个版本号的IndexReader读取另一个版本号生成的索引的时候，会因为此值不同而报错。</li>
</ul>
</li>
<li>Version：<ul>
<li>索引的版本号，记录了IndexWriter将修改提交到索引文件中的次数。</li>
<li>其初始值大多数情况下从索引文件里面读出，仅仅在索引开始创建的时候，被赋予当前的时间，已取得一个唯一值。</li>
<li>其值改变在 <code>IndexWriter.commit-&gt;IndexWriter.startCommit-&gt;SegmentInfos.prepareCommit-&gt;SegmentInfos.write-&gt;writeLong(++version)</code></li>
<li>其初始值之所最初取一个时间，是因为我们并不关心IndexWriter将修改提交到索引的具体次数，而更关心到底哪个是最新的。IndexReader中常比较自己的version和索引文件中的version是否相同来判断此IndexReader被打开后，还有没有被IndexWriter更新。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在DirectoryReader中有一下函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCurrent</span><span class="params">()</span> <span class="keyword">throws</span> CorruptIndexException, IOException &#123;  </span><br><span class="line">  <span class="keyword">return</span> SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>NameCount<ul>
<li>是下一个新段(Segment)的段名。</li>
<li>所有属于同一个段的索引文件都以段名作为文件名，一般为_0.xxx, _0.yyy,  _1.xxx, _1.yyy ……</li>
<li>新生成的段的段名一般为原有最大段名加一。</li>
<li>如同的索引，NameCount读出来是2，说明新的段为_2.xxx, _2.yyy</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272232711.png" alt></p>
<ul>
<li>SegCount<ul>
<li>段(Segment)的个数。</li>
<li>如上图，此值为2。</li>
</ul>
</li>
<li>SegCount个段的元数据信息：<ul>
<li>SegName<ul>
<li>段名，所有属于同一个段的文件都有以段名作为文件名。</li>
<li>如上图，第一个段的段名为”_0”，第二个段的段名为”_1”</li>
</ul>
</li>
<li>SegSize<ul>
<li>此段中包含的文档数</li>
<li>然而此文档数是包括已经删除，又没有optimize的文档的，因为在optimize之前，Lucene的段中包含了所有被索引过的文档，而被删除的文档是保存在.del文件中的，在搜索的过程中，是先从段中读到了被删除的文档，然后再用.del中的标志，将这篇文档过滤掉。</li>
<li>如下的代码形成了上图的索引，可以看出索引了两篇文档形成了_0段，然后又删除了其中一篇，形成了_0_1.del，又索引了两篇文档形成_1段，然后又删除了其中一篇，形成_1_1.del。因而在两个段中，此值都是2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IndexWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriter</span>(FSDirectory.open(INDEX\_DIR), <span class="keyword">new</span> <span class="title class_">StandardAnalyzer</span>(Version.LUCENE\_CURRENT), <span class="literal">true</span>, IndexWriter.MaxFieldLength.LIMITED);  </span><br><span class="line">writer.setUseCompoundFile(<span class="literal">false</span>);  </span><br><span class="line">indexDocs(writer, docDir);<span class="comment">//docDir中只有两篇文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文档一为：Students should be allowed to go out with their friends, but not allowed to drink beer.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文档二为：My friend Jerry went to school to see his students but found them drunk which is not allowed.</span></span><br><span class="line"></span><br><span class="line">writer.commit();<span class="comment">//提交两篇文档，形成\_0段。</span></span><br><span class="line"></span><br><span class="line">writer.deleteDocuments(<span class="keyword">new</span> <span class="title class_">Term</span>(<span class="string">&quot;contents&quot;</span>, <span class="string">&quot;school&quot;</span>));<span class="comment">//删除文档二  </span></span><br><span class="line">writer.commit();<span class="comment">//提交删除，形成\_0\_1.del  </span></span><br><span class="line">indexDocs(writer, docDir);<span class="comment">//再次索引两篇文档，Lucene不能判别文档与文档的不同，因而算两篇新的文档。  </span></span><br><span class="line">writer.commit();<span class="comment">//提交两篇文档，形成\_1段  </span></span><br><span class="line">writer.deleteDocuments(<span class="keyword">new</span> <span class="title class_">Term</span>(<span class="string">&quot;contents&quot;</span>, <span class="string">&quot;school&quot;</span>));<span class="comment">//删除第二次添加的文档二  </span></span><br><span class="line">writer.close();<span class="comment">//提交删除，形成\_1\_1.del</span></span><br></pre></td></tr></table></figure>



<ul>
<li><ul>
<li>DelGen<ul>
<li>.del文件的版本号</li>
<li>Lucene中，在optimize之前，删除的文档是保存在.del文件中的。</li>
<li>在Lucene 2.9中，文档删除有以下几种方式：<ul>
<li>IndexReader.deleteDocument(int docID)是用IndexReader按文档号删除。</li>
<li>IndexReader.deleteDocuments(Term term)是用IndexReader删除包含此词(Term)的文档。</li>
<li>IndexWriter.deleteDocuments(Term term)是用IndexWriter删除包含此词(Term)的文档。</li>
<li>IndexWriter.deleteDocuments(Term[] terms)是用IndexWriter删除包含这些词(Term)的文档。</li>
<li>IndexWriter.deleteDocuments(Query query)是用IndexWriter删除能满足此查询(Query)的文档。</li>
<li>IndexWriter.deleteDocuments(Query[] queries)是用IndexWriter删除能满足这些查询(Query)的文档。</li>
<li>原来的版本中Lucene的删除一直是由IndexReader来完成的，在Lucene 2.9中虽可以用IndexWriter来删除，但是其实真正的实现是在IndexWriter中，保存了readerpool，当IndexWriter向索引文件提交删除的时候，仍然是从readerpool中得到相应的IndexReader，并用IndexReader来进行删除的。下面的代码可以说明：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">IndexWriter.applyDeletes()</span><br><span class="line">-&gt; DocumentsWriter.applyDeletes(SegmentInfos)</span><br><span class="line">  -&gt; reader.deleteDocument(doc);</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li><ul>
<li>DelGen是每当IndexWriter向索引文件中提交删除操作的时候，加1，并生成新的.del文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table zoompage-fontsize="14"><tbody zoompage-fontsize="14"><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">IndexWriter.commit()</p><p zoompage-fontsize="14">-&gt; IndexWriter.applyDeletes()</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp; -&gt; IndexWriter$ReaderPool.release(SegmentReader)</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; SegmentReader(IndexReader).commit()</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; SegmentReader.doCommit(Map)</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; SegmentInfo.advanceDelGen()</p><p zoompage-fontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; if (delGen == NO) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delGen = YES;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delGen++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p></td></tr><tr zoompage-fontsize="14"><td zoompage-fontsize="14"><p zoompage-fontsize="14">IndexWriter writer = new IndexWriter(FSDirectory.open(INDEX_DIR), new StandardAnalyzer(Version.LUCENE_CURRENT), true, IndexWriter.MaxFieldLength.LIMITED);<br>writer.setUseCompoundFile(false);</p><p zoompage-fontsize="14">indexDocs(writer, docDir);//索引两篇文档，一篇包含"school"，另一篇包含"beer"<br>writer.commit();//提交两篇文档到索引文件，形成段(Segment) "_0"<br>writer.deleteDocuments(new Term("contents", "school"));//删除包含"school"的文档，其实是删除了两篇文档中的一篇。<br>writer.commit();//提交删除到索引文件，形成"_0_1.del"<br>writer.deleteDocuments(new Term("contents", "beer"));//删除包含"beer"的文档，其实是删除了两篇文档中的另一篇。<br>writer.commit();//提交删除到索引文件，形成"_0_2.del"<br>indexDocs(writer, docDir);//索引两篇文档，和上次的文档相同，但是Lucene无法区分，认为是另外两篇文档。<br>writer.commit();//提交两篇文档到索引文件，形成段"_1"<br>writer.deleteDocuments(new Term("contents", "beer"));//删除包含"beer"的文档，其中段"_0"已经无可删除，段"_1"被删除一篇。<br>writer.close();//提交删除到索引文件，形成"_1_1.del"</p><p zoompage-fontsize="14">形成的索引文件如下：</p><p zoompage-fontsize="14"><a href="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022112703.png" rel="noopener" zoompage-fontsize="14"><img title="image" height="431" alt="image" src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022112703.png" width="204"></a></p></td></tr></tbody></table>

<ul>
<li><ul>
<li><p>DocStoreOffset</p>
</li>
<li><p>DocStoreSegment</p>
</li>
<li><p>DocStoreIsCompoundFile</p>
<ul>
<li>对于域(Stored Field)和词向量(Term Vector)的存储可以有不同的方式，即可以每个段(Segment)单独存储自己的域和词向量信息，也可以多个段共享域和词向量，把它们存储到一个段中去。</li>
<li>如果DocStoreOffset为-1，则此段单独存储自己的域和词向量，从存储文件上来看，如果此段段名为XXX，则此段有自己的XXX.fdt，XXX.fdx，XXX.tvf，XXX.tvd，XXX.tvx文件。DocStoreSegment和DocStoreIsCompoundFile在此处不被保存。</li>
<li>如果DocStoreOffset不为-1，则DocStoreSegment保存了共享的段的名字，比如为YYY，DocStoreOffset则为此段的域及词向量信息在共享段中的偏移量。则此段没有自己的XXX.fdt，XXX.fdx，XXX.tvf，XXX.tvd，XXX.tvx文件，而是将信息存放在共享段的YYY.fdt，YYY.fdx，YYY.tvf，YYY.tvd，YYY.tvx文件中。</li>
<li>DocumentsWriter中有两个成员变量：String segment是当前索引信息存放的段，String docStoreSegment是域和词向量信息存储的段。两者可以相同也可以不同，决定了域和词向量信息是存储在本段中，还是和其他的段共享。</li>
<li>IndexWriter.flush(boolean triggerMerge, boolean flushDocStores, boolean flushDeletes)中第二个参数flushDocStores会影响到是否单独或是共享存储。其实最终影响的是DocumentsWriter.closeDocStore()。每当flushDocStores为false时，closeDocStore不被调用，说明下次添加到索引文件中的域和词向量信息是同此次共享一个段的。直到flushDocStores为true的时候，closeDocStore被调用，从而下次添加到索引文件中的域和词向量信息将被保存在一个新的段中，不同此次共享一个段(在这里需要指出的是Lucene的一个很奇怪的实现，虽然下次域和词向量信息是被保存到新的段中，然而段名却是这次被确定了的，在initSegmentName中当docStoreSegment == null时，被置为当前的segment，而非下一个新的segment，docStoreSegment = segment，于是会出现如下面的例子的现象)。</li>
<li>好在共享域和词向量存储并不是经常被使用到，实现也或有缺陷，暂且解释到此。</li>
</ul>
<p>IndexWriter writer = new IndexWriter(FSDirectory.open(INDEX_DIR), new StandardAnalyzer(Version.LUCENE_CURRENT), true, IndexWriter.MaxFieldLength.LIMITED);<br>writer.setUseCompoundFile(false);</p>
</li>
</ul>
</li>
</ul>
<pre><code>indexDocs(writer, docDir);  
writer.flush();</code></pre><p>//flush生成segment “_0”，并且flush函数中，flushDocStores设为false，也即下个段将同本段共享域和词向量信息，这时DocumentsWriter中的docStoreSegment= “_0”。</p>
<pre><code>indexDocs(writer, docDir);  
writer.commit();</code></pre><p>//commit生成segment “_1”，由于上次flushDocStores设为false，于是段”_1”的域以及词向量信息是保存在”_0”中的，在这个时刻，段”_1”并不生成自己的”_1.fdx”和”_1.fdt”。然而在commit函数中，flushDocStores设为true，也即下个段将单独使用新的段来存储域和词向量信息。然而这时，DocumentsWriter中的docStoreSegment= “_1”，也即当段”_2”存储其域和词向量信息的时候，是存在”_1.fdx”和”_1.fdt”中的，而段”_1”的域和词向量信息却是存在”_0.fdt”和”_0.fdx”中的，这一点非常令人困惑。 如图writer.commit的时候，_1.fdt和_1.fdx并没有形成。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022114233.png" alt></p>
<pre><code>indexDocs(writer, docDir);  
writer.flush();</code></pre><p>//段”_2”形成，由于上次flushDocStores设为true，其域和词向量信息是新创建一个段保存的，却是保存在_1.fdt和_1.fdx中的，这时候才产生了此二文件。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022115773.png" alt></p>
<pre><code>indexDocs(writer, docDir);  
writer.flush();</code></pre><p>//段”_3”形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_1.fdt和_1.fdx中的</p>
<pre><code>indexDocs(writer, docDir);  
writer.commit();</code></pre><p>//段”_4”形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_1.fdt和_1.fdx中的。然而函数commit中flushDocStores设为true，也意味着下一个段将新创建一个段保存域和词向量信息，此时DocumentsWriter中docStoreSegment= “_4”，也表明了虽然段”_4”的域和词向量信息保存在了段”_1”中，将来的域和词向量信息却要保存在段”_4”中。此时”_4.fdx”和”_4.fdt”尚未产生。   </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022115627.png" alt></p>
<pre><code>indexDocs(writer, docDir);  
writer.flush();</code></pre><p>//段”_5”形成，由于上次flushDocStores设为true，其域和词向量信息是新创建一个段保存的，却是保存在_4.fdt和_4.fdx中的，这时候才产生了此二文件。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022116165.png" alt></p>
<pre><code>indexDocs(writer, docDir);  
writer.commit();  
writer.close();</code></pre><p>//段”_6”形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_4.fdt和_4.fdx中的</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022116777.png" alt></p>
<ul>
<li><ul>
<li>HasSingleNormFile<ul>
<li>在搜索的过程中，标准化因子(Normalization Factor)会影响文档最后的评分。</li>
<li>不同的文档重要性不同，不同的域重要性也不同。因而每个文档的每个域都可以有自己的标准化因子。</li>
<li>如果HasSingleNormFile为1，则所有的标准化因子都是存在.nrm文件中的。</li>
<li>如果HasSingleNormFile不是1，则每个域都有自己的标准化因子文件.fN</li>
</ul>
</li>
<li>NumField<ul>
<li>域的数量</li>
</ul>
</li>
<li>NormGen<ul>
<li>如果每个域有自己的标准化因子文件，则此数组描述了每个标准化因子文件的版本号，也即.fN的N。</li>
</ul>
</li>
<li>IsCompoundFile<ul>
<li>是否保存为复合文件，也即把同一个段中的文件按照一定格式，保存在一个文件当中，这样可以减少每次打开文件的个数。</li>
<li>是否为复合文件，由接口IndexWriter.setUseCompoundFile(boolean)设定。 </li>
<li>非符合文件同符合文件的对比如下图：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>DeletionCount<ul>
<li>记录了此段中删除的文档的数目。</li>
</ul>
</li>
<li>HasProx<ul>
<li>如果至少有一个段omitTf为false，也即词频(term freqency)需要被保存，则HasProx为1，否则为0。</li>
</ul>
</li>
<li>Diagnostics<ul>
<li>调试信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>User map data</p>
<ul>
<li>保存了用户从字符串到字符串的映射Map</li>
</ul>
</li>
<li><p>CheckSum</p>
<ul>
<li>此文件segment_N的校验和。</li>
</ul>
</li>
</ul>
<p>读取此文件格式参考SegmentInfos.read(Directory directory, String segmentFileName):</p>
<ul>
<li><p>int format = input.readInt();</p>
</li>
<li><p>version = input.readLong(); // read version</p>
</li>
<li><p>counter = input.readInt(); // read counter</p>
</li>
<li><p>for (int i = input.readInt(); i &gt; 0; i–) // read segmentInfos</p>
<ul>
<li>add(new SegmentInfo(directory, format, input));<ul>
<li>name = input.readString();</li>
<li>docCount = input.readInt();</li>
<li>delGen = input.readLong();</li>
<li>docStoreOffset = input.readInt();</li>
<li>docStoreSegment = input.readString();</li>
<li>docStoreIsCompoundFile = (1 == input.readByte());</li>
<li>hasSingleNormFile = (1 == input.readByte());</li>
<li>int numNormGen = input.readInt();</li>
<li>normGen = new long[numNormGen];</li>
<li>for(int j=0;j</li>
<li>normGen[j] = input.readLong();</li>
</ul>
</li>
<li>isCompoundFile = input.readByte();</li>
<li>delCount = input.readInt();</li>
<li>hasProx = input.readByte() == 1;</li>
<li>diagnostics = input.readStringStringMap();</li>
</ul>
</li>
<li><p>userData = input.readStringStringMap();</p>
</li>
<li><p>final long checksumNow = input.getChecksum();</p>
</li>
<li><p>final long checksumThen = input.readLong();</p>
</li>
</ul>
<h4><span id="412-域field的元数据信息fnm"><strong>4.1.2. 域(Field)的元数据信息(.fnm)</strong></span></h4><p>一个段(Segment)包含多个域，每个域都有一些元数据信息，保存在.fnm文件中，.fnm文件的格式如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022117877.png" alt></p>
<ul>
<li>FNMVersion<ul>
<li>是fnm文件的版本号，对于Lucene 2.9为-2</li>
</ul>
</li>
<li>FieldsCount<ul>
<li>域的数目</li>
</ul>
</li>
<li>一个数组的域(Fields)<ul>
<li>FieldName：域名，如”title”，”modified”，”content”等。</li>
<li>FieldBits:一系列标志位，表明对此域的索引方式<ul>
<li>最低位：1表示此域被索引，0则不被索引。所谓被索引，也即放到倒排表中去。<ul>
<li>仅仅被索引的域才能够被搜到。</li>
<li>Field.Index.NO则表示不被索引。</li>
<li>Field.Index.ANALYZED则表示不但被索引，而且被分词，比如索引”hello world”后，无论是搜”hello”，还是搜”world”都能够被搜到。</li>
<li>Field.Index.NOT_ANALYZED表示虽然被索引，但是不分词，比如索引”hello world”后，仅当搜”hello world”时，能够搜到，搜”hello”和搜”world”都搜不到。</li>
<li>一个域出了能够被索引，还能够被存储，仅仅被存储的域是搜索不到的，但是能通过文档号查到，多用于不想被搜索到，但是在通过其它域能够搜索到的情况下，能够随着文档号返回给用户的域。</li>
<li>Field.Store.Yes则表示存储此域，Field.Store.NO则表示不存储此域。</li>
</ul>
</li>
<li>倒数第二位：1表示保存词向量，0为不保存词向量。<ul>
<li>Field.TermVector.YES表示保存词向量。</li>
<li>Field.TermVector.NO表示不保存词向量。</li>
</ul>
</li>
<li>倒数第三位：1表示在词向量中保存位置信息。<ul>
<li>Field.TermVector.WITH_POSITIONS</li>
</ul>
</li>
<li>倒数第四位：1表示在词向量中保存偏移量信息。<ul>
<li>Field.TermVector.WITH_OFFSETS</li>
</ul>
</li>
<li>倒数第五位：1表示不保存标准化因子<ul>
<li>Field.Index.ANALYZED_NO_NORMS</li>
<li>Field.Index.NOT_ANALYZED_NO_NORMS</li>
</ul>
</li>
<li>倒数第六位：是否保存payload</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>要了解域的元数据信息，还要了解以下几点：</p>
<ul>
<li>位置(Position)和偏移量(Offset)的区别<ul>
<li>位置是基于词Term的，偏移量是基于字母或汉字的。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022117067.png" alt></p>
<ul>
<li>索引域(Indexed)和存储域(Stored)的区别<ul>
<li>一个域为什么会被存储(store)而不被索引(Index)呢？在一个文档中的所有信息中，有这样一部分信息，可能不想被索引从而可以搜索到，但是当这个文档由于其他的信息被搜索到时，可以同其他信息一同返回。</li>
<li>举个例子，读研究生时，您好不容易写了一篇论文交给您的导师，您的导师却要他所第一作者而您做第二作者，然而您导师不想别人在论文系统中搜索您的名字时找到这篇论文，于是在论文系统中，把第二作者这个Field的Indexed设为false，这样别人搜索您的名字，永远不知道您写过这篇论文，只有在别人搜索您导师的名字从而找到您的文章时，在一个角落表述着第二作者是您。</li>
</ul>
</li>
<li>payload的使用<ul>
<li>我们知道，索引是以倒排表形式存储的，对于每一个词，都保存了包含这个词的一个链表，当然为了加快查询速度，此链表多用跳跃表进行存储。</li>
<li>Payload信息就是存储在倒排表中的，同文档号一起存放，多用于存储与每篇文档相关的一些信息。当然这部分信息也可以存储域里(stored Field)，两者从功能上基本是一样的，然而当要存储的信息很多的时候，存放在倒排表里，利用跳跃表，有利于大大提高搜索速度。</li>
<li>Payload的存储方式如下图：</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022122309.png" alt></p>
<ul>
<li><ul>
<li>Payload主要有以下几种用法：<ul>
<li>存储每个文档都有的信息：比如有的时候，我们想给每个文档赋一个我们自己的文档号，而不是用Lucene自己的文档号。于是我们可以声明一个特殊的域(Field)”_ID”和特殊的词(Term)”_ID”，使得每篇文档都包含词”_ID”，于是在词”_ID”的倒排表里面对于每篇文档又有一项，每一项都有一个payload，于是我们可以在payload里面保存我们自己的文档号。每当我们得到一个Lucene的文档号的时候，就能从跳跃表中查找到我们自己的文档号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>//声明一个特殊的域和特殊的词</p>
<p>public static final String ID_PAYLOAD_FIELD = “_ID”;</p>
<p>public static final String ID_PAYLOAD_TERM = “_ID”;</p>
<p>public static final Term ID_TERM = new Term(ID_PAYLOAD_TERM, ID_PAYLOAD_FIELD);</p>
<p>//声明一个特殊的TokenStream，它只生成一个词(Term)，就是那个特殊的词，在特殊的域里面。</p>
<p>static class SinglePayloadTokenStream extends TokenStream {<br>    private Token token;<br>    private boolean returnToken = false;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SinglePayloadTokenStream(String idPayloadTerm) &#123;  </span><br><span class="line">    <span class="type">char</span>[] term = idPayloadTerm.toCharArray();  </span><br><span class="line">    token = <span class="keyword">new</span> <span class="title class_">Token</span>(term, <span class="number">0</span>, term.length, <span class="number">0</span>, term.length);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setPayloadValue</span><span class="params">(<span class="type">byte</span>[] value)</span> &#123;  </span><br><span class="line">    token.setPayload(<span class="keyword">new</span> <span class="title class_">Payload</span>(value));  </span><br><span class="line">    returnToken = <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="keyword">if</span> (returnToken) &#123;  </span><br><span class="line">        returnToken = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> token;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>}</p>
<p>//对于每一篇文档，都让它包含这个特殊的词，在特殊的域里面</p>
<p>SinglePayloadTokenStream singlePayloadTokenStream = new SinglePayloadTokenStream(ID_PAYLOAD_TERM);<br>singlePayloadTokenStream.setPayloadValue(long2bytes(id));<br>doc.add(new Field(ID_PAYLOAD_FIELD, singlePayloadTokenStream));</p>
<p>//每当得到一个Lucene的文档号时，通过以下的方式得到payload里面的文档号</p>
<p>long id = 0;<br>TermPositions tp = reader.termPositions(ID_PAYLOAD_TERM);<br>boolean ret = tp.skipTo(docID);<br>tp.nextPosition();<br>int payloadlength = tp.getPayloadLength();<br>byte[] payloadBuffer = new byte[payloadlength];<br>tp.getPayload(payloadBuffer, 0);<br>id = bytes2long(payloadBuffer);<br>tp.close();</p>
<ul>
<li><ul>
<li><ul>
<li>影响词的评分<ul>
<li>在Similarity抽象类中有函数public float scorePayload(byte [] payload, int offset, int length)  可以根据payload的值影响评分。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>读取域元数据信息的代码如下：</li>
</ul>
<p>FieldInfos.read(IndexInput, String)</p>
<ul>
<li>int firstInt = input.readVInt();</li>
<li>size = input.readVInt();</li>
<li>for (int i = 0; i &lt; size; i++)<ul>
<li>String name = input.readString();</li>
<li>byte bits = input.readByte();</li>
<li>boolean isIndexed = (bits &amp; IS_INDEXED) != 0;</li>
<li>boolean storeTermVector = (bits &amp; STORE_TERMVECTOR) != 0;</li>
<li>boolean storePositionsWithTermVector = (bits &amp; STORE_POSITIONS_WITH_TERMVECTOR) != 0;</li>
<li>boolean storeOffsetWithTermVector = (bits &amp; STORE_OFFSET_WITH_TERMVECTOR) != 0;</li>
<li>boolean omitNorms = (bits &amp; OMIT_NORMS) != 0;</li>
<li>boolean storePayloads = (bits &amp; STORE_PAYLOADS) != 0;</li>
<li>boolean omitTermFreqAndPositions = (bits &amp; OMIT_TERM_FREQ_AND_POSITIONS) != 0;</li>
</ul>
</li>
</ul>
<h4><span id="413-域field的数据信息fdtfdx"><strong>4.1.3. 域(Field)的数据信息(.fdt，.fdx)</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022125684.png" alt></p>
<ul>
<li>域数据文件(fdt):<ul>
<li>真正保存存储域(stored field)信息的是fdt文件</li>
<li>在一个段(segment)中总共有segment size篇文档，所以fdt文件中共有segment size个项，每一项保存一篇文档的域的信息</li>
<li>对于每一篇文档，一开始是一个fieldcount，也即此文档包含的域的数目，接下来是fieldcount个项，每一项保存一个域的信息。</li>
<li>对于每一个域，fieldnum是域号，接着是一个8位的byte，最低一位表示此域是否分词(tokenized)，倒数第二位表示此域是保存字符串数据还是二进制数据，倒数第三位表示此域是否被压缩，再接下来就是存储域的值，比如new Field(“title”, “lucene in action”, Field.Store.Yes, …)，则此处存放的就是”lucene in action”这个字符串。</li>
</ul>
</li>
<li>域索引文件(fdx)<ul>
<li>由域数据文件格式我们知道，每篇文档包含的域的个数，每个存储域的值都是不一样的，因而域数据文件中segment size篇文档，每篇文档占用的大小也是不一样的，那么如何在fdt中辨别每一篇文档的起始地址和终止地址呢，如何能够更快的找到第n篇文档的存储域的信息呢？就是要借助域索引文件。</li>
<li>域索引文件也总共有segment size个项，每篇文档都有一个项，每一项都是一个long，大小固定，每一项都是对应的文档在fdt文件中的起始地址的偏移量，这样如果我们想找到第n篇文档的存储域的信息，只要在fdx中找到第n项，然后按照取出的long作为偏移量，就可以在fdt文件中找到对应的存储域的信息。</li>
</ul>
</li>
<li>读取域数据信息的代码如下：</li>
</ul>
<p>Document FieldsReader.doc(int n, FieldSelector fieldSelector)</p>
<ul>
<li>long position = indexStream.readLong();//indexStream points to “.fdx”</li>
<li>fieldsStream.seek(position);//fieldsStream points to “fdt”</li>
<li>int numFields = fieldsStream.readVInt();</li>
<li>for (int i = 0; i &lt; numFields; i++)<ul>
<li>int fieldNumber = fieldsStream.readVInt();</li>
<li>byte bits = fieldsStream.readByte();</li>
<li>boolean compressed = (bits &amp; FieldsWriter.FIELD_IS_COMPRESSED) != 0;</li>
<li>boolean tokenize = (bits &amp; FieldsWriter.FIELD_IS_TOKENIZED) != 0;</li>
<li>boolean binary = (bits &amp; FieldsWriter.FIELD_IS_BINARY) != 0;</li>
<li>if (binary)<ul>
<li>int toRead = fieldsStream.readVInt();</li>
<li>final byte[] b = new byte[toRead];</li>
<li>fieldsStream.readBytes(b, 0, b.length);</li>
<li>if (compressed)<ul>
<li>int toRead = fieldsStream.readVInt();</li>
<li>final byte[] b = new byte[toRead];</li>
<li>fieldsStream.readBytes(b, 0, b.length);</li>
<li>uncompress(b),</li>
</ul>
</li>
</ul>
</li>
<li>else<ul>
<li>fieldsStream.readString()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span id="413-词向量term-vector的数据信息tvxtvdtvf"><strong>4.1.3. 词向量(Term Vector)的数据信息(.tvx，.tvd，.tvf)</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022135786.png" alt></p>
<p>词向量信息是从索引(index)到文档(document)到域(field)到词(term)的正向信息，有了词向量信息，我们就可以得到一篇文档包含那些词的信息。</p>
<ul>
<li>词向量索引文件(tvx)<ul>
<li>一个段(segment)包含N篇文档，此文件就有N项，每一项代表一篇文档。</li>
<li>每一项包含两部分信息：第一部分是词向量文档文件(tvd)中此文档的偏移量，第二部分是词向量域文件(tvf)中此文档的第一个域的偏移量。</li>
</ul>
</li>
<li>词向量文档文件(tvd)<ul>
<li>一个段(segment)包含N篇文档，此文件就有N项，每一项包含了此文档的所有的域的信息。</li>
<li>每一项首先是此文档包含的域的个数NumFields，然后是一个NumFields大小的数组，数组的每一项是域号。然后是一个(NumFields - 1)大小的数组，由前面我们知道，每篇文档的第一个域在tvf中的偏移量在tvx文件中保存，而其他(NumFields - 1)个域在tvf中的偏移量就是第一个域的偏移量加上这(NumFields - 1)个数组的每一项的值。</li>
</ul>
</li>
<li>词向量域文件(tvf)<ul>
<li>此文件包含了此段中的所有的域，并不对文档做区分，到底第几个域到第几个域是属于那篇文档，是由tvx中的第一个域的偏移量以及tvd中的(NumFields - 1)个域的偏移量来决定的。</li>
<li>对于每一个域，首先是此域包含的词的个数NumTerms，然后是一个8位的byte，最后一位是指定是否保存位置信息，倒数第二位是指定是否保存偏移量信息。然后是NumTerms个项的数组，每一项代表一个词(Term)，对于每一个词，由词的文本TermText，词频TermFreq(也即此词在此文档中出现的次数)，词的位置信息，词的偏移量信息。</li>
</ul>
</li>
<li>读取词向量数据信息的代码如下：</li>
</ul>
<p>TermVectorsReader.get(int docNum, String field, TermVectorMapper)</p>
<ul>
<li>int fieldNumber = fieldInfos.fieldNumber(field);//通过field名字得到field号</li>
<li>seekTvx(docNum);//在tvx文件中按docNum文档号找到相应文档的项</li>
<li>long tvdPosition = tvx.readLong();//找到tvd文件中相应文档的偏移量</li>
<li>tvd.seek(tvdPosition);//在tvd文件中按偏移量找到相应文档的项</li>
<li>int fieldCount = tvd.readVInt();//此文档包含的域的个数。</li>
<li>for (int i = 0; i &lt; fieldCount; i++) //按域号查找域<ul>
<li>number = tvd.readVInt();</li>
<li>if (number == fieldNumber)<ul>
<li>found = i;</li>
</ul>
</li>
</ul>
</li>
<li>position = tvx.readLong();//在tvx中读出此文档的第一个域在tvf中的偏移量</li>
<li>for (int i = 1; i &lt;= found; i++)<ul>
<li>position += tvd.readVLong();//加上所要找的域在tvf中的偏移量</li>
</ul>
</li>
<li>tvf.seek(position);</li>
<li>int numTerms = tvf.readVInt();</li>
<li>byte bits = tvf.readByte();</li>
<li>storePositions = (bits &amp; STORE_POSITIONS_WITH_TERMVECTOR) != 0;</li>
<li>storeOffsets = (bits &amp; STORE_OFFSET_WITH_TERMVECTOR) != 0;</li>
<li>for (int i = 0; i &lt; numTerms; i++)<ul>
<li>start = tvf.readVInt();</li>
<li>deltaLength = tvf.readVInt();</li>
<li>totalLength = start + deltaLength;</li>
<li>tvf.readBytes(byteBuffer, start, deltaLength);</li>
<li>term = new String(byteBuffer, 0, totalLength, “UTF-8”);</li>
<li>if (storePositions)<ul>
<li>positions = new int[freq];</li>
<li>int prevPosition = 0;</li>
<li>for (int j = 0; j &lt; freq; j++)<ul>
<li>positions[j] = prevPosition + tvf.readVInt();</li>
<li>prevPosition = positions[j];</li>
</ul>
</li>
</ul>
</li>
<li>if (storeOffsets)<ul>
<li>offsets = new TermVectorOffsetInfo[freq];</li>
<li>int prevOffset = 0;</li>
<li>for (int j = 0; j &lt; freq; j++)</li>
<li>int startOffset = prevOffset + tvf.readVInt();</li>
<li>int endOffset = startOffset + tvf.readVInt();</li>
<li>offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);</li>
<li>prevOffset = endOffset;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="42-反向信息"><strong>4.2. 反向信息</strong></span></h3><p>反向信息是索引文件的核心，也即反向索引。</p>
<p>反向索引包括两部分，左面是词典(Term Dictionary)，右面是倒排表(Posting List)。</p>
<p>在Lucene中，这两部分是分文件存储的，词典是存储在tii，tis中的，倒排表又包括两部分，一部分是文档号及词频，保存在frq中，一部分是词的位置信息，保存在prx中。</p>
<ul>
<li>Term Dictionary (tii, tis)<ul>
<li>–&gt; Frequencies (.frq)</li>
<li>–&gt; Positions (.prx)</li>
</ul>
</li>
</ul>
<h4><span id="421-词典tis及词典索引tii信息"><strong>4.2.1. 词典(tis)及词典索引(tii)信息</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022136378.png" alt></p>
<p>在词典中，所有的词是按照字典顺序排序的。</p>
<ul>
<li>词典文件(tis)<ul>
<li>TermCount：词典中包含的总的词数</li>
<li>IndexInterval：为了加快对词的查找速度，也应用类似跳跃表的结构，假设IndexInterval为4，则在词典索引(tii)文件中保存第4个，第8个，第12个词，这样可以加快在词典文件中查找词的速度。</li>
<li>SkipInterval：倒排表无论是文档号及词频，还是位置信息，都是以跳跃表的结构存在的，SkipInterval是跳跃的步数。</li>
<li>MaxSkipLevels：跳跃表是多层的，这个值指的是跳跃表的最大层数。</li>
<li>TermCount个项的数组，每一项代表一个词，对于每一个词，以前缀后缀规则存放词的文本信息(PrefixLength + Suffix)，词属于的域的域号(FieldNum)，有多少篇文档包含此词(DocFreq)，此词的倒排表在frq，prx中的偏移量(FreqDelta, ProxDelta)，此词的倒排表的跳跃表在frq中的偏移量(SkipDelta)，这里之所以用Delta，是应用差值规则。</li>
</ul>
</li>
<li>词典索引文件(tii)<ul>
<li>词典索引文件是为了加快对词典文件中词的查找速度，保存每隔IndexInterval个词。</li>
<li>词典索引文件是会被全部加载到内存中去的。</li>
<li>IndexTermCount = TermCount / IndexInterval：词典索引文件中包含的词数。</li>
<li>IndexInterval同词典文件中的IndexInterval。</li>
<li>SkipInterval同词典文件中的SkipInterval。</li>
<li>MaxSkipLevels同词典文件中的MaxSkipLevels。</li>
<li>IndexTermCount个项的数组，每一项代表一个词，每一项包括两部分，第一部分是词本身(TermInfo)，第二部分是在词典文件中的偏移量(IndexDelta)。假设IndexInterval为4，此数组中保存第4个，第8个，第12个词。。。</li>
</ul>
</li>
<li>读取词典及词典索引文件的代码如下：</li>
</ul>
<p>origEnum = new SegmentTermEnum(directory.openInput(segment + “.” + IndexFileNames.TERMS_EXTENSION,readBufferSize), fieldInfos, false);//用于读取tis文件</p>
<ul>
<li>int firstInt = input.readInt();</li>
<li>size = input.readLong();</li>
<li>indexInterval = input.readInt();</li>
<li>skipInterval = input.readInt();</li>
<li>maxSkipLevels = input.readInt();</li>
</ul>
<p>SegmentTermEnum indexEnum = new SegmentTermEnum(directory.openInput(segment + “.” + IndexFileNames.TERMS_INDEX_EXTENSION, readBufferSize), fieldInfos, true);//用于读取tii文件</p>
<ul>
<li>indexTerms = new Term[indexSize];</li>
<li>indexInfos = new TermInfo[indexSize];</li>
<li>indexPointers = new long[indexSize];</li>
<li>for (int i = 0; indexEnum.next(); i++)<ul>
<li>indexTerms[i] = indexEnum.term();</li>
<li>indexInfos[i] = indexEnum.termInfo();</li>
<li>indexPointers[i] = indexEnum.indexPointer;</li>
</ul>
</li>
</ul>
<h4><span id="422-文档号及词频frq信息"><strong>4.2.2. 文档号及词频(frq)信息</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022137895.png" alt></p>
<p>文档号及词频文件里面保存的是倒排表，是以跳跃表形式存在的。</p>
<ul>
<li>此文件包含TermCount个项，每一个词都有一项，因为每一个词都有自己的倒排表。</li>
<li>对于每一个词的倒排表都包括两部分，一部分是倒排表本身，也即一个数组的文档号及词频，另一部分是跳跃表，为了更快的访问和定位倒排表中文档号及词频的位置。</li>
<li>对于文档号和词频的存储应用的是差值规则和或然跟随规则，Lucene的文档本身有以下几句话，比较难以理解，在此解释一下：</li>
</ul>
<p>For example, the TermFreqs for a term which occurs once in document seven and three times in document eleven, with omitTf false, would be the following sequence of VInts:</p>
<p>15, 8, 3</p>
<p>If omitTf were true it would be this sequence of VInts instead:</p>
<p>7,4</p>
<p>首先我们看omitTf=false的情况，也即我们在索引中会存储一个文档中term出现的次数。</p>
<p>例子中说了，表示在文档7中出现1次，并且又在文档11中出现3次的文档用以下序列表示：15，8，3.</p>
<p>那这三个数字是怎么计算出来的呢？</p>
<p>首先，根据定义TermFreq –&gt; DocDelta[, Freq?]，一个TermFreq结构是由一个DocDelta后面或许跟着Freq组成，也即上面我们说的A+B？结构。</p>
<p>DocDelta自然是想存储包含此Term的文档的ID号了，Freq是在此文档中出现的次数。</p>
<p>所以根据例子，应该存储的完整信息为[DocID = 7, Freq = 1] [DocID = 11,  Freq = 3](见全文检索的基本原理章节)。</p>
<p>然而为了节省空间，Lucene对编号此类的数据都是用差值来表示的，也即上面说的规则2，Delta规则，于是文档ID就不能按完整信息存了，就应该存放如下：</p>
<p>[DocIDDelta = 7, Freq = 1][DocIDDelta = 4 (11-7), Freq = 3]</p>
<p>然而Lucene对于A+B?这种或然跟随的结果，有其特殊的存储方式，见规则3，即A+B?规则，如果DocDelta后面跟随的Freq为1，则用DocDelta最后一位置1表示。</p>
<p>如果DocDelta后面跟随的Freq大于1，则DocDelta得最后一位置0，然后后面跟随真正的值，从而对于第一个Term，由于Freq为1，于是放在DocDelta的最后一位表示，DocIDDelta = 7的二进制是000 0111，必须要左移一位，且最后一位置一，000 1111 = 15，对于第二个Term，由于Freq大于一，于是放在DocDelta的最后一位置零，DocIDDelta = 4的二进制是0000 0100，必须要左移一位，且最后一位置零，0000 1000 = 8，然后后面跟随真正的Freq = 3。</p>
<p>于是得到序列：[DocDleta = 15][DocDelta = 8, Freq = 3]，也即序列，15，8，3。</p>
<p>如果omitTf=true，也即我们不在索引中存储一个文档中Term出现的次数，则只存DocID就可以了，因而不存在A+B?规则的应用。</p>
<p>[DocID = 7][DocID = 11]，然后应用规则2，Delta规则，于是得到序列[DocDelta = 7][DocDelta = 4 (11 - 7)]，也即序列，7，4.</p>
<ul>
<li>对于跳跃表的存储有以下几点需要解释一下：<ul>
<li>跳跃表可根据倒排表本身的长度(DocFreq)和跳跃的幅度(SkipInterval)而分不同的层次，层次数为NumSkipLevels = Min(MaxSkipLevels, floor(log(DocFreq/log(SkipInterval)))).</li>
<li>第Level层的节点数为DocFreq/(SkipInterval^(Level + 1))，level从零计数。</li>
<li>除了最低层之外，其他层都有SkipLevelLength来表示此层的二进制长度(而非节点的个数)，方便读取某一层的跳跃表到缓存里面。</li>
<li>高层在前，低层在后，当读完所有的高层后，剩下的就是最低一层，因而最后一层不需要SkipLevelLength。这也是为什么Lucene文档中的格式描述为 <sup zoompage-fontsize="12">NumSkipLevels-1</sup>, SkipLevel，也即低NumSKipLevels-1层有SkipLevelLength，最后一层只有SkipLevel，没有SkipLevelLength。</li>
<li>除最低层以外，其他层都有SkipChildLevelPointer来指向下一层相应的节点。</li>
<li>每一个跳跃节点包含以下信息：文档号，payload的长度，文档号对应的倒排表中的节点在frq中的偏移量，文档号对应的倒排表中的节点在prx中的偏移量。</li>
<li>虽然Lucene的文档中有以下的描述，然而实验的结果却不是完全准确的：</li>
</ul>
</li>
</ul>
<p>Example: SkipInterval = 4, MaxSkipLevels = 2, DocFreq = 35. Then skip level 0 has 8 SkipData entries, containing the 3<sup zoompage-fontsize="12">rd</sup>, 7<sup zoompage-fontsize="12">th</sup>, 11<sup zoompage-fontsize="12">th</sup>, 15<sup zoompage-fontsize="12">th</sup>, 19<sup zoompage-fontsize="12">th</sup>, 23<sup zoompage-fontsize="12">rd</sup>, 27<sup zoompage-fontsize="12">th</sup>, and 31<sup zoompage-fontsize="12">st</sup> document numbers in TermFreqs. Skip level 1 has 2 SkipData entries, containing the 15<sup zoompage-fontsize="12">th</sup> and 31<sup zoompage-fontsize="12">st</sup> document numbers in TermFreqs.</p>
<p>按照描述，当SkipInterval为4，且有35篇文档的时候，Skip level = 0应该包括第3，第7，第11，第15，第19，第23，第27，第31篇文档，Skip level = 1应该包括第15，第31篇文档。</p>
<p>然而真正的实现中，跳跃表节点的时候，却向前偏移了，偏移的原因在于下面的代码：</p>
<ul>
<li>FormatPostingsDocsWriter.addDoc(int docID, int termDocFreq)<ul>
<li>final int delta = docID - lastDocID;</li>
<li>if ((++df % skipInterval) == 0)<ul>
<li>skipListWriter.setSkipData(lastDocID, storePayloads, posWriter.lastPayloadLength);</li>
<li>skipListWriter.bufferSkip(df);</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从代码中，我们可以看出，当SkipInterval为4的时候，当docID = 0时，++df为1，1%4不为0，不是跳跃节点，当docID = 3时，++df=4，4%4为0，为跳跃节点，然而skipData里面保存的却是lastDocID为2。</p>
<p>所以真正的倒排表和跳跃表中保存一下的信息：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022137901.png" alt></p>
<h4><span id="423-词位置prx信息"><strong>4.2.3. 词位置(prx)信息</strong></span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022138998.png" alt></p>
<p>词位置信息也是倒排表，也是以跳跃表形式存在的。</p>
<ul>
<li>此文件包含TermCount个项，每一个词都有一项，因为每一个词都有自己的词位置倒排表。</li>
<li>对于每一个词的都有一个DocFreq大小的数组，每项代表一篇文档，记录此文档中此词出现的位置。这个文档数组也是和frq文件中的跳跃表有关系的，从上面我们知道，在frq的跳跃表节点中有ProxSkip，当SkipInterval为3的时候，frq的跳跃表节点指向prx文件中的此数组中的第1，第4，第7，第10，第13，第16篇文档。</li>
<li>对于每一篇文档，可能包含一个词多次，因而有一个Freq大小的数组，每一项代表此词在此文档中出现一次，则有一个位置信息。</li>
<li>每一个位置信息包含：PositionDelta(采用差值规则)，还可以保存payload，应用或然跟随规则。</li>
</ul>
<h3><span id="43-其他信息"><strong>4.3. 其他信息</strong></span></h3><h4><span id="431-标准化因子文件nrm"><strong>4.3.1. 标准化因子文件(nrm)</strong></span></h4><p>为什么会有标准化因子呢？从第一章中的描述，我们知道，在搜索过程中，搜索出的文档要按与查询语句的相关性排序，相关性大的打分(score)高，从而排在前面。相关性打分(score)使用向量空间模型(Vector Space Model)，在计算相关性之前，要计算Term Weight，也即某Term相对于某Document的重要性。在计算Term Weight时，主要有两个影响因素，一个是此Term在此文档中出现的次数，一个是此Term的普通程度。显然此Term在此文档中出现的次数越多，此Term在此文档中越重要。</p>
<p>这种Term Weight的计算方法是最普通的，然而存在以下几个问题：</p>
<ul>
<li>不同的文档重要性不同。有的文档重要些，有的文档相对不重要，比如对于做软件的，在索引书籍的时候，我想让计算机方面的书更容易搜到，而文学方面的书籍搜索时排名靠后。</li>
<li>不同的域重要性不同。有的域重要一些，如关键字，如标题，有的域不重要一些，如附件等。同样一个词(Term)，出现在关键字中应该比出现在附件中打分要高。</li>
<li>根据词(Term)在文档中出现的绝对次数来决定此词对文档的重要性，有不合理的地方。比如长的文档词在文档中出现的次数相对较多，这样短的文档比较吃亏。比如一个词在一本砖头书中出现了10次，在另外一篇不足100字的文章中出现了9次，就说明砖头书应该排在前面码？不应该，显然此词在不足100字的文章中能出现9次，可见其对此文章的重要性。</li>
</ul>
<p>由于以上原因，Lucene在计算Term Weight时，都会乘上一个标准化因子(Normalization Factor)，来减少上面三个问题的影响。</p>
<p>标准化因子(Normalization Factor)是会影响随后打分(score)的计算的，Lucene的打分计算一部分发生在索引过程中，一般是与查询语句无关的参数如标准化因子，大部分发生在搜索过程中，会在搜索过程的代码分析中详述。</p>
<p>标准化因子(Normalization Factor)在索引过程总的计算如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139227.png" alt></p>
<p>它包括三个参数：</p>
<ul>
<li>Document boost：此值越大，说明此文档越重要。</li>
<li>Field boost：此域越大，说明此域越重要。</li>
<li>lengthNorm(field) = (1.0 / Math.sqrt(numTerms))：一个域中包含的Term总数越多，也即文档越长，此值越小，文档越短，此值越大。</li>
</ul>
<p>从上面的公式，我们知道，一个词(Term)出现在不同的文档或不同的域中，标准化因子不同。比如有两个文档，每个文档有两个域，如果不考虑文档长度，就有四种排列组合，在重要文档的重要域中，在重要文档的非重要域中，在非重要文档的重要域中，在非重要文档的非重要域中，四种组合，每种有不同的标准化因子。</p>
<p>于是在Lucene中，标准化因子共保存了(文档数目乘以域数目)个，格式如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139297.png" alt></p>
<ul>
<li>标准化因子文件(Normalization Factor File: nrm)：<ul>
<li>NormsHeader：字符串“NRM”外加Version，依Lucene的版本的不同而不同。</li>
<li>接着是一个数组，大小为NumFields，每个Field一项，每一项为一个Norms。</li>
<li>Norms也是一个数组，大小为SegSize，即此段中文档的数量，每一项为一个Byte，表示一个浮点数，其中0<del>2为尾数，3</del>8为指数。</li>
</ul>
</li>
</ul>
<h4><span id="432-删除文档文件del"><strong>4.3.2. 删除文档文件(del)</strong></span></h4><p> <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139282.png" alt></p>
<ul>
<li>被删除文档文件(Deleted Document File: .del)<ul>
<li>Format：在此文件中，Bits和DGaps只能保存其中之一，-1表示保存DGaps，非负值表示保存Bits。</li>
<li>ByteCount：此段中有多少文档，就有多少个bit被保存，但是以byte形式计数，也即Bits的大小应该是byte的倍数。</li>
<li>BitCount：Bits中有多少位被至1，表示此文档已经被删除。</li>
<li>Bits：一个数组的byte，大小为ByteCount，应用时被认为是byte*8个bit。</li>
<li>DGaps：如果删除的文档数量很小，则Bits大部分位为0，很浪费空间。DGaps采用以下的方式来保存稀疏数组：比如第十，十二，三十二个文档被删除，于是第十，十二，三十二位设为1，DGaps也是以byte为单位的，仅保存不为0的byte，如第1个byte，第4个byte，第1个byte十进制为20，第4个byte十进制为1。于是保存成DGaps，第1个byte，位置1用不定长正整数保存，值为20用二进制保存，第2个byte，位置4用不定长正整数保存，用差值为3，值为1用二进制保存，二进制数据不用差值表示。</li>
</ul>
</li>
</ul>
<h2><span id="五-总体结构"><strong>五、总体结构</strong></span></h2><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139069.png" alt></p>
<ul>
<li>图示为Lucene索引文件的整体结构：<ul>
<li>属于整个索引(Index)的segment.gen，segment_N，其保存的是段(segment)的元数据信息，然后分多个segment保存数据信息，同一个segment有相同的前缀文件名。</li>
<li>对于每一个段，包含域信息，词信息，以及其他信息(标准化因子，删除文档)</li>
<li>域信息也包括域的元数据信息，在fnm中，域的数据信息，在fdx，fdt中。</li>
<li>词信息是反向信息，包括词典(tis, tii)，文档号及词频倒排表(frq)，词位置倒排表(prx)。</li>
</ul>
</li>
</ul>
<p>大家可以通过看源代码，相应的Reader和Writer来了解文件结构，将更为透彻。</p>
<p>参考资料</p>
<ul>
<li><a href="https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html">https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html</a></li>
<li><a href="https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html">https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql启动时 &amp;quot;No space left on device&amp;quot;</title>
    <url>/77f38978/</url>
    <content><![CDATA[<p>先用<code>free</code> 命令查看剩余空间</p>
<pre><code>[root@tokyo mysqld]# free
              total        used        free      shared  buff/cache   available
Mem:        1016108      632132      205776       66344      178200      180496
Swap:             0           0           0</code></pre><p>发现swap 为零了</p>
<p>执行</p>
<pre><code>dd if=/dev/zero of=/swapfile bs=1M count=1024
mkswap /swapfile
wapon /swapfile
swapon /swapfile</code></pre><p>再用<code>free</code>查看</p>
<pre><code>[root@tokyo ~]# free
              total        used        free      shared  buff/cache   available
Mem:        1016108      732148       63984       51400      219976       71132
Swap:       1048572      209240      839332</code></pre><p>启动mysql, 解决</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</title>
    <url>/784beb8f/</url>
    <content><![CDATA[<p>【报错原因】：没有utf-8这个语系（没添加语言_国名前缀），LC_ALL又没设定值。 <strong>服务端解决方法：</strong> 在远程系统上， <code>/etc/environment</code>加入以下两行，重新登陆即可。</p>
<pre><code>LANG=en_US.utf-8
LC_ALL=en_US.utf-8</code></pre><p><strong>Mac终端解决方法：</strong> 编辑<code>~/.bashrc</code>或者<code>~/.zshrc</code>文件，添加</p>
<pre><code>export LC_ALL=en_US.UTF-8  
export LANG=en_US.UTF-8</code></pre>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 寻找index 原理</title>
    <url>/ab14d5fa/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p><strong>1. nginx 是怎么找index.php 文件的</strong><br>当nginx发现需要<code>/web/echo/index.php</code> 文件时, 就会向内核发起 IO 系统调用(因为要跟硬件打交道, 这里的硬件是指硬盘, 通常需要靠内核来操作, 而内核提供的这些功能是通过系统调用来实现的), 告诉内核, 我需要这个文件, 内核从<code>/</code> 开始找到<code>web</code> 目录, 再在<code>web</code> 目录下找到<code>echo</code> 目录, 最后在<code>echo</code> 目录下找到<code>index.php</code> 文件, 于是把这个<code>index.php</code> 从硬盘上读取到内核自身的内存空间, 然后再把这个文件复制到nginx进程所在的内存空间, 于是 nginx就得到了自己想要的文件了 </p>
<p><strong>2. 寻找文件在文件系统层面是怎么操作的</strong><br>如, nginx 需要得到<code>/web/echo/index.php</code> 这个文件 每个分区(像ext3 等文件系统, block块是文件存储的最小单元, 默认是4096字节) 都是包含元数据区和数据区, 每个文件在元数据区都有元数据条目(一般是128字节大小), 每个条目都有一个编号, 称之为 inode(index node), 这个inode 里包含 文件类型, 权限, 连接次数, 属主和数组的 ID&amp;时间戳, 这个文件占据了哪些磁盘块也就是块的编号(block, 每个文件可以占用多个 block, 且 block 不一定是连续的, 每个 block 都有编号), 如下图: </p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207010354.png" alt> </p>
<p>目录其实也是普通文件, 也需要占用磁盘块, 目录不是一个容器. 默认创建的目录大小为4096字节, 即只需要占用一个磁盘块, 但这是不确定的. 所以要找到目录也是需要到元数据区里找到对应的条目, 只要找到对应的inode就可以找到目录所占用的磁盘块. 目录里存着一张表(映射表), 里面放着 目录或文件的名称和对应的inode号, 如下:</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>文件名称(只是字符串)</td>
<td>inode 号</td>
</tr>
<tr>
<td>test.txt</td>
<td>100</td>
</tr>
</tbody></table>
<p>假如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/           在数据区占据1, 2号 block, `/` 其实也是一个目录, 里面有两个目录, web 和 111</span><br><span class="line">web         占据5号 block, 是目录, 里面有2个目录 <span class="built_in">echo</span> 和 data</span><br><span class="line"><span class="built_in">echo</span>        占据11号 block, 是目录, 里面有一个文件 index.php</span><br><span class="line">index.php   占据15, 16号 block, 是文件</span><br></pre></td></tr></table></figure>

<p>其在文件系统中分布如下图: </p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207010430.png" alt></p>
<p> 那么内核究竟是怎么找到<code>index.php</code> 这个文件的呢? 内核拿到 nginx 的 IO 系统调用要获取<code>/web/echo/index.php</code> 这个文件请求之后,</p>
<pre><code>1. 内核读取元数据区 / 的inode, 从 inode 里读取 / 所对应的数据块的编号, 然后在数据区找到其对应的块(1, 2号块), 读取1号块上的映射表找到 web 这个名称在元数据区对应的 inode 号
2. 内核读取 web 对应的 inode(3号), 从中得到 web 在数据区对应的块是5号块, 于是到数据区找到5号块, 从中读取映射表, 知道 echo 对应的 inode 是5号, 于是到元数据区找到5号 inode
3. 内核读取5号 inode, 得到 echo 在数据区对应的事11号块, 于是到数据区读取11号块得到映射表, 得到index.php 对应的 inode 事9号
4. 内核到元数据区读取9号 inode, 得到 index.php 对应的事15号和16号数据块, 于是就到数据区域找到15 16号块, 读取其中的内容, 得到 index.php 的完整内容</code></pre>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置中的location</title>
    <url>/a209000e/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p><strong>语法</strong><br><code>location [=|~|~*|^~] /uri/ &#123;...&#125;</code> </p>
<p>上下文: <code>server</code> </p>
<p>此命令随URL 不同而接受不同的结构. 可以配置使用常规字符串和正则表达式. 若使用正则表达式, 则必须使用<code>~*</code>前缀(选择不区分大小写的匹配) 或<code>~</code>前缀(区分大小写的匹配)</p>
<ul>
<li><code>=</code> 表示<code>uri</code> 以某个常规字符串开头, 理解为匹配url 路径即可. nginx 不对url 做编码, 因此请求为<code>/static/%20%/aa</code> 可以被规则<code>^~ /static/ /aa</code> (有空格) 匹配到.</li>
<li><code>~</code> 表示区分大小写的正则匹配</li>
<li><code>~*</code> 表示不区分大小写的正则匹配</li>
<li><code>!~</code> 和 <code>!~*</code> 分别为区分大小写不匹配 和 不区分大小写不匹配 的正则</li>
<li><code>/</code> 通用匹配, 任何请求都会匹配到</li>
</ul>
<p>多个<code>location</code> 配置的情况下, 匹配顺序为: </p>
<p>先匹配<code>=</code>, 其次匹配<code>^~</code>, 再匹配按文件中顺序的正则匹配, 最后匹配<code>/</code>. 当有匹配成功的时候, 停止匹配, 按当前匹配规则处理请求.</p>
<p> <strong>例1:</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> = / &#123;</span><br><span class="line">    <span class="comment"># 规则A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> = /login &#123;</span><br><span class="line">    <span class="comment"># 规则B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /static &#123;</span><br><span class="line">    <span class="comment"># 规则C</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> <span class="regexp">~ \.(gif|jpg|png|js|css)$</span> &#123;</span><br><span class="line">    <span class="comment"># 规则D</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> <span class="regexp">~* \.png$</span> &#123;</span><br><span class="line">    <span class="comment"># 规则E</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> !<span class="regexp">~ \.xhtml$</span> &#123;</span><br><span class="line">    <span class="comment"># 规则F</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> !<span class="regexp">~* \.xhtml$</span> &#123;</span><br><span class="line">    <span class="comment"># 规则G</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment"># 规则H</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>产生效果如下:</p>
<ul>
<li>访问<code>/</code> 根目录, 如<code>http://localhost/</code> 将匹配规则A</li>
<li>访问<code>http://localhost/login</code> 将匹配规则B; <code>http://localhost/register</code> 将匹配规则H</li>
<li>访问<code>http://localhost/static/a.html</code> 将匹配规则C</li>
<li>访问<code>http://localhost/a.png</code> 讲匹配规则D 和规则E, 但规则D 顺序优先, 规则E 不起作用</li>
<li>访问<code>http://localhost/static/c.png</code> 优先匹配到规则C</li>
<li>访问<code>http://localhost/a.PNG</code> 将匹配规则E</li>
<li>访问<code>http://localhost/a.xhtml</code> 不会匹配到规则F 和规则G, <code>http://localhost/a.XHTML</code> 不会匹配到规则G</li>
<li>访问<code>http://localhost/category/id/1111</code> 匹配到规则H, 因为以上规则都不匹配, 这个时候应该是nginx 转发给后端应用服务器, 如FastCGI(php), tomcat(jsp), nginx 作为反向代理服务器存在.</li>
</ul>
<p>所以实际使用中, 通常有至少三个匹配规则定义, 如下:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个必选规则 直接匹配网站根, 通过域名访问网站首页比较频繁, 使用这个会加速处理; 这里直接转发给后端应用服务器了, 也可以是一个静态首页</span></span><br><span class="line"><span class="section">location</span> = / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat:8080/index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个必选规则 处理静态文件请求, 这是nginx 作为http 服务器的强项. 有如下两种配置模式, 目录匹配或后缀匹配, 任选其一或搭配使用</span></span><br><span class="line">location<span class="regexp"> ^~</span> /static/ &#123;</span><br><span class="line">    <span class="attribute">root</span> /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> <span class="regexp">~* \.(gif|jpg|jpeg|png|css|js|ico)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个必选规则 通用规则, 用来转发动态请求到后端应用服务器. 非静态文件请求就默认是动态请求. </span></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat:8080/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>protocol buffer</title>
    <url>/66065582/</url>
    <content><![CDATA[<h5><span id="developer-guide">Developer Guide</span></h5><p><code>.proto</code> 文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> PhoneType type = <span class="number">2</span> [default = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Once you’ve defined your messages, you run the protocol buffer compiler for your application’s language on your .proto file to generate data access classes. These provide simple accessors for each field (like name() and set_name()) as well as methods to serialize/parse the whole structure to/from raw bytes</p>
<p>You can add new fields to your message formats without breaking backwards-compatibility; old binaries simply ignore the new field when parsing. So if you have a communications protocol that uses protocol buffers as its data format, you can extend your protocol without having to worry about breaking existing code.</p>
<h5><span id="language-guide">Language Guide</span></h5><h6><span id="defining-a-message-type">Defining A Message Type</span></h6><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// First non-empty; first non-comment line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>; <span class="comment">// unique numbered tag</span></span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6><span id="specifying-field-types">Specifying Field Types</span></h6><h6><span id="assigning-tags">Assigning Tags</span></h6><p>1-15 one byte 16-2047 two bytes you should reserve the tags 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.</p>
<p>range: 1 to 536,870,911 You also cannot use the numbers 19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber)</p>
<h6><span id="specifying-field-rules">Specifying Field Rules</span></h6><ul>
<li>singular zero or one of this field</li>
<li>repeated any number of times</li>
</ul>
<h6><span id="adding-more-message-types">Adding More Message Types</span></h6><h6><span id="reserved-fields">Reserved Fields</span></h6><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Note that you can’t mix field names and tag numbers in the same reserved statement.</p>
<h6><span id="whats-generated-from-your-proto">What’s Generated From Your .proto?</span></h6><h6><span id="default-values">Default Values</span></h6><p>sigular: - string - byte - bool - numeric type - enum - message field</p>
<p>repeated: - repeated filed</p>
<h6><span id="enumerations">Enumerations</span></h6><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>You can define aliases by assigning the same value to different enum constants</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6><span id="reserved-values">Reserved Values</span></h6><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>, <span class="number">40</span> to max;</span><br><span class="line">  reserved <span class="string">&quot;FOO&quot;</span>, <span class="string">&quot;BAR&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Note that you can’t mix field names and numeric values in the same reserved statement.</p>
<h6><span id="using-other-message-types">Using Other Message Types</span></h6><p>Define a message in the same <code>.proto</code> file.</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6><span id="importing-definitions">Importing Definitions</span></h6><p>By default you can only use definitions from directly imported .proto files. <code>import &quot;myproject/other_protos.proto&quot;;</code></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new.proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br><span class="line">======================================================</span><br><span class="line"><span class="comment">// old.proto</span></span><br><span class="line"><span class="comment">// This is the proto that all clients are importing.</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br><span class="line">======================================================</span><br><span class="line"><span class="comment">// client.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// You use definitions from old.proto and new.proto, but not other.proto</span></span><br></pre></td></tr></table></figure>


<p>The protocol compiler searches for imported files in a set of directories specified on the protocol compiler command line using the -I/–proto_path flag. If no flag was given, it looks in the directory in which the compiler was invoked. In general you should set the –proto_path flag to the root of your project and use fully qualified names for all imports.</p>
<h6><span id="using-proto2-message-types">Using proto2 Message Types</span></h6><p>It’s possible to import proto2 message types and use them in your proto3 messages, and vice versa. However, proto2 enums cannot be used directly in proto3 syntax (it’s okay if an imported proto2 message uses them).</p>
<h6><span id="nested-types">Nested Types</span></h6><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>If you want to reuse this message type outside its parent message type, you refer to it as <code>Parent.Type</code>:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">  SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>You can nest messages as deeply as you like</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Outer</span> &#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleAA</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleBB</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6><span id="updating-a-message-type">Updating A Message Type</span></h6><ul>
<li>Don’t change the numeric tags for any existing fields</li>
<li>If you add new fields, any messages serialized by code using your “old” message format can still be parsed by your new generated code</li>
<li>Fields can be removed, as long as the tag number is not used again in your updated message type<ul>
<li>You may want to rename the field instead, perhaps adding the prefix “OBSOLETE_”, or make the tag reserved, so that future users of your .proto can’t accidentally reuse the number.</li>
</ul>
</li>
<li>Compatibility<ul>
<li>int32, uint32, int64, uint64, and bool are all compatible</li>
<li>sint32 and sint64 are compatible with each other but are not compatible with the other integer types</li>
<li>string and bytes are compatible as long as the bytes are valid UTF-8</li>
<li>Embedded messages are compatible with bytes if the bytes contain an encoded version of the message</li>
<li>fixed32 is compatible with sfixed32, and fixed64 with sfixed64</li>
<li>enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit)</li>
</ul>
</li>
<li>Moving any fields into an existing oneof is not safe</li>
</ul>
<h6><span id="any">Any</span></h6><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorStatus</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6><span id="oneof">Oneof</span></h6><p>You can add fields of any type, but cannot use <code>repeated</code> fields</p>
<p>Features: - Setting a oneof field will automatically clear all other members of the oneof - If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message - If you’re using C++, make sure your code doesn’t cause memory crashes - Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case</p>
<h6><span id="maps">Maps</span></h6><p><code>map&lt;key_type, value_type&gt; map_field = N</code> The <code>key_type</code> can be any integral or string type. The <code>value_type</code> can be any type except another map.</p>
<ul>
<li>Map fields cannot be <code>repeated</code></li>
<li>Wire format ordering and map iteration ordering of map values is undefined</li>
<li>When generating text format for a <code>.proto</code>, maps are sorted by key</li>
<li>When parsing from the wire or when merging, if there are duplicate map keys the last key seen is used. When parsing a map from text format, parsing may fail if there are duplicate keys</li>
</ul>
<p>backwords compatibility:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MapFieldEntry</span> &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>


<h6><span id="packages">Packages</span></h6><h6><span id="json-mapping">JSON Mapping</span></h6>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>pb</tag>
      </tags>
  </entry>
  <entry>
    <title>qt 同步方式发送post 请求</title>
    <url>/c57f4e3b/</url>
    <content><![CDATA[<p>不成功的方式: 1. QNetworkReply的isFinished()函数, 通过while循环判断reply是否已经结束, 结束后再调用readAll()读取响应信息, 结果与判断isRunning() 方式结果一样, 都会进入死循环, 没有响应. 2. QNetworkReply继承自QIODevice, 尝试调用QIODevice的waitForReadyRead()方法, 结果不阻塞, 直接返回</p>
<p>成功的方式: 使用QEventLoop来阻塞运行, 知道信号发出</p>
<pre><code>QNetworkReply *reply = _manager-&gt;post(QNetworkRequest(QUrl(SERVER_URL)), data);
QByteArray responseData;
QEventLoop eventLoop;
connect(_manager, SIGNAL(finished(QNetworkReply*)), &amp;eventLoop, SLOT(quit()));
eventLoop.exec();       //block until finish
responseData = reply-&gt;readAll();</code></pre>]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyenv工具</title>
    <url>/e1d73156/</url>
    <content><![CDATA[<p>Python 版本管理工具的主要作用是帮助开发者在同一台机器上管理多个 Python 版本和环境。这对于开发和部署不同项目非常有用，因为不同项目可能依赖不同的 Python 版本或者不同的包版本。具体来说，Python 版本管理工具应有以下功能：</p>
<p>（1）避免依赖冲突，不同的项目可能依赖不同版本的库，使用版本管理工具可以创建独立的虚拟环境，避免依赖冲突。</p>
<p>（2）简化开发流程，开发者可以轻松地在不同的 Python 版本之间切换，而不需要重新安装或配置 Python。</p>
<p>（3）便于部署，减少冲突。在开发环境中使用与生产环境相同的 Python 版本和依赖，可以减少部署时出现的问题。</p>
<p>（4）共享环境配置，提高开发环境一致性。可以将环境配置文件（如 <code>requirements.txt</code> 或 <code>pyproject.toml</code>）共享给团队成员，确保大家使用相同的开发环境。</p>
<h2><span id="一-工具选择">一、工具选择</span></h2><p>常见的管理工具有 Pyenv 和 Conda。Pyenv 是当前最流行的 Python 版本管理工具，支持多种 Python 版本，如 CPython、Anaconda、PyPy 等，功能全面且简单易用。Conda 最初由 Anaconda, Inc. 开发，主要用于 Python 和 R 编程语言的软件包（含 Python）及环境管理，特别适合跨平台、多语言项目，Python 版本管理只是其一小部分功能，若仅用于管理 Python 版本，Conda 有些大材小用，且系统较复杂、学习成本略高。相比之下，Pyenv 是常规项目 Python 版本管理的最优选择。</p>
<p>以下详细介绍 Pyenv 的使用方法。</p>
<h2><span id="二-pyenv-安装">二、Pyenv 安装</span></h2><p><strong>建议：</strong> 先卸载系统内置的 Python，否则可能导致 pyenv 设置不生效。</p>
<h3><span id="1-windows">1. Windows</span></h3><p>pyenv 本身是为 Unix 系统设计的。你可以使用 <a href="https://github.com/pyenv-win/pyenv-win">pyenv-win</a> 这个项目，它是 pyenv 的 Windows 版本。</p>
<p>你需要在 PowerShell 中执行以下命令安装 pyenv-win：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Invoke-WebRequest -UseBasicParsing -Uri <span class="string">&quot;https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1&quot;</span> -OutFile <span class="string">&quot;./install-pyenv-win.ps1&quot;</span>; &amp;<span class="string">&quot;./install-pyenv-win.ps1&quot;</span></span><br></pre></td></tr></table></figure>

<p>重新打开 PowerShell，运行 pyenv –version 检查安装是否成功。</p>
<h3><span id="2-linux">2. Linux</span></h3><p>你可以使用以下命令来安装 <code>pyenv</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://pyenv.run | bash</span><br></pre></td></tr></table></figure>

<p>之后再将 pyenv 配置到环境变量中并使之生效，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>上述配置仅能使 pyenv 在 bash 环境生效，更多 shell 环境配置请参考：<a href="https://github.com/pyenv/pyenv?tab=readme-ov-file#set-up-your-shell-environment-for-pyenv">Set up your shell environment for Pyenv</a>。配置的本质在于将$PYENV_ROOT 下的 shims 和 bin 目录配置到 PATH 变量中，且 shims 需配置在前。配置后的 PATH 如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo $PATH /root/.pyenv/shims:/root/.pyenv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br></pre></td></tr></table></figure>

<h2><span id="三-pyenv-基本用法">三、Pyenv 基本用法</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看帮助文档 </span></span><br><span class="line">pyenv</span><br><span class="line"><span class="comment">## 查看某个命令帮助文档</span></span><br><span class="line">pyenv install --<span class="built_in">help</span></span><br><span class="line"><span class="comment">## 查看版本</span></span><br><span class="line">pyenv version</span><br><span class="line"><span class="comment">## 检查 Python 是否正常运行 </span></span><br><span class="line">python -c <span class="string">&quot;import sys; print(sys.executable)&quot;</span> </span><br><span class="line"><span class="comment">## 查看已安装的 Python 版本 </span></span><br><span class="line">pyenv versions </span><br><span class="line"><span class="comment">## 查看当前使用的 Python 版本 </span></span><br><span class="line">pyenv version </span><br><span class="line"><span class="comment">## 查看所有可用的 Python 版 </span></span><br><span class="line">pyenv install --list</span><br><span class="line"><span class="comment">## 安装指定版本 </span></span><br><span class="line">pyenv install 3.9.1 </span><br><span class="line"><span class="comment">## 验证</span></span><br><span class="line">python --version</span><br><span class="line"><span class="comment">## 卸载指定版本 </span></span><br><span class="line">pyenv uninstall 3.9.1</span><br><span class="line"><span class="comment">## 全局指定 Python 版本（影响所有项目） </span></span><br><span class="line">pyenv global 3.9.1 </span><br><span class="line"><span class="comment">## 局部指定 Python 版本（仅影响当前项目目录），指定后在当前项目目录内创建 .python-version 文件，保存版本信息## 优先级高于 global</span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.1 </span><br><span class="line"><span class="comment">## 会话级指定 Python 版本（影响所有项目） </span></span><br><span class="line">pyenv shell 3.9.1</span><br><span class="line"><span class="comment">## 查看 python 的安装目录</span></span><br><span class="line">pyenv <span class="built_in">which</span> python </span><br><span class="line"><span class="comment">## 重新生成 pyenv 的 shims 目录中的可执行文件</span></span><br><span class="line">pyenv <span class="built_in">rehash</span></span><br></pre></td></tr></table></figure>

<p>Python 安装常见问题，可参考：<a href="https://github.com/pyenv/pyenv/wiki/Common-build-problems">Python common build problems</a></p>
<h2><span id="四-pyenv-核心原理-shims">四、Pyenv 核心原理 -Shims</span></h2><p>pyenv 通过 Shims 实现了对不同 Python 版本的透明管理和切换。</p>
<h3><span id="1-工作原理">1. 工作原理</span></h3><p>上述环境配置中，在 PATH 环境变量最前面插入一个 shims 目录，<code>$(pyenv root)/shims:$(pyenv root)/bin:/usr/local/bin:/usr/bin:/bin</code>。通过一个称为 rehashing 的过程，pyenv 在该目录中维护垫片，以匹配每个已安装的 Python 版本中的每个 Python 命令，如： python、pip 等。</p>
<p>Shims 是轻量级可执行文件，它只是将你的命令传递给 pyenv。因此，在安装了 pyenv 的情况下，当你运行 pip 时，你的操作系统将执行以下操作：</p>
<p>（1）搜索 PATH 环境变量，寻找 pip 可执行文件</p>
<p>（2）在 <code>$(pyenv root)/shims</code> 中找到 pip</p>
<p>（3）运行名为 pip 的 shim，它将命令传递给 pyenv</p>
<h3><span id="2-作用">2. 作用</span></h3><p>（1）通过使用 Shims，pyenv 可以实现对不同项目使用不同 Python 版本的灵活管理，而不需要手动修改环境变量或路径。</p>
<p>（2）你可以方便地在全局、目录级别甚至是 shell 会话级别设置或切换 Python 版本，极大地方便了开发和测试工作。</p>
<h3><span id="3-示例">3. 示例</span></h3><p>（1）假设你在项目 A 中使用 Python 3.8，而在项目 B 中使用 Python 3.9。通过 pyenv 和 Shims，你可以在项目目录中分别设置 Python 版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在项目 A 目录中 </span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.8.10 </span><br><span class="line"><span class="comment"># 在项目 B 目录中</span></span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.5</span><br></pre></td></tr></table></figure>

<p>（2）当你在项目 A 目录中运行 <code>python</code> 命令时，Shims 会确保调用的是 Python 3.8.10，而在项目 B 目录中则会调用 Python 3.9.5。</p>
<p>通过这种方式，Shims 实现了对不同 Python 版本的透明管理和切换。</p>
<h2><span id="五-pyenv-初始化操作源码解读">五、Pyenv 初始化操作源码解读</span></h2><h3><span id="1-pyenv-init-">1. <code>pyenv init -</code></span></h3><p>用于初始化 pyenv，使其在当前 shell 会话中工作。运行后，执行如下命令（相关说明附在注释中）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.PATH 变量处理</span></span><br><span class="line"><span class="comment">## 该脚本将当前的 PATH 变量拆分为一个数组 paths，并赋予</span></span><br><span class="line"><span class="comment">## 通过遍历 paths 数组，检查每个路径是否为 &#x27;/root/.pyenv/shims&#x27;，如果是，则将其移除</span></span><br><span class="line">PATH=<span class="string">&quot;<span class="subst">$(bash --norc -ec &#x27;IFS=:; paths=($PATH)</span>; </span></span><br><span class="line"><span class="string">for i in <span class="variable">$&#123;!paths[@]&#125;</span>; do </span></span><br><span class="line"><span class="string">if [[ <span class="variable">$&#123;paths[i]&#125;</span> == &quot;</span><span class="string">&#x27;&#x27;</span>/root/.pyenv/shims<span class="string">&#x27;&#x27;</span><span class="string">&quot; ]]; then unset &#x27;\&#x27;&#x27;paths[i]&#x27;\&#x27;&#x27;; </span></span><br><span class="line"><span class="string">fi; done; </span></span><br><span class="line"><span class="string">echo &quot;</span><span class="variable">$&#123;paths[*]&#125;</span><span class="string">&quot;&#x27;)&quot;</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 更新 PATH 变量</span></span><br><span class="line"><span class="comment">## 将 &#x27;/root/.pyenv/shims&#x27; 添加到 PATH 变量的最前面</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/root/.pyenv/shims:<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">## 设置 PYENV_SHELL 环境变量为 bash，sh 环境下，输出的是 shell</span></span><br><span class="line"><span class="built_in">export</span> PYENV_SHELL=bash</span><br><span class="line"><span class="comment">## sh 环境下，无该行代码，bash 环境下执行改行的作用是：source 命令加载 pyenv 的自动补全脚本</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;/root/.pyenv/libexec/../completions/pyenv.bash&#x27;</span> </span><br><span class="line"><span class="comment">## 通过 command 命令执行 pyenv rehash（主要作用是重新生成 pyenv 的 shims 目录中的可执行文件），并将错误输出重定向到 /dev/null</span></span><br><span class="line"><span class="built_in">command</span> pyenv <span class="built_in">rehash</span> 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 定义一个 pyenv 函数，该函数根据不同的子命令执行不同的操作</span></span><br><span class="line"><span class="comment">## 如果子命令是 activate、deactivate、rehash 或 shell，则通过 eval 执行 pyenv &quot;sh-$command&quot;</span></span><br><span class="line"><span class="comment">## 对于其他子命令，直接调用 command pyenv &quot;$command&quot; &quot;$@&quot;</span></span><br><span class="line"><span class="function"><span class="title">pyenv</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> <span class="built_in">command</span></span><br><span class="line">  <span class="built_in">command</span>=<span class="string">&quot;<span class="variable">$&#123;1:-&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$command</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  activate|deactivate|<span class="built_in">rehash</span>|shell)</span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv <span class="string">&quot;sh-<span class="variable">$command</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">command</span> pyenv <span class="string">&quot;<span class="variable">$command</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="2-pyenv-init-path">2. pyenv init –path</span></h3><p>用于设置 PYENV_ROOT 环境变量，使得 pyenv 可以找到安装的 Python 版本。<code>pyenv init -</code> 包含 <code>pyenv init --path</code> 操作。</p>
<p>sh 或 bash 环境运行后，执行如下命令（相关说明附在注释中）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 该脚本将当前的 PATH 变量拆分为一个数组 paths，并赋予</span></span><br><span class="line"><span class="comment">## 通过遍历 paths 数组，检查每个路径是否为 &#x27;/root/.pyenv/shims&#x27;，如果是，则将其移除</span></span><br><span class="line">PATH=<span class="string">&quot;<span class="subst">$(bash --norc -ec &#x27;IFS=:; paths=($PATH)</span>; </span></span><br><span class="line"><span class="string">for i in <span class="variable">$&#123;!paths[@]&#125;</span>; do </span></span><br><span class="line"><span class="string">if [[ <span class="variable">$&#123;paths[i]&#125;</span> == &quot;</span><span class="string">&#x27;&#x27;</span>/root/.pyenv/shims<span class="string">&#x27;&#x27;</span><span class="string">&quot; ]]; then unset &#x27;\&#x27;&#x27;paths[i]&#x27;\&#x27;&#x27;; </span></span><br><span class="line"><span class="string">fi; done; </span></span><br><span class="line"><span class="string">echo &quot;</span><span class="variable">$&#123;paths[*]&#125;</span><span class="string">&quot;&#x27;)&quot;</span></span><br><span class="line"><span class="comment">## 将 &#x27;/root/.pyenv/shims&#x27; 添加到 PATH 变量的最前面</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/root/.pyenv/shims:<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">## 通过 command 命令执行 pyenv rehash，并将错误输出重定向到 /dev/null</span></span><br><span class="line"><span class="built_in">command</span> pyenv <span class="built_in">rehash</span> 2&gt;/dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>qt 的 pro 文件</title>
    <url>/8304997e/</url>
    <content><![CDATA[<h4><span id="注释">注释</span></h4><p>使用<code>#</code> 进行行注释</p>
<h4><span id="模板">模板</span></h4><p><code>TEMPLATE = app</code> 告诉<code>qmake</code>为这个应用程序生成哪种<code>makefile</code>. - app 默认值. 生成app的makefile - lib 生成一个库的makefile - vcapp 生成一个应用程序的<code>VisualStudio</code>项目文件 - vclib 生成一个库的<code>VisualStudio</code> 项目文件 - subdirs 生成<code>makefile</code>文件编译<code>subdirs</code>指定的子文件夹</p>
<h4><span id="应用程序目录">应用程序目录</span></h4><p>指定生成的应用程序放置的目录 <code>DESTDIR += ../bin</code></p>
<h4><span id="配置信息">配置信息</span></h4><p><code>COFNIG</code> 用来告诉<code>qmake</code> 关于应用程序的配置信息 <code>CONFIG += qt warn_on release</code></p>
<h4><span id="ui目录">ui目录</span></h4><p>指定uic命令将<code>.ui</code>文件转化成的<code>ui_*.h</code>文件的存放目录 <code>UI_DIR += forms</code></p>
<h4><span id="rcc目录">rcc目录</span></h4><p>指定rcc命令将<code>.qrc</code>文件转换成的<code>qrc_*.h</code>文件的存放目录 <code>RCC_DIR += ../tmp</code></p>
<h4><span id="moc目录">moc目录</span></h4><p>指定moc命令将<strong>含Q_OBJECT的头文件转换成标准<code>.h</code>文件的存放目录</strong> <code>MOC_DIR += ../tmp</code></p>
<h4><span id="目标文件目录">目标文件目录</span></h4><p>指定目标文件(obj)的存放目录 <code>OBJECTS_DIR += ../tmp</code></p>
<h4><span id="依赖相关路径">依赖相关路径</span></h4><p>程序编译时依赖的相关路径 <code>DEPENDPATH += . forms include qrc sources</code></p>
<h4><span id="头文件包含路径">头文件包含路径</span></h4><p><code>INCLUDEPATH += .</code></p>
<h4><span id="qmake时产生的信息">qmake时产生的信息</span></h4><p><code>message($$(PATH))</code></p>
<h4><span id="源文件编码方式">源文件编码方式</span></h4><p><code>CODECFORSRC = GBK</code></p>
<h4><span id="工程中包含的头文件">工程中包含的头文件</span></h4><p><code>HEADERS += include/aa.h</code></p>
<h4><span id="工程中包含的ui文件">工程中包含的<code>.ui</code>文件</span></h4><p><code>FORMS += forms/aa.ui</code></p>
<h4><span id="工程中包含的源文件">工程中包含的源文件</span></h4><p><code>SOURCES += sources/main.cpp sources/aa.cpp</code></p>
<h4><span id="工程中包含的资源文件">工程中包含的资源文件</span></h4><pre><code>RESOURCES += qrc/aa.qrc
LIBS += -LfolderPath
Release: LIBS += -LfolderReleasePath
Debug: LIBS += -LfolderDebugPath
DEFINES += XX_XX_XXX // 定义编译选项, 在.h文件中就可以用 #ifdefine XX_XX_XXX
RC_FIELS = xxx.icns</code></pre><h4><span id="平台相关性处理">平台相关性处理</span></h4><p>根据qmake所运行的平台来使用相应的作用域来进行处理.</p>
<p>为Windows平台添加的依赖平台的文件示例:</p>
<pre><code>win32&#123;
SOURCES += hello_win.cpp
&#125;</code></pre><h4><span id="生成makefile">生成Makefile</span></h4><p><code>qmake -oMakefile hello.pro</code></p>
<p>对于VisualStudio用户, qmake也可以生成<code>.dsp</code>文件 <code>qmake -tvcapp -o hello.dsp hello.pro</code></p>
<h6><span id="pro文件实例">pro文件实例</span></h6><pre><code>TEMPLATE = app #模块配置
LANGUAGE = C++ #C++语言

CONFIG += qt warn_on debug release

#引入的lib文件,用于引入动态链接库
LIBS += qaxcontainer.lib

#头文件包含路径
INCLUDEPATH += ../../qtcompnent/qtchklisten/inc ../../qtcompnent/qtclearfile/inc ../../validator/inc/validerrcode ../../qtcompnent/qtdir/inc ../inc ../../utillib/inc/xmlapi ../../utillib/inc/util ../../xercesc ../../qtcompnent/qteditor/inc ../../qtcompnent/qtfunreview/inc ../../qtcompnent/qttable/inc ../../qtcompnent/qtversion/inc ../../qtcompnent/qtini/inc ../../icdtool/icdservices/inc ../../icdtool/dataset/inc ../../icdtool/doi/inc ../../icdtool/reportcontrol/inc ../../icdtool/GSEconctrol/inc ../../icdtool/inputs/inc ../../icdtool/SMVconctrol/inc ../../icdtool/logcontrol/inc ../../scdpreview/inc/scdpreviewtoollib ../../scdpreview/form ../../icdtool/sclcontrol/inc ../../icdtool/log/inc ../../icdtool/settingcontrol/inc ../../qtcompnent/qteditor/inc ../../qtcompnent/qttreeview/inc ../../qtcompnent/qttabwidget/inc ../../communication/inc ../../qtcompnent/qtabout/inc ../iedmanage/inc ../ldmanage/inc ../foriecrun/inc ../../qtcompnent/validset/inc

#工程中包含的头文件
HEADERS += ../inc/exportstable.h /
../inc/maintabwidget.h /
../inc/outputtab.h /
../inc/strutil.h /
../inc/treeeditview.h /
../inc/MainForm.h /
../inc/recenfileini.h /
../inc/ExportCIDFunction.h

#工程中包含的源文件
SOURCES += ../src/main.cpp /
../src/exportstable.cpp /
../src/maintabwidget.cpp /
../src/outputtab.cpp /
../src/treeeditview.cpp /
../src/MainForm.cpp /
../src/recenfileini.cpp /
../src/ExportCIDFunction.cpp

#工程中包含的.ui设计文件
FORMS = ../form/scdmainform.ui /
../form/exportiedform.ui /
../form/Exportsedform.ui /
../form/Importsedform.ui /
../form/formiminputs.ui

#图像文件

IMAGES = images/substation.png /
images/communication.png /
images/autocom.png /
images/reportcfg.png /
images/comcfg.png /
images/filetrans.png /
images/review.png /
images/setting.png

#工程中包含的资源文件
RESOURCES = Scintilla.qrc

#CONFIG -= release
CONFIG -= debug


RC_FILE = scdtool.rc


BINLIB = ../../bin ../../xercesc/lib

UI_HEADERS_DIR = ../inc # .ui文件转会为**.h 存放的目录
UI_SOURCES_DIR = ../src # .ui文件转会为**.cpp 存放的目录
QMAKE_LIBDIR = $$&#123;BINLIB&#125;

release &#123;
TARGET = scdtool #指定生成的应用程序名
OBJECTS_DIR = ../../obj/scdtool/release #指定目标文件(obj)的存放目录
&#125;
debug &#123;
TARGET = scdtool_d #指定生成的应用程序名
OBJECTS_DIR = ../../obj/scdtool/debug #指定目标文件(obj)的存放目录
&#125;

MOC_DIR = $$&#123;OBJECTS_DIR&#125;
DESTDIR = ../../bin #指定生成的应用程序放置的目录</code></pre><p>补充: <a href="https://www.cnblogs.com/Braveliu/p/5107550.html">cnblogs</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>qt 程序打包</title>
    <url>/7e8574d1/</url>
    <content><![CDATA[<h6><span id="设置程序图标">设置程序图标</span></h6><ol>
<li>把ico文件放到源文件目录下, 命名为”test.ico”</li>
<li>创建一个<code>myico.rc</code> 文件, 输入如下内容 <code>IDI_ICON1 ICON DISCARDABLE &quot;test.ico&quot;</code></li>
<li>在pro文件写入 <code>RC_FILE = myico.rc</code></li>
<li>执行qmake, 编译</li>
</ol>
<h6><span id="编译-打包">编译, 打包</span></h6><ol>
<li>选择release编译运行</li>
<li>将生成的exe文件放到某个路径下, 如 <code>Desktop/Test</code></li>
<li>在cmd里, 进入到exe存放路径, 使用wendeployqt工具拷贝exe运行需要的dll</li>
<li>使用Inno Setup Compiler生成安装文件</li>
</ol>
<h6><span id="inno-setup-工具使用注意事项">Inno Setup 工具使用注意事项</span></h6><ul>
<li>添加主执行文件外的其他应用程序文件夹下的文件时, 需要编辑一次, 重新指定目标子文件夹</li>
<li>编译脚本为<code>*.iss</code> 文件, 编译后默认在源exe的Base 目录下生成Output文件夹, 指定的setup.exe文件生成在Output 文件夹下</li>
<li>Inno Setup 工具基础版不支持中文. 如需显示中文, 需要找汉化版</li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 配置中的rewrite</title>
    <url>/389c639/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p><strong>语法</strong></p>
<p> <code>rewrite regex replacement flag</code> </p>
<p>flag有如下: </p>
<ul>
<li><p>last </p>
</li>
<li><p>break 中止 rewrite, 不再继续匹配 </p>
</li>
<li><p>redirect 返回临时重定向的 HTTP 状态302  </p>
</li>
<li><p>permanet 返回永久重定向的 HTTP 状态301</p>
</li>
</ul>
<pre><code>last 和 break 的不同:  
break 是终止当前location 的 rewrite 检测, 且不再进行 location 匹配;  
last是终止当前location的rewrite检测,但会继续重试location匹配并处理区块中的rewrite规则</code></pre><ol>
<li>下面是可以用来判断的表达式:<br> <code>-f</code> 和<code>!-f</code> 判断是否存在文件<br> <code>-d</code> 和<code>!-d</code> 判断是否存在目录<br> <code>-e</code> 和<code>!-e</code> 判断是否存在文件或目录<br> <code>-x</code> 和<code>!-x</code> 判断文件是否可执行</li>
</ol>
<p>2.下面是可以用作判断的全局变量</p>
<ul>
<li>$args 等于请求行中的参数</li>
<li>$content_length 请求头中的<code>Content-length</code> 字段</li>
<li>$content_type 请求头中的<code>Content-Type</code> 字段</li>
<li>$document_root 当前请求在<code>root</code> 指令中指定的值</li>
<li>$host 请求主机头字段, 否则为服务器名称</li>
<li>$http_user_agent 客户端<code>agent</code> 信息</li>
<li>$http_cookie 客户端<code>cookie</code> 信息</li>
<li>$limit_rate 这个变量可以限制连接速率</li>
<li>$request_body_file 客户端请求主题信息的临时文件名</li>
<li>$request_method #客户端请求的动作，通常为GET或POST。</li>
<li>$remote_addr #客户端的IP地址。</li>
<li>$remote_port #客户端的端口。</li>
<li>$remote_user #已经经过Auth Basic Module验证的用户名。</li>
<li>$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。</li>
<li><code>$query_string</code> #与$args相同。</li>
<li>$scheme #HTTP方法（如http，https）。</li>
<li>$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</li>
<li>$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。</li>
<li>$server_name #服务器名称。</li>
<li>$server_port #请求到达服务器的端口号。</li>
<li>$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li>
<li><code>$uri</code> 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</li>
<li><code>$document_uri</code> #与<code>$uri</code>相同</li>
</ul>
<p>例:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">http://localhost:88/test1/test2/test.<span class="attribute">php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$host</span>: localhost</span><br><span class="line"><span class="variable">$server_post</span>: <span class="number">88</span></span><br><span class="line"><span class="variable">$request_uri</span>: http://localhost:88/test1/test2/test.php</span><br><span class="line"><span class="variable">$document_uri</span>: /test1/test2/test.php</span><br><span class="line"><span class="variable">$document_root</span>: /usr/share/nginx/html (在nginx.conf里配置的)</span><br><span class="line"><span class="variable">$request_filename</span>: /usr/share/nginx/html/test1/test2/test.php (在nginx.conf里配置的)</span><br></pre></td></tr></table></figure>


<p><strong>详例:</strong><br><em>多目录转成参数</em><br><code>abc.domain.com/sort/2</code> =&gt; <code>abc.domain.com/index.php?act=sort&amp;name=abc&amp;id=2</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$host</span> <span class="regexp">~* (.*)\.domain\.com)</span> &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$sub_name</span> <span class="variable">$1</span>;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/sort\/(\d+)\/?$</span> /index.php?act=sort&amp;cid=<span class="variable">$sub_name</span>&amp;id=<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>目录对换</em><br><code>/123456/xxxx</code> =&gt; <code>/xxxx?id=123456</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^/(\d+)\/(.+)/</span> /<span class="variable">$2</span>?id=<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">// <span class="attribute">rewrite</span><span class="regexp"> ^/\/(\d+)\/(\w+)\/?</span> /<span class="variable">$2</span>?id=<span class="variable">$1</span> <span class="literal">last</span>;</span><br></pre></td></tr></table></figure>


<p><em>如果使用IE浏览器, 则重定向到/nginx-ie 目录下</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$http_user_agent</span> <span class="regexp">~ MSIE)</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /nginx-ie/<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>目录自动加 /</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (-d <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^/(.*)([^/])$</span> http://<span class="variable">$host</span>/<span class="variable">$1</span><span class="variable">$2</span>/ <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>禁止htaccess</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> ~/\.ht &#123;</span><br><span class="line">	<span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>禁止多个目录</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ ^/(cron|templates)/</span> &#123;</span><br><span class="line">	<span class="attribute">deny</span> all;</span><br><span class="line">	break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>禁止以/data开头的文件</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">可以禁止/data/下多级目录下.log.txt等请求;</span><br><span class="line"><span class="section">location</span> <span class="regexp">~ ^/data</span> &#123;</span><br><span class="line">	<span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>禁止单个目录</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">不能禁止.log.txt能请求</span><br><span class="line"><span class="section">location</span> /searchword/cron/ &#123;</span><br><span class="line">	<span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>禁止单个文件</em></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /data/sql/data.sql</span> &#123;</span><br><span class="line">	<span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em>给 favicon.ico和 robots.txt设置过期时间;</em><br>这里为 favicon.ico为99 天,robots.txt 为 7 天并不记录 404 错误日志</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">1.     <span class="section">location</span> ~(favicon.ico) &#123;</span><br><span class="line">2.                      <span class="attribute">log_not_found</span> <span class="literal">off</span>;</span><br><span class="line">3.     <span class="attribute">expires</span> <span class="number">99d</span>;</span><br><span class="line">4.     break;</span><br><span class="line">5.          &#125;</span><br><span class="line">6.      </span><br><span class="line">7.          <span class="section">location</span> ~(robots.txt) &#123;</span><br><span class="line">8.                      <span class="attribute">log_not_found</span> <span class="literal">off</span>;</span><br><span class="line">9.     <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">10. break;</span><br><span class="line">11.      &#125;</span><br></pre></td></tr></table></figure>


<p><em>设定某个文件的过期时间;这里为600秒，并不记录访问日志</em></p>
<pre><code>1.     location ^~ /html/scripts/loadhead_1.js &#123;
2.                      access_log   off;
3.                      root /opt/lampp/htdocs/web;
4.     expires 600;
5.     break;
6.            &#125;</code></pre><p><em>文件反盗链并设置过期时间</em><br>这里的return 412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求<br>“rewrite ^/ <a href="http://leech.c1gstudio.com/leech.gif;”显示一张防盗链图片">http://leech.c1gstudio.com/leech.gif;”显示一张防盗链图片</a><br>“access_log off;”不记录访问日志，减轻压力<br>“expires 3d”所有文件3天的浏览器缓存</p>
<pre><code>1.     location ~* ^.+\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ &#123;
2.     valid_referers none blocked *.c1gstudio.com *.c1gstudio.net localhost 208.97.167.194;
3.     if ($invalid_referer) &#123;
4.         rewrite ^/ http://leech.c1gstudio.com/leech.gif;
5.         return 412;
6.         break;
7.     &#125;
8.                      access_log   off;
9.                      root /opt/lampp/htdocs/web;
10. expires 3d;
11. break;
12.      &#125;</code></pre><p><em>只充许固定ip访问网站，并加上密码</em></p>
<pre><code>1.     root  /opt/htdocs/www;
2.     allow   208.97.167.194;
3.     allow   222.33.1.2;
4.     allow   231.152.49.4;
5.     deny    all;
6.     auth_basic &quot;C1G_ADMIN&quot;;
7.     auth_basic_user_file htpasswd;</code></pre><p><em>将多级目录下的文件转成一个文件，增强seo效果</em><br><code>/job-123-456-789.html</code> 指向 <code>/job/123/456/789.html</code></p>
<pre><code>1.     rewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;</code></pre><p><em>将根目录下某个文件夹指向2级目录</em><br>如<code>/shanghaijob/</code> 指向 <code>/area/shanghai/</code> 如果你将last改成permanent，那么浏览器地址栏显是 <code>/location/shanghai/</code></p>
<pre><code>1.     rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;</code></pre><p>上面例子有个问题是访问/shanghai 时将不会匹配</p>
<pre><code>1.     rewrite ^/([0-9a-z]+)job$ /area/$1/ last;
2.     rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;</code></pre><p>这样/shanghai 也可以访问了，但页面中的相对链接无法使用， 如<code>./list_1.html</code>真实地址是<code>/area /shanghia/list_1.html</code>会变成<code>/list_1.html</code>,导至无法访问。<br>那我加上自动跳转也是不行咯 <code>(-d $request_filename)</code>它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果</p>
<pre><code>1.     if (-d $request_filename)&#123;
2.     rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;
3.     &#125;</code></pre><p>知道原因后就好办了，让我手动跳转吧</p>
<pre><code>1.     rewrite ^/([0-9a-z]+)job$ /$1job/ permanent;
2.     rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;</code></pre><p><em>文件和目录不存在的时候重定向：</em></p>
<pre><code>1.     if (!-e $request_filename) &#123;
2.     proxy_pass http://127.0.0.1;
3.     &#125;</code></pre><p><em>域名跳转</em></p>
<pre><code>1.     server
2.          &#123;
3.                  listen       80;
4.                  server_name  jump.c1gstudio.com;
5.                  index index.html index.htm index.php;
6.                  root  /opt/lampp/htdocs/www;
7.                  rewrite ^/ http://www.c1gstudio.com/;
8.                  access_log  off;
9.          &#125;</code></pre><p><em>多域名转向</em></p>
<pre><code>1.     server_name  www.c1gstudio.com www.c1gstudio.net;
2.                  index index.html index.htm index.php;
3.                  root  /opt/lampp/htdocs;
4.     if ($host ~ &quot;c1gstudio\.net&quot;) &#123;
5.     rewrite ^(.*) http://www.c1gstudio.com$1 permanent;
6.     &#125;</code></pre><p><em>三级域名跳转</em></p>
<pre><code>1.     if ($http_host ~* &quot;^(.*)\.i\.c1gstudio\.com$&quot;) &#123;
2.     rewrite ^(.*) http://top.yingjiesheng.com$1;
3.     break;
4.     &#125;</code></pre><p><em>域名镜向</em></p>
<pre><code>1.     server
2.          &#123;
3.                  listen       80;
4.                  server_name  mirror.c1gstudio.com;
5.                  index index.html index.htm index.php;
6.                  root  /opt/lampp/htdocs/www;
7.                  rewrite ^/(.*) http://www.c1gstudio.com/$1 last;
8.                  access_log  off;
9.          &#125;</code></pre>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>raft 算法</title>
    <url>/3d118e3a/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#拜占庭将军问题">拜占庭将军问题</a></li>
<li><a href="#针对简化版拜占庭将军问题raft-解决方案类比">针对简化版拜占庭将军问题，Raft 解决方案类比</a><ul>
<li><a href="#1-raft-节点状态">1. Raft 节点状态</a></li>
<li><a href="#2-选主-leader-election">2. 选主 Leader Election</a><ul>
<li><a href="#21-正常情况下选主">2.1 正常情况下选主</a></li>
<li><a href="#22-leader-出故障情况下的选主">2.2 Leader 出故障情况下的选主</a></li>
<li><a href="#23-多个-candidate-情况下的选主">2.3 多个 Candidate 情况下的选主</a></li>
</ul>
</li>
<li><a href="#3-复制日志-log-replication">3. 复制日志 Log Replication</a><ul>
<li><a href="#31-正常情况下复制日志">3.1 正常情况下复制日志</a></li>
<li><a href="#32-network-partition-情况下进行复制日志">3.2 Network Partition 情况下进行复制日志</a></li>
</ul>
</li>
<li><a href="#小总结">小总结</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="拜占庭将军问题">拜占庭将军问题</span></h1><p>拜占庭将军问题是 Leslie Lamport 在 <a href="https://web.archive.org/web/20170205142845/http://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem</a> 论文中提出的分布式领域的容错问题，它是分布式领域中最复杂、最严格的容错模型。</p>
<p>在该模型下，系统不会对集群中的节点做任何的限制，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。</p>
<p>拜占庭将军问题描述了一个如下的场景，有一组将军分别指挥一部分军队，每一个将军都不知道其它将军是否是可靠的，也不知道其他将军传递的信息是否可靠，但是它们需要通过投票选择是否要进攻或者撤退：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204025.png" alt></p>
<p>在这一节中，黄色代表状态未知，绿色代表进攻，蓝色代表撤退，最后红色代表当前将军的信息不可靠。</p>
<p>在这时，无论将军是否可靠，只要所有的将军达成了统一的方案，选择进攻或者撤退其实就是没有任何问题的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204121.png" alt></p>
<p>上述的情况不会对当前的战局有太多的影响，也不会造成损失，但是如果其中的一个将军告诉其中一部分将军选择进攻、另一部分选择撤退，就会出现非常严重的问题了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204149.png" alt></p>
<p>由于将军的队伍中出了一个叛徒或者信息在传递的过程中被拦截，会导致一部分将军会选择进攻，剩下的一部分会选择撤退，它们都认为自己的选择是大多数人的选择，这时就出现了严重的不一致问题。</p>
<p>拜占庭将军问题是对分布式系统容错的最高要求，然而这不是日常工作中使用的大多数分布式系统中会面对的问题，我们遇到更多的还是节点故障宕机或者不响应等情况，这就大大简化了系统对容错的要求；不过类似 Bitcoin、Ethereum 等分布式系统确实需要考虑拜占庭容错的问题。</p>
<blockquote>
<p>​    拜占庭将军问题是分布式领域最复杂、最严格的容错模型。但在日常工作中使用的分布式系统面对的问题不会那么复杂，更多的是计算机故障挂掉了，或者网络通信问题而没法传递信息，这种情况不考虑计算机之间互相发送恶意信息，极大简化了系统对容错的要求，最主要的是达到一致性。</p>
</blockquote>
<p>所以将拜占庭将军问题根据常见的工作上的问题进行简化：<strong>假设将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成一致性决定？</strong></p>
<p>对于这个简化后的问题，有许多解决方案，第一个被证明的共识算法是 Paxos，由拜占庭将军问题的作者 Leslie Lamport 在1990年提出，最初以论文难懂而出名，后来这哥们在2001重新发了一篇简单版的论文 <a href="https://link.jianshu.com?t=%5Bhttps%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf%5D(https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf)">Paxos Made Simple</a>，然而还是挺难懂的。</p>
<p>因为 Paxos 难懂，难实现，所以斯坦福大学的教授在2014年发表了新的分布式协议 Raft。与 Paxos 相比，Raft 有着基本相同运行效率，但是更容易理解，也更容易被用在系统开发上。</p>
<h1><span id="针对简化版拜占庭将军问题raft-解决方案类比">针对简化版拜占庭将军问题，Raft 解决方案类比</span></h1><p>我们还是用拜占庭将军的例子来帮助理解 Raft。</p>
<blockquote>
<p>​    假设将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成一致性决定？</p>
</blockquote>
<p>Raft 的解决方案大概可以理解成 先在所有将军中选出一个大将军，所有的决定由大将军来做。<strong>选举环节</strong>：比如说现在一共有3个将军 A, B, C，每个将军都有一个<strong>随机时间</strong>的倒计时器，倒计时一结束，这个将军就会把自己当成大将军候选人，然后派信使去问其他几个将军，能不能选我为总将军？假设现在将军A倒计时结束了，他派信使传递选举投票的信息给将军B和C，如果将军B和C还没把自己当成候选人（倒计时还没有结束），并且没有把选举票投给其他，他们把票投给将军A，信使在回到将军A时，将军A知道自己收到了足够的票数，成为了大将军。在这之后，是否要进攻就由大将军决定，然后派信使去通知另外两个将军，如果在一段时间后还没有收到回复（可能信使被暗杀），那就再重派一个信使，直到收到回复。</p>
<p>故事先讲到这里，希望不做技术方面的朋友可以大概能理解 Raft 的原理，下面从比较技术的角度讲讲 Raft 的原理。 </p>
<h2><span id="1-raft-节点状态">1. Raft 节点状态</span></h2><p>从拜占庭将军的故事映射到分布式系统上，每个将军相当于一个分布式网络节点，每个节点有<strong>三种状态：Follower，Candidate，Leader</strong>，状态之间是互相转换的，可以参考下图，具体的后面说。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204532.png" alt></p>
<p>每个节点上都有一个倒计时器 (Election Timeout)，时间随机在 150ms 到 300ms 之间。有几种情况会重设 Timeout：</p>
<ol>
<li>收到选举的请求</li>
<li>收到 Leader 的 Heartbeat (后面会讲到)</li>
</ol>
<p>在 Raft 运行过程中，最主要进行两个活动：</p>
<ol>
<li>选主 Leader Election</li>
<li>复制日志 Log Replication</li>
</ol>
<h2><span id="2-选主-leader-election">2. 选主 Leader Election</span></h2><h3><span id="21-正常情况下选主">2.1 正常情况下选主</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204600.png" alt></p>
<p>假设现在有如图5个节点，5个节点一开始的状态都是 Follower。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204614.png" alt></p>
<p>在一个节点倒计时结束 (Timeout) 后，这个节点的状态变成 Candidate 开始选举，它给其他几个节点发送选举请求 (RequestVote)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204652.png" alt></p>
<p>其他四个节点都返回成功，这个节点的状态由 Candidate 变成了 Leader，并在每个一小段时间后，就给所有的 Follower 发送一个 Heartbeat 以保持所有节点的状态，Follower 收到 Leader 的 Heartbeat 后重设 Timeout。</p>
<p>这是最简单的选主情况，<strong>只要有超过一半的节点投支持票了，Candidate 才会被选举为 Leader</strong>，5个节点的情况下，3个节点 (包括 Candidate 本身) 投了支持就行。</p>
<h3><span id="22-leader-出故障情况下的选主">2.2 Leader 出故障情况下的选主</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204743.png" alt></p>
<p>一开始已经有一个 Leader，所有节点正常运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204807.png" alt></p>
<p>Leader 出故障挂掉了，其他四个 Follower 将进行重新选主。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204831.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204909.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226204929.png" alt></p>
<p>4个节点的选主过程和5个节点的类似，在选出一个新的 Leader 后，原来的 Leader 恢复了又重新加入了，这个时候怎么处理？在 Raft 里，第几轮选举是有记录的，重新加入的 Leader 是第一轮选举 (Term 1) 选出来的，而现在的 Leader 则是 Term 2，所有原来的 Leader 会自觉降级为 Follower</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205008.png" alt></p>
<h3><span id="23-多个-candidate-情况下的选主">2.3 多个 Candidate 情况下的选主</span></h3><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205055.png" alt></p>
<p>假设一开始有4个节点，都还是 Follower。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205115.png" alt></p>
<p>有两个 Follower 同时 Timeout，都变成了 Candidate 开始选举，分别给一个 Follower 发送了投票请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205141.png" alt></p>
<p>两个 Follower 分别返回了ok，这时两个 Candidate 都只有2票，要3票才能被选成 Leader。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205210.png" alt></p>
<p>两个 Candidate 会分别给另外一个还没有给自己投票的 Follower 发送投票请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205227.png" alt></p>
<p>但是因为 Follower 在这一轮选举中，都已经投完票了，所以都拒绝了他们的请求。所以在 Term 2 没有 Leader 被选出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205242.png" alt></p>
<p>这时，两个节点的状态是 Candidate，两个是 Follower，但是他们的倒计时器仍然在运行，最先 Timeout 的那个节点会进行发起新一轮 Term 3 的投票。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205257.png" alt></p>
<p>两个 Follower 在 Term 3 还没投过票，所以返回 OK，这时 Candidate 一共有三票，被选为了 Leader。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205319.png" alt></p>
<p>如果 Leader Heartbeat 的时间晚于另外一个 Candidate timeout 的时间，另外一个 Candidate 仍然会发送选举请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205340.png" alt></p>
<p>两个 Follower 已经投完票了，拒绝了这个 Candidate 的投票请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205354.png" alt></p>
<p>Leader 进行 Heartbeat， Candidate 收到后状态自动转为 Follower，完成选主。</p>
<p>以上是 Raft 最重要活动之一选主的介绍，以及在不同情况下如何进行选主。</p>
<h2><span id="3-复制日志-log-replication">3. 复制日志 Log Replication</span></h2><h3><span id="31-正常情况下复制日志">3.1 正常情况下复制日志</span></h3><p>Raft 在实际应用场景中的一致性更多的是体现在不同节点之间的数据一致性，客户端发送请求到任何一个节点都能收到一致的返回，当一个节点出故障后，其他节点仍然能以已有的数据正常进行。在选主之后的复制日志就是为了达到这个目的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205420.png" alt></p>
<p>一开始，Leader 和 两个 Follower 都没有任何数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205438.png" alt></p>
<p>客户端发送请求给 Leader，储存数据 “sally”，Leader 先将数据写在本地日志，这时候数据还是 <strong>Uncommitted</strong> (还没最终确认，红色表示)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205539.png" alt></p>
<p>Leader 给两个 Follower 发送 AppendEntries 请求，数据在 Follower 上没有冲突，则将数据暂时写在本地日志，Follower 的数据也还是 Uncommitted。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205616.png" alt></p>
<p>Follower 将数据写到本地后，返回 OK。Leader 收到后成功返回，<strong>只要收到的成功的返回数量超过半数 (包含Leader)</strong>，Leader 将数据 “sally” 的状态改成 Committed。( 这个时候 Leader 就可以返回给客户端了)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205634.png" alt></p>
<p>Leader 再次给 Follower 发送 AppendEntries 请求，收到请求后，Follower 将本地日志里 Uncommitted 数据改成 Committed。这样就完成了一整个复制日志的过程，三个节点的数据是一致的，</p>
<h3><span id="32-network-partition-情况下进行复制日志">3.2 Network Partition 情况下进行复制日志</span></h3><p>在 Network Partition 的情况下，部分节点之间没办法互相通信，Raft 也能保证在这种情况下数据的一致性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205655.png" alt></p>
<p>一开始有 5 个节点处于同一网络状态下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205712.png" alt></p>
<p>Network Partition 将节点分成两边，一边有两个节点，一边三个节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205803.png" alt></p>
<p>两个节点这边已经有 Leader 了，来自客户端的数据 “bob” 通过 Leader 同步到 Follower。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205819.png" alt></p>
<p>因为只有两个节点，少于3个节点，所以 “bob” 的状态仍是 Uncommitted。所以在这里，<strong>服务器会返回错误给客户端</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205832.png" alt></p>
<p>另外一个 Partition 有三个节点，进行重新选主。客户端数据 “tom” 发到新的 Leader，通过和上节网络状态下相似的过程，同步到另外两个 Follower。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205851.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226205919.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210105.png" alt></p>
<p>因为这个 Partition 有3个节点，超过半数，所以数据 “tom” 都 Commit 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210129.png" alt></p>
<p>网络状态恢复，5个节点再次处于同一个网络状态下。但是这里出现了数据冲突 “bob” 和 “tom”</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210159.png" alt></p>
<p>三个节点的 Leader 广播 AppendEntries</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210245.png" alt></p>
<p>两个节点 Partition 的 Leader 自动降级为 Follower，因为这个 Partition 的数据 “bob” 没有 Commit，返回给客户端的是错误，客户端知道请求没有成功，所以 Follower 在收到 AppendEntries 请求时，可以把 “bob“ 删除，然后同步 ”tom”，通过这么一个过程，就完成了在 Network Partition 情况下的复制日志，保证了数据的一致性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210226210329.png" alt></p>
<h2><span id="小总结">小总结</span></h2><p>Raft 是能够实现分布式系统强一致性的算法，每个系统节点有三种状态 Follower，Candidate，Leader。实现 Raft 算法两个最重要的事是：选主和复制日志</p>
<p><strong>参考链接：</strong><br>Raft 官网：<a href="https://link.jianshu.com?t=https%3A%2F%2Fraft.github.io%2F">https://raft.github.io/</a></p>
<p>Raft 原理动画 (推荐看看)：<a href="https://link.jianshu.com?t=http%3A%2F%2Fthesecretlivesofdata.com%2Fraft%2F">http://thesecretlivesofdata.com/raft/</a></p>
<p>Raft 算法解析图片来源：<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fcoreos-analyse-etcd">http://www.infoq.com/cn/articles/coreos-analyse-etcd</a></p>
<p>分布式一致性与共识算法 <a href="https://draveness.me/consensus/">https://draveness.me/consensus/</a></p>
<p>共识算法：Raft <a href="https://www.jianshu.com/p/8e4bbe7e276c">https://www.jianshu.com/p/8e4bbe7e276c</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 跳表分析并用 Go 实现</title>
    <url>/e98e0a2b/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-跳表结构">1. 跳表结构</a></li>
<li><a href="#2-节点的插入">2. 节点的插入</a><ul>
<li><a href="#21-查找比s25小的最大节点">2.1. 查找比s2.5小的最大节点</a></li>
<li><a href="#22-插入节点s25">2.2. 插入节点s2.5</a></li>
</ul>
</li>
<li><a href="#3-删除节点">3. 删除节点</a><ul>
<li><a href="#32-查找比s3小的最大节点">3.2. 查找比s3小的最大节点</a></li>
<li><a href="#23-删除节点">2.3. 删除节点</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<p>redis的zset和set都使用跳表实现。跳表简单地说，就是在链表上构造多级索引，以加速查找，是用空间换时间。它比红黑树实现更简单，不需要耗费大量的精力维护树的平衡。跳表的各个节点是有顺序的，可以进行范围查询。</p>
<p>本文将分析跳表的构成、插入、删除等操作，并使用go实现。</p>
<h2><span id="1-跳表结构">1.  跳表结构</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503231105.png" alt></p>
<p>上图就是一个包含5个节点的跳表结构。跳表的结构包含一个又一个的节点，和header节点。header节点是查询的起始点。跳表定义如下，包含头结点、尾节点、长度以及跳表的索引层数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// skiplist 持有一个跳表的完整数据</span><br><span class="line">type skiplist struct &#123;</span><br><span class="line">  // header和tail表示跳表的头结点和尾节点</span><br><span class="line">  header, tail *skiplistNode</span><br><span class="line">  // length 表示跳表的长度</span><br><span class="line">  length int</span><br><span class="line">  // level 表示该跳表索引的层数</span><br><span class="line">  level int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面跳表的定义看不出什么，跳表每个节点的定义就有很多东西了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// skiplistLevel 表示skiplist每一节点在每一层持有的数据结构</span><br><span class="line">type skiplistLevel struct &#123;</span><br><span class="line">  // 该层节点的下一个节点，redis使用forward</span><br><span class="line">  next *skiplistNode</span><br><span class="line">  // 该层节点到下一节点中间间隔的跳数</span><br><span class="line">  span int</span><br><span class="line">&#125;</span><br><span class="line">// skiplistNode 表示skiplist的每一个节点</span><br><span class="line">type skiplistNode struct &#123;</span><br><span class="line">  // robj 代表该节点的数据</span><br><span class="line">  robj interface&#123;&#125;</span><br><span class="line">  // score 表示该节点的分数，以便排序</span><br><span class="line">  score float64</span><br><span class="line">  // prev 表示该节点的上一节点，redis 中使用backward</span><br><span class="line">  prev *skiplistNode</span><br><span class="line">  // levels 表示该节点在每一层索引中到下一节点的信息</span><br><span class="line">  levels []skiplistLevel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个节点中持有数据robj、该数据的分数score用来排序、上一节点的指针prev以便于反向遍历、各层索引信息levels。每一层的索引信息skiplistlevel包括该层索引中该节点指向的下一个节点的指针next、该节点到下一节点的间隔span。例如上图中，节点s2在第三层索引的下一节点是s4，而在第二层索引的下一节点是s3，而且间隔span分别是2和1。</p>
<p>每个节点的索引层数通过随机数生成，redis设计的思路：使用第n级索引是使用第n-1级索引概率的1/4，最多使用32级索引，如果真用到了32级索引，这个跳表所持有的数据也是巨大的，因此不用担心索引不够用。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func randomLevel() int &#123;</span><br><span class="line">  var level = 1</span><br><span class="line">    // SKIPLIST_P = 0.25</span><br><span class="line">  for rand.Float64() &lt; SKIPLIST_P &#123;</span><br><span class="line">    level ++</span><br><span class="line">  &#125;</span><br><span class="line">  if level &lt; SKIPLIST_MAXLEVEL &#123;</span><br><span class="line">    return level</span><br><span class="line">  &#125;</span><br><span class="line">  return SKIPLIST_MAXLEVEL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳表按照score和robj从小到大进行排序，因此它的各个节点是有序的，可以进行范围查找。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// compareObj 如果obj1&gt;obj2，返回true</span><br><span class="line">func compareObj(obj1, obj2 interface&#123;&#125;) bool &#123;</span><br><span class="line">  var t1, t2 reflect.Type</span><br><span class="line">  t1 = reflect.TypeOf(obj1)</span><br><span class="line">  t2 = reflect.TypeOf(obj2)</span><br><span class="line">  if t1.Kind() != t2.Kind() &#123;</span><br><span class="line">    compareObj(fmt.Sprint(obj1), fmt.Sprint(obj2))</span><br><span class="line">  &#125;</span><br><span class="line">  var v1, v2 reflect.Value</span><br><span class="line">  v1 = reflect.ValueOf(obj1)</span><br><span class="line">  v2 = reflect.ValueOf(obj2)</span><br><span class="line">  switch t1.Kind() &#123;</span><br><span class="line">  case reflect.Int:</span><br><span class="line">    return v1.Int() &gt; v2.Int()</span><br><span class="line">  case reflect.Float64, reflect.Float32:</span><br><span class="line">    return v1.Float() &gt; v2.Float()</span><br><span class="line">  case reflect.String:</span><br><span class="line">    return v1.String() &gt; v2.String()</span><br><span class="line">  &#125;</span><br><span class="line">  return compareObj(fmt.Sprint(obj1), fmt.Sprint(obj2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-节点的插入">2.  节点的插入</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503231517.png" alt></p>
<p>在链表中如果要插入一个节点S，需要找到在链表中比S小的最大节点F，把S挂在F节点后面。那么在跳表中也是这样的套路，只不过更复杂一些。下面分几步将上图中s2.5节点挂在s2后面，已知s2.5的score或者obj比s2的score或obj要大，但是小于s3。</p>
<h3><span id="21-查找比s25小的最大节点">2.1.  查找比s2.5小的最大节点</span></h3><p>在插入新节点之前，需要找到新节点可以插入的位置，就需要找出每一层索引中新节点的前一节点，这里就是比s2.5小的最大节点。跳表有五层索引，表示为0-4。跳表的起点是header，因此查找节点时需要从header的level 4开始进行，表示为header.levels[4]。代码中使用update[i]表示第i层索引中比s2.5小的最大节点指针。注意下面的代码还有一个rank数组，rank[i]就表示第i层索引中，update[i]节点到header的span，下面注意它是怎么增加的。</p>
<ol>
<li>从header.levels[4]开始向右遍历，此时rank[4]=0；header.levels[4]下一节点是s4比s2.5大，因此该层索引中s2.5的上一节点就是header，即update[4]=header，接下来向下进入第3层索引，即header.levels[3]</li>
<li>第3层索引中，初始rank[3] =rank[4]=0，向右遍历搜索到header的下一节点s2。s2就是这一层s2.5需要插入的位置的前一节点，因此update[3]=s2，rank[3]=rank[3]+header.levels[3].span=2，然后向下进入s2.levels[2]</li>
<li>依次遍历第2、1、0层索引，路径为s2.levels[2]-&gt;s2.levels[1]-&gt;s2.levels[0]，求得update[2]=update[1]=update[0]=s2，rank[2]=rank[1]=rank[0]=rank[3]=2。到这里，通过走楼梯的方式将s2.5需要插入的位置全找出来了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = sl.header</span><br><span class="line"> for i := sl.level-1; i &gt;= 0; i -- &#123;</span><br><span class="line">   if i == sl.level-1 &#123;</span><br><span class="line">     rank[i] = 0</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     rank[i] = rank[i+1]</span><br><span class="line">   &#125;</span><br><span class="line">   // 寻找比score和robj小的最近节点</span><br><span class="line">   for x.levels[i].next != nil &amp;&amp; (x.levels[i].next.score &lt; score ||</span><br><span class="line">         (x.levels[i].next.score == score &amp;&amp; compareObj(robj, x.levels[i].next.robj))) &#123;</span><br><span class="line">     rank[i] += x.levels[i].span</span><br><span class="line">     x = x.levels[i].next</span><br><span class="line">   &#125;</span><br><span class="line">   update[i] = x</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="22-插入节点s25">2.2.  插入节点s2.5</span></h3><p>现在有了update数组表示各层索引中s2.5的上一节点位置，以及rank数组表示update各节点到header的距离，就可以进行s2.5的插入了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var level = randomLevel()</span><br><span class="line">  // 代码1</span><br><span class="line">  if level &gt; sl.level &#123;</span><br><span class="line">    for i := sl.level; i &lt; level; i ++ &#123;</span><br><span class="line">      rank[i] = 0</span><br><span class="line">      update[i] = sl.header</span><br><span class="line">      update[i].levels[i].span = sl.length</span><br><span class="line">    &#125;</span><br><span class="line">    sl.level = level</span><br><span class="line">  &#125;</span><br><span class="line">  //-----</span><br><span class="line">  x = createSkiplistNode(level, score, robj)</span><br><span class="line">  // 代码2</span><br><span class="line">  for i := 0; i &lt; level; i ++ &#123;</span><br><span class="line">    x.levels[i].next = update[i].levels[i].next</span><br><span class="line">    update[i].levels[i].next = x</span><br><span class="line"></span><br><span class="line">    x.levels[i].span = update[i].levels[i].span - (rank[0]-rank[i])</span><br><span class="line">    update[i].levels[i].span = rank[0] - rank[1] + 1</span><br><span class="line">  &#125;</span><br><span class="line">  // -----</span><br><span class="line">  // 代码3</span><br><span class="line">  for i := level-1; i &lt; sl.level; i ++ &#123;</span><br><span class="line">    update[i].levels[i].span ++</span><br><span class="line">  &#125;</span><br><span class="line">  //-----</span><br><span class="line">  // 如果当前节点是插入的第一个节点，它的prev是nil</span><br><span class="line">  if update[0] == sl.header &#123;</span><br><span class="line">    x.prev = nil</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    x.prev = update[0]</span><br><span class="line">  &#125;</span><br><span class="line">  if x.levels[0].next != nil &#123;</span><br><span class="line">    x.levels[0].next.prev = x</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sl.tail = x</span><br><span class="line">  &#125;</span><br><span class="line">  sl.length ++</span><br></pre></td></tr></table></figure>



<ol>
<li><p>首先通过随机算法randomLevel()获取该节点的索引层数</p>
</li>
<li><p>现在有两种情况：level比跳表原来的层数sl.level要大或者level小于等于sl.level</p>
</li>
<li><ul>
<li>首先处理level&gt;sl.level的情况（代码1）。高于sl.level小于level的索引i中，s2.5的前一节点就直接是header，因此设置update[i]=header，同时rank[i]=0。header.levels[i].span设置为跳表的长度。设置sl.level=level。<ul>
<li>现在只有level&lt;=sl.level的情况了（代码2）。当索引i&lt;level时，直接将s2.5挂在update[i].levels[i]的后面，并更新update[i].levels[i]和s2.5.levels[i]的span</li>
<li>而在level&lt;=sl.level的情况（代码3），当level&lt;=索引i&lt;sl.level时，直接把update节点的span加一。因为此时新节点的索引层数level比跳表的层数少，那么新节点的插入对于比level高的索引节点来说就是将其与后面节点的距离增加了一个单位。</li>
</ul>
</li>
</ul>
</li>
<li><p>处理s2.5的prev指针，由上面的图也可以知道prev指针和第0层的索引是反向的，但是并不会指向header。这里我认为是为了方便反向遍历，如果s1.prev指向header，在反向遍历时需要加一层header的判断。</p>
</li>
<li><p>处理跳表的tail指针，如果插入的节点在最后，则重新设置tail</p>
</li>
<li><p>更新跳表长度</p>
</li>
</ol>
<h2><span id="3-删除节点">3.  删除节点</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210503231624.png" alt></p>
<p>上图中，如果想删除s3节点，需要两步：找到s3节点在各层索引处的上一节点；删除s3节点。</p>
<h3><span id="32-查找比s3小的最大节点">3.2.  查找比s3小的最大节点</span></h3><p>查找的算法依旧是从header的最高层索引开始下楼梯，并使用update数组保存每一层索引中s3的前一个节点。</p>
<p>在上图中：</p>
<ol>
<li>从header.levels[4]开始向右遍历，找不到其他的节点小于s3，因此向下遍历header.levels[3]，第4层的最大节点是header，即update[4]=header</li>
<li>依次类推，update[3]=s2，update[2]=s2，update[1]=update[0]=s2，遍历路径见图中的蓝色箭头。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 查找最近节点</span><br><span class="line">  x = sl.header</span><br><span class="line">  for i := sl.level-1; i &gt;= 0; i -- &#123;</span><br><span class="line">    for x.levels[i].next != nil &amp;&amp; (x.levels[i].next.score &lt; score || </span><br><span class="line">      (x.levels[i].next.score == score &amp;&amp; compareObj(robj, x.levels[i].next.robj))) &#123;</span><br><span class="line">      x = x.levels[i].next</span><br><span class="line">    &#125;</span><br><span class="line">    update[i] = x</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="23-删除节点">2.3.  删除节点</span></h3><p>删除节点就比较简单了，但是在这之前需要验证一下x指向的下一节点是不是需要删除的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// x之后的节点可能是需要删除的节点，也可能不是</span><br><span class="line">x = x.levels[0].next</span><br><span class="line">if x != nil &amp;&amp; x.score == score &amp;&amp; equalObj(x.robj, robj) &#123;</span><br><span class="line">  sl.deleteNode(update, x)</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在deleteNode中，进行如下删除步骤：</p>
<ol>
<li><p>对每一层的update[i]进行：</p>
</li>
<li><ul>
<li>如果update[i].levels[i]的下一节点是x，则进行x的删除，包括节点指针和span的改变<ul>
<li>如果update[i].levels[i]的下一节点不是x，例如：删除s3节点，它的update[4].levels[4]下一节点是s4，此时直接将update[4].levels[4]的span减一</li>
</ul>
</li>
</ul>
</li>
<li><p>将x的next节点（如果有的话）挂在x的prev节点后面</p>
</li>
<li><p>更新跳表的level值。以删除s4节点为例，删除完该节点之后跳表实际层数应该调整为3。从第4层开始向下遍历，如果header.levels[i].next是nil，说明该层索引已经没必要存在了，就将跳表的level减一</p>
</li>
<li><p>别忘了把跳表的length减一</p>
</li>
</ol>
<h2><span id="总结">总结</span></h2><p>跳表听起来挺难，如果仔细研究它的代码的话还是挺简单的。跳表主要难的地方就在于节点的插入和删除，只要理解了跳表的多级索引是怎么使用的，其他的操作：范围查询、查询排名等都比较简单了。这块的代码可以看redis的源码，在它的t_zset.c和redis.h中有zsl开头的代码就是跳表相关内容。不过我觉得更难的是写文档，写文档的时候需要阅读完代码之后理清思路，这块我发现通过画图还是可以加深理解的。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>sed替换含有路径的字符串</title>
    <url>/e4c7cf89/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#问题描述">问题描述</a></li>
<li><a href="#初级思路">初级思路</a></li>
<li><a href="#更好的解决方案">更好的解决方案</a></li>
</ul>
<!-- tocstop -->

<h3><span id="问题描述">问题描述</span></h3><p><code>sed -i &quot;s/old/new/g&quot; file.txt</code></p>
<p>如果 <code>new</code> 是个路径，即字符串中含有<code>/</code>，这么执行会报错</p>
<h3><span id="初级思路">初级思路</span></h3><p>把 <code>new</code> 中的 <code>/</code> 进行转义</p>
<p>比如 <code>new</code> 为 <code>/home/users/config.yaml</code></p>
<p>替换时</p>
<p><code>sed -i &quot;s/old/\/home\/users\/config.yaml/g&quot; file.txt</code></p>
<p>如果 <code>new</code> 是变量，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new=<span class="string">&quot;/home/users/config.yaml&quot;</span></span><br><span class="line">new_sed=$(<span class="built_in">echo</span> <span class="variable">$new</span> | sed -e <span class="string">&#x27;s/\//\\\//g&#x27;</span>)</span><br><span class="line">sed -i <span class="string">&quot;s/old/<span class="variable">$&#123;new_sed&#125;</span>/g&quot;</span> file.txt</span><br></pre></td></tr></table></figure>



<h3><span id="更好的解决方案">更好的解决方案</span></h3><p>转义会降低可读性，只需用其他特殊字符作为<code>sed</code>表达式的“分隔符”（取代默认的<code>/</code>）即可。<br>例如：<code>sed &#39;s#\$CONFIG#/home/users/config.yaml#g&#39;</code>，使用<code>#</code>代替<code>/</code>从而避免大量转义。</p>
<p>你可以尝试一下 <code>echo aabbccdd | sed &#39;s#aa#bb#g&#39; | sed &#39;s?bb?cc?g&#39; | sed &#39;s@cc@dd@g&#39; | sed &#39;s%dd%ee%g&#39;</code>  用任意字符作间隔</p>
<p>这是 <code>sed</code> 命令方便用户的一个特性，<code>vim</code> 中的 <code>:s</code> 也同样支持</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>split命令</title>
    <url>/aa4c47b6/</url>
    <content><![CDATA[<h3><span id="选项">选项</span></h3><pre><code>-b 值为每一个输出档案的大小, 单位为byte
-C 每一个输出档中, 单行的最大byte 数
-d 使用数字作为后缀
-l 值为每一个输出档的行数大小</code></pre><h3><span id="实例">实例</span></h3><p>生成一个大小为100KB 的测试文件</p>
<pre><code>dd if=/dev/zero bs=100k count=1 of=date.file
1+0 records in
1+0 records out
102400 bytes (102 kB) copied, 0.00043 seconds, 238 MB/s</code></pre><p>使用split 命令将上面创建的date.file文件分割成大小为10KB 的小文件</p>
<pre><code>$ split -b 10k date.file
$ ls
date.file  xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj</code></pre><p>文件被分割成带有字母的后缀文件, 如果想用数字后缀可使用<code>-d</code>参数, 同时可以使用<code>-a length</code>指定后缀的长度</p>
<pre><code>[root@localhost split]# split -b 10k date.file -d -a 3
[root@localhost split]# ls
date.file  x000  x001  x002  x003  x004  x005  x006  x007  x008  x009</code></pre><p>为分割后的文件指定文件名的前缀</p>
<pre><code>[root@localhost split]# split -b 10k date.file -d -a 3 split_file
[root@localhost split]# ls
date.file  split_file000  split_file001  split_file002  split_file003  split_file004  split_file005  split_file006  split_file007  split_file008  split_file009</code></pre><p>使用<code>-l</code>选项根据文件的行数来分割文件,如把文件分割成每个包含10行的小文件</p>
<pre><code>split -l 10 date.file</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>strict weak ordering</title>
    <url>/22f34ac7/</url>
    <content><![CDATA[<p>A strict weak ordering is a <em>binary relation</em> &lt; on a set S that is a strict partial order (a transitive relation that is irreflexive, or equivalently, that is asymmetric) in which the relation <code>neither a &lt; b nor b &lt; a</code> is transitive. Therefore, a strict weak ordering has the following properties:</p>
<ul>
<li>For all x in S, it is not the case that x &lt; x (irreflexivity).</li>
<li>For all x, y in S, if x &lt; y then it is not the case that y &lt; x (asymmetry).</li>
<li>For all x, y, z in S, if x &lt; y and y &lt; z then x &lt; z (transitivity).</li>
<li>For all x, y, z in S, if x is incomparable with y (neither x &lt; y nor y &lt; x hold), and y is incomparable with z, then x is incomparable with z (transitivity of incomparability).</li>
</ul>
<p>This list of properties is somewhat redundant, as asymmetry follows readily from irreflexivity and transitivity.</p>
<p><strong>离散数学中的relation:</strong> Given a function f (which models a binary relation) over a domain D, and a, b ∈ D:</p>
<ul>
<li>Reflexivity: f (a, a) is true.</li>
<li>Asymmetry: For a ≠ b, if f(a, b) is true, f(b,a) is false</li>
<li>Anti-symmetry: If f(a, b) and f(b, a) are both true iff a ≡ b</li>
<li>Transitivity: If f(a, b) and f(b, c) are true, then f(a, c) is true</li>
<li>Incomparability: Neither f(a, b) nor f(b, a) is true</li>
<li>Transitivity of incomparability: If a and b are incomparable, and so are b and c, then a and c are incomparable.</li>
</ul>
<p>摘自WikiPedia</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map笔记</title>
    <url>/d97ca7/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p>unordered_map与map的区别 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。 而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。 用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator== 或者hash_value()了。 最后，说，当不需要结果排好序时，最好用unordered_map。</p>
<p>linux下使用 普通的key就不说了和map一样 看一下用sockaddr_in 作为key的方法</p>
<pre><code>#ifndef CSESSION_H  
#define CSESSION_H  

#include &lt;netinet in.h=&quot;&quot;&gt;
#include &lt;time.h&gt;
#include &lt;/time.h&gt;&lt;/netinet&gt;

&lt;map&gt;
#include &lt;string.h&gt;
#include &lt;tr1 unordered_map=&quot;&quot;&gt;  //头文件
#include &lt;iostream&gt;

using namespace std;
using namespace std::tr1;

struct Terminal
&#123;
int             nid ; //id  the key for terminal
sockaddr_in     addr; //ip  the key for Client
time_t          tm;   //last alive time
enTerminalStat  enStat;//status
Terminal();
~Terminal();
Terminal &amp;amp;operator =(const Terminal&amp;amp; term);
&#125;;

struct hash_func  //hash 函数
&#123;
size_t operator()(const sockaddr_in &amp;amp;addr) const
&#123;
return addr.sin_port*9999 + addr.sin_addr.s_addr;
&#125;
&#125;;
struct cmp_fun //比较函数 ==
&#123;
bool operator()(const sockaddr_in &amp;amp;addr1, const sockaddr_in &amp;amp;addr2) const
&#123;
return memcmp(&amp;amp;addr1, &amp;amp;addr2, sizeof(sockaddr_in)) == 0 ? true:false;
&#125;
&#125;;

//typedef unordered_map&lt;int,terminal*&gt; MapTerminal; // Terminal socket 作为key
//typedef unordered_map&lt;int,terminal*&gt;::iterator MapTerminal_It; //  &lt;/int,terminal*&gt;&lt;/int,terminal*&gt;

typedef unordered_map&lt;sockaddr_in, terminal*,hash_func,=&quot;&quot; cmp_fun=&quot;&quot;&gt; MapClientSession; // sockaddr_in作为key
typedef unordered_map&lt;sockaddr_in, terminal*,hash_func,=&quot;&quot; cmp_fun=&quot;&quot;&gt;::iterator MapClientSession_It; //  &lt;/sockaddr_in,&gt;&lt;/sockaddr_in,&gt;

#endif // CSESSION_H</code></pre><p><code>operator==</code>有两种方式 一种是</p>
<pre><code>struct st
&#123;
bool operator==(const st &amp;amp;s) const
...
&#125;；</code></pre><p>另一种就是自定义函数体，代码中</p>
<pre><code>struct cmp_fun
&#123;
bool operator()(...)
...
&#125;</code></pre><p>必须要自定义<code>operator==</code>和<code>hash_value</code>。 重载<code>operator==</code>是因为，如果两个元素的<code>hash_value</code>的值相同，并不能断定这两个元素就相同，必须再调用<code>operator==</code>。 当然，如果<code>hash_value</code>的值不同，就不需要调用<code>operator==</code>了。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_set笔记</title>
    <url>/14decfad/</url>
    <content><![CDATA[<p><a href="http://www.cplusplus.com/reference/unordered_set/unordered_set/">http://www.cplusplus.com/reference/unordered_set/unordered_set/</a></p>
<!-- toc -->



<!-- tocstop -->

<p><strong>unordered_set</strong> 模板原型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,  </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = hash&lt;key&gt;,</span><br><span class="line">	<span class="keyword">class</span> Pred = equal_to&lt;key&gt;,</span><br><span class="line">	<span class="keyword">class</span> Alloc = allocator&lt;key&gt;</span><br><span class="line">	&gt; <span class="keyword">class</span> unordered_set;</span><br></pre></td></tr></table></figure>

<p>当比较unordered_set中某两个元素时, 先调用<code>hash&lt;key&gt;</code>, 如果<code>hash&lt;key&gt;</code>  不相等, 说明两个元素不同, 如果<code>hash&lt;key&gt;</code> 值相等, 则调用<code>equal_to&lt;key&gt;</code>, 判断两个元素是否完全相等. (Hash函数和Compare函数都可以自定义)</p>
<p>C++ 11中对unordered_set描述大体如下：无序集合容器（unordered_set）是一个存储唯一(unique，即无重复）的关联容器（Associative container），容器中的元素无特别的秩序关系，该容器允许基于值的快速元素检索，同时也支持正向迭代。<br>在一个unordered_set内部，元素不会按任何顺序排序，而是通过元素值的hash值将元素分组放置到各个槽(Bucker，也可以译为“桶”），这样就能通过元素值快速访问各个对应的元素（均摊耗时为O（1））。<br>原型中的Key代表要存储的类型，而hash<key>也就是你的hash函数，equal_to<key>用来判断两个元素是否相等，allocator<key>是内存的分配策略。一般情况下，我们只关心hash<key>和equal_to<key>参数，下面将介绍这两部分。</key></key></key></key></key></p>
<p><strong><code>hash&lt;key&gt;</code></strong><br><code>hash&lt;key&gt;</code>通过相应的hash函数，将传入的参数转换为一个size_t类型值，然后用该值对当前hashtable的bucket取模算得其对应的hash值。而C++标准库，为我们提供了基本数据类型的hash函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Primary class template hash. template struct hash;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Partial specializations for pointer types. template struct hash&lt;\_Tp*&gt; : public \_\_hash\_base&lt;size\_t, \_tp*=&quot;&quot;&gt; &#123; size\_t operator()(\_Tp* \_\_p) const noexcept &#123; return reinterpret_cast(__p); &#125; &#125;; &lt;/size_t,&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Explicit specializations for integer types.</span></span><br><span class="line"></span><br><span class="line">define \_Cxx\_hashtable\_define\_trivial\_hash(\_Tp) \</span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; \ <span class="keyword">struct</span> hash&lt;\_Tp&gt; : <span class="keyword">public</span> \_\_hash\_base&lt;size\<span class="type">_t</span>, \_tp=<span class="string">&quot;&quot;</span>&gt; \ &#123; \ size\<span class="type">_t</span> \ <span class="built_in">operator</span>()(\_Tp \_\_val) <span class="type">const</span> <span class="keyword">noexcept</span> \ &#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>(__val); &#125; \ &#125;; &lt;/<span class="type">size_t</span>,&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for bool. \_Cxx\_hashtable\_define\_trivial_hash(bool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for char. \_Cxx\_hashtable\_define\_trivial_hash(char)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for signed char. \_Cxx\_hashtable\_define\_trivial_hash(signed char)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for unsigned char. \_Cxx\_hashtable\_define\_trivial_hash(unsigned char)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for wchar\_t. \_Cxx\_hashtable\_define\_trivial\_hash(wchar_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for char16\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char16_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for char32\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char32_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for short. \_Cxx\_hashtable\_define\_trivial_hash(short)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for int. \_Cxx\_hashtable\_define\_trivial_hash(int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for long. \_Cxx\_hashtable\_define\_trivial_hash(long)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for long long. \_Cxx\_hashtable\_define\_trivial_hash(long long)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for unsigned short. \_Cxx\_hashtable\_define\_trivial_hash(unsigned short)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for unsigned int. \_Cxx\_hashtable\_define\_trivial_hash(unsigned int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for unsigned long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Explicit specialization for unsigned long long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long long)</span></span><br></pre></td></tr></table></figure>



<p>   对于指针类型，标准库只是单一将地址转换为一个size_t值作为hash值，这里特别需要注意的是<code>char *</code>类型的指针，其标准库提供的hash函数只是将指针所指地址转换为一个sieze_t值，如果，你需要用<code>char *</code>所指的内容做hash，那么，你需要自己写hash函数或者调用系统提供的<code>hash&lt;string&gt;</code>。<br>标准库为string类型对象提供了一个hash函数，即：Murmur hash，。对于float、double、long double标准库也有相应的hash函数，这里，不做过多的解释，相应的可以参看functional_hash.h头文件。<br>上述只是介绍了基本数据类型，而在实际应用中，有时，我们需要使用自己写的hash函数，那怎么自定义hash函数？参考标准库基本数据类型的hash函数，我们会发现这些hash函数有个共同的特点：通过定义函数对象，实现相应的hash函数，这也就意味我们可以通过自定义相应的函数对象，来实现自定义hash函数。比如：已知平面上有N，每个点的x轴、y轴范围为[0，100]，现在需要统计有多少个不同点？hash函数设计为：将每个点的x、y值看成是101进制，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits\stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myHash</span>   </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; __val)</span> <span class="type">const</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(__val.first * <span class="number">101</span> + __val.second);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    unordered_set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, myHash&gt; S;  </span><br><span class="line">    <span class="type">int</span> x, y;  </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)  </span><br><span class="line">        S.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x, y));  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = S.<span class="built_in">begin</span>(); it != S.<span class="built_in">end</span>(); ++it)  </span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><strong><code>equal_to&lt;key&gt;</code></strong><br>该参数用于实现比较两个关键字是否相等，至于为什么需要这个参数？这里做点解释，前面我们说过，当不同关键字，通过hash函数，可能会得到相同的关键字值，每当我们在unordered_set里面做数据插入、删除时，由于unordered_set关键字唯一性，所以我们得确保唯一性。标准库定义了基本类型的比较函数，而对于自定义的数据类型，我们需要自定义比较函数。这里有两种方法:重载==操作符和使用函数对象，下面是STL中实现<code>equal_to&lt;key&gt;</code>的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg, <span class="keyword">typename</span> _Result&gt;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">unary_function</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="comment">/// @c argument_type is the type of the argument  </span></span><br><span class="line">      <span class="keyword">typedef</span> _Arg  argument_type;     </span><br><span class="line"></span><br><span class="line">      <span class="comment">/// @c result_type is the return type  </span></span><br><span class="line">      <span class="keyword">typedef</span> _Result   result_type;    </span><br><span class="line">    &#125;;  </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">equal_to</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;  </span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="function"><span class="type">bool</span>  </span></span><br><span class="line"><span class="function">      <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span>  </span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> __x == __y; &#125;  </span><br><span class="line">    &#125;; </span><br></pre></td></tr></table></figure>



<p><strong>扩容与缩容</strong> </p>
<p>在vector中，每当我们插入一个新元素时，如果当前的容量（capacity)已不足，需要向系统申请一个更大的空间，然后将原始数据拷贝到新空间中。这种现象在unordered_set中也存在，比如当前的表长为100，而真实存在表中的数据已经大于1000个元素，此时，每个bucker均摊有10个元素，这样就会影响到unordered_set的存取效率，而标准库通过采用某种策略来对当前空间进行扩容，以此来提高存取效率。当然，这里也存在缩容，原理和扩容类似，不过，需要注意的是，每当unordered_set内部进行一次扩容或者缩容，都需要对表中的数据重新计算，也就是说，扩容或者缩容的时间复杂度至少为。</p>
<p> code：</p>
<pre><code>// unordered_set::find
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;  &lt;/unordered_set&gt;&lt;/string&gt;&lt;/iostream&gt;

int main ()
&#123;
std::unordered_set&lt;std::string&gt; myset = &#123; &quot;red&quot;,&quot;green&quot;,&quot;blue&quot; &#125;;  &lt;/std::string&gt;

std::string input;
std::cout &amp;lt;&amp;lt; &quot;color? &quot;;  
  getline (std::cin,input);  

  std::unordered_set&lt;std::string&gt;::const_iterator got = myset.find (input);  &lt;/std::string&gt;

if ( got == myset.end() )
std::cout &amp;lt;&amp;lt; &quot;not found in myset&quot;;  
  else  
    std::cout &amp;lt;&amp;lt; *got &amp;lt;&amp;lt; &quot; is in myset&quot;;  

  std::cout &amp;lt;&amp;lt; std::endl;  

  return 0;  
&#125;</code></pre>]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>x == x</title>
    <url>/72da8a18/</url>
    <content><![CDATA[<p>C的表达式 x == x，何时为假呢？即下面的代码：</p>
<pre><code>if (x == x)
&#123;
printf(&quot;Equal\n&quot;);
&#125;
else
&#123;
printf(&quot;Not equal\n&quot;);
&#125;</code></pre><p>什么时候输出为”Not equal”呢？</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;&lt;/string.h&gt;&lt;/stdio.h&gt;&lt;/stdlib.h&gt;

int main(void)
&#123;
float x = 0xffffffff;

if (x == x)
&#123;
printf(&quot;Equal\n&quot;);
&#125;
else
&#123;
printf(&quot;Not equal\n&quot;);
&#125;

if (x &amp;gt;= 0)
&#123;
printf(&quot;x(%f) &amp;gt;= 0\n&quot;, x);
&#125;
else if (x &amp;lt; 0) 
    &#123;
        printf(&quot;x(%f) &amp;lt; 0\n&quot;, x);
    &#125;

    int a = 0xffffffff;
    memcpy(&amp;amp;x, &amp;amp;a, sizeof(x));
    if (x == x) 
    &#123;
        printf(&quot;Equal\n&quot;);
    &#125;
    else 
    &#123;
        printf(&quot;Not equal\n&quot;);
    &#125;

    if (x &amp;gt;= 0)
&#123;
printf(&quot;x(%f) &amp;gt;= 0\n&quot;, x);
&#125;
else if (x &amp;lt; 0) 
    &#123;
        printf(&quot;x(%f) &amp;lt; 0\n&quot;, x);
    &#125;
    else 
    &#123;
        printf(&quot;Surprise x(%f)!!!\n&quot;, x);
    &#125;

    return 0;
&#125;</code></pre><p>编译<code>gcc -g -Wall test.c</code>，看执行结果：</p>
<pre><code>$ ./a.out
Equal
x(4294967296.000000) &amp;gt;= 0
Not equal
Surprise x(-nan)!!!</code></pre><p>最后两行输出是不是有点surprise啊。</p>
<p>下面先简单解释一下： 1. 当<code>float x = 0xffffffff</code>：这时将整数赋给一个浮点数，由于float和int的size都是4，而浮点数的存储格式与整数不同，其需要将某些位作为小数位，所以float的范围要小于int的范围。因此这里涉及到了整数转换浮点的规定。因为这个转换其实很少用到，我也就不查了。但是总之，这个转换是合法的。但是最终的值很可能不是你想要的结果——尤其是当浮点的范围小于整数的范围时。 2. 即使整数转换成浮点，数值再不是期望值，但它也一定是一个合法的浮点数值。所以第一个<code>x == x</code>，一定为true，且x不是大于0，就是小于0。这时x存的并不是0xffffffff。 3. 当使用memcpy将0xff填充到x的地址时，这时x存的保证为0xffffffff。但是这个不是一个合法的float的值。因此奇怪的现象发生了，x并不等于x。原因则是与cpu的浮点指令相关. 4. 作为一个非法的float值，当它与其它任何数值比较时，都会返回false。这也就造成了，后面惊奇的结果，x既不大于等于0，也不小于0。</p>
<p>总结一下：一般来说，浮点类型很少被使用，也不应该在程序中鼓励使用。不仅其效率比整数低，且由于浮点类型特殊的存储格式，很容易造成一些意想不到的错误。如果真的无法避免时，一定要小心小心再小心。特别要注意今天的主题，这种非法的浮点值，会导致任何比较判断都失败。而判断这种浮点值的方法也很简单，如果<code>x != x</code>，那么该浮点即为非法浮点值。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>xargs</title>
    <url>/38dfadad/</url>
    <content><![CDATA[<p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>
<p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p>
<p>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p>
<p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p>
<p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /sbin -perm 700 |ls -l       #这个命令是错误的</span><br><span class="line">find /sbin -perm 700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure>

<p><strong>命令格式</strong><br><code>somecommand |xargs -item command</code></p>
<p><strong>重要参数:</strong></p>
<ul>
<li>-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</li>
</ul>
<p><strong>其他参数:</strong></p>
<ul>
<li>-a file 从文件中读入作为sdtin</li>
<li>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li>
<li>-p 当每次执行一个argument的时候询问一次用户。</li>
<li>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</li>
<li>-t 表示先打印命令，然后再执行。</li>
<li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</li>
<li>-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li>
<li>-L num 从标准输入一次读取 num 行送给 command 命令。</li>
<li>-l 同 -L。</li>
<li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li>
<li>-x exit的意思，主要是配合-s使用。。</li>
<li>-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</li>
</ul>
<h4><span id="实例">实例:</span></h4><h5><span id="1-多行变成单行">1. 多行变成单行</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat test.txt</span><br><span class="line"></span><br><span class="line">a b c d e f g</span><br><span class="line">h i j k l m n</span><br><span class="line">o p q</span><br><span class="line">r s t</span><br><span class="line">u v w x y z</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat test.txt | xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>



<h5><span id="2-一次使用n个参数">2. 一次使用n个参数</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat test.txt | xargs -n3</span><br><span class="line"></span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure>

<h5><span id="3-d选项指定分隔符">3. d选项指定分隔符</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX</span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>

<p>结合<code>-n</code> 选项使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span><br><span class="line"></span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure>

<h5><span id="4-i选项的使用">4. I选项的使用</span></h5><h6><span id="41-获取参数并替换123125">4.1 获取参数并替换<code>&#123;&#125;</code></span></h6><p>假设一个命令为 <a href="http://sk.sh/">sk.sh</a> 和一个保存参数的文件 arg.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#sk.sh命令内容，打印出所有参数。</span><br><span class="line"></span><br><span class="line">echo $*</span><br></pre></td></tr></table></figure>

<p>arg.txt.文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat arg.txt</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<p><code>xargs</code> 的一个选项 <code>-I</code>，使用 <code>-I</code> 指定一个替换字符串 <code>&#123;&#125;</code>，这个字符串在 <code>xargs</code> 扩展时会被替换掉，当 <code>-I</code> 与 <code>xargs</code> 结合使用，每一个参数命令都会被执行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat arg.txt | xargs -I &#123;&#125; ./sk.sh sombefore &#123;&#125; someafter</span><br><span class="line"></span><br><span class="line">sombefore aaa someafter</span><br><span class="line">sombefore bbb someafter</span><br><span class="line">sombefore ccc someafter</span><br></pre></td></tr></table></figure>

<h6><span id="42-复制文件实例">4.2 复制文件实例</span></h6><p>复制所有图片文件到 /data/images 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images/</span><br></pre></td></tr></table></figure>

<h6><span id="43-xargs-结合find-使用">4.3 xargs 结合find 使用</span></h6><p>用 rm 删除太多的文件时候，可能得到一个错误信息：<code>/bin/rm Argument list too long.</code> 用 xargs 去避免这个问题：</p>
<p><code>find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f</code> xargs -0 将 \0 作为定界符。</p>
<p>统计一个源代码目录中所有 php 文件的行数： <code>find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</code></p>
<p>查找所有的 jpg 文件，并且压缩它们： <code>find . -type f -name &quot;*.jpg&quot; -print | xargs tar -czvf images.tar.gz</code></p>
<h6><span id="44-下载多个文件">4.4 下载多个文件</span></h6><p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接： <code># cat url-list.txt | xargs wget -c</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】了解一下 Fossil，一个 Git 的替代品</title>
    <url>/ff3c9770/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#安装-fossil">安装 Fossil</a></li>
<li><a href="#创建一个-fossil-仓库">创建一个 Fossil 仓库</a></li>
<li><a href="#fossil-仓库工作流">Fossil 仓库工作流</a><ul>
<li><a href="#添加文件">添加文件</a></li>
<li><a href="#使用分支">使用分支</a></li>
<li><a href="#合并修改">合并修改</a></li>
</ul>
</li>
<li><a href="#查看-fossil-时间线">查看 Fossil 时间线</a></li>
<li><a href="#公开你的-fossil-仓库">公开你的 Fossil 仓库</a></li>
<li><a href="#使用-fossil-作为独立的托管">使用 Fossil 作为独立的托管</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>Fossil 是一个集版本控制系统、bug 追踪、维基、论坛以及文档解决方案于一体的系统。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103215724.png" alt></p>
<p>每个开发者都知道，追踪代码的修改是至关重要的。有时候你会处于好奇或者教育的目的需要展示你的项目开始和进化的历史。有时候你想让其他的开发者参与到你的项目中，因此你需要一种值得信赖的能合并不同代码分支的方法。更极端一点，有时候你为了解决一个问题而修改的代码导致已有的功能不能正常使用。</p>
<p><a href="https://fossil-scm.org/home/doc/trunk/www/index.wiki">Fossil</a> 源码管理系统是由著名的 <a href="https://www.sqlite.org/index.html">SQLite</a> 数据库的作者开发的一个集版本控制系统、bug 追踪、维基、论坛以及文档解决方案于一体的系统。</p>
<h3><span id="安装-fossil">安装 Fossil</span></h3><p>Fossil 是一个独立的 C 程序，因此你可以从它的网站上<a href="https://fossil-scm.org/home/uv/download.html">下载</a>后放在环境变量 <a href="https://opensource.com/article/17/6/set-path-linux">PATH</a> 中的任意位置。例如，假定 <code>/usr/local/bin</code> 已经在你的环境变量中（默认情况下是在的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget https://fossil-scm.org/home/uv/fossil-linux-x64-X.Y.tar.gz</span><br><span class="line">$ sudo tar xvf fossil-linux-x64-X.Y.tar.gz --directory /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>你也可以通过包管理器从软件仓库中找到 Fossil，或者直接从源码编译。</p>
<h3><span id="创建一个-fossil-仓库">创建一个 Fossil 仓库</span></h3><p>如果你已经有一个代码项目，想用 Fossil 来追踪，那么第一步就是创建一个 Fossil 仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil init myproject.fossil</span><br><span class="line">project-id: 010836ac6112fefb0b015702152d447c8c1d8604</span><br><span class="line">server-id:  54d837e9dc938ba1caa56d31b99c35a4c9627f44</span><br><span class="line">admin-user: klaatu (initial password is &quot;14b605&quot;)</span><br></pre></td></tr></table></figure>

<p>创建 Fossil 仓库的过程中会返回三行信息：一个唯一的项目 ID、一个唯一的服务器 ID 以及管理员 ID 和密码。项目 ID 和服务器 ID 是版本数字。管理员凭证表明你对这个仓库的所有权，当你把 Fossil 作为服务器让其他用户来访问时可以使用管理员权限。</p>
<h3><span id="fossil-仓库工作流">Fossil 仓库工作流</span></h3><p>在你使用 Fossil 仓库之前，你需要先为它的数据创建一个工作路径。你可以把这个过程类比为使用 Python 时创建一个虚拟环境或者解压一个只用来备份的 ZIP 文件。</p>
<p>创建一个工作目录并进入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir myprojectdir</span><br><span class="line">$ cd myprojectdir</span><br></pre></td></tr></table></figure>

<p>把你的 Fossil 打开到刚刚创建的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil open ../myproject</span><br><span class="line">project-name: &lt;unnamed&gt;</span><br><span class="line">repository:   /home/klaatu/myprojectdir/../myproject</span><br><span class="line">local-root:   /home/klaatu/myprojectdir/</span><br><span class="line">config-db:    /home/klaatu/.fossil</span><br><span class="line">project-code: 010836ac6112fefb0b015702152d447c8c1d8604</span><br><span class="line">checkout:     9e6cd96dd675544c58a246520ad58cdd460d1559 2020-11-09 04:09:35 UTC</span><br><span class="line">tags:         trunk</span><br><span class="line">comment:      initial empty check-in (user: klaatu)</span><br><span class="line">check-ins:    1</span><br></pre></td></tr></table></figure>

<p>你可能注意到了，Fossil 在你的家目录下创建了一个名为 <code>.fossil</code> 的隐藏文件，用来追踪你的全局 Fossil 配置。这个配置不是只适用于你的一个项目的；这个文件只会在你第一次使用 Fossil 时生成。</p>
<h4><span id="添加文件">添加文件</span></h4><p>使用 <code>add</code> 和 <code>commit</code> 子命令来向你的仓库添加文件。例如，创建一个简单的 <code>README</code> 文件，把它添加到仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;My first Fossil project&quot; &gt; README</span><br><span class="line">$ fossil add README</span><br><span class="line">ADDED  README</span><br><span class="line">$ fossil commit -m &#x27;My first commit&#x27;</span><br><span class="line">New_Version: 2472a43acd11c93d08314e852dedfc6a476403695e44f47061607e4e90ad01aa</span><br></pre></td></tr></table></figure>

<h4><span id="使用分支">使用分支</span></h4><p>Fossil 仓库开始时默认使用的主分支名为 <code>trunk</code>。当你想修改代码而又不影响主干代码时，你可以从 trunk 分支切走。创建新分支需要使用 <code>branch</code> 子命令，这个命令需要两个参数：一个新分支的名字，一个新分支的基分支名字。在本例中，只有一个分支 <code>trunk</code>，因此尝试创建一个名为 <code>dev</code> 的新分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil branch --help</span><br><span class="line">Usage: fossil branch new BRANCH-NAME BASIS ?OPTIONS?</span><br><span class="line">$ fossil branch new dev trunk</span><br><span class="line">New branch: cb90e9c6f23a9c98e0c3656d7e18d320fa52e666700b12b5ebbc4674a0703695</span><br></pre></td></tr></table></figure>

<p>你已经创建了一个新分支，但是你当前所在的分支仍然是 <code>trunk</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil branch current</span><br><span class="line">trunk</span><br></pre></td></tr></table></figure>

<p>使用 <code>checkout</code> 命令切换到你的新分支 <code>dev</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil checkout dev</span><br><span class="line">dev</span><br></pre></td></tr></table></figure>

<h4><span id="合并修改">合并修改</span></h4><p>假设你在 <code>dev</code> 分支中添加了一个新文件，完成了测试，现在想把它合并到 <code>trunk</code>。这个过程叫做<em>合并</em>。</p>
<p>首先，切回目标分支（本例中目标分支为 <code>trunk</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil checkout trunk</span><br><span class="line">trunk</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure>

<p>这个分支中没有你的新文件（或者你对其他文件的修改），而那些内容是合并的过程需要的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil merge dev</span><br><span class="line"> &quot;fossil undo&quot; is available to undo changes to the working checkout.</span><br><span class="line">$ ls</span><br><span class="line">myfile.lua  README</span><br></pre></td></tr></table></figure>

<h3><span id="查看-fossil-时间线">查看 Fossil 时间线</span></h3><p>使用 <code>timeline</code> 选项来查看仓库的历史。这个命令列出了你的仓库的所有活动的详细信息，包括用来表示每次修改的哈希值、每次提交时填写的信息以及提交者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil timeline</span><br><span class="line">=== 2020-11-09 ===</span><br><span class="line">06:24:16 [5ef06e668b] added exciting new file (user: klaatu tags: dev)</span><br><span class="line">06:11:19 [cb90e9c6f2] Create new branch named &quot;dev&quot; (user: klaatu tags: dev)</span><br><span class="line">06:08:09 [a2bb73e4a3] *CURRENT* some additions were made (user: klaatu tags: trunk)</span><br><span class="line">06:00:47 [2472a43acd] This is my first commit. (user: klaatu tags: trunk)</span><br><span class="line">04:09:35 [9e6cd96dd6] initial empty check-in (user: klaatu tags: trunk)</span><br><span class="line">+++ no more data (5) +++</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103215802.png" alt="Fossil UI" title="Fossil UI"></p>
<h3><span id="公开你的-fossil-仓库">公开你的 Fossil 仓库</span></h3><p>因为 Fossil 有个内置的 web 界面，所以 Fossil 不像 GitLab 和 Gitea 那样需要主机服务。Fossil 就是它自己的主机服务，只要你把它放在一台机器上就行了。在你公开你的 Fossil 仓库之前，你还需要通过 web 用户界面（UI）来配置一些信息：</p>
<p>使用 <code>ui</code> 子命令启动一个本地的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/home/klaatu/myprojectdir/</span><br><span class="line">$ fossil ui</span><br></pre></td></tr></table></figure>

<p>“Users” 和 “Settings” 是安全相关的，“Configuration” 是项目属性相关的（包括一个合适的标题）。web 界面不仅仅是一个方便的功能。 它是能在生产环境中使用并作为 Fossil 项目的宿主机来使用的。它还有一些其他的高级选项，比如用户管理（或者叫自我管理）、在同一个服务器上与其他的 Fossil 仓库进行单点登录（SSO）。</p>
<p>当配置完成后，关掉 web 界面并按下 <code>Ctrl+C</code> 来停止 UI 引擎。像提交代码一样提交你的 web 修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil commit -m &#x27;web ui updates&#x27;</span><br><span class="line">New_Version: 11fe7f2855a3246c303df00ec725d0fca526fa0b83fa67c95db92283e8273c60</span><br></pre></td></tr></table></figure>

<p>现在你可以配置你的 Fossil 服务器了。</p>
<ol>
<li>把你的 Fossil 仓库（本例中是 <code>myproject.fossil</code>）复制到服务器，你只需要这一个文件。</li>
<li>如果你的服务器没有安装 Fossil，就在你的服务器上安装 Fossil。在服务器上安装的过程跟在本地一样。</li>
<li>在你的 <code>cgi-bin</code> 目录下（或它对应的目录，这取决于你的 HTTP 守护进程）创建一个名为 <code>repo_myproject.cgi</code> 的文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/local/bin/fossil</span><br><span class="line">repository: /home/klaatu/public_html/myproject.fossil</span><br></pre></td></tr></table></figure>

<p>添加可执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod +x repo_myproject.cgi</span><br></pre></td></tr></table></figure>

<p>你需要做的都已经做完了。现在可以通过互联网访问你的项目了。</p>
<p>你可以通过 CGI 脚本来访问 web UI，例如 <code>https://example.com/cgi-bin/repo_myproject.cgi</code>。</p>
<p>你也可以通过命令行来进行交互：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil clone https://klaatu@example.com/cgi-bin/repo_myproject.cgi</span><br></pre></td></tr></table></figure>

<p>在本地的克隆仓库中工作时，你需要使用 <code>push</code> 子命令把本地的修改推送到远程的仓库，使用 <code>pull</code> 子命令把远程的修改拉取到本地仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fossil push https://klaatu@example.com/cgi-bin/repo_myproject.cgi</span><br></pre></td></tr></table></figure>

<h3><span id="使用-fossil-作为独立的托管">使用 Fossil 作为独立的托管</span></h3><p>Fossil 将大量的权力交到了你的手中（以及你的合作者的手中），让你不再依赖托管服务。本文只是简单的介绍了基本概念。你的代码项目还会用到很多有用的 Fossil 功能。尝试一下 Fossil。它不仅会改变你对版本控制的理解；它会让你不再考虑其他的版本控制系统。</p>
<hr>
<p>via: <a href="https://opensource.com/article/20/11/fossil">https://opensource.com/article/20/11/fossil</a></p>
<p>作者：<a href="https://opensource.com/users/klaatu">Klaatu</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">lxbwolf</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】String&amp;#039;s interface</title>
    <url>/4c3249cd/</url>
    <content><![CDATA[<p>考虑以下代码:</p>
<pre><code>bool fun(const string&amp;amp; code)
&#123;
assert(code.length() &amp;gt;= 2);
if (code.substr(0, 2) == string(&quot;XX&quot;))
&#123;
// ...
&#125;
// ...
&#125;</code></pre><p>有没有发现什么问题? 不要纠结于assert(), 它只是为了保证 string “code” 长度大于2而已.</p>
<p>很显然, 这段代码用来检查string是否以”XX”开头. 基于它长度大于2 的前提, 这段代码能正常运行. 我们的关心的问题是, 表达式能否达到正确的结果.</p>
<p>绝大多数情况下, 我们之所以使用C++, 是希望能使我们的程序达到最优的性能. 基于这个目标, 上面的代码看起来就不是很正确了. 为了检查”code”是否以”XX”开头, 我们生成了两个临时的string, 每个string都可能潜在地申请堆上的内存. 有人可能会为此辩解: std::string应该能为一个 2字母的序列实现 短字符串最优化(SSO). 就算这个辩解是正确的, 这段代码也已经 耗费了 一些不能被优化掉的开销, 更何况, 并不是所有的都会实现SSO. 例如, 我使用的GCC 4.4.7 就不会为string实现SSO.</p>
<p>类模板<code>std::basic_string</code> 的接口很复杂. 它提供了大量的成员函数, 似乎不用它们显得不领情, 同时开发者也不会有自己一遍遍重新解析的冲动.</p>
<p>因为开发者模糊地记得应用于NTBS(null-terminated byte strings)(可以被隐式地转为<code>const char*</code> )的 操作符 <code>==</code> 会使结果出错, 所以他通过 确保参与比较的两个值都是<code>std::string</code> 类型来避开这个错误. 他可能在想, 在运行操作符<code>==</code> 前文本”XX” 已经被显式地转成了<code>std::string</code>, 那么这么做也没有坏处. <strong>但是</strong>, 这是错误的, 因为对于操作符<code>==</code>, 标准提供了两种版本:</p>
<pre><code>bool operator==(const std::string&amp;amp; lhs, const char* rhs);
bool operator==(const char* lhs, const std::string&amp;amp; rhs);</code></pre><p>当然实际上他们是带有多个参数的函数模板, 远比这个复杂. <code>std::string</code> 可以直接跟NTBS比较, 没有必要生成临时的<code>std::string</code>. 我们开头的例子, 可以通过去除显式生成的临时副本 进行优化: <code>if (code.substr(0, 2) == &quot;XX&quot;)</code></p>
<p>更进一步, 不可否认, 在有些地方使用操作符<code>==</code> 看起来很高雅, 但是仅仅为了检查一个<code>string</code> 本身的一部分而去新申请一部分资源(生成一个新的<code>string</code>) 这种做法是错误的. 开发者的初衷, 并不是要是程序看起来高雅. 实际上, 如果我们深入研究<code>std::basic_string</code> 的官方文档, 就会发现, <code>std::basic_string</code>提供了一种比较它的子字符串和NTBS的方法: <code>if(code.compare(0, 2, &quot;XX&quot;) == 0)</code> 这个比较是三方比较, 结果等于0表示相等. 它可以达到目的, 并且不需要生成任何临时的<code>string</code>.</p>
<p>尽管这个<code>compare()</code> 使性能达到了很大的优化, 但我并不满足于此. 虽然它做了正确的事情, 但如果我们是第一次遇到他, 很难抓住他的精髓. 如果你可以使用boost库, 我的建议性的解决方案是使用<code>Boost String Algorithms Library</code> 中的算法:</p>
<pre><code>#include &lt;boost algorithm=&quot;&quot; string=&quot;&quot; predicate.hpp=&quot;&quot;&gt;&lt;/boost&gt;

bool func(const string&amp;amp; code)
&#123;
if (boost::algorithm::starts_with(code, &quot;XX&quot;))
&#125;</code></pre><p>这段代码很好地体现了我想说的意思, 没有任何多余的开销.</p>
<p>原文地址: <a href="https://akrzemi1.wordpress.com/2015/04/15/strings-interface/">https://akrzemi1.wordpress.com/2015/04/15/strings-interface/</a></p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>从图片头信息中获取图片格式</title>
    <url>/be14bd28/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#图片文件头标识分析">图片文件头标识分析</a></li>
<li><a href="#文件头标识比对">文件头标识比对</a></li>
<li><a href="#代码">代码</a></li>
</ul>
<!-- tocstop -->

<h2><span id="图片文件头标识分析">图片文件头标识分析</span></h2><p>一个图片文件的后缀名并不能说明这个图片的真正格式什么，读取图片文件的文件头标识可以获取图片的格式。用十六进制编辑器察看图片的文件头</p>
<p><strong>1.JPEG</strong></p>
<ul>
<li>文件头标识 (2 bytes): $ff, $d8 (SOI) (JPEG 文件标识) </li>
<li>文件结束标识 (2 bytes): $ff, $d9 (EOI)</li>
</ul>
<p><strong>2.TGA</strong></p>
<ul>
<li>未压缩的前5字节    00 00 02 00 00</li>
<li>RLE压缩的前5字节   00 00 10 00 00</li>
</ul>
<p><strong>3.PNG</strong></p>
<ul>
<li>文件头标识 (8 bytes)   89 50 4E 47 0D 0A 1A 0A</li>
</ul>
<p><strong>4.GIF</strong></p>
<ul>
<li>文件头标识 (6 bytes)   47 49 46 38 39(37) 61<pre><code>G    I    F     8    9 (7)     a</code></pre></li>
</ul>
<p><strong>5.BMP</strong></p>
<ul>
<li>文件头标识 (2 bytes)   42 4D<pre><code>B    M</code></pre></li>
</ul>
<p><strong>6.PCX</strong></p>
<ul>
<li>文件头标识 (1 bytes)   0A</li>
</ul>
<p><strong>7.TIFF</strong></p>
<ul>
<li>文件头标识 (2 bytes)   4D 4D 或 49 49</li>
</ul>
<p><strong>8.ICO</strong></p>
<ul>
<li>文件头标识 (8 bytes)   00 00 01 00 01 00 20 20</li>
</ul>
<p><strong>9.CUR</strong></p>
<ul>
<li>文件头标识 (8 bytes)   00 00 02 00 01 00 20 20</li>
</ul>
<p><strong>10.IFF</strong></p>
<ul>
<li>文件头标识 (4 bytes)   46 4F 52 4D<pre><code>F    O   R    M</code></pre></li>
</ul>
<p><strong>11.ANI</strong></p>
<ul>
<li>文件头标识 (4 bytes)   52 49 46 46<pre><code>R     I     F    F</code></pre></li>
</ul>
<h2><span id="文件头标识比对">文件头标识比对</span></h2><p>根据这些文件头标识的收集，我可以写一个识别图像格式的模块了。但是在写这个模块之前可以对收集到的文件头标识进行优化，使得程序中字符串比对次数尽量的少。</p>
<p>1.JPEG我们知需要比对文件头的$ff, $d8这两个字符，而不用读取最后的两个结束标识了</p>
<p>2.TGA，ICO，CUR只需比对第三个与第五个字符即可。</p>
<p>3.PNG 比对[89][50]这两个字符。</p>
<p>4.GIF 比对[47][49][46]与第五个字符。</p>
<p>模块代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;枚举图片格式种类</span></span><br><span class="line"><span class="string">Public Enum ImageForm</span></span><br><span class="line"><span class="string">   [BMP] = 0</span></span><br><span class="line"><span class="string">   [JPEG] = 1</span></span><br><span class="line"><span class="string">   [GIF87] = 2</span></span><br><span class="line"><span class="string">   [GIF89] = 3</span></span><br><span class="line"><span class="string">   [PNG] = 4</span></span><br><span class="line"><span class="string">   [TGA Normal] = 5 &#x27;</span>TGA未压缩</span><br><span class="line">   [TGA RLE] = <span class="number">6</span>     <span class="string">&#x27;TGA经过RLE压缩后的</span></span><br><span class="line"><span class="string">   [PCX] = 7</span></span><br><span class="line"><span class="string">   [TIFF] = 8</span></span><br><span class="line"><span class="string">   [ICO] = 9</span></span><br><span class="line"><span class="string">   [CUR] = 10</span></span><br><span class="line"><span class="string">   [IFF] = 11</span></span><br><span class="line"><span class="string">   [ANI] = 12</span></span><br><span class="line"><span class="string">   [Other] = 13</span></span><br><span class="line"><span class="string">   [FileError] = 14</span></span><br><span class="line"><span class="string">End Enum</span></span><br></pre></td></tr></table></figure>


<p>常用的图片格式有以下几种。</p>
<ul>
<li>PNG</li>
<li>JPEG</li>
<li>GIF</li>
<li>WebP 是 Google 制造的一个图片格式，针对网络上快速传输就行了优化</li>
<li>TIFF/TIF 在数字影响、遥感、医学等领域中得到了广泛的应用。TIFF文件的后缀是.tif或者.tiff</li>
<li>HEIC iOS11 后，苹果拍照图片的默认格式</li>
<li>HEIF 用于存储动态图像</li>
</ul>
<h5><span id="jpge-二进制数据前两个字节数据为">JPGE 二进制数据前两个字节数据为</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">FF D8</span><br></pre></td></tr></table></figure>

<h5><span id="png">PNG</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">89 50 4E 47 0D 0A 1A 0A</span><br></pre></td></tr></table></figure>

<h5><span id="gif">GIF</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">47 49 46 38 37 61 or</span><br><span class="line">47 49 46 38 39 61</span><br></pre></td></tr></table></figure>

<h5><span id="tiff">TIFF</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">49 20 49 or</span><br><span class="line">49 49 2A 00 or</span><br><span class="line">4D 4D 00 2B or</span><br><span class="line">4D 4D 00 2A</span><br></pre></td></tr></table></figure>

<h5><span id="heic">HEIC</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">00</span><br></pre></td></tr></table></figure>

<h5><span id="heif">HEIF</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">00</span><br></pre></td></tr></table></figure>

<h5><span id="webp">WEBP</span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex Signature</span><br><span class="line">52</span><br></pre></td></tr></table></figure>

<p><strong>判断 Webp 为什么是截取 0-12 的长度？转换成 ASCII 之后判断的依据？</strong></p>
<p>在 Google 官方介绍中找到了此图。说明的是：头文件的大小是 <code>12Bytes</code></p>
<p>WEBP的 header 中写明了 <code>ASCII</code> 是 <code>RIFF</code> 或者 <code>WEBP</code> Google Developer: <a href="https://developers.google.com/speed/webp/docs/riff_container">https://developers.google.com/speed/webp/docs/riff_container</a></p>
<h2><span id="代码">代码</span></h2><p><strong>demo 代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enum ImageFormat &#123;</span><br><span class="line">    <span class="keyword">case</span> Unknow</span><br><span class="line">    <span class="keyword">case</span> JPEG</span><br><span class="line">    <span class="keyword">case</span> PNG</span><br><span class="line">    <span class="keyword">case</span> GIF</span><br><span class="line">    <span class="keyword">case</span> TIFF</span><br><span class="line">    <span class="keyword">case</span> WebP</span><br><span class="line">    <span class="keyword">case</span> HEIC</span><br><span class="line">    <span class="keyword">case</span> HEIF</span><br><span class="line">&#125;</span><br><span class="line">extension Data &#123;</span><br><span class="line">    func getImageFormat() -&gt; ImageFormat  &#123;</span><br><span class="line">        var buffer = [UInt8](repeating: <span class="number">0</span>, count: <span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.copyBytes(to: &amp;buffer, count: <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        switch buffer &#123;</span><br><span class="line">        <span class="keyword">case</span> [<span class="number">0xFF</span>]: <span class="keyword">return</span> .JPEG</span><br><span class="line">        <span class="keyword">case</span> [<span class="number">0x89</span>]: <span class="keyword">return</span> .PNG</span><br><span class="line">        <span class="keyword">case</span> [<span class="number">0x47</span>]: <span class="keyword">return</span> .GIF</span><br><span class="line">        <span class="keyword">case</span> [<span class="number">0x49</span>],[<span class="number">0x4D</span>]: <span class="keyword">return</span> .TIFF</span><br><span class="line">        <span class="keyword">case</span> [<span class="number">0x52</span>] where <span class="variable language_">self</span>.count &gt;= <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">if</span> let <span class="built_in">str</span> = String(data: <span class="variable language_">self</span>[<span class="number">0.</span>.<span class="number">.11</span>], encoding: .<span class="built_in">ascii</span>), <span class="built_in">str</span>.hasPrefix(<span class="string">&quot;RIFF&quot;</span>), <span class="built_in">str</span>.hasSuffix(<span class="string">&quot;WEBP&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> .WebP</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> [<span class="number">0x00</span>] where <span class="variable language_">self</span>.count &gt;= <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">if</span> let <span class="built_in">str</span> = String(data: <span class="variable language_">self</span>[<span class="number">8.</span>.<span class="number">.11</span>], encoding: .<span class="built_in">ascii</span>) &#123;</span><br><span class="line">                let HEICBitMaps = <span class="type">Set</span>([<span class="string">&quot;heic&quot;</span>, <span class="string">&quot;heis&quot;</span>, <span class="string">&quot;heix&quot;</span>, <span class="string">&quot;hevc&quot;</span>, <span class="string">&quot;hevx&quot;</span>])</span><br><span class="line">                <span class="keyword">if</span> HEICBitMaps.contains(<span class="built_in">str</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> .HEIC</span><br><span class="line">                &#125;</span><br><span class="line">                let HEIFBitMaps = <span class="type">Set</span>([<span class="string">&quot;mif1&quot;</span>, <span class="string">&quot;msf1&quot;</span>])</span><br><span class="line">                <span class="keyword">if</span> HEIFBitMaps.contains(<span class="built_in">str</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> .HEIF</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        default: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> .Unknow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>C++ 代码1</strong></p>
<p>Image_file.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImageFile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> blink &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JPEG_FILE_TYPE          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BMP_FILE_TYPE           2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PNG_FILE_TYPE           3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GIF_FILE_TYPE           4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">　　通过文件头标识判断图片格式，</span></span><br><span class="line"><span class="comment">　　jpg： FF, D8</span></span><br><span class="line"><span class="comment">　　bmp： 42 4D</span></span><br><span class="line"><span class="comment">　　gif： 47 49 46 38</span></span><br><span class="line"><span class="comment">　　png： 89 50 4E 47</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_fileType</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0xFF</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="number">0xd8</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="number">0xFF</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JPEG_FILE_TYPE; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0x42</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="number">0x4d</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BMP_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0x47</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="number">0x49</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="number">0x46</span> &amp;&amp; buf[<span class="number">3</span>] == <span class="number">0x38</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GIF_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0x89</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="number">0x50</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="number">0x4e</span> &amp;&amp; buf[<span class="number">3</span>] == <span class="number">0x47</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PNG_FILE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在构造函数内获取像素宽高：mwidth、mheigh*/</span></span><br><span class="line"></span><br><span class="line">ImageFile::<span class="built_in">ImageFile</span>(<span class="type">const</span> String&amp; path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    mpath = path;</span><br><span class="line">    mwidth = <span class="number">0</span>;</span><br><span class="line">    mheight = <span class="number">0</span>;</span><br><span class="line">    mtype = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    src = (<span class="type">char</span> *)path.<span class="built_in">utf8</span>().<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buff = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp = <span class="built_in">fopen</span>(src,<span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mtype = <span class="string">&quot;The file was not opened!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">    buff = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(buff)</span><br><span class="line">        <span class="built_in">memset</span>(buff,<span class="number">0</span>,size);</span><br><span class="line">    <span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_SET);   </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fread</span>(buff,<span class="number">1</span>,size,fp)!=size)</span><br><span class="line">    &#123;</span><br><span class="line">        mtype =<span class="string">&quot;read error!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    type = <span class="built_in">check_fileType</span>(buff);</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JPEG_FILE_TYPE:</span><br><span class="line">            mtype = <span class="string">&quot;jpg file!&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(buff[i] == <span class="number">0xff</span> &amp;&amp; buff[i<span class="number">+1</span>] == <span class="number">0xc0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i<span class="number">+7</span>]&lt;&lt;<span class="number">8</span>) | buff[i<span class="number">+8</span>];</span><br><span class="line">                    mheight = (buff[i<span class="number">+5</span>]&lt;&lt;<span class="number">8</span>) | buff[i<span class="number">+6</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> BMP_FILE_TYPE:</span><br><span class="line">            mtype = <span class="string">&quot;bmp file!&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(buff[i] == <span class="number">0x28</span> &amp;&amp; buff[i<span class="number">+1</span>] == <span class="number">0x00</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i<span class="number">+7</span>]&lt;&lt;<span class="number">24</span>) | buff[i<span class="number">+6</span>]&lt;&lt;<span class="number">16</span> | buff[i<span class="number">+5</span>]&lt;&lt;<span class="number">8</span> | buff[i<span class="number">+4</span>];</span><br><span class="line">                    mheight = (buff[i<span class="number">+11</span>]&lt;&lt;<span class="number">24</span>) | buff[i<span class="number">+10</span>]&lt;&lt;<span class="number">16</span> | buff[i<span class="number">+9</span>]&lt;&lt;<span class="number">8</span> | buff[i<span class="number">+8</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> PNG_FILE_TYPE:</span><br><span class="line">            mtype = <span class="string">&quot;png file!&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(buff[i] == <span class="number">0x49</span> &amp;&amp; buff[i<span class="number">+1</span>] == <span class="number">0x48</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    mheight = (buff[i<span class="number">+8</span>]&lt;&lt;<span class="number">24</span>) | buff[i<span class="number">+9</span>]&lt;&lt;<span class="number">16</span> | buff[i<span class="number">+10</span>]&lt;&lt;<span class="number">8</span> | buff[i<span class="number">+11</span>];</span><br><span class="line">                    mwidth = (buff[i<span class="number">+4</span>]&lt;&lt;<span class="number">24</span>) | buff[i<span class="number">+5</span>]&lt;&lt;<span class="number">16</span> | buff[i<span class="number">+6</span>]&lt;&lt;<span class="number">8</span> | buff[i<span class="number">+7</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> GIF_FILE_TYPE:</span><br><span class="line">            mtype = <span class="string">&quot;gif file!&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(buff[i] == <span class="number">0x00</span> &amp;&amp; buff[i<span class="number">+1</span>] == <span class="number">0x2c</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    mwidth = (buff[i<span class="number">+7</span>]&lt;&lt;<span class="number">8</span>) | buff[i<span class="number">+6</span>];</span><br><span class="line">                    mheight = (buff[i<span class="number">+9</span>]&lt;&lt;<span class="number">8</span>) | buff[i<span class="number">+8</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">free</span>(buff);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">ImageFile::type</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mtype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">ImageFile::location</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = mpath.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> pos = mpath.<span class="built_in">reverseFind</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pos == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = mpath.<span class="built_in">reverseFind</span>(<span class="string">&#x27;/&#x27;</span> ,pos - <span class="number">1</span>);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mpath.<span class="built_in">substring</span>(<span class="number">0</span>,pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">ImageFile::fileName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = mpath.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> pos = mpath.<span class="built_in">reverseFind</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pos == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = mpath.<span class="built_in">reverseFind</span>(<span class="string">&#x27;/&#x27;</span> , pos - <span class="number">1</span>);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mpath.<span class="built_in">substring</span>(pos + <span class="number">1</span>,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ImageFile::width</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mwidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ImageFile::height</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mheight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>image_file.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ImageFile_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ImageFile_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> blink &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ImageFile</span>  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ImageFile* <span class="title">create</span><span class="params">(<span class="type">const</span> String&amp; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FILE* fS;</span><br><span class="line">        fS =<span class="built_in">fopen</span>(path.<span class="built_in">utf8</span>().<span class="built_in">data</span>(),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fS !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="type">int</span> iLen = path.<span class="built_in">length</span>() ;</span><br><span class="line">            <span class="type">int</span> iPos = path.<span class="built_in">reverseFind</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (iPos &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String name=path.<span class="built_in">substring</span>(iPos + <span class="number">1</span>, iLen);</span><br><span class="line">            <span class="type">char</span> s1[<span class="number">10</span>];</span><br><span class="line">            <span class="type">char</span> s2[]=<span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">            <span class="type">char</span> s3[]=<span class="string">&quot;bmp&quot;</span>;</span><br><span class="line">            <span class="type">char</span> s4[]=<span class="string">&quot;gif&quot;</span>;</span><br><span class="line">            <span class="type">char</span> s5[]=<span class="string">&quot;png&quot;</span>;</span><br><span class="line">            <span class="type">char</span> s6[]=<span class="string">&quot;jpeg&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;name.<span class="built_in">length</span>();i++)</span><br><span class="line">                s1[i] = name[i];</span><br><span class="line">            s1[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s1,s2,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s3,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s4,<span class="number">3</span>)==<span class="number">0</span> || <span class="built_in">strncmp</span>(s1,s5,<span class="number">3</span>)==<span class="number">0</span>|| <span class="built_in">strncmp</span>(s1,s6,<span class="number">4</span>)==<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NGBImageFile</span>(path);     <span class="comment">//路径正确且图片文件格式是以上四种，创建文件对象</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">location</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">fileName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ImageFile</span>(<span class="type">const</span> String&amp; path);</span><br><span class="line">    <span class="type">char</span>* src;</span><br><span class="line">    String mpath;</span><br><span class="line">    String mtype;</span><br><span class="line">    <span class="type">double</span> mwidth;</span><br><span class="line">    <span class="type">double</span> mheight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace blink</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ImageFile_H</span></span></span><br></pre></td></tr></table></figure>



<p><strong>Qt 代码</strong></p>
<p>imageinfo.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IMAGEINFO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGEINFO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QUrl&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSize&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDate&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageInfo</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">IMAGE_FORMAT</span>&#123;</span><br><span class="line">        BMP_FORMAT,</span><br><span class="line">        JPG_FORMAT,</span><br><span class="line">        GIF_FORMAT,</span><br><span class="line">        PNG_FORMAT,</span><br><span class="line">        NVL_FORMAT</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ImageInfo</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ImageInfo</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Q_INVOKABLE QString <span class="title">getImageFormat</span><span class="params">(QString imageUrl)</span></span>;</span><br><span class="line">    <span class="function">Q_INVOKABLE QString <span class="title">getImageSize</span><span class="params">(QString imageUrl)</span></span>;</span><br><span class="line">    <span class="function">Q_INVOKABLE QSize <span class="title">getImageDimension</span><span class="params">(QString imageUrl)</span></span>;</span><br><span class="line">    <span class="function">Q_INVOKABLE QDate <span class="title">getImageDate</span><span class="params">(QString imageUrl)</span></span>;</span><br><span class="line">    <span class="function">Q_INVOKABLE QString <span class="title">getImageTitle</span><span class="params">(QString imageUrl)</span></span>;</span><br><span class="line">Q_SIGNALS:</span><br><span class="line"><span class="keyword">public</span> Q_SLOTS :</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getImageFormat</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">getBMPSize</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">getGIFSize</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">getPNGSize</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">getJPGSize</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function">QSize <span class="title">getBMPDimension</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function">QSize <span class="title">getPNGDimension</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function">QSize <span class="title">getJPGDimension</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function">QSize <span class="title">getGIFDimension</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// IMAGEINFO_H</span></span></span><br></pre></td></tr></table></figure>

<p>imageinfo.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageinfo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFileInfo&gt;</span></span></span><br><span class="line"></span><br><span class="line">ImageInfo::<span class="built_in">ImageInfo</span>(QObject *parent) :</span><br><span class="line">    <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;---------------------------- image info constructed &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ImageInfo::~<span class="built_in">ImageInfo</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QDate <span class="title">ImageInfo::getImageDate</span><span class="params">(QString imageUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDate date;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.<span class="built_in">toLocalFile</span>();</span><br><span class="line">        <span class="keyword">if</span>(QFile::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">            <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            date = fileinfo.<span class="built_in">lastModified</span>().<span class="built_in">date</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从文件头中读取相应字段以判断图片格式</span></span><br><span class="line"><span class="comment">//详情参看: http://www.garykessler.net/library/file_sigs.html</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ImageInfo::getImageFormat</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//BMP格式特征码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> BMPHeader[] = &#123;<span class="number">0x42</span>, <span class="number">0x4d</span>&#125;;</span><br><span class="line">    <span class="comment">//JPG,JPEG格式特征码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> JPGHeader1[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xdb</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> JPGHeader2[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> JPGHeader3[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe1</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> JPGHeader4[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe2</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> JPGHeader5[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe3</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> JPGHeader6[] = &#123;<span class="number">0xff</span>, <span class="number">0xd8</span>, <span class="number">0xff</span>, <span class="number">0xe8</span>&#125;;</span><br><span class="line">    <span class="comment">//GIF格式特征码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> GIFHeader1[] = &#123;<span class="number">0x47</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x38</span>, <span class="number">0x37</span>, <span class="number">0x61</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> GIFHeader2[] = &#123;<span class="number">0x47</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x61</span>&#125;;</span><br><span class="line">    <span class="comment">//PNG格式特征码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> PNGHeader[] = &#123;<span class="number">0x89</span>, <span class="number">0x50</span>, <span class="number">0x4E</span>, <span class="number">0x47</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//以二进制方式打开文件并读取前几个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> header[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;文件路径: &quot;</span>&lt;&lt;path.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">std::ifstream <span class="title">readf</span><span class="params">(path.c_str(), std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!readf.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> NVL_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先读两个，判断是否BMP格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(header, BMPHeader, count) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;文件格式特征码:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%0x\t&quot;</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;BMP格式&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> BMP_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读两个，判断是否JPG格式、PNG格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">memcmp</span>(header, JPGHeader1, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader2, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader3, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader4, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader5, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, JPGHeader6, count) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;文件格式特征码:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%0x\t&quot;</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;JPG格式&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> JPG_FORMAT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">memcmp</span>(header, PNGHeader, count) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;文件格式特征码:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%0x\t&quot;</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;PNG格式&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> PNG_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读两个，判断是否GIF格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;step; i++) &#123;</span><br><span class="line">        readf&gt;&gt;header[count+i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = count + step;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">memcmp</span>(header, GIFHeader1, count) == <span class="number">0</span>)</span><br><span class="line">            || (<span class="built_in">memcmp</span>(header, GIFHeader2, count) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;文件格式特征码:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%0x\t&quot;</span>,header[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;GIF格式&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> GIF_FORMAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;文件格式特征码:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%0x\t&quot;</span>,header[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;不属于以上任何一种格式&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> NVL_FORMAT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">ImageInfo::getImageFormat</span><span class="params">(QString imageUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString strFormat = <span class="string">&quot;NA&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.<span class="built_in">toLocalFile</span>();</span><br><span class="line">        <span class="keyword">if</span>(QFile::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">            std::string path = filePath.<span class="built_in">toStdString</span>();</span><br><span class="line">            <span class="type">int</span> iFormat = <span class="built_in">getImageFormat</span>(path);</span><br><span class="line">            <span class="keyword">switch</span>(iFormat) &#123;</span><br><span class="line">            <span class="keyword">case</span> BMP_FORMAT:</span><br><span class="line">                strFormat = <span class="string">&quot;BMP&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JPG_FORMAT:</span><br><span class="line">                strFormat = <span class="string">&quot;JPG&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GIF_FORMAT:</span><br><span class="line">                strFormat = <span class="string">&quot;GIF&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PNG_FORMAT:</span><br><span class="line">                strFormat = <span class="string">&quot;PNG&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strFormat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">ImageInfo::getImageSize</span><span class="params">(QString imageUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString strSize;</span><br><span class="line">    <span class="type">long</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.<span class="built_in">toLocalFile</span>();</span><br><span class="line">        <span class="keyword">if</span>(QFile::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">            <span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            <span class="type">bool</span> ret = file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">            <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size = file.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            file.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;!!!!!&quot;</span>&lt;&lt;size;</span><br><span class="line">    strSize = QString::<span class="built_in">number</span>(size, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;strSize;</span><br><span class="line">    <span class="keyword">return</span> strSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BMP文件头的第2、3字为文件大小信息</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ImageInfo::getBMPSize</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">if</span>((fid=<span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(),<span class="string">&quot;rb+&quot;</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳过图片特征码</span></span><br><span class="line">    <span class="built_in">fseek</span>(fid, <span class="number">2</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;size, <span class="built_in">sizeof</span>(<span class="type">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    <span class="built_in">fclose</span>(fid);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;size=&quot;</span>&lt;&lt;size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ImageInfo::getGIFSize</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ImageInfo::getPNGSize</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ImageInfo::getJPGSize</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">if</span>((fid = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(),<span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fseek</span>(fid, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = <span class="built_in">ftell</span>(fid);</span><br><span class="line">    <span class="built_in">fclose</span>(fid);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;size=&quot;</span>&lt;&lt;size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BMP文件头的第10、11字为文件宽度信息</span></span><br><span class="line"><span class="comment">//BMP文件头的第12、13字为文件高度信息</span></span><br><span class="line"><span class="function">QSize <span class="title">ImageInfo::getBMPDimension</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">if</span>((fid=<span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(),<span class="string">&quot;rb+&quot;</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">//读取宽度和高度</span></span><br><span class="line">    <span class="built_in">fseek</span>(fid, <span class="number">18</span>, SEEK_SET); <span class="comment">//偏移18个字节</span></span><br><span class="line">    <span class="built_in">fread</span>(&amp;width, <span class="built_in">sizeof</span>(<span class="type">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    <span class="built_in">fread</span>(&amp;height, <span class="built_in">sizeof</span>(<span class="type">long</span>), <span class="number">1</span>, fid);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;width=&quot;</span>&lt;&lt;width;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;height=&quot;</span>&lt;&lt;height;</span><br><span class="line">    <span class="built_in">fclose</span>(fid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QSize</span>(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考： http://mcljc.blog.163.com/blog/static/83949820102239610974/</span></span><br><span class="line"><span class="comment">//http://download.csdn.net/download/chp845/4255011</span></span><br><span class="line"><span class="function">QSize <span class="title">ImageInfo::getJPGDimension</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fid;</span><br><span class="line">    <span class="keyword">if</span>((fid = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(),<span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="built_in">fseek</span>(fid,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="type">long</span> length = <span class="built_in">ftell</span>(fid);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[length];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer_bakup = buffer;</span><br><span class="line">    <span class="built_in">fseek</span>(fid, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">fread</span>(buffer, length, <span class="number">1</span>, fid);</span><br><span class="line">    <span class="built_in">fclose</span>(fid);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *temp = buffer + length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *temp_ori = buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ff;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type=<span class="number">0xff</span>;</span><br><span class="line">    <span class="type">int</span> m_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//跳过文件头中标志文件类型的两个字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">        buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((temp &gt; buffer) &amp;&amp; (type != <span class="number">0xDA</span>)) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ff = *buffer++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(ff != <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            type = *buffer++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(type == <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD7</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xC0</span>:<span class="comment">//SOF0段</span></span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            buffer++; <span class="comment">//舍弃精度值</span></span><br><span class="line">            height = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            height += *buffer++;</span><br><span class="line">            width = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            width += *buffer;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xE0</span>: <span class="comment">//APP0段</span></span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;APP0段&quot;</span>;</span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            buffer = buffer + <span class="number">12</span>;</span><br><span class="line">            <span class="comment">//丢弃APP0标记(5bytes)、主版本号(1bytes)、次版本号(1bytes)、像素点单位(1bytes)、垂直像素点(2bytes)、 水平像素点(2bytes)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            temp_ori = buffer;</span><br><span class="line">            m_pos = (*buffer++)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">            m_pos += *buffer++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = temp_ori + m_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;width=&quot;</span>&lt;&lt;width;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;height=&quot;</span>&lt;&lt;height;</span><br><span class="line">    <span class="comment">//记得释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer_bakup;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QSize</span>(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PNG文件头的第9字为文件宽度信息</span></span><br><span class="line"><span class="comment">//PNG文件头的第10字为文件高度信息</span></span><br><span class="line"><span class="comment">//参考：http://blog.chinaunix.net/uid-25799257-id-3358174.html</span></span><br><span class="line"><span class="function">QSize <span class="title">ImageInfo::getPNGDimension</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((fid=<span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(),<span class="string">&quot;rb+&quot;</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打开文件失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> wtmp[<span class="number">4</span>]=&#123;<span class="string">&#x27;0&#x27;</span>&#125;;   <span class="comment">//宽度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> htmp[<span class="number">4</span>]=&#123;<span class="string">&#x27;0&#x27;</span>&#125;;   <span class="comment">//高度</span></span><br><span class="line">    <span class="built_in">fseek</span>(fid, <span class="number">16</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">fread</span>(wtmp, <span class="number">4</span>, <span class="number">1</span>, fid);         <span class="comment">// example 00000080</span></span><br><span class="line">    <span class="built_in">fread</span>(htmp, <span class="number">4</span>, <span class="number">1</span>, fid);         <span class="comment">// example 00000080</span></span><br><span class="line">    <span class="built_in">fclose</span>(fid);</span><br><span class="line">    width = ((<span class="type">int</span>)(<span class="type">unsigned</span> <span class="type">char</span>)wtmp[<span class="number">2</span>]) * <span class="number">256</span> + (<span class="type">int</span>)(<span class="type">unsigned</span> <span class="type">char</span>)wtmp[<span class="number">3</span>];</span><br><span class="line">    height = ((<span class="type">int</span>)(<span class="type">unsigned</span> <span class="type">char</span>)htmp[<span class="number">2</span>]) * <span class="number">256</span> + (<span class="type">int</span>)(<span class="type">unsigned</span> <span class="type">char</span>)htmp[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;width=&quot;</span>&lt;&lt;width;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;height=&quot;</span>&lt;&lt;height;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QSize</span>(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GIF文件头的第4字为文件宽度信息</span></span><br><span class="line"><span class="comment">//GIF文件头的第5字为文件高度信息</span></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/zhaoweikid/article/details/156422</span></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/asaasa66/article/details/5875340</span></span><br><span class="line"><span class="function">QSize <span class="title">ImageInfo::getGIFDimension</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ffin</span><span class="params">(path.c_str(), std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ffin)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Can not open this file.&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;, s2[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ffin.<span class="built_in">seekg</span>(<span class="number">6</span>);</span><br><span class="line">    ffin.<span class="built_in">read</span>(s1, <span class="number">2</span>);</span><br><span class="line">    ffin.<span class="built_in">read</span>(s2, <span class="number">2</span>);</span><br><span class="line">    width = (<span class="type">unsigned</span> <span class="type">int</span>)(s1[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>|(<span class="type">unsigned</span> <span class="type">int</span>)(s1[<span class="number">0</span>]);</span><br><span class="line">    height = (<span class="type">unsigned</span> <span class="type">int</span>)(s2[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>|(<span class="type">unsigned</span> <span class="type">int</span>)(s2[<span class="number">0</span>]);</span><br><span class="line">    ffin.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;width=&quot;</span>&lt;&lt;width;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;height=&quot;</span>&lt;&lt;height;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QSize</span>(width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QSize <span class="title">ImageInfo::getImageDimension</span><span class="params">(QString imageUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSize dimension;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.<span class="built_in">toLocalFile</span>();</span><br><span class="line">        <span class="keyword">if</span>(QFile::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">            std::string path = filePath.<span class="built_in">toStdString</span>();</span><br><span class="line">            <span class="type">int</span> iFormat = <span class="built_in">getImageFormat</span>(path);</span><br><span class="line">            <span class="keyword">switch</span>(iFormat) &#123;</span><br><span class="line">            <span class="keyword">case</span> BMP_FORMAT:</span><br><span class="line">                dimension = <span class="built_in">getBMPDimension</span>(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JPG_FORMAT:</span><br><span class="line">                dimension = <span class="built_in">getJPGDimension</span>(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GIF_FORMAT:</span><br><span class="line">                dimension = <span class="built_in">getGIFDimension</span>(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PNG_FORMAT:</span><br><span class="line">                dimension = <span class="built_in">getPNGDimension</span>(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;图片尺寸:&quot;</span>&lt;&lt;dimension;</span><br><span class="line">    <span class="keyword">return</span> dimension;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">ImageInfo::getImageTitle</span><span class="params">(QString imageUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString title;</span><br><span class="line">    <span class="keyword">if</span>(!imageUrl.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QUrl <span class="title">fileUrl</span><span class="params">(imageUrl)</span></span>;</span><br><span class="line">        QString filePath = fileUrl.<span class="built_in">toLocalFile</span>();</span><br><span class="line">        <span class="keyword">if</span>(QFile::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">            <span class="function">QFileInfo <span class="title">fileinfo</span><span class="params">(filePath)</span></span>;</span><br><span class="line">            title = fileinfo.<span class="built_in">baseName</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>pic</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】使用 Lens Desktop 监控和调试 Kubernetes</title>
    <url>/e94f2376/</url>
    <content><![CDATA[<p><img src="https://img.linux.net.cn/data/attachment/album/202305/04/193543uvvdi14469ngnop4.png" alt></p>
<blockquote>
<p>Lens Desktop 是一个令人兴奋的 Kubernetes 工作平台。它是基于 OpenLens 资源库的一个定制化发行版本。通过本文来了解下 Lens Desktop 能做什么以及它是如何工作的。</p>
</blockquote>
<p>Lens Desktop 是免费的。你可以查看 <a href="https://app.k8slens.dev/subscribe">https://app.k8slens.dev/subscribe</a> 来了解更多内容。Lens Desktop 有如下优势：</p>
<ul>
<li>简单高效 —— 你无需学习 <code>kubectl</code> 命令</li>
<li>可视化已有的 Kubernetes 资源</li>
<li>基于开源代码构建</li>
<li>可观测性 —— 实时的统计数据、事件和日志流</li>
<li>错误和警告可以直接在 Lens 仪表盘上看到</li>
<li>支持 EKS、AKS、GKE、Minikube、Rancher、k0s、k3s、OpenShift</li>
<li>强大的社区支持 —— 有 450000 用户，在 GitHub 上共获得 17000 星</li>
</ul>
<h3><span id="minikube-安装">Minikube 安装</span></h3><p>Minikube 是一个用于本地运行 Kubernetes 的工具。它运行一个单节点的 Kubernetes 集群，这样就可以在 Kubernetes 上进行日常软件开发的实践工作。</p>
<p>我们将使用 Minikube 并验证 Lens 的用法。首先让我们在基于 Windows 的系统上安装 Minikube。你也可以把它安装在其他操作系统、虚拟机或笔记本电脑上。</p>
<ul>
<li>2 核以上 CPU</li>
<li>2GB RAM</li>
<li>20GB 空闲硬盘空间</li>
<li>能连接网络</li>
<li>容器或虚拟机管理器，如 Docker、VirtualBox</li>
</ul>
<p>在终端或命令提示符处，运行 <code>minikube start</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minikube start --driver=virtualbox</span><br><span class="line">* minikube v1.12.3 on Microsoft Windows 10 Home Single Language 10.0.19044 Build 19044</span><br><span class="line">* Using the virtualbox driver based on existing profile</span><br><span class="line">* minikube 1.26.0 is available! Download it: https://github.com/kubernetes/minikube/releases/tag/v1.26.0</span><br><span class="line">* To <span class="built_in">disable</span> this notice, run: ‘minikube config <span class="built_in">set</span> WantUpdateNotification <span class="literal">false</span>’</span><br><span class="line">* Starting control plane node minikube <span class="keyword">in</span> cluster minikube</span><br><span class="line">* virtualbox “minikube” VM is missing, will recreate.</span><br><span class="line">* Creating virtualbox VM (CPUs=2, Memory=3000MB, Disk=20000MB) ...</span><br><span class="line">! This VM is having trouble accessing https://k8s.gcr.io</span><br><span class="line">* To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/</span><br><span class="line">* Preparing Kubernetes v1.18.3 on Docker 19.03.12 ...</span><br><span class="line">* Verifying Kubernetes components...</span><br><span class="line">* Enabled addons: default-storageclass, storage-provisioner</span><br><span class="line">* Done! kubectl is now configured to use “minikube”</span><br></pre></td></tr></table></figure>

<p>进入你的 VirtualBox，并验证刚安装的 Minikube 虚拟机功能正常（图 1）。</p>
<p><img src="https://www.opensourceforu.com/wp-content/uploads/2022/08/Figure-1-Minikube-virtual-machine-in-virtual-box.jpg" alt="Figure 1: Minikube virtual machine in virtual box"></p>
<p>使用 <code>minikube status</code> 命令，查看状态是否与下面的输出一致：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\&gt;minikube status</span><br><span class="line">minikube</span><br><span class="line"><span class="built_in">type</span>: Control Plane</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubeconfig: Configured</span><br></pre></td></tr></table></figure>

<p>然后，使用 <code>kubectl cluster-info</code> 命令查看 KubeDNS 详情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https://192.168.99.103:8443</span><br><span class="line">KubeDNS is running at https://192.168.99.103:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>kubectl cluster-info dump</code> 命令来调试和诊断集群问题。</p>
<p>当 Minikube 安装完成后，安装 <code>kubectl</code>（<a href="https://kubernetes.io/docs/tasks/tools/">https://kubernetes.io/docs/tasks/tools/</a>）。它是一个命令行集群，用于对 Kubernetes 集群和 Minikube 执行命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050826151.png" alt="Figure 2: Lens"></p>
<p>执行 <code>kubectl get nodes</code> 命令获取所有 node 的详情，在本例中是获取 Minikube 的详情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\&gt;kubectl get nodes</span><br><span class="line">NAME       STATUS   ROLES    AGE     VERSION</span><br><span class="line">minikube   Ready    master   7m57s   v1.18.3</span><br></pre></td></tr></table></figure>

<p>使用 <code>kubectl get all</code> 命令获取默认命名空间下的所有详情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\&gt;kubectl get all</span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   7m58s</span><br></pre></td></tr></table></figure>

<p>我们现在已经有一个 Minikube 集群，并准备好了 Kubectl。下一步是安装和配置 Lens，并用示例应用程序来验证。</p>
<h3><span id="lens-的安装和配置">Lens 的安装和配置</span></h3><p>打开 <a href="https://k8slens.dev/">https://k8slens.dev/</a> ，下载与你的操作系统匹配的安装包。</p>
<p>然后，参照屏幕上的教程来安装 Lens，安装完成后打开 Lens。你会发现在目录中有一个 <code>minikube</code>（图 3）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050828133.png" alt="Figure 3: Lens catalogue"></p>
<p>点击 “minikube” 后，你就进入了 Minikube 的世界，你会爱上它的。</p>
<p>点击 nodes 获取有关 <code>kubectl get nodes</code> 命令输出的 node 详情。</p>
<p>现在，你可以使用 Lens 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050829353.png" alt="Figure 4: Lens cluster"></p>
<p>我们现在部署 <a href="https://github.com/GoogleCloudPlatform/microservices-demo">https://github.com/GoogleCloudPlatform/microservices-demo</a>，这是一个云原生微服务演示应用程序。它有 11 层的微服务应用，是一个基于网络的电子商务应用。</p>
<p>下载这个应用程序，把它解压到与 Minikube 相同的目录。</p>
<p>进入 <code>release</code> 目录，执行以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kubernetes-manifests.yaml</span><br><span class="line"></span><br><span class="line">deployment.apps/emailservice created</span><br><span class="line">service/emailservice created</span><br><span class="line">deployment.apps/checkoutservice created</span><br><span class="line">service/checkoutservice created</span><br><span class="line">deployment.apps/recommendationservice created</span><br><span class="line">service/recommendationservice created</span><br><span class="line">deployment.apps/frontend created</span><br><span class="line">service/frontend created</span><br><span class="line">service/frontend-external created</span><br><span class="line">deployment.apps/paymentservice created</span><br><span class="line">service/paymentservice created</span><br><span class="line">deployment.apps/productcatalogservice created</span><br><span class="line">service/productcatalogservice created</span><br><span class="line">deployment.apps/cartservice created</span><br><span class="line">service/cartservice created</span><br><span class="line">deployment.apps/loadgenerator created</span><br><span class="line">deployment.apps/currencyservice created</span><br><span class="line">service/currencyservice created</span><br><span class="line">deployment.apps/shippingservice created</span><br><span class="line">service/shippingservice created</span><br><span class="line">deployment.apps/redis-cart created</span><br><span class="line">service/redis-cart created</span><br><span class="line">deployment.apps/adservice created</span><br><span class="line">service/adservice created</span><br></pre></td></tr></table></figure>

<p>安装过程现在应该已经开始了，不过它需要一些时间来反映出我们使用了 <code>kubectl</code> 命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050829421.png" alt="Figure 5: Lens nodes"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">adservice-775d8b9bf5-cp7jr   0/1     Pending   0          8h</span><br><span class="line">cartservice-79749895f5-jrq4d  1/1     Running   0         8h</span><br><span class="line">checkoutservice-5645bf9c65-882m4  1/1   Running  0        8h</span><br><span class="line">currencyservice-545c79d477-8rhg7  1/1  Running   0         8h</span><br><span class="line">emailservice-7cc5c74b4f-hk74s     1/1  Running   0        8h</span><br><span class="line">frontend-9cdf787f5-klfkh    1/1     Running   1          8h</span><br><span class="line">loadgenerator-7b6874cb4c-645v9   1/1  Running   0        8h</span><br><span class="line">paymentservice-5f74bc7b87-l4248  1/1  Running   0        8h</span><br><span class="line">productcatalogservice-6846f59899-v4q4w  1/1  Running  0  8h</span><br><span class="line">recommendationservice-d9c6c8b55-m2x9k  1/1  Running   0  8h</span><br><span class="line">redis-cart-57bd646894-v7kfr    0/1   Pending   0         8h</span><br><span class="line">shippingservice-8685dd9855-pmgjm  1/1  Running  0        8h</span><br></pre></td></tr></table></figure>

<p>表 1 列出了你可以通过 <code>kubectl</code> 来获取信息的几个命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050829835.png" alt="Figure 6: Lens pods"></p>
<table>
<thead>
<tr>
<th align="left">描述</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">列出节点</td>
<td align="left"><code>kubectl get node</code></td>
</tr>
<tr>
<td align="left">列出集群中的所有资源</td>
<td align="left"><code>kubectl get all –all-namespaces</code></td>
</tr>
<tr>
<td align="left">列出部署</td>
<td align="left"><code>kubectl get deployment</code></td>
</tr>
<tr>
<td align="left">显示部署的完整状态</td>
<td align="left"><code>kubectl describe deployment &lt;deployment_name&gt;</code></td>
</tr>
<tr>
<td align="left">修改集群上的部署</td>
<td align="left"><code>kubectl edit deployment &lt;deployment_name&gt;</code></td>
</tr>
<tr>
<td align="left">删除部署</td>
<td align="left"><code>kubectl delete deployment &lt;deployment_name&gt;</code></td>
</tr>
<tr>
<td align="left">列出容器荚</td>
<td align="left"><code>kubectl get pod</code></td>
</tr>
<tr>
<td align="left">删除容器荚</td>
<td align="left"><code>kubectl delete pod &lt;pod_name&gt;</code></td>
</tr>
<tr>
<td align="left">显示容器荚的完整状态</td>
<td align="left"><code>kubectl describe pod &lt;pod_name&gt;</code></td>
</tr>
<tr>
<td align="left">在 Shell 中运行一个单容器荚</td>
<td align="left"><code>kubectl exec -it &lt;pod_name&gt; /bin/bash</code></td>
</tr>
<tr>
<td align="left">列出机密信息</td>
<td align="left"><code>kubectl get secrets</code></td>
</tr>
<tr>
<td align="left">列出服务</td>
<td align="left"><code>kubectl get services</code></td>
</tr>
<tr>
<td align="left">列出服务的完整状态</td>
<td align="left"><code>kubectl describe services</code></td>
</tr>
<tr>
<td align="left">修改集群中的服务</td>
<td align="left"><code>kubectl edit services / kubectl edit deployment &lt;deployment_name&gt;</code></td>
</tr>
<tr>
<td align="left">列出命名空间</td>
<td align="left"><code>kubectl get namespace &lt;namespace_name&gt;</code></td>
</tr>
<tr>
<td align="left">打印容器荚日志</td>
<td align="left"><code>kubectl logs &lt;pod_name&gt;</code></td>
</tr>
<tr>
<td align="left">打印容器荚中特定容器的日志</td>
<td align="left"><code>kubectl logs -c &lt;container_name&gt; &lt;pod_name&gt;</code></td>
</tr>
</tbody></table>
<p>Lens 不仅可以帮你获取表 1 中列出的所有信息，它还可以获取指定集群的信息。我们还能用 Lens 来对 Kubernetes 资源进行编辑和删除操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050830403.png" alt="Figure 7: Lens deployments"></p>
<p>我们来看下是如何操作的。在 Workloads 部分选择 Pods（图 6），我们能通过 Lens 来编辑、删除、查看日志、访问 Pod 的终端，这是不是很酷？</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050830853.png" alt="Figure 8: Lens Replicasets"></p>
<p>你可以验证 Workloads 区域中所有 deployments（图 7），Workloads 区域中所有 Replicasets （图 8），Config 区域中所有 Secrets （图 9），以及 Network 区域中所有 Services 是否都正常（图 10），</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050830883.png" alt="Figure 9: Lens Secrets"></p>
<p>你可以看到，跳转到所有的资源以及在一个地方高效地查看所有资源就是如此轻松。我们可以用 Lens 修改 YAML 文件，在运行时应用它来查看变更。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305050831236.png" alt="Figure 10: Lens Services"></p>
<p>对于配置在不同的云服务商部署的多个集群，我们仍可以用 Lens 来进行观察和故障处理。</p>
<p><em>（题图：MJ/069da8c5-9043-46b3-9b14-87a0ffc6bb35）</em></p>
<hr>
<p>via: <a href="https://www.opensourceforu.com/2022/09/monitoring-and-debugging-kubernetes-with-lens-desktop/">https://www.opensourceforu.com/2022/09/monitoring-and-debugging-kubernetes-with-lens-desktop/</a></p>
<p>作者：<a href="https://www.opensourceforu.com/author/mitesh_soni/">Mitesh Soni</a><br>选题：<a href="https://github.com/lkxed">lkxed</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】使用 gosec 检查 Go 代码中的安全问题</title>
    <url>/a59515fd/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#开始使用-gosec">开始使用 gosec</a><ul>
<li><a href="#安装-go-和-gosec">安装 Go 和 gosec</a></li>
</ul>
</li>
<li><a href="#使用默认选项运行-gosec">使用默认选项运行 gosec</a><ul>
<li><a href="#关于误判">关于误判</a></li>
<li><a href="#高优先级问题">高优先级问题</a></li>
<li><a href="#中优先级问题">中优先级问题</a></li>
<li><a href="#低优先级问题">低优先级问题</a></li>
</ul>
</li>
<li><a href="#自定义-gosec-扫描">自定义 gosec 扫描</a><ul>
<li><a href="#排除指定的测试">排除指定的测试</a></li>
<li><a href="#运行指定的检查">运行指定的检查</a></li>
<li><a href="#扫描测试文件">扫描测试文件</a></li>
<li><a href="#修改输出的格式">修改输出的格式</a></li>
</ul>
</li>
<li><a href="#用-gosec-检查容易被发现的问题">用 gosec 检查容易被发现的问题</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>来学习下 Go 语言的安全检查工具 gosec。</p>
</blockquote>
<p><img src="https://img.linux.net.cn/data/attachment/album/202010/04/125129bh4qxxsyqpvqjtx4.jpg" alt></p>
<p><a href="https://golang.org/">Go 语言</a>写的代码越来越常见，尤其是在容器、Kubernetes 或云生态相关的开发中。Docker 是最早采用 Golang 的项目之一，随后是 Kubernetes，之后大量的新项目在众多编程语言中选择了 Go。</p>
<p>像其他语言一样，Go 也有它的长处和短处（如安全缺陷）。这些缺陷可能会因为语言本身的缺陷加上程序员编码不当而产生，例如，C 代码中的内存安全问题。</p>
<p>无论它们出现的原因是什么，安全问题都应该在开发过程的早期修复，以免在封装好的软件中出现。幸运的是，静态分析工具可以帮你以更可重复的方式处理这些问题。静态分析工具通过解析用某种编程语言写的代码来找到问题。</p>
<p>这类工具中很多被称为 linter。传统意义上，linter 更注重的是检查代码中编码问题、bug、代码风格之类的问题，它们可能不会发现代码中的安全问题。例如，<a href="https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html">Coverity</a> 是一个很流行的工具，它可以帮助寻找 C/C++ 代码中的问题。然而，也有一些工具专门用来检查源码中的安全问题。例如，<a href="https://pypi.org/project/bandit/">Bandit</a> 可以检查 Python 代码中的安全缺陷。而 <a href="https://github.com/securego/gosec">gosec</a> 则用来搜寻 Go 源码中的安全缺陷。<code>gosec</code> 通过扫描 Go 的 AST（抽象语法树abstract syntax tree<ruby>抽象语法树<rt>abstract syntax tree</rt></ruby>）来检查源码中的安全问题。</p>
<h3><span id="开始使用-gosec">开始使用 gosec</span></h3><p>在开始学习和使用 <code>gosec</code> 之前，你需要准备一个 Go 语言写的项目。有这么多开源软件，我相信这不是问题。你可以在 GitHub 的 <a href="https://github.com/trending/go">热门 Golang 仓库</a>中找一个。</p>
<p>本文中，我随机选了 <a href="https://github.com/docker/docker-ce">Docker CE</a> 项目，但你可以选择任意的 Go 项目。</p>
<h4><span id="安装-go-和-gosec">安装 Go 和 gosec</span></h4><p>如果你还没安装 Go，你可以先从仓库中拉取下来。如果你用的是 Fedora 或其他基于 RPM 的 Linux 发行版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dnf install golang.x86_64</span><br></pre></td></tr></table></figure>

<p>如果你用的是其他操作系统，请参照 <a href="https://golang.org/doc/install">Golang 安装</a>页面。</p>
<p>使用 <code>version</code> 参数来验证 Go 是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.14.6 linux/amd64</span><br></pre></td></tr></table></figure>

<p>运行 <code>go get</code> 命令就可以轻松地安装 <code>gosec</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go get github.com/securego/gosec/cmd/gosec</span><br></pre></td></tr></table></figure>

<p>上面这行命令会从 GitHub 下载 <code>gosec</code> 的源码，编译并安装到指定位置。在仓库的 <code>README</code> 中你还可以看到<a href="https://github.com/securego/gosec#install">安装该工具的其他方法</a>。</p>
<p><code>gosec</code> 的源码会被下载到 <code>$GOPATH</code> 的位置，编译出的二进制文件会被安装到你系统上设置的 <code>bin</code> 目录下。你可以运行下面的命令来查看 <code>$GOPATH</code> 和 <code>$GOBIN</code> 目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go env | grep GOBIN</span><br><span class="line">GOBIN=&quot;/root/go/gobin&quot;</span><br><span class="line">$ go env | grep GOPATH</span><br><span class="line">GOPATH=&quot;/root/go&quot;</span><br></pre></td></tr></table></figure>

<p>如果 <code>go get</code> 命令执行成功，那么 <code>gosec</code> 二进制应该就可以使用了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l ~/go/bin/</span><br><span class="line">total 9260</span><br><span class="line">-rwxr-xr-x. 1 root root 9482175 Aug 20 04:17 gosec</span><br></pre></td></tr></table></figure>

<p>你可以把 <code>$GOPATH</code> 下的 <code>bin</code> 目录添加到 <code>$PATH</code> 中。这样你就可以像使用系统上的其他命令一样来使用 <code>gosec</code> 命令行工具（CLI）了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ which gosec</span><br><span class="line">/root/go/bin/gosec</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>使用 <code>gosec</code> 命令行工具的 <code>-help</code> 选项来看看运行是否符合预期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gosec -help</span><br><span class="line"></span><br><span class="line">gosec - Golang security checker</span><br><span class="line"></span><br><span class="line">gosec analyzes Go source code to look for common programming mistakes that</span><br><span class="line">can lead to security problems.</span><br><span class="line"></span><br><span class="line">VERSION: dev</span><br><span class="line">GIT TAG:</span><br><span class="line">BUILD DATE:</span><br><span class="line"></span><br><span class="line">USAGE:</span><br></pre></td></tr></table></figure>

<p>之后，创建一个目录，把源码下载到这个目录作为实例项目（本例中，我用的是 Docker CE）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir gosec-demo</span><br><span class="line">$ cd gosec-demo/</span><br><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo</span><br><span class="line">$ git clone https://github.com/docker/docker-ce.git</span><br><span class="line">Cloning into &#x27;docker-ce&#x27;...</span><br><span class="line">remote: Enumerating objects: 1271, done.</span><br><span class="line">remote: Counting objects: 100% (1271/1271), done.</span><br><span class="line">remote: Compressing objects: 100% (722/722), done.</span><br><span class="line">remote: Total 431003 (delta 384), reused 981 (delta 318), pack-reused 429732</span><br><span class="line">Receiving objects: 100% (431003/431003), 166.84 MiB | 28.94 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (221338/221338), done.</span><br><span class="line">Updating files: 100% (10861/10861), done.</span><br></pre></td></tr></table></figure>

<p>代码统计工具（本例中用的是 <code>cloc</code>）显示这个项目大部分是用 Go 写的，恰好迎合了 <code>gosec</code> 的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./cloc /root/gosec-demo/docker-ce/</span><br><span class="line">   10771 text files.</span><br><span class="line">    8724 unique files.                                          </span><br><span class="line">    2560 files ignored.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Language                         files          blank        comment           code</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">Go                                7222         190785         230478        1574580</span><br><span class="line">YAML                                37           4831            817         156762</span><br><span class="line">Markdown                           529          21422              0          67893</span><br><span class="line">Protocol Buffers                   149           5014          16562          10071</span><br></pre></td></tr></table></figure>

<h3><span id="使用默认选项运行-gosec">使用默认选项运行 gosec</span></h3><p>在 Docker CE 项目中使用默认选项运行 <code>gosec</code>，执行 <code>gosec ./...</code> 命令。屏幕上会有很多输出内容。在末尾你会看到一个简短的 “Summary”，列出了浏览的文件数、所有文件的总行数，以及源码中发现的问题数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/root/gosec-demo/docker-ce</span><br><span class="line">$ time gosec ./...</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Including rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Excluding rules: default</span><br><span class="line">[gosec] 2020/08/20 04:44:15 Import directory: /root/gosec-demo/docker-ce/components/engine/opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking package: opts</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/address_pools.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/env.go</span><br><span class="line">[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/hosts.go</span><br><span class="line"></span><br><span class="line"># End of gosec run</span><br><span class="line"></span><br><span class="line">Summary:</span><br><span class="line">   Files: 1278</span><br><span class="line">   Lines: 173979</span><br><span class="line">   Nosec: 4</span><br><span class="line">  Issues: 644</span><br><span class="line"></span><br><span class="line">real    0m52.019s</span><br><span class="line">user    0m37.284s</span><br><span class="line">sys     0m12.734s</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>滚动屏幕你会看到不同颜色高亮的行：红色表示需要尽快查看的高优先级问题，黄色表示中优先级的问题。</p>
<h4><span id="关于误判">关于误判</span></h4><p>在开始检查代码之前，我想先分享几条基本原则。默认情况下，静态检查工具会基于一系列的规则对测试代码进行分析，并报告出它们发现的<em>所有</em>问题。这是否意味着工具报出来的每一个问题都需要修复？非也。这个问题最好的解答者是设计和开发这个软件的人。他们最熟悉代码，更重要的是，他们了解软件会在什么环境下部署以及会被怎样使用。</p>
<p>这个知识点对于判定工具标记出来的某段代码到底是不是安全缺陷至关重要。随着工作时间和经验的积累，你会慢慢学会怎样让静态分析工具忽略非安全缺陷，使报告内容的可执行性更高。因此，要判定 <code>gosec</code> 报出来的某个问题是否需要修复，让一名有经验的开发者对源码做人工审计会是比较好的办法。</p>
<h4><span id="高优先级问题">高优先级问题</span></h4><p>从输出内容看，<code>gosec</code> 发现了 Docker CE 的一个高优先级问题，它使用的是低版本的 TLS（传输层安全Transport Layer Security<ruby>传输层安全<rt>Transport Layer Security<rt></rt></rt></ruby>）。无论什么时候，使用软件和库的最新版本都是确保它更新及时、没有安全问题的最好的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/daemon/logger/splunk/splunk.go:173] - G402 (CWE-295): TLS MinVersion too low. (Confidence: HIGH, Severity: HIGH)</span><br><span class="line">    172:</span><br><span class="line">  &gt; 173:        tlsConfig := &amp;tls.Config&#123;&#125;</span><br><span class="line">    174:</span><br></pre></td></tr></table></figure>

<p>它还发现了一个弱随机数生成器。它是不是一个安全缺陷，取决于生成的随机数的使用方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/namesgenerator/names-generator.go:843] - G404 (CWE-338): Use of weak random number generator (math/rand instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)</span><br><span class="line">    842: begin:</span><br><span class="line">  &gt; 843:        name := fmt.Sprintf(&quot;%s_%s&quot;, left[rand.Intn(len(left))], right[rand.Intn(len(right))])</span><br><span class="line">    844:        if name == &quot;boring_wozniak&quot; /* Steve Wozniak is not boring */ &#123;</span><br></pre></td></tr></table></figure>

<h4><span id="中优先级问题">中优先级问题</span></h4><p>这个工具还发现了一些中优先级问题。它标记了一个通过与 <code>tar</code> 相关的解压炸弹这种方式实现的潜在的 DoS 威胁，这种方式可能会被恶意的攻击者利用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/copy.go:357] - G110 (CWE-409): Potential DoS vulnerability via decompression bomb (Confidence: MEDIUM, Severity: MEDIUM)</span><br><span class="line">    356:</span><br><span class="line">  &gt; 357:                        if _, err = io.Copy(rebasedTar, srcTar); err != nil &#123;</span><br><span class="line">    358:                                w.CloseWithError(err)</span><br></pre></td></tr></table></figure>

<p>它还发现了一个通过变量访问文件的问题。如果恶意使用者能访问这个变量，那么他们就可以改变变量的值去读其他文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/context/tlsdata.go:80] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    79:         if caPath != &quot;&quot; &#123;</span><br><span class="line">  &gt; 80:                 if ca, err = ioutil.ReadFile(caPath); err != nil &#123;</span><br><span class="line">    81:                         return nil, err</span><br></pre></td></tr></table></figure>

<p>文件和目录通常是操作系统安全的最基础的元素。这里，<code>gosec</code> 报出了一个可能需要你检查目录的权限是否安全的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/contrib/apparmor/main.go:41] - G301 (CWE-276): Expect directory permissions to be 0750 or less (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    40:         // make sure /etc/apparmor.d exists</span><br><span class="line">  &gt; 41:         if err := os.MkdirAll(path.Dir(apparmorProfilePath), 0755); err != nil &#123;</span><br><span class="line">    42:                 log.Fatal(err)</span><br></pre></td></tr></table></figure>

<p>你经常需要在源码中启动命令行工具。Go 使用内建的 exec 库来实现。仔细地分析用来调用这些工具的变量，就能发现安全缺陷。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/testutil/fakestorage/fixtures.go:59] - G204 (CWE-78): Subprocess launched with variable (Confidence: HIGH, Severity: MEDIUM)</span><br><span class="line">    58:</span><br><span class="line">  &gt; 59:              cmd := exec.Command(goCmd, &quot;build&quot;, &quot;-o&quot;, filepath.Join(tmp, &quot;httpserver&quot;), &quot;github.com/docker/docker/contrib/httpserver&quot;)</span><br><span class="line">    60:                 cmd.Env = append(os.Environ(), []string&#123;</span><br></pre></td></tr></table></figure>

<h4><span id="低优先级问题">低优先级问题</span></h4><p>在这个输出中，gosec 报出了一个 <code>unsafe</code> 调用相关的低优先级问题，这个调用会绕开 Go 提供的内存保护。再仔细分析下你调用 <code>unsafe</code> 的方式，看看是否有被别人利用的可能性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/archive/changes_linux.go:264] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    263:        for len(buf) &gt; 0 &#123;</span><br><span class="line">  &gt; 264:                dirent := (*unix.Dirent)(unsafe.Pointer(&amp;buf[0]))</span><br><span class="line">    265:                buf = buf[dirent.Reclen:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[/root/gosec-demo/docker-ce/components/engine/pkg/devicemapper/devmapper_wrapper.go:88] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    87: func free(p *C.char) &#123;</span><br><span class="line">  &gt; 88:         C.free(unsafe.Pointer(p))</span><br><span class="line">    89: &#125;</span><br></pre></td></tr></table></figure>

<p>它还标记了源码中未处理的错误。源码中出现的错误你都应该处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/root/gosec-demo/docker-ce/components/cli/cli/command/image/build/context.go:172] - G104 (CWE-703): Errors unhandled. (Confidence: HIGH, Severity: LOW)</span><br><span class="line">    171:                err := tar.Close()</span><br><span class="line">  &gt; 172:                os.RemoveAll(dockerfileDir)</span><br><span class="line">    173:                return err</span><br></pre></td></tr></table></figure>

<h3><span id="自定义-gosec-扫描">自定义 gosec 扫描</span></h3><p>使用 <code>gosec</code> 的默认选项会带来很多的问题。然而，经过人工审计，随着时间推移你会掌握哪些问题是不需要标记的。你可以自己指定排除和包含哪些测试。</p>
<p>我上面提到过，<code>gosec</code> 是基于一系列的规则从 Go 源码中查找问题的。下面是它使用的完整的<a href="https://github.com/securego/gosec#available-rules">规则</a>列表：</p>
<ul>
<li>G101：查找硬编码凭证</li>
<li>G102：绑定到所有接口</li>
<li>G103：审计 <code>unsafe</code> 块的使用</li>
<li>G104：审计未检查的错误</li>
<li>G106：审计 <code>ssh.InsecureIgnoreHostKey</code> 的使用</li>
<li>G107: 提供给 HTTP 请求的 url 作为污点输入</li>
<li>G108: <code>/debug/pprof</code> 上自动暴露的剖析端点</li>
<li>G109: <code>strconv.Atoi</code> 转换到 int16 或 int32 时潜在的整数溢出</li>
<li>G110: 潜在的通过解压炸弹实现的 DoS</li>
<li>G201：SQL 查询构造使用格式字符串</li>
<li>G202：SQL 查询构造使用字符串连接</li>
<li>G203：在 HTML 模板中使用未转义的数据</li>
<li>G204：审计命令执行情况</li>
<li>G301：创建目录时文件权限分配不合理</li>
<li>G302：使用 <code>chmod</code> 时文件权限分配不合理</li>
<li>G303：使用可预测的路径创建临时文件</li>
<li>G304：通过污点输入提供的文件路径</li>
<li>G305：提取 zip/tar 文档时遍历文件</li>
<li>G306: 写到新文件时文件权限分配不合理</li>
<li>G307: 把返回错误的函数放到 <code>defer</code> 内</li>
<li>G401：检测 DES、RC4、MD5 或 SHA1 的使用</li>
<li>G402：查找错误的 TLS 连接设置</li>
<li>G403：确保最小 RSA 密钥长度为 2048 位</li>
<li>G404：不安全的随机数源（<code>rand</code>）</li>
<li>G501：导入黑名单列表：crypto/md5</li>
<li>G502：导入黑名单列表：crypto/des</li>
<li>G503：导入黑名单列表：crypto/rc4</li>
<li>G504：导入黑名单列表：net/http/cgi</li>
<li>G505：导入黑名单列表：crypto/sha1</li>
<li>G601: 在 <code>range</code> 语句中使用隐式的元素别名</li>
</ul>
<h4><span id="排除指定的测试">排除指定的测试</span></h4><p>你可以自定义 <code>gosec</code> 来避免对已知为安全的问题进行扫描和报告。你可以使用 <code>-exclude</code> 选项和上面的规则编号来忽略指定的问题。</p>
<p>例如，如果你不想让 <code>gosec</code> 检查源码中硬编码凭证相关的未处理的错误，那么你可以运行下面的命令来忽略这些错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gosec -exclude=G104 ./...</span><br><span class="line">$ gosec -exclude=G104,G101 ./...</span><br></pre></td></tr></table></figure>

<p>有时候你知道某段代码是安全的，但是 <code>gosec</code> 还是会报出问题。然而，你又不想完全排除掉整个检查，因为你想让 <code>gosec</code> 检查新增的代码。通过在你已知为安全的代码块添加 <code>#nosec</code> 标记可以避免 <code>gosec</code> 扫描。这样 <code>gosec</code> 会继续扫描新增代码，而忽略掉 <code>#nosec</code> 标记的代码块。</p>
<h4><span id="运行指定的检查">运行指定的检查</span></h4><p>另一方面，如果你只想检查指定的问题，你可以通过 <code>-include</code> 选项和规则编号来告诉 <code>gosec</code> 运行哪些检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gosec -include=G201,G202 ./...</span><br></pre></td></tr></table></figure>

<h4><span id="扫描测试文件">扫描测试文件</span></h4><p>Go 语言自带对测试的支持，通过单元测试来检验一个元素是否符合预期。在默认模式下，<code>gosec</code> 会忽略测试文件，你可以使用 <code>-tests</code> 选项把它们包含进来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gosec -tests ./...</span><br></pre></td></tr></table></figure>

<h4><span id="修改输出的格式">修改输出的格式</span></h4><p>找出问题只是它的一半功能；另一半功能是把它检查到的问题以用户友好同时又方便工具处理的方式报告出来。幸运的是，<code>gosec</code> 可以用不同的方式输出。例如，如果你想看 JSON 格式的报告，那么就使用 <code>-fmt</code> 选项指定 JSON 格式并把结果保存到 <code>results.json</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gosec -fmt=json -out=results.json ./...</span><br><span class="line"></span><br><span class="line">$ ls -l results.json</span><br><span class="line">-rw-r--r--. 1 root root 748098 Aug 20 05:06 results.json</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line">             &quot;severity&quot;: &quot;LOW&quot;,</span><br><span class="line">             &quot;confidence&quot;: &quot;HIGH&quot;,</span><br><span class="line">             &quot;cwe&quot;: &#123;</span><br><span class="line">                 &quot;ID&quot;: &quot;242&quot;,</span><br><span class="line">                 &quot;URL&quot;: &quot;https://cwe.mitre.org/data/definitions/242.html&quot;</span><br><span class="line">             &#125;,</span><br><span class="line">             &quot;rule_id&quot;: &quot;G103&quot;,</span><br><span class="line">             &quot;details&quot;: &quot;Use of unsafe calls should be audited&quot;,</span><br><span class="line">             &quot;file&quot;: &quot;/root/gosec-demo/docker-ce/components/engine/daemon/graphdriver/graphtest/graphtest_unix.go&quot;,</span><br><span class="line">             &quot;code&quot;: &quot;304: \t// Cast to []byte\n305: \theader := *(*reflect.SliceHeader)(unsafe.Pointer(\u0026buf))\n306: \theader.      Len *= 8\n&quot;,</span><br><span class="line">             &quot;line&quot;: &quot;305&quot;,</span><br><span class="line">             &quot;column&quot;: &quot;36&quot;</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure>

<h3><span id="用-gosec-检查容易被发现的问题">用 gosec 检查容易被发现的问题</span></h3><p>静态检查工具不能完全代替人工代码审计。然而，当代码量变大、有众多开发者时，这样的工具往往有助于以可重复的方式找出容易被发现的问题。它对于帮助新开发者识别和在编码时避免引入这些安全缺陷很有用。</p>
<hr>
<p>via: <a href="https://opensource.com/article/20/9/gosec">https://opensource.com/article/20/9/gosec</a></p>
<p>作者：<a href="https://opensource.com/users/gkamathe">Gaurav Kamathe</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">lxbowlf</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>url编码解码</title>
    <url>/fdc9c210/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BURSIZE 2048</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hex2dec</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">dec2hex</span><span class="params">(<span class="type">short</span> <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt;= c &amp;&amp; c &lt;= <span class="number">9</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">10</span> &lt;= c &amp;&amp; c &lt;= <span class="number">15</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">&#x27;A&#x27;</span> - <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//编码一个url</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">urlencode</span><span class="params">(<span class="type">char</span> url[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(url);</span><br><span class="line">    <span class="type">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> res[BURSIZE];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = url[i];</span><br><span class="line">        <span class="keyword">if</span> (    (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">                (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">                (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) || </span><br><span class="line">                c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res[res_len++] = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = (<span class="type">short</span> <span class="type">int</span>)c;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                j += <span class="number">256</span>;</span><br><span class="line">            <span class="type">int</span> i1, i0;</span><br><span class="line">            i1 = j / <span class="number">16</span>;</span><br><span class="line">            i0 = j - i1 * <span class="number">16</span>;</span><br><span class="line">            res[res_len++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            res[res_len++] = <span class="built_in">dec2hex</span>(i1);</span><br><span class="line">            res[res_len++] = <span class="built_in">dec2hex</span>(i0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[res_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(url, res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 解码url</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">urldecode</span><span class="params">(<span class="type">char</span> url[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(url);</span><br><span class="line">    <span class="type">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> res[BURSIZE];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = url[i];</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;%&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res[res_len++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c1 = url[++i];</span><br><span class="line">            <span class="type">char</span> c0 = url[++i];</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            num = <span class="built_in">hex2dec</span>(c1) * <span class="number">16</span> + <span class="built_in">hex2dec</span>(c0);</span><br><span class="line">            res[res_len++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[res_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(url, res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> url[<span class="number">100</span>] = <span class="string">&quot;http://&#x27;测试/@mike&quot;</span>;</span><br><span class="line">    <span class="built_in">urlencode</span>(url); <span class="comment">//编码后</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;http://&#x27;测试/@mike  ----&gt; %s\n&quot;</span>, url);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;http%3A//%27%E6%B5%8B%E8%AF%95/%40mike&quot;</span>;</span><br><span class="line">    <span class="built_in">urldecode</span>(buf); <span class="comment">//解码后</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;http%%3A//%%27%%E6%%B5%%8B%%E8%%AF%%95/%%40mike  ----&gt; %s\n&quot;</span>, buf);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】使用子模块和子树来管理 Git 项目</title>
    <url>/331c3227/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#必要性">必要性</a></li>
<li><a href="#git-子模块和子树">Git 子模块和子树</a></li>
<li><a href="#git-子模块是什么">Git 子模块是什么？</a><ul>
<li><a href="#克隆一个存储库并加载子模块">克隆一个存储库并加载子模块</a></li>
<li><a href="#下载子模块">下载子模块</a></li>
<li><a href="#拉取子模块">拉取子模块</a></li>
<li><a href="#使用子模块创建存储库">使用子模块创建存储库：</a></li>
<li><a href="#更新子模块的提交">更新子模块的提交</a></li>
<li><a href="#从一个父存储库中删除一个子模块">从一个父存储库中删除一个子模块</a></li>
</ul>
</li>
<li><a href="#git-子树是什么">Git 子树是什么？</a><ul>
<li><a href="#向父存储库中添加一个子树">向父存储库中添加一个子树</a></li>
<li><a href="#向子树推送修改以及从子树拉取修改">向子树推送修改以及从子树拉取修改</a></li>
</ul>
</li>
<li><a href="#你应该使用哪个">你应该使用哪个？</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>使用子模块和子树来帮助你管理多个存储库中共有的子项目。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222058.png" alt></p>
<p>如果你参与了开源项目的开发，那么你很可能已经用了 Git 来管理你的源码。你可能遇到过有很多依赖和/或子项目的项目。你是如何管理它们的？</p>
<p>对于一个开源组织，要实现社区<strong>和</strong>产品的单一来源文档和依赖管理比较棘手。文档和项目往往会碎片化和变得冗余，这致使它们很难维护。</p>
<h3><span id="必要性">必要性</span></h3><p>假设你想把单个项目作为一个存储库内的子项目，传统的方法是把该项目复制到父存储库中，但是，如果你想要在多个父项目中使用同一个子项目呢？如果把子项目复制到所有父项目中，当有更新时，你都要在每个父项目中做修改，这是不太可行的。这会导致父项目中的冗余和数据不一致，使更新和维护子项目变得很困难。</p>
<h3><span id="git-子模块和子树">Git 子模块和子树</span></h3><p>如果你可以用一条命令把一个项目放进另一个项目中，会怎样呢？如果你随时可以把一个项目作为子项目添加到任意数目的项目中，并可以同步更新修改呢？Git 提供了这类问题的解决方案：Git 子模块submodule<ruby>子模块<rt>submodule</rt></ruby>和 Git 子树subtree<ruby>子树<rt>subtree</rt></ruby>。创建这些工具的目的是以更加模块化的水平来支持共用代码的开发工作流，旨在 Git 存储库源码管理source-code management<ruby>源码管理<rt>source-code management</rt></ruby>（SCM）与它下面的子树之间架起一座桥梁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222135.png" alt="Cherry tree growing on a mulberry tree" title="Cherry tree growing on a mulberry tree"></p>
<p><em>生长在桑树上的樱桃树</em></p>
<p>下面是本文要详细介绍的概念的一个真实应用场景。如果你已经很熟悉树形结构，这个模型看起来是下面这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222254.png" alt="Tree with subtrees" title="Tree with subtrees"></p>
<h3><span id="git-子模块是什么">Git 子模块是什么？</span></h3><p>Git 在它默认的包中提供了子模块，子模块可以把 Git 存储库嵌入到其他存储库中。确切地说，Git 子模块指向子树中的某次提交。下面是我 <a href="https://github.com/manaswinidas/Docs-test/">Docs-test</a> GitHub 存储库中的 Git 子模块的样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222434.png" alt="Git submodules screenshot" title="Git submodules screenshot"></p>
<p><a href="mailto:folder@commitId">文件夹@提交 Id</a> 格式表明这个存储库是一个子模块，你可以直接点击文件夹进入该子树。名为 <code>.gitmodules</code> 的配置文件包含所有子模块存储库的详细信息。我的存储库的 <code>.gitmodules</code> 文件如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222553.png" alt="Screenshot of .gitmodules file" title="Screenshot of .gitmodules file"></p>
<p>你可以用下面的命令在你的存储库中使用 Git 子模块：</p>
<h4><span id="克隆一个存储库并加载子模块">克隆一个存储库并加载子模块</span></h4><p>克隆一个含有子模块的存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone --recursive &lt;URL to Git repo&gt;</span><br></pre></td></tr></table></figure>

<p>如果你之前已经克隆了存储库，现在想加载它的子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init</span><br></pre></td></tr></table></figure>

<p>如果有嵌套的子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h4><span id="下载子模块">下载子模块</span></h4><p>串行地连续下载多个子模块是很枯燥的工作，所以 <code>clone</code> 和 <code>submodule update</code> 会支持 <code>--jobs</code> （或 <code>-j</code>）参数：</p>
<p>例如，想一次下载 8 个子模块，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive -j 8</span><br><span class="line">$ git clone --recursive --jobs 8 &lt;URL to Git repo&gt;</span><br></pre></td></tr></table></figure>

<h4><span id="拉取子模块">拉取子模块</span></h4><p>在运行或构建父项目之前，你需要确保依赖的子项目都是最新的。</p>
<p>拉取子模块的所有修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule update --remote</span><br></pre></td></tr></table></figure>

<h4><span id="使用子模块创建存储库">使用子模块创建存储库：</span></h4><p>向一个父存储库添加子树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule add &lt;URL to Git repo&gt;</span><br></pre></td></tr></table></figure>

<p>初始化一个已存在的 Git 子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule init</span><br></pre></td></tr></table></figure>

<p>你也可以通过为 <code>submodule update</code> 命令添加 <code>--update</code> 参数在子模块中创建分支和追踪提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule update --remote</span><br></pre></td></tr></table></figure>

<h4><span id="更新子模块的提交">更新子模块的提交</span></h4><p>上面提到过，一个子模块就是一个指向子树中某次提交的链接。如果你想更新子模块的提交，不要担心。你不需要显式地指定最新的提交。你只需要使用通用的 <code>submodule update</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule update</span><br></pre></td></tr></table></figure>

<p>就像你平时创建父存储库和把父存储库推送到 GitHub 那样添加和提交就可以了。</p>
<h4><span id="从一个父存储库中删除一个子模块">从一个父存储库中删除一个子模块</span></h4><p>仅仅手动删除一个子项目文件夹不会从父项目中移除这个子项目。想要删除名为 <code>childmodule</code> 的子模块，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm -f childmodule</span><br></pre></td></tr></table></figure>

<p>虽然 Git 子模块看起来很容易上手，但是对于初学者来说，有一定的使用门槛。</p>
<h3><span id="git-子树是什么">Git 子树是什么？</span></h3><p>Git 子树 subtree<ruby>子树<rt> subtree</rt></ruby>，是在 Git 1.7.11 引入的，让你可以把任何存储库的副本作为子目录嵌入另一个存储库中。它是 Git 项目可以注入和管理项目依赖的几种方法之一。它在常规的提交中保存了外部依赖信息。Git 子树提供了整洁的集成点，因此很容易复原它们。</p>
<p>如果你参考 <a href="https://help.github.com/en/github/using-git/about-git-subtree-merges">GitHub 提供的子树教程</a>来使用子树，那么无论你什么时候添加子树，在本地都不会看到 <code>.gittrees</code> 配置文件。这让我们很难分辨哪个是子树，因为它们看起来很像普通的文件夹，但是它们却是子树的副本。默认的 Git 包中不提供带 <code>.gittrees</code> 配置文件的 Git 子树版本，因此如果你想要带 <code>.gittrees</code> 配置文件的 git-subtree 命令，必须从 Git 源码存储库的 <a href="https://github.com/git/git/tree/master/contrib/subtree">/contrib/subtree 文件夹</a> 下载 git-subtree。</p>
<p>你可以像克隆其他常规的存储库那样克隆任何含有子树的存储库，但由于在父存储库中有整个子树的副本，因此克隆过程可能会持续很长时间。</p>
<p>你可以用下面的命令在你的存储库中使用 Git 子树。</p>
<h4><span id="向父存储库中添加一个子树">向父存储库中添加一个子树</span></h4><p>想要向父存储库中添加一个子树，首先你需要执行 <code>remote add</code>，之后执行 <code>subtree add</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add remote-name &lt;URL to Git repo&gt;</span><br><span class="line">$ git subtree add --prefix=folder/ remote-name &lt;URL to Git repo&gt; subtree-branchname</span><br></pre></td></tr></table></figure>

<p>上面的命令会把整个子项目的提交历史合并到父存储库。</p>
<h4><span id="向子树推送修改以及从子树拉取修改">向子树推送修改以及从子树拉取修改</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git subtree push-all</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git subtree pull-all</span><br></pre></td></tr></table></figure>

<h3><span id="你应该使用哪个">你应该使用哪个？</span></h3><p>任何工具都有优缺点。下面是一些可能会帮助你决定哪种最适合你的特性：</p>
<ul>
<li>Git 子模块的存储库占用空间更小，因为它们只是指向子项目的某次提交的链接，而 Git 子树保存了整个子项目及其提交历史。</li>
<li>Git 子模块需要在服务器中可访问，但子树是去中心化的。</li>
<li>Git 子模块大量用于基于组件的开发，而 Git 子树多用于基于系统的开发。</li>
</ul>
<p>Git 子树并不是 Git 子模块的直接可替代项。有明确的说明来指导我们该使用哪种。如果有一个归属于你的外部存储库，使用场景是向它回推代码，那么就使用 Git 子模块，因为推送代码更容易。如果你有第三方代码，且不会向它推送代码，那么使用 Git 子树，因为拉取代码更容易。</p>
<p>自己尝试使用 Git 子树和子模块，然后在评论中留下你的使用感想。</p>
<hr>
<p>via: <a href="https://opensource.com/article/20/5/git-submodules-subtrees">https://opensource.com/article/20/5/git-submodules-subtrees</a></p>
<p>作者：<a href="https://opensource.com/users/manaswinidas">Manaswini Das</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】关于 CGo 的字符串函数的解释</title>
    <url>/8c45788a/</url>
    <content><![CDATA[<p><a href="https://github.com/golang/go/wiki/cgo">cgo</a> 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。在 CGo 的文档中有简洁的解释，但我认为解释得太简洁了，因为文档只涉及了定义中的某些特定字符串，而忽略了两个很重要的注意事项。我曾经踩过这里的坑，现在我要详细解释一下。</p>
<p>四个函数分别是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">CString</span><span class="params">(<span class="type">string</span>)</span></span> *C.char</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">GoString</span><span class="params">(*C.char)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">GoStringN</span><span class="params">(*C.char, C.<span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">GoBytes</span><span class="params">(unsafe.Pointer, C.<span class="type">int</span>)</span></span> []<span class="type">byte</span></span><br></pre></td></tr></table></figure>

<p><code>C.CString()</code> 等价于 C 的 <code>strdup()</code>，像文档中提到的那样，把 Go 的字符串复制为可以传递给 C 函数的 C 的 <code>char *</code>。很讨厌的一件事是，由于 Go 和 CGo 类型的定义方式，调用 <code>C.free</code> 时需要做一个转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cs := C.CString(<span class="string">&quot;a string&quot;</span>)</span><br><span class="line">C.free(unsafe.Pointer(cs))</span><br></pre></td></tr></table></figure>

<p>请留意，Go 字符串中可能嵌入了 <code>\0</code> 字符，而 C 字符串不会。如果你的 Go 字符串中有 <code>\0</code> 字符，当你调用 <code>C.CString()</code> 时，C 代码会从 <code>\0</code> 字符处截断你的字符串。这往往不会被注意到，但<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString">有时文本并不保证不含 null 字符</a>。</p>
<p><code>C.GoString()</code> 也等价于 <code>strdup()</code>，但与 <code>C.CString()</code> 相反，是把 C 字符串转换为 Go 字符串。你可以用它定义结构体的字段，或者是声明为 C 的 <code>char *</code>（在 Go 中叫 <code>*C.cahr</code>） 的其他变量，抑或其他的一些变量（我们后面会看到）。</p>
<p><code>C.GoStringN()</code> 等价于 C 的 <code>memmove()</code>，与 C 中普通的字符串函数不同。<strong>它把整个 N 长度的 C buffer 复制为一个 Go 字符串，不单独处理 null 字符。</strong>再详细点，它也通过复制来实现。如果你有一个定义为 <code>char feild[64]</code> 的结构体的字段，然后调用了 <code>C.GoStringN(&amp;field, 64)</code>，那么你得到的 Go 字符串一定是 64 个字符，字符串的末尾有可能是一串 <code>\0</code> 字符。</p>
<p>(我认为这是 cgo 文档中的一个 bug。它宣称 GoStringN 的入参是一个 C 的字符串，但实际上很明显不是，因为 C 的字符串不能以 null 字符结束，而 GoStringN 不会在 null 字符处结束处理。)</p>
<p><code>C.GoBytes()</code> 是 <code>C.GoStringN()</code> 的另一个版本，不返回 <code>string</code> 而是返回 <code>[]byte</code>。它没有宣称以 C 字符串作为入参，它仅仅是对整个 buffer 做了内存拷贝。</p>
<p>如果你要拷贝的东西不是以 null 字符结尾的 C 字符串，而是固定长度的 memory buffer，那么 <code>C.GoString()</code> 正好能满足需求；它避开了 C 中传统的问题<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString">处理不是 C 字符串的 ’string‘</a>。然而，如果你要处理定义为 <code>char field[N]</code> 的结构体字段这种限定长度的 C 字符串时，这些函数<em>都不能</em>满足需求。</p>
<p>传统语义的结构体中固定长度的字符串变量，定义为 <code>char field[N]</code> 的字段，以及“包含一个字符串”等描述，都表示当且仅当字符串有足够空间时以 null 字符结尾，换句话说，字符串最多有 N-1 个字符。如果字符串正好有 N 个字符，那么它不会以 null 字符结尾。这是 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/UnixAPIMistake">C 代码中诸多 bug 的根源</a>，也不是一个好的 API，但我们却摆脱不了这个 API。每次我们遇到这样的字段，文档不会明确告诉你字段的内容并不一定是 null 字符结尾的，你需要自己假设你有这种 API。</p>
<p><code>C.GoString()</code> 或 <code>C.GoStringN()</code> 都不能正确处理这些字段。使用 <code>GoStringN()</code> 相对来说出错更少；它仅仅返回一个末尾有一串 <code>\0</code> 字符长度为 N 的 Go 字符串（如果你仅仅是把这些字段打印出来，那么你可能不会留意到；我经常干这种事）。使用有诱惑力的 <code>GoString()</code> 更是引狼入室，因为它内部会对入参做 <code>strlen()</code>；如果字符末尾没有 null 字符，<code>strlen()</code> 会访问越界的内存地址。如果你走运，你得到的 Go 字符串末尾会有大量的垃圾。如果你不走运，你的 Go 程序出现段错误，因为 <code>strlen()</code> 访问了未映射的内存地址。</p>
<p>（总的来说，如果字符串末尾出现了大量垃圾，通常意味着在某处有不含结束符的 C 字符串。）</p>
<p>你需要的是与 C 的 <code>strndup()</code> 等价的 Go 函数，以此来确保复制不超过 N 个字符且在 null 字符处终止。下面是我写的版本，不保证无错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">   s := C.GoStringN(cs, C.<span class="type">int</span>(<span class="built_in">len</span>))</span><br><span class="line">   i := strings.IndexByte(s, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> C.GoString(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于有 <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding">Go 的字符串怎样占用内存</a>的问题，这段代码做了些额外的工作来最小化额外的内存占用。你可能想用另一种方法，返回一个 <code>GoStringN()</code> 字符串的切片。你也可以写复杂的代码，根据 i 和 len 的不同来决定选用哪种方法。</p>
<p>更新：<a href="https://github.com/golang/go/issues/12428#issuecomment-136581154">Ian Lance Taylor 给我展示了份更好的代码</a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strndup</span><span class="params">(cs *C.char, <span class="built_in">len</span> <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> C.GoStringN(cs, C.<span class="type">int</span>(C.strnlen(cs, C.size_t(<span class="built_in">len</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的，这里有大量的转换。这篇文章就是你看到的 Go 和 Gco 类型的结合。</p>
<hr>
<p>via: <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions">https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions</a></p>
<p>作者：<a href="https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann">ChrisSiebenmann</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/polaris1119">polaris1119</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go 中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式发号器架构设计</title>
    <url>/3d5a1f1d/</url>
    <content><![CDATA[<h3><span id="一-需求设计">一 需求设计</span></h3><ol>
<li><p>分布式环境下，保证每个序列号（sequence）是全系统唯一的；</p>
</li>
<li><p>序列号可排序，满足单调递增的规律；</p>
</li>
<li><p>特定场景下，能生成无规则（或者看不出规则）的序列号；</p>
</li>
<li><p>生成的序列号尽量短；</p>
</li>
<li><p>序列号可进行二次混淆，提供可扩展的interface，业务方自定义实现。</p>
</li>
</ol>
<h3><span id="二-方案设计">二 方案设计</span></h3><p>为了满足上述需求，发号器必须能够支持不同的生成策略，最好是还能支持自定义的生成策略，这就对系统本身的可扩展性提出了要求。 目前，发号器设计了两种比较通用的基础策略，各有优缺点，但结合起来，能达到优势互补的目的。</p>
<h4><span id="1-segment">1. segment</span></h4><p>第一种策略称之为『分段』（segment），下文将对其进行详细阐述： 整个segment发号器有两个重要的角色：Redis和MongoDB，理论上MongoDB是可以被MySQL或其他DB产品所替代的。 segment发号器所产生的号码满足单调递增的规律，短时间内产生的号码不会有过长的问题（可根据实际需要，设置初始值，比如 100）。</p>
<h5><span id="redis数据结构hash类型">Redis数据结构（Hash类型）</span></h5><pre><code>key: &lt;string&gt;，表示业务主键/名称
value: &#123;
  cur: &lt;long&gt;，表示当前序列号
  max: &lt;long&gt;，表示这个号段最大的可用序列号
&#125;</code></pre><p>取号的大部分操作都集中在Redis，为了保证序列号递增的原子性，取号的功能可以用Lua脚本实现。</p>
<pre><code>--[[
  由于RedisTemplate设置的HashValueSerializer是GenericToStringSerializer，故此处的HASH结构中的
  VALUE都是string类型，需要使用tonumber函数转换成数字类型。
]]
local max = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;max&quot;)  --获取一段序列号的max
local cur = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;cur&quot;)  --获取当前发号位置
if tonumber(cur) &gt;= tonumber(max) then  --没有超过这段序列号的上限
    local step = ARGV[1]
    if (step == nil) then  --没有传入step参数
        step = redis.pcall(&quot;HGET&quot;, KEYS[1], &quot;step&quot;)  --获取这段序列号的step配置参数值
    end
    redis.pcall(&quot;HSET&quot;, KEYS[1], &quot;max&quot;, tonumber(max) + tonumber(step))  --调整max参数值，扩展上限
end
return redis.pcall(&quot;HINCRBY&quot;, KEYS[1], &quot;cur&quot;, 1)  --触发HINCRBY操作，对cur自增，并返回自增后的值</code></pre><p>​    </p>
<p>注意：在redis执行lua script期间，redis处于BUSY状态，这个时候对redis的任何形式的访问都会抛出JedisBusyException异常，所以lua script中的处理逻辑不得太复杂。 </p>
<p>值得一提的是，即使切换到一个新的database，或者开启新线程执行lua script，都将会遇到同样的问题，毕竟redis是单进程单线程的。</p>
<p> 如果不幸遇到上述问题，需要使用redis-cli客户端连上redis-server，向其发送SCRIPT KILL命令，即可终止脚本执行。</p>
<p>如果想避免上述问题，也可以直接使用Springboot提供的RedisTemplate，能支持绝大部分redis command。</p>
<h5><span id="mongodb-数据结构">MongoDB 数据结构</span></h5><pre><code>&#123;
 bizTag: &lt;string&gt;,  表示业务主键/名称
 max: &lt;long&gt;,  表示这个号段最大的可用序列号
 step: &lt;int&gt;, 每次分段的步长
 timestamp: &lt;long&gt;,  更新数据的时间戳（毫秒）
&#125;</code></pre><p>MongoDB部分主要是对号段的分配进行管理，一个号段不能多发，也可以根据发号情况，适当放缩号段步长（step）。 </p>
<p>到此为止，segment发号器的雏形已经形成了。 一个比较突出的问题是在两个号段衔接的时间点，当一个segment派发完了后，会对MongoDB和Redis中的数据中的max扩容，I/O消耗比正常发号要稍多，会遇到“尖刺” </p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210219.png" alt></p>
<p>为了消除“尖刺”，可以使用双Buffer模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210239.png" alt></p>
<p>这个模型的核心思想就是“<strong>预分配</strong>”。可以设置一个阈值（threshold），比如20%，当Buffer-1里面的号段已经消耗了20%，那么立刻根据Buffer-1的max和step，开辟Buffer-2。 当Buffer-1完全消耗了，可以无缝衔接Buffer-2,。</p>
<p>如果Buffer-2的消耗也达到阈值了，又可以开辟Buffer-1，如此往复。 </p>
<p>接下来，我们来讨论一下<strong>异常/故障</strong>情况。</p>
<p> ① Redis宕机。因为大部分发号工作都是依靠Redis完成的，所以发生了这种情况是非常糟糕的。如果想有效降低此风险，最行之有效的办法是对Redis进行集群化，通常是1主2从，这样可以挺住非常高的QPS了。 当然也有退而求其次的办法，就是利用上述提到的双Buffer模型。不依赖Redis取号，直接通过程序控制，利用机器内存。所以当需要重启发号服务之前，要确保依赖的组件是运行良好的，不然号段就丢失了。</p>
<p> ② 要不要持久化的问题。这个问题主要是针对Redis，如果没有记录下当前的取号进度，那么随着Redis的宕机，取号现场就变得难以恢复了；如果每次都记录取号进度，那么这种I/O高密度型的作业会对服务性能 造成一定影响，并且随着取号的时间延长，恢复取号现场就变得越来越慢了，甚至到最后是无法忍受的。除了对Redis做高可用之外，引入MongoDB也是出于对Redis持久化功能辅助的考虑。 个人建议：如果Redis已经集群化了，而且还开启了双Buffer的策略，以及MongoDB的加持，可以不用再开启Redis的持久化了。 如果考虑到极端情况下，Redis还是宕机了，我们可以使用MongoDB里面存下来的max，就max+1赋值给cur（避免上个号段取完，正好宕机了）。 </p>
<p>③ MongoDB宕机。这个问题不是很严重，只要将step适当拉长一些（至少取号能支撑20分钟），利用Redis还在正常取号的时间来抢救MongoDB。不过，考虑到实际可能没这么快恢复mongo服务，可以在程序中采取 一些容错措施，比如号段用完了，mongo服务无法到达，直接关闭取号通道，直到MongoDB能正常使用；或者程序给一个默认的step，让MongoDB中的max延长到max+step*n（可能取了N个号段MongoDB才恢复过来）， 这样取号服务也可以继续。依靠程序本身继续服务，那么需要有相关的log，这样才有利于恢复MongoDB中的数据。</p>
<p> ④ 取号服务宕机。这个没什么好说的，只能尽快恢复服务运行了。 </p>
<p>⑤ Redis，MongoDB都宕机了。这种情况已经很极端了，只能利用双Buffer策略，以及程序默认的设置进行工作了，同样要有相关的log，以便恢复Redis和MongoDB。</p>
<p> ⑥ 都宕机了。我有一句mmp不知当讲不当讲……</p>
<h4><span id="2-snowflake">2、snowflake</span></h4><p>第二种策略是Twitter出品，算法思想比较巧妙，实现的难度也不大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210341.png" alt></p>
<p>以上示意图描述了一个序列号的二进制组成结构。 第一位不用，恒为0，即表示正整数； 接下来的41位表示时间戳，精确到毫秒。为了节约空间，可以将此时间戳定义为距离某个时间点所经历的毫秒数（Java默认是1970-01-01 00:00:00）； 再后来的10位用来标识工作机器，如果出现了跨IDC的情况，可以将这10位一分为二，一部分用于标识IDC，一部分用于标识服务器； 最后12位是序列号，自增长。</p>
<p> snowflake的核心思想是64bit的合理分配，但不必要严格按照上图所示的分法。 如果在机器较少的情况下，可以适当缩短机器id的长度，留出来给序列号。 </p>
<p>当然，snowflake的算法将会面临两个挑战： </p>
<p>① 机器id的指定。这个问题在分布式的环境下会比较突出，通常的解决方案是利用Redis或者Zookeeper进行机器注册，确保注册上去的机器id是唯一的。为了解决 强依赖Redis或者Zookeeper的问题，可以将机器id写入本地文件系统。</p>
<p> ② 机器id的生成规则。这个问题会有一些纠结，因为机器id的生成大致要满足三个条件：a. int类型(10bit)纯数字，b. 相对稳定，c. 与其他机器要有所区别。至于优雅美观，都是其次了。对于机器id的存储，可以使用HASH结构，KEY的规则是“application-name.port.ip”，其中ip是通过算法转换成了一段长整型的纯数字，VALUE则是机器id， 服务id，机房id，其中，可以通过服务id和机房id反推出机器id。 </p>
<p>假设服务id(workerId)占8bit，机房id(rackId)占2bit，从1开始，workerId=00000001，rackId=01，machineId=00000000101 如果用Redis存储，其表现形式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210414.png" alt></p>
<p> 如果存储在文件中（建议properties文件），则文件名是sequence-client:8112:3232235742.properties，文件内容如下：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210429.png" alt></p>
<p>如果发号服务上线，直接按照“application-name.port.ip”的规则取其内容。</p>
<p> ③ 时钟回拨。因为snowflake对系统时间是很依赖的，所以对于时钟的波动是很敏感的，尤其是时钟回拨，很有可能就会出现重复发号的情况。时钟回拨问题解决策略通常是直接拒绝发号，直到时钟正常，必要时进行告警。</p>
<h3><span id="三-程序设计">三 程序设计</span></h3><p>整个发号过程可以分成三个层次：</p>
<p> 1、策略层(strategy layer)：这个层面决定的是发号方法/算法，涵盖了上述所讲的segment和snowflake两种方式，当然，用户也可以自己扩展实现其他发号策略。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210445.png" alt></p>
<p>最顶上定义Sequence实际上就是发号的结果。bizType是对发号业务场景的定义，比如订单号，用户ID，邀请好友的分享码。 发号策略的init接口是发号前的初始化工作，而generate接口就是调用发号器的主入口了。 当然，考虑到各种异常情况，加入了拒绝发号的处理器（SequenceRejectedHandler），默认实现只是记录日志，用户可根据需求去实现该处理器，然后用set方法设置发号策略的拒绝处理器。</p>
<p> 2、插件层(plugin layer)：此处的插件可以理解是一种拦截器，贯穿SequenceStrategy的发号全周期。引入插件后，无疑是丰富了整个发号的操作过程，用户可以从中干预到发号的整个流程，以便达到其他的目的，比如：记录发号历史，统计发号速率，发号二次混淆等。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210511.png" alt></p>
<p> 可以看出，插件被设计成『注册式』的，发号策略只有注册了相关插件之后，插件才能生效， 当然，一个插件能被多个发号策略所注册，一个发号策略也能同时注册多个插件，所以两者是多对多的关系，PluginManager的出现就是解决插件的注册管理问题。 从SequencePlugin的定义中可以发现，插件是有优先级（Order）的，通过getOrder()可以获得，在这套发号系统里，Order值越小，表示该插件越优先执行。此外，插件有三个重要的操作： before，表示发号之前的处理。若返回了false，那么该插件后面的操作都失效了，否则继续执行发号流程。 after，表示发号之后的处理。 doException，表示插件发生异常的处理方法。</p>
<p> 3、持久层(persistence layer)：这个层面指代的是上述所提的MongoDB部分，如果不需要持久化的支持，可以不实现此接口，那么整个发号器就变成纯内存管理的了。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210529.png" alt></p>
<p>PersistRepository定义了基本的CRUD方法，其中persistId可以理解成上述提到的BizType。 一切的持久化对象都是从PersistModel开始的，上图中的Segment、PersistDocument都是为了实现分段发号器而定义的。</p>
<h3><span id="四-总结">四 总结</span></h3><p>这篇文章详细阐述了分布式发号器系统的设计，旨在能做出一个可扩展，易维护的发号系统。业界比较知名的发号算法似乎也不多，整个发号系统不一定就按照笔者所做的设计，还是要立足于具体的业务需求。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式数据库系统(DDBS)</title>
    <url>/728c18a3/</url>
    <content><![CDATA[<p>业务规模较小时，使用单机mysql作存储。但伴随业务发展，存储容量和并发能力会有瓶颈。</p>
<p>首先，假设单机的硬盘为1.8T，也可以挂更大容量硬盘，但仍有限。</p>
<p>其次，单机的读写并发能力有限，假设峰值写入qps1000，峰值读取qps3000，网卡对读取时流量也有要求，单次访问的读取量不应过大。</p>
<p>单机的链接数也有限。</p>
<p>那么，当使用单机mysql的业务发展，受到以上瓶颈时，一般的思路会是什么呢？一台机器不行，用两台呢，再不行，扩展更多台。</p>
<p>一台扩展为两台，磁盘容量扩大了，通过分表，将表打散在不同机器上，共同承担写入任务，并发也提高了，感觉这个思路是对的。</p>
<p>那么在这个过程中，我们需要做什么？</p>
<p>业务发展到单机无法承受，即使在单机上，很多表应该也做过分表了。一般会根据业务选择分表键。单个表的大小mysql也有一定要求，一般存储量不大于1G，单条记录小一些，一般不超过1k，条数一般不超过1000万条，最多不超过5000万条，否则表的使用和维护效率都很低。假设业务已经做了足够多的分表，满足三年的数据增长需要，第一年过后，每个分表的条数达到200万条，整机存储容量使用了一半，此时我们想拆分为两台机器。</p>
<p>此时我们可以将原机器上部分表数据同步到新机器上，并在model层抽象一个路由层，将对数据库的操作发到不同的机器上，上层业务仍可以认为在使用单机。此时可以将原机器上不归属自己管理范围的表删除，腾出空间。</p>
<p>一台变成了两台，向分布式走了一步。此时存储容量和并发都提高了，由路由层管理两台机器。如果两台或今后的多台机器，并发数高于路由层处理能力怎么办？那还要把路由层机器也扩一下，把路由规则都写进去，大家按一个格则办事。</p>
<p>经过上面的一番折腾，数据库机器水平扩展，解决了单机存在的一些问题。在这个扩展的过程中，是否会对业务产生中断影响呢？</p>
<p>会有一点影响。至少在路由层改路由表时，会中断数据库的写入，读取此时可以不中断。</p>
<p>ddbs中，使用到的多台机器，都叫做分片。分片提高了系统存储容量和并发能力，引入分片，也是系统的复杂度提高了，需要引入路由层机器，路由机器也可能需要扩展，复杂操作，还需要添加更多逻辑功能。但至少可以可业务逻辑区分开，业务可以把ddbs当做单机在使用。</p>
<p>那么ddbs有哪些不足呢？</p>
<p>ddbs还是要基于分表、分片实现的。那么对数据库的任何操作，首要条件是需要指明操作的分表键。没有这个维度的准确值，就不能对数据库操作，当然除非是备用库，那你随便扫表，因为备用库可以转为冗余安全，不走线上流量，可以做统计任务。</p>
<p>单指明分表键还不行，还要注意操作的数据可能会分布在不同分表、不同分片中，这样的操作会引发ddbs产生大量并发操作，业务的一个请求就会占用多个机器多个链接，使ddbs得并发能力大打折扣。比如 ‘where 分表键 in （）’操作，这种操作要慎重，in中个数不可太多。</p>
<p> 分表键最好选用整形，字符串型，可能hash后分配不均，表大小不均衡。</p>
<p>事物操作在ddbs中的实现，非常耗费系统性能。事务类操作需要路由控制层控制整个操作过程，期中可能涉及多个分片，多个不同的表的操作，对系统整体可用性要求高</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁高并发优化</title>
    <url>/7db296fb/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#问题场景">问题场景:</a></li>
<li><a href="#库存超卖现象是怎么产生的">库存超卖现象是怎么产生的？</a></li>
<li><a href="#用分布式锁如何解决库存超卖问题">用分布式锁如何解决库存超卖问题？</a></li>
<li><a href="#分布式锁的方案在高并发场景下">分布式锁的方案在高并发场景下</a></li>
<li><a href="#如何对分布式锁进行高并发优化">如何对分布式锁进行高并发优化？</a></li>
<li><a href="#分布式锁并发优化方案有没有什么不足">分布式锁并发优化方案有没有什么不足？</a></li>
</ul>
<!-- tocstop -->

<h4><span id="问题场景">问题场景:</span></h4><p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？</p>
<h4><span id="库存超卖现象是怎么产生的">库存超卖现象是怎么产生的？</span></h4><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004321.png" alt="库存超卖"></p>
<p>假设订单系统部署两台机器上，不同的用户都要同时买10台iphone，分别发了一个请求给订单系统。<br>接着每个订单系统实例都去数据库里查了一下，当前iphone库存是12台<br>于是乎，每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台</p>
<h4><span id="用分布式锁如何解决库存超卖问题">用分布式锁如何解决库存超卖问题？</span></h4><p>分布式锁的实现原理:<br>同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004449.png" alt="分布式锁代码"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004607.png" alt="fenbushisuo_yuanli"></p>
<p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</p>
<p>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的</p>
<h4><span id="分布式锁的方案在高并发场景下">分布式锁的方案在高并发场景下</span></h4><p>分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。</p>
<p>比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。</p>
<p>假设加锁之后，释放锁之前，查库存 -&gt; 创建订单 -&gt; 扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。</p>
<p>那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。</p>
<p>比如一秒钟来50个请求，都是对iphone下单的，那么每个请求处理20毫秒，一个一个来，最后1000毫秒正好处理完50个请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004059.png" alt="分布式锁串行"></p>
<p>所以, 能看出来简单的使用分布式锁来处理库存超卖问题，存在的缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p>
<p>这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p>
<p>因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在一秒内瞬间下1000个订单，因为小电商系统没那场景。</p>
<h4><span id="如何对分布式锁进行高并发优化">如何对分布式锁进行高并发优化？</span></h4><p>现在按照刚才的计算，你一秒钟只能处理针对iphone的50个订单。</p>
<p>其实说出来也很简单，相信很多人看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁！</p>
<p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。</p>
<p>另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p>
<p>LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p>
<p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p>
<p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004652.png" alt="分段加锁"></p>
<p>其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。</p>
<p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p>
<p>接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p>
<p>这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&gt; 判断库存是否充足 -&gt; 扣减库存。</p>
<p>这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。</p>
<p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？</p>
<p>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现</p>
<h4><span id="分布式锁并发优化方案有没有什么不足">分布式锁并发优化方案有没有什么不足？</span></h4>]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/6a0b412d/</url>
    <content><![CDATA[<p>leetcode-26</p>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>理解题意:</p>
<pre><code>1. 当给定数组为空时, 返回0
 2. 不能引入其他数组空间, 即不能再使用一个新的数组来存放结果
 3. 最终结果不重复, 整体思路是把数组后面的几个元素挪到前面去, 用后面的元素覆盖掉前面重复了的元素, 保持数组的长度始终不变. 数组中超出新长度(去重后的长度) 后的元素无视</code></pre><p>用快慢指针的思路解答:</p>
<ol>
<li>给定两个游标 left和right</li>
<li>当给定数组的下标为left和right的值相等时,  就不管</li>
<li>当不相等时, 做一个操作: 把当前right的值赋给left的下一个坐标</li>
</ol>
<p>code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">    //如果是空切片，那就返回0</span><br><span class="line">    if len(nums) == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    //用两个标记来比较相邻位置的值</span><br><span class="line">    //当一样的话，那就不管继续</span><br><span class="line">    //当不一样的时候，就把right指向的值赋值给left下一位</span><br><span class="line">    left, right := 0, 1</span><br><span class="line">    for ; right &lt; len(nums); right++ &#123;</span><br><span class="line">        if nums[left] == nums[right] &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(nums[:left+1])</span><br><span class="line">    return left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>制作种子</title>
    <url>/7592d71b/</url>
    <content><![CDATA[<p>1.下载mktorrent<br><code>git clone https://github.com/lxbwolf/mktorrent.git</code><br>2.下载完成后进入到文件夹里面<br>例如：<code>cd mktorrent</code>（如果是根目录的话）<br>3. <code>make</code><br>4. <code>make install</code><br>5. 默认安装目录位于<code>/usr/local/bin</code>，使用cd命令，从默认的/root路径切换到要制作成种子的文件上一级。<br> 例如<code>cd /Downloads</code><br>6. 制作种子命令为： <code>mktorrent -v -p -l 22 -a tracker_address -o name.torrent file_name</code><br>参数说明： tracker_address为你要发布的网站的tracker。 name.torrent为对生成torrent种子文件的命名，规则为：xxx.torrent。 file_name为你要做种的文件或文件夹。避免含有空格。<br>7. 等待一会儿会提示做种完成，在当前目录下即可找到。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>几种发布策略</title>
    <url>/8b49ed57/</url>
    <content><![CDATA[<h3><span id="蓝绿发布blue-green-deployment">蓝绿发布(Blue-Green Deployment)</span></h3><p>蓝绿发布提供了一种零宕机的部署方式。不停老版本，部署新版本进行测试，确认OK，将流量切到新版本，然后老版本同时也升级到新版本。始终有两个版本同时在线，有问题可以快速切换。<br>蓝绿部署中，一共有两套系统：</p>
<ul>
<li>一套是正在提供服务系统，标记为“绿色”；</li>
<li>另一套是准备发布的系统，标记为“蓝色”。</li>
</ul>
<p>优缺点</p>
<ul>
<li><p>优点：新版本升级和老版本回滚迅速。用户可以灵活控制流量走向</p>
</li>
<li><p>缺点：成本较高，需要部署两套环境（蓝/绿）</p>
<blockquote>
<p>比如日常运行时，需要10台服务器支撑业务，那么使用蓝绿部署，你就需要购置二十台服务器。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230905233800.gif" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230905233801.png" alt></p>
<h3><span id="金丝雀发布灰度发布canary-release">金丝雀发布/灰度发布(Canary Release)</span></h3><p>灰度发布 Gray Release（又名金丝雀发布 Canary Release）</p>
<blockquote>
<p>金丝雀发布有一个有趣的小故事，被称为「金丝雀在矿井」。这个故事用来形象地描述金丝雀发布策略的概念。<br>故事背景是在过去的煤矿开采中，矿工们面临着一种危险的情况，即有毒气体的积累。由于无法直接检测到这些气体，矿工们需要一种警报机制来提醒他们是否面临危险。他们找到了一种解决方案：带上一只小小的金丝雀。<br>矿工们将金丝雀放入煤矿，如果气体达到了危险的水平，金丝雀会首先受到影响并死亡，从而警示矿工们立即离开矿井以避免危险。这种警报系统保护了矿工的生命安全。</p>
</blockquote>
<p>不停机旧版本，部署新版本，高比例流量（例如：95%）走旧版本，低比例流量（例如：5%）切换到新版本，通过监控观察无问题，逐步扩大范围，最终把所有流量都迁移到新版本上。属无损发布<br>在软件开发中，灰度测试通常涉及将新功能或更新推送到一小部分用户，例如5％或10％的用户。<br>这些用户将能够使用新功能或更新，而其他用户则不会看到它们。<br>通过监视这些用户的反馈和行为，开发人员可以评估新功能或更新的效果，并识别任何问题或错误。</p>
<p>在Java中，可以使用一些工具来实现灰度测试，例如FeatureToggle和LaunchDarkly。<br>这些工具可以帮助开发人员轻松地控制新功能或更新的推出，并监视用户反馈和行为。</p>
<ul>
<li><p>优点：灵活简单，不需要用户标记驱动。安全性高，新版本如果出现问题，只会发生在低比例的流量上</p>
</li>
<li><p>缺点：成本较高，需要部署稳定/灰度两套环境  </p>
</li>
</ul>
<pre><code>![](https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230908233802.png)</code></pre><h3><span id="ab测试">A/B测试</span></h3><p>首先需要明确的是，A/B测试和蓝绿部署以及金丝雀，完全是两回事。<br>蓝绿部署和金丝雀是发布策略，目标是确保新上线的系统稳定，关注的是新系统的BUG、隐患。<br>A/B测试是效果测试，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分（它们上线时可能采用了蓝绿部署的方式）。<br>A/B测试关注的是不同版本的服务的实际效果，譬如说转化率、订单情况等。<br>A/B测试时，线上同时运行多个版本的服务，这些服务通常会有一些体验上的差异，譬如说页面样式、颜色、操作流程不同。相关人员通过分析各个版本服务的实际效果，选出效果最好的版本。<br>在A/B测试中，需要能够控制流量的分配，譬如说，为A版本分配10%的流量，为B版本分配10%的流量，为C版本分配80%的流量。  </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230908233803.png" alt></p>
<h3><span id="滚动发布rolling-release">滚动发布（Rolling Release）</span></h3><p>每次只升级一个或多个服务，通过观察无问题，不断执行这个过程，直到集群中的全部旧版本升级到新版本。属有损发布<br>K8S 默认采用了滚动发布</p>
<ul>
<li>优点：成本较低，只需要部署一套环境。出现问题影响范围，只限于发生在若干台正在滚动发布的服务上</li>
<li>缺点：停止旧版本的过程中，无法精确计算旧版本是否已经完成它正在执行的工作，需要靠业务自身去判断。旧版本不保留，一旦全部升级完毕后才发现问题，无法快速回滚，必须重新降级部署。发布和回滚需要较长的时间周期</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230908233804.png" alt></p>
<h3><span id="红黑部署red-black-deployment">红黑部署(Red-Black Deployment)</span></h3><p>这是Netflix采用的部署手段，Netflix的主要基础设施是在AWS上，所以它利用AWS的特性，在部署新的版本时，通过AutoScaling Group用包含新版本应用的AMI的LaunchConfiguration创建新的服务器。测试不通过，找到问题原因后，直接干掉新生成的服务器以及Autoscaling Group就可以，测试通过，则将ELB指向新的服务器集群，然后销毁掉旧的服务器集群以及AutoScaling Group。</p>
<p>红黑部署的好处是服务始终在线，同时采用不可变部署的方式，也不像蓝绿部署一样得保持冗余的服务始终在线。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统的CAP理论</title>
    <url>/3bdd21ca/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#cap理论概述">CAP理论概述</a></li>
<li><a href="#cap的定义">CAP的定义</a><ul>
<li><a href="#consistency-一致性">Consistency 一致性</a></li>
<li><a href="#availability-可用性">Availability 可用性</a></li>
<li><a href="#partition-tolerance分区容错性">Partition Tolerance分区容错性</a></li>
</ul>
</li>
<li><a href="#cap的证明">CAP的证明</a></li>
<li><a href="#cap权衡">CAP权衡</a><ul>
<li><a href="#ca-without-p">CA without P</a></li>
<li><a href="#cp-without-a">CP without A</a></li>
<li><a href="#ap-wihtout-c">AP wihtout C</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="cap理论概述">CAP理论概述</span></h2><p>CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226145516.png" alt></p>
<blockquote>
<p>CAP理论中的CA和数据库事务中ACID的CA并不是同一回事儿。两者之中的C都是都是一致性(Consistency)。CAP中的A指的是可用性（Availability），而ACID中的A指的是原子性（Atomicity)，切勿混为一谈。</p>
</blockquote>
<h2><span id="cap的定义">CAP的定义</span></h2><h3><span id="consistency-一致性">Consistency 一致性</span></h3><p>一致性指“<code>all nodes see the same data at the same time</code>”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。<a href="http://www.hollischuang.com/archives/663">分布式的一致性</a></p>
<p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p>
<p>一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p>
<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p>
<p><strong>三种一致性策略</strong></p>
<p>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</p>
<p>如果能容忍后续的部分或者全部访问不到，则是弱一致性。</p>
<p>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p>
<p>CAP中说，不可能同时满足的这个一致性指的是强一致性。</p>
<h3><span id="availability-可用性">Availability 可用性</span></h3><p>可用性指“<code>Reads and writes always succeed</code>”，即服务一直可用，而且是正常响应时间。</p>
<p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p>
<table>
<thead>
<tr>
<th align="center">可用性分类</th>
<th align="center">可用水平（%）</th>
<th align="center">年可容忍停机时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">容错可用性</td>
<td align="center">99.9999</td>
<td align="center">&lt;1 min</td>
</tr>
<tr>
<td align="center">极高可用性</td>
<td align="center">99.999</td>
<td align="center">&lt;5 min</td>
</tr>
<tr>
<td align="center">具有故障自动恢复能力的可用性</td>
<td align="center">99.99</td>
<td align="center">&lt;53 min</td>
</tr>
<tr>
<td align="center">高可用性</td>
<td align="center">99.9</td>
<td align="center">&lt;8.8h</td>
</tr>
<tr>
<td align="center">商品可用性</td>
<td align="center">99</td>
<td align="center">&lt;43.8 min</td>
</tr>
</tbody></table>
<p>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 <code>(1-0.99999)*365*24*60 = 5.256 min</code>，这是一个极高的要求。</p>
<p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。</p>
<h3><span id="partition-tolerance分区容错性">Partition Tolerance分区容错性</span></h3><p>分区容错性指“<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p>
<p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p>
<p>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</p>
<h2><span id="cap的证明">CAP的证明</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226154057.png" alt></p>
<p>如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p>
<p>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226154153.png" alt></p>
<p>如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p>
<p>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？</p>
<p>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226154349.png" alt></p>
<p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？</p>
<p>有二种选择，第一，牺牲数据一致性，保证可用性。响应旧的数据V0给用户；</p>
<p>第二，牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</p>
<p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p>
<h2><span id="cap权衡">CAP权衡</span></h2><p>通过CAP理论及前面的证明，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p>
<p>我们分三种情况来阐述一下。</p>
<h3><span id="ca-without-p">CA without P</span></h3><p>这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。</p>
<p>比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。</p>
<p>其实，在CAP理论中。C，A，P三者并不是平等的，CAP之父在《Spanner，真时，CAP理论》一文中写到：</p>
<blockquote>
<p>如果说Spanner真有什么特别之处，那就是谷歌的广域网。Google通过建立私有网络以及强大的网络工程能力来保证P，在多年运营改进的基础上，在生产环境中可以最大程度的减少分区发生，从而实现高可用性。</p>
</blockquote>
<p>从Google的经验中可以得到的结论是，无法通过降低CA来提升P。要想提升系统的分区容错性，需要通过提升基础设施的稳定性来保障。</p>
<p>所以，对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。</p>
<h3><span id="cp-without-a">CP without A</span></h3><p>如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。</p>
<p>一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。</p>
<p>设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。</p>
<p>无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？</p>
<p>ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。</p>
<h3><span id="ap-wihtout-c">AP wihtout C</span></h3><p>要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p>
<p>这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。</p>
<p>你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p>
<p>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。</p>
<p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>升级https</title>
    <url>/ddf7de45/</url>
    <content><![CDATA[<p><em>环境</em></p>
<pre><code>CentOS
nginx</code></pre><h3><span id="获取证书">获取证书</span></h3><p>HTTPS 证书分三类：1. DV 域名验证证书 2. OV 组织机构验证证书 3. EV 增强的组织机构验证证书。每类证书的审核要求不同，在浏览器地址栏也会有区分，对于个人网站而言，使用免费的 DV 证书就足够了。 我使用了大名鼎鼎的 Let’s Encrypt 来生成证书。</p>
<h4><span id="1-安装-certbot">1. 安装 certbot</span></h4><p>certbot 是 Let’s Encrypt 提供的一套自动化工具。</p>
<pre><code>yum install epel-release
yum install certbot</code></pre><h4><span id="2-生成证书">2. 生成证书</span></h4><p>这里采用 webroot 作为 Let’s Encrypt 的认证方式。</p>
<pre><code>certbot certonly -a webroot --webroot-path=/your/project/path -d example.com -d www.example.com</code></pre><p>webroot-path就是项目根路径，使用 -d 可以添加多个域名。这时证书就已经生成成功了，默认保存在 /etc/letsencrypt/live/example.com/ 下。证书文件包括：</p>
<ul>
<li>cert.pem: 服务端证书</li>
<li>chain.pem: 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</li>
<li>fullchain.pem: 包括了cert.pem和chain.pem的内容</li>
<li>privkey.pem: 证书私钥</li>
</ul>
<h4><span id="3-生成迪菲-赫尔曼密钥交换组-strong-diffie-hellman-group">3. 生成迪菲-赫尔曼密钥交换组（ Strong Diffie-Hellman Group）</span></h4><p>为了进一步提高安全性，也可以生成一个 Strong Diffie-Hellman Group。</p>
<pre><code>openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048</code></pre><h3><span id="配置nginx">配置nginx</span></h3><p>编辑 Nginx 配置文件，如果你不知道配置文件在哪，可以用 locate /nginx.conf 命令查找。添加以下内容，具体参数以你的实际情况为准。</p>
<pre><code>server &#123;
        listen 443 ssl;
        # 启用http2
        # 需要安装 Nginx Http2 Module
        # listen 443 http2 ssl;
        server_name my_server_name;
        #证书文件
        ssl_certificate /etc/letsencrypt/live/my_server_name/fullchain.pem;
        #私钥文件
        ssl_certificate_key /etc/letsencrypt/live/my_server_name/privkey.pem;

        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        # 优先采取服务器算法
        ssl_prefer_server_ciphers on;
        # 定义算法
        ssl_ciphers &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&amp;quot;;
        ssl_ecdh_curve secp384r1;
        ssl_session_cache shared:SSL:10m;
        ssl_session_tickets off;
        ssl_stapling on;
        ssl_stapling_verify on;
        resolver 8.8.8.8 8.8.4.4 valid=300s;
        resolver_timeout 5s;

        add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        # 使用DH文件
        ssl_dhparam /etc/ssl/certs/dhparam.pem;

        location ~ /.well-known &#123;
            allow all;
        &#125;

        location ~ \.php$ &#123;
            root           my_root;
            fastcgi_pass   my_host:my_port;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
        &#125;

        root my_root;
        index index.html index.php;

        location / &#123;
            root my_root;
            autoindex on;
            index index.html index.php;
            client_max_body_size 1024m;
        &#125;
&#125;</code></pre><p>其中的几项配置: <code>ssl_stapling on;</code> 开启 OCSP Stapling，使服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而让客户端跳过自己去验证的过程，提高 TLS 握手效率。 <code>add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubdomains&amp;quot;;</code> 启用 HSTS 策略，强制浏览器使用 HTTPS 连接，max-age设置单位时间内強制使用 HTTPS 连接；includeSubDomains 可选，设置所有子域同时生效。浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接 <code>add_header X-Frame-Options DENY;</code> 添加 X-Frame-Options 响应头，可以禁止网站被嵌入到 iframe 中，减少点击劫持 (clickjacking)攻击。 <code>add_header X-Content-Type-Options nosniff;</code> 添加 X-Content-Type-Options 响应头，防止 MIME 类型嗅探攻击 测试nginx.conf 是否有语法错误 <code>nginx -t</code> 重启nginx <code>nginx -s reload</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>升级到php7.1之后wordpress 网站出现Error establishing a database connection的解决方法</title>
    <url>/b6b408b2/</url>
    <content><![CDATA[<p>现在很多WordPress的插件都推荐将php版本升级到7.0或者7.1以上，于是就折腾了一下把几个blog升级到了7.1.5，升级的过程不难，无非就是额外安装一个php，然后启动自带的配套php-fpm7，然后nginx里location转发到新的php socket文件，这里就不表了。 升级完了，phpinfo()发现一切都正常，但是访问WordPress，却意外提示Error establishing a database connection，但是db的连接信息明明没有问题，经过反复搜索尝试，发现只要将 <code>/usr/share/nginx/html/wp-config.php</code> 文件里的 <code>define(&#39;DB_HOST&#39;, &#39;localhost&#39;);</code> 修改为 <code>define(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;);</code> 即可解决，猜测原因可能是php7.1中对域的resolve问题 另外, 为了 Debug, 可以把 <code>/usr/share/nginx/html/wp-config.php</code> 的 debug 改为 true <code>define(&#39;WP_DEBUG&#39;, true);</code> 改好了, 再改成 false.</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>可靠性、可用性、稳定性</title>
    <url>/18166f99/</url>
    <content><![CDATA[<blockquote>
<p> 对比Availability可用性、Reliability可靠性、Stability稳定性</p>
</blockquote>
<!-- toc -->

<ul>
<li><a href="#区分">区分</a></li>
<li><a href="#总体对比">总体对比</a></li>
<li><a href="#可用性">可用性</a></li>
<li><a href="#可靠性">可靠性</a><ul>
<li><a href="#mtbfmean-time-between-failure">MTBF（Mean Time Between Failure）</a></li>
<li><a href="#mttrmean-time-to-repair">MTTR（Mean Time To Repair）</a></li>
<li><a href="#mttfmean-time-to-failure">MTTF（Mean Time To Failure）</a></li>
</ul>
</li>
<li><a href="#稳定性">稳定性</a></li>
</ul>
<!-- tocstop -->

<h2><span id="区分">区分</span></h2><p>从事故、稳定方面简单理解如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>不出事故</td>
</tr>
<tr>
<td>可用性</td>
<td>出事故后，快速止损</td>
</tr>
<tr>
<td>稳定性</td>
<td>解决故障问题基础上，服务持续稳定、性能稳定</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509160538.png" alt></p>
<h2><span id="总体对比">总体对比</span></h2><table> 
    <tr>
        <td></td>
        <td>可用性</td>
        <td>可靠性</td>
        <td>稳定性</td>
    </tr>
    <tr>
        <td>英文</td>
        <td>Availability</td>
        <td>Reliability</td>
        <td>Stability</td>
    </tr>
    <tr>
        <td>关注点</td>
        <td>关注的是服务总体的持续时间。系统在给定时间内总体的运行时间越长，可用性越高。</td>
        <td>关注系统可以无故障地持续运行的概率，关注的是故障率。<br>故障的频率越高，可靠性越低。<br>影响可靠性的因素就是能够引起故障的所有因素，包括软件设计错误，编码错误，硬件故障等等。</td>
        <td>指软件在一个运行周期内、在一定的压力条件下，在持续操作时间内出错的概率，性能劣化趋势等等。<br>如果一个系统的性能时好时坏，它一定是不稳定的，而不一定是不可靠的。<br>稳定性更关注系统在给定条件下的响应是否一致，行为是否稳定。<br>可靠是可用的前提，稳定是可靠的进一步提升。</td>
    </tr>
    <tr>
        <td>对比</td>
        <td colspan="2">在《分布式系统原理与范型》中提到的下面例子中比较准确的解释了两者的区别：<br>如果系统在每小时崩溃1ms，那么它的可用性就超过99.9999%，但是它还是高度不可靠。<br>与之类似，如果一个系统从来不崩溃，但是每年要停机两星期，那么它是高度可靠的，但是可用性只有96%。<br>作为系统的响应，首要目标是先降低故障的次数，频率要低，从而提高可靠性；<br>同时在故障出现后，要提高故障的恢复时间，速度要快，从而提高业务的可用性。</td>
        <td></td>
    </tr>
    <tr>
        <td>对比</td>
        <td></td>
        <td colspan="2">对于电力系统而言，<br>稳定性就是“人民用电不要忽明忽暗忽快忽慢”，可靠性就是”不要用着用着突然没有啦“。<br>故障与出错的差别</td>
    </tr>
</table>



<h2><span id="可用性">可用性</span></h2><p>可用性指系统在给定时间内可以正常工作的概率，通常用SLA（服务等级协议，service level agreement）指标来表示。</p>
<p>这是这段时间的总体的可用性指标。</p>
<table>
<thead>
<tr>
<th>通俗叫法</th>
<th>可用性级别</th>
<th>年度宕机时间</th>
<th>周宕机时间</th>
<th>每天宕机时间</th>
</tr>
</thead>
<tbody><tr>
<td>1个9</td>
<td>90%</td>
<td>36.5天</td>
<td>16.8小时</td>
<td>2.4小时</td>
</tr>
<tr>
<td>2个9</td>
<td>99%</td>
<td>87.6小时</td>
<td>1.68小时</td>
<td>14分钟</td>
</tr>
<tr>
<td>3个9</td>
<td>99.9%</td>
<td>8.76小时</td>
<td>10.1分钟</td>
<td>86秒</td>
</tr>
<tr>
<td>4个9</td>
<td>99.99%</td>
<td>52.6分钟</td>
<td>1.01分钟</td>
<td>8.6秒</td>
</tr>
<tr>
<td>5个9</td>
<td>99.999%</td>
<td>5.26分钟，315.36秒</td>
<td>6.05秒</td>
<td>0.86秒</td>
</tr>
</tbody></table>
<h2><span id="可靠性">可靠性</span></h2><p>可靠性相关的几个指标如下：</p>
<h3><span id="mtbfmean-time-between-failure">MTBF（Mean Time Between Failure）</span></h3><p>即平均无故障时间，是指从新的产品在规定的工作环境条件下开始工作到出现第一个故障的时间的平均值。</p>
<p>MTBF越长表示可靠性越高，正确工作能力越强 。</p>
<h3><span id="mttrmean-time-to-repair">MTTR（Mean Time To Repair）</span></h3><p>即平均修复时间，是指可修复产品的平均修复时间，就是从出现故障到修复中间的这段时间。</p>
<p>MTTR越短表示易恢复性越好。</p>
<h3><span id="mttfmean-time-to-failure">MTTF（Mean Time To Failure）</span></h3><p>即平均失效时间。系统平均能够正常运行多长时间，才发生一次故障。</p>
<p>系统的可靠性越高，平均无故障时间越长。</p>
<p>这些指标跟可用性关系</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Availability = UpTime/(UpTime+DownTime) = MTBF / (MTBF + MTTR)</span><br></pre></td></tr></table></figure>

<h2><span id="稳定性">稳定性</span></h2><p>Stackoverflow 看到这样一段代码来表示稳定性和可靠性的区别，甚为有趣：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reliable but unstable:</span></span><br><span class="line">    add(a,b):</span><br><span class="line">     <span class="keyword">if</span> randomInt mod <span class="number">5</span> == <span class="number">0</span>: </span><br><span class="line">        throw exception</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span> a+b        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Stable but unreliable:</span></span><br><span class="line">    add(a,b):</span><br><span class="line">     <span class="keyword">if</span> randomInt mod <span class="number">5</span> == <span class="number">0</span>: </span><br><span class="line">         <span class="built_in">print</span> a+a</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">print</span> a+b</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>命令组和代码块</title>
    <url>/8cb7d3c0/</url>
    <content><![CDATA[<h1><span id="命令组-和-代码块">命令组 和 代码块</span></h1><p>() 命令组. 如 <code>(a=hello,echo $a)</code> 在()中的命令列表, 将作为一个子Shell来运行 在()中的变量, 由于是在子Shell总运行的, 因此对脚本剩下的部分是不可见的</p>
<p>如</p>
<pre><code>a=123
(a=321;)
echo &quot;a=$a&quot; # a=123
# 在()中的a变量, 更像是一个局部变量</code></pre><p>{} 代码块, 又称内部组. 这个结构创建了一个匿名的函数, 与函数不同的是, 在{}中声明的变量, 对于脚本剩余的代码是可见的, 如</p>
<pre><code>&#123;
    local a;
    a=123;
&#125;
# bash中的local申请的变量只能用在函数中


a=123;
&#123;a=321;&#125;
echo &quot;a=$a&quot; # a=321</code></pre><p>()也可用作初始化数组 array=(element1,element2,element3)</p>
<p>{xxx,yyy,zzz} 大括号扩展, 例</p>
<pre><code>cat &#123;file1,file2,file3&#125; &gt; combined_file
# 把file1 file2 file3连接在一起, 重定向到combined_file


cp file1.&#123;txt,bak&#125;
# 把file1.txt 复制到file1.bak</code></pre><p>一个命令会对大括号中以逗号分隔的文件列表起作用, file globbing会对大括号中的文件名作扩展</p>
<pre><code># 大括号中不允许有空白, 除非这个空白是有意义的
echo &#123;file1,file2&#125;\ :&#123;\ A,&quot; B&quot;,&apos; C&apos;&#125;
# file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>在shell脚本中使用ls命令的注意事项</title>
    <url>/12994d1/</url>
    <content><![CDATA[<p>请对比如下两个测试：</p>
<pre><code>$ for i in `ls /etc`;do echo $i;done
adjtime
adobe
appstream.conf
arch-release
asound.conf
avahi
bash.bash_logout
bash.bashrc
bind.keys
binfmt.d
......


$ for i in /etc/*;do echo $i;done
/etc/adjtime
/etc/adobe
/etc/appstream.conf
/etc/arch-release
/etc/asound.conf
/etc/avahi
/etc/bash.bash_logout
/etc/bash.bashrc
/etc/bind.keys
/etc/binfmt.d
......</code></pre><p>像ls这样的命令很多时候是设计给人用的，它的很多显示是有特殊设定的，可能并不是纯文本。 比如可能包含一些格式化字符，也可能包含可以让终端显示出颜色的标记字符等等。 当我们在程序里面使用类似这样的命令的时候要格外小心，说不定什么时候在什么不同环境配置的系统上， 你的程序就会有意想不到的异常出现，到时候排查起来非常麻烦。 所以这里我们应该尽量避免使用ls这样的命令来做类似的行为，用通配符可能更好。</p>
<p>当然，如果你要操作的是多层目录文件的话，那么ls就更不能帮你的忙了，它遇到目录之后显示成这样：</p>
<pre><code>$ ls /etc/*
/etc/adobe:
mms.cfg

/etc/avahi:
avahi-autoipd.action  avahi-daemon.conf  avahi-dnsconfd.action  hosts  services

/etc/binfmt.d:

/etc/bluetooth:
main.conf

/etc/ca-certificates:
extracted  trust-source</code></pre><p>所以遍历一个目录还是要用两个连续的<code>**</code>，如果不是bash 4.0之后的版本的话，可以使用find。 我推荐用find，因为它更通用。 有时候你会发现，使用find之后，绝大多数原来需要写脚本解决的问题可能都用不着了，一个find命令解决很多问题</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】域名末尾带个点</title>
    <url>/a258db2c/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#在-dns-的请求响应中域名的末尾并没有">在 DNS 的请求/响应中，域名的末尾并没有 “.”</a></li>
<li><a href="#区域文件中域名末尾的">区域文件中域名末尾的 “.”</a></li>
<li><a href="#你也可以不通过区域文件来使用-dns">你也可以不通过区域文件来使用 DNS</a></li>
<li><a href="#dig-命令输出中末尾的">dig 命令输出中末尾的 “.”</a></li>
<li><a href="#curl-命令输出中末尾的">curl 命令输出中末尾的 “.”</a></li>
<li><a href="#初识搜索域">初识搜索域</a></li>
<li><a href="#什么时候搜索域被使用">什么时候搜索域被使用?</a></li>
<li><a href="#我的计算机怎么知道使用哪个搜索域呢">我的计算机怎么知道使用哪个搜索域呢？</a></li>
<li><a href="#所以为什么要在域名末尾加一个点呢">所以为什么要在域名末尾加一个点呢？</a></li>
<li><a href="#什么时候在末尾添加">什么时候在末尾添加 “.”？</a></li>
<li><a href="#我认为相对域名在过去是比较常见的">我认为相对域名在过去是比较常见的</a></li>
</ul>
<!-- tocstop -->

<p>大家好！今年早些时候，我在写《[DNS 是如何工作的][1]》 时，有人问我——为什么人们有时在域名的末尾加一个点？例如，如果你通过运行 <code>dig example.com</code> 查询 <code>example.com</code> 的 IP，你会看到一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ dig example.com</span><br><span class="line">example.com.        5678    IN  A   93.184.216.34</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行完 <code>dig</code> 命令后，<code>example.com</code> 有一个 <code>.</code> ——变成了 <code>example.com.</code>！发生了什么？</p>
<p>有些 DNS 工具也要求传给它的域名后加一个 <code>.</code>：如果你在使用 [miekg/dns][2] 时传给它 <code>example.com</code>，它会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// trying to send this message will return an error</span><br><span class="line">m := new(dns.Msg)</span><br><span class="line">m.SetQuestion(&quot;example.com&quot;, dns.TypeA)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最初我以为我知道这个问题的答案（“呃，末尾的点意味着域名是完全限定的？”）。这是对的 —— 一个<ruby>完全限定域名<rt>fully qualified domain name</rt></ruby>（FQDN）是一个末尾有 <code>.</code> 的域名！</p>
<p>但是<em>为什么</em>末尾的点是有用且重要的呢？</p>
<h3><span id="在-dns-的请求响应中域名的末尾并没有">在 DNS 的请求/响应中，域名的末尾并没有 “.”</span></h3><p>我曾经（错误地）认为 “为什么末尾有一个点？”的答案可能是 “在 DNS 请求/响应中，域名末尾有一个 <code>.</code>，所以我们把它放进去，以匹配你的计算机实际发送/接收的内容”。但事实并不是这样！</p>
<p>当计算机发送 DNS 请求/响应时，域名的末尾并没有点。实际上，域名中<em>没有</em>点。</p>
<p>域名会被编码成一系列的长度/字符串对。例如，域名 <code>example.com</code> 被编码为这 13 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7example3com0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编码后的内容一个点也没有。一个 ASCII 域名（如 <code>example.com</code>）被转成了各种 DNS 软件的 DNS 请求/响应中使用的格式。</p>
<p>今天我们来讨论域名被转成 DNS 响应的一个地方：区域文件。</p>
<h3><span id="区域文件中域名末尾的">区域文件中域名末尾的 “.”</span></h3><p>一些人管理域名的 DNS 记录的方法是创建一个被称为 “区域文件” 的文本文件，然后配置一些 DNS 服务器软件（如 <code>nsd</code> 或 <code>bind</code>）来为该区域文件中指定的 DNS 记录提供服务。</p>
<p>下面是一个对应 <code>example.com</code> 的示例区域文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">orange  300   IN    A     1.2.3.4</span><br><span class="line">fruit   300   IN    CNAME orange</span><br><span class="line">grape   3000  IN    CNAME example.com.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个文件中，任何不以 <code>.</code> 结尾的域名（比如 <code>orange</code>）后都会自动加上 <code>.example.com</code>。所以 <code>orange</code> 成了 <code>orange.example.com</code> 的简称。DNS 服务器从它的配置中得知这是一个 <code>example.com</code> 的区域文件，所以它知道在所有不以点结尾的名字后面自动添加 <code>example.com</code>。</p>
<p>我想这里的想法只是为了少打几个字符——如果要打出全称，区域文件会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">orange.example.com.  300   IN    A     1.2.3.4</span><br><span class="line">fruit.example.com.   300   IN    CNAME orange.example.com.</span><br><span class="line">grape.example.com.   3000  IN    CNAME example.com.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>确实多了很多字符。</p>
<h3><span id="你也可以不通过区域文件来使用-dns">你也可以不通过区域文件来使用 DNS</span></h3><p>尽管官方的 DNS RFC（[RFC 1035][3]）中定义了区域文件格式，但你也可以不通过区域文件来使用 DNS。例如，AWS Route 53 就不用区域文件来存储 DNS 记录！你可以通过 Web 界面或 API 来创建记录，我猜他们是用某种数据库而不是一堆文本文件来存储记录。</p>
<p>不过，Route 53（像许多其他 DNS 工具一样）确实支持导入和导出区域文件，这个功能或许在你更换 DNS 提供商时很有用。</p>
<h3><span id="dig-命令输出中末尾的">dig 命令输出中末尾的 “.”</span></h3><p>现在我们来讨论下 <code>dig</code> 命令的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ dig example.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;&gt;&gt; +all example.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 10712</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;example.com.           IN  A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">example.com.        81239   IN  A   93.184.216.34</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有一件奇怪的事是，几乎每一行都以 <code>;;</code> 开头，这是怎么回事？<code>;</code> 是区域文件中的注释字符！</p>
<p>我想 <code>dig</code> 以这种奇怪的方式输出的原因可能是为了方便你粘贴这些内容到区域文件时，不用修改就可以直接用。</p>
<p>这也是 <code>example.com</code> 末尾有个 <code>.</code> 的原因 —— 区域文件要求域名末尾必须有点（否则它们会被解释为是相对于该区域的）。因此 <code>dig</code> 也这么处理了。</p>
<p>我真的希望 dig 有一个 <code>+human</code> 选项，以更人性化的方式打印出这些信息，但现在我太懒了，懒得花工夫去实际贡献代码来做这件事（而且我并不擅长 C），所以我只能在我的博客上抱怨一下 :)</p>
<h3><span id="curl-命令输出中末尾的">curl 命令输出中末尾的 “.”</span></h3><p>我们来看下另一个末尾有 <code>.</code> 的例子：<code>curl</code>！</p>
<p>我家里有台计算机名为 <code>grapefruit</code>，其上运行着 Web 服务器。当我执行 <code>curl grapefruit</code> 时，会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ curl grapefruit</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这样运行没问题！但是如果我在域名后加一个 <code>.</code> 会怎样呢？它报错了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl grapefruit.</span><br><span class="line">curl: (6) Could not resolve host: grapefruit.</span><br></pre></td></tr></table></figure>

<p>发生了什么？为了搞清楚，我们需要先来学习下搜索域：</p>
<h3><span id="初识搜索域">初识搜索域</span></h3><p>当我执行 <code>curl grapefrult</code> 时，它是怎么被转成一个 DNS 请求的？你可能会认为我的计算机会向域名 <code>grapefruit</code> 发送一个请求，对吗？但事实并不是这样。</p>
<p>让我们用 <code>tcpdump</code> 来看看到底是什么域名在被查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo tcpdump -i any port 53</span><br><span class="line">[...] A? grapefruit.lan. (32)</span><br></pre></td></tr></table></figure>

<p>实际上是向 <code>grapefruit.lan.</code> 发送的请求。为什么呢？</p>
<p>解释一下：</p>
<ol>
<li><code>curl</code> 调用函数 <code>getaddrinfo</code> 来查询 <code>grapefruit</code></li>
<li><code>getaddrinfo</code> 查询了我计算机上的文件 <code>/etc/resolv.conf</code></li>
<li><code>/etc/resolv.conf</code> 包含两行内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 127.0.0.53</span><br><span class="line">search lan</span><br></pre></td></tr></table></figure></li>
<li>因为有 <code>search lan</code> 这行内容，所以 <code>getaddrinfo</code> 在 <code>grapefruit</code> 的末尾添加了一个 <code>lan</code>，去查询 <code>grapefruit.lan</code></li>
</ol>
<h3><span id="什么时候搜索域被使用">什么时候搜索域被使用?</span></h3><p>现在我们知道了一些奇怪的事情：当我们查询一个域名时，有时会有一个额外的东西（如 <code>lan</code>）被加到最后。但是什么时候会发生这种情况呢？</p>
<ol>
<li>如果我们在域名<strong>末尾</strong>添加一个 <code>.</code>，那么这时不会用到搜索域</li>
<li>如果域名<strong>中间包含</strong>一个 <code>.</code>（如 <code>example.com</code>），那么默认也不会用到搜索域。但是可以通过修改配置来改变处理逻辑（在 [ndots][4] 里有更详细的说明）</li>
</ol>
<p>我们现在知道了 <code>curl grapefruit.</code> 与 <code>curl grapefruit</code> 结果不一样的原因——因为一个查询的是 <code>grapefruit.</code>，而另一个查询的是 <code>grapefruit.lan.</code>。</p>
<h3><span id="我的计算机怎么知道使用哪个搜索域呢">我的计算机怎么知道使用哪个搜索域呢？</span></h3><p>当我连接路由时，它会通过 DHCP 告诉我它的搜索域是 <code>lan</code> —— 它也是通过这个方式给我的计算机分配 IP。</p>
<h3><span id="所以为什么要在域名末尾加一个点呢">所以为什么要在域名末尾加一个点呢？</span></h3><p>现在我们已经了解了区域文件和搜索域，下面是我认为的人们要在域名末尾加点的原因：</p>
<p>有两种情况下，域名会被修改，并在末尾添加其他东西。</p>
<ul>
<li>在 <code>example.com</code> 的区域文件中，<code>grapefruit</code> 会被转为 <code>grapefruit.example.com</code></li>
<li>在我的本地网络（我的计算机已经配置了使用搜索域 <code>lan</code>），<code>grapefruit</code> 被转为 <code>grapefruit.lan</code></li>
</ul>
<p>因此，由于域名在某些情况下实际上可能被转成其他名字，人们就在结尾处加一个 <code>.</code>，以此来表示 “<strong>这是域名，末尾不需要添加任何东西，这就是全部内容</strong>”。否则会引起混乱。</p>
<p>“这就是全部内容”的技术术语是<strong>“完全限定域名”</strong>，简称为<strong>“FQDN”</strong>。所以 <code>google.com.</code> 是一个完全限定域名，而 <code>google.com</code> 不是。</p>
<p>我总是要提醒自己这样做的原因，因为我很少使用区域文件和搜索域，所以我经常觉得——“我当然是指 <code>google.com</code> 而不是 <code>google.com.something.else</code>! 我为什么要指其他东西？那太傻了！”</p>
<p>但是有些人确实在使用区域文件和搜索域（例如 Kubernetes 中使用了搜索域！），所以结尾的 <code>.</code> 很有用，可以让人确切的知道，不应该再添加其他东西。</p>
<h3><span id="什么时候在末尾添加">什么时候在末尾添加 “.”？</span></h3><p>以下是关于何时在域名末尾加 “. “ 的几个简单说明：</p>
<p><strong>需要添加：配置 DNS 时</strong></p>
<p>在配置 DNS 时，使用完全限定域名从来都不是坏事。你不一定要这样做：非完全限定域名通常也能正常工作，但我从来没有遇到过不接受完全限定域名的 DNS 软件。</p>
<p>有些 DNS 软件需要这样做：现在我为 <code>jvns.ca</code> 使用的 DNS 服务器让我在域名的末尾加上 <code>.</code>（例如在 CNAME 记录中），并提示如果我不添加，它将在我输入的内容末尾加上 <code>.jvns.ca</code>。我不同意这个设计决定，但这不是什么大问题，我只是在最后加一个 <code>.</code>。</p>
<p><strong>不需要加：在浏览器中</strong></p>
<p>令人困惑的是，在浏览器中，在域名结尾处加一个 <code>.</code> <em>不能</em>正常运行。例如，如果我在浏览器中输入 <code>https://twitter.com.</code>，它就会报错。它会返回 404。</p>
<p>我认为这里发生的事情是，它将 HTTP <code>Host</code> 标头设置为 <code>Host：twitter.com.</code>，而对端的 Web 服务器则期望 <code>Host：twitter.com</code>。</p>
<p>同样地，<code>https://jvns.ca.</code> 由于某种原因，返回了一个 SSL 错误。</p>
<h3><span id="我认为相对域名在过去是比较常见的">我认为相对域名在过去是比较常见的</span></h3><p>最后一件事：我认为“相对”域名（比如我用 <code>grapefruit</code> 来指代我家的另一台计算机 <code>grapefruit.lan</code>）在过去更常用，因为 DNS 是在大学或其他有大型内部网络的大机构中开发的。</p>
<p>在今天的互联网上，使用“绝对”域名（如 <code>example.com</code>）似乎更为普遍。</p>
<hr>
<p>via: <a href="https://jvns.ca/blog/2022/09/12/why-do-domain-names-end-with-a-dot-/">https://jvns.ca/blog/2022/09/12/why-do-domain-names-end-with-a-dot-/</a></p>
<p>作者：<a href="https://jvns.ca/">Julia Evans</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FFmpeg的推送文件到RTMP服务器</title>
    <url>/5722b57a/</url>
    <content><![CDATA[<p>原文地址: <a href="http://blog.csdn.net/leixiaohua1020/article/details/39803457">http://blog.csdn.net/leixiaohua1020/article/details/39803457</a></p>
<p>将本地的MOV/AVI/MKV/MP4/FLV等格式的媒体文件， 通过流媒体协议(RTMP, HTTP, UDP, TCP, RTP等)以直播流的形式推送出去.</p>
<p>在这个推流器的基础上, 可以进行以下几种方式的修改, 实现各式各样的推流器. 例如: * 将输入文件改为网络流URL, 可以显示转流器 * 将输入文件改为回调函数(内存读取)的形式, 可以推送内存中的视频数据 * 将输入文件改为系统设备(通过libavdevice), 同时加上编码的功能, 可以实现实时推流器(现场直播)</p>
<h3><span id="需要注意的地方">需要注意的地方</span></h3><h4><span id="封装格式">封装格式</span></h4><p>RTMP采用的封装格式FLV, 因此在指定输出流媒体的时候需要制定其封装格式为”flv”. 同理, 其他流媒体协议也需要指定其封装格式. 例如采用UDP推送流媒体的时候, 可以指定其封装格式为”mpegts”.</p>
<h4><span id="延时">延时</span></h4><p>发送流媒体的数据的时候需要延时. 否则, FFmpeg处理数据速度很快, 瞬间就能把所有的数据发送出去, 流媒体服务器是承受不了的. 因此需要按照视频实际的帧率发送数据. 本文的推流器在视频帧与帧之间采用av_usleep()函数休眠的方式来延迟发送. 这样就可以按照视频的帧率发送数据了, 代码如下</p>
<pre><code>//…  
int64_t start_time=av_gettime();  
while (1) &#123;  
//…  
    //Important:Delay  
    if(pkt.stream_index==videoindex)&#123;  
        AVRational time_base=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;  
        AVRational time_base_q=&#123;1,AV_TIME_BASE&#125;;  
        int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q);  
        int64_t now_time = av_gettime() - start_time;  
        if (pts_time &gt; now_time)  
            av_usleep(pts_time - now_time);  
    &#125;  
//…  
&#125;  
//… </code></pre><h4><span id="ptsdts问题">PTS/DTS问题</span></h4><p>没有封装格式的裸流(例如H.264裸流)是不包含PTS, DTS这些参数的. 在发送这种数据的时候, 需要自己计算并写入AVPacket的PTS, DTS, duration等参数.</p>
<pre><code>//FIX：No PTS (Example: Raw H.264)  
//Simple Write PTS  
if(pkt.pts==AV_NOPTS_VALUE)&#123;  
    //Write PTS  
    AVRational time_base1=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;  
    //Duration between 2 frames (us)  
    int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(ifmt_ctx-&gt;streams[videoindex]-&gt;r_frame_rate);  
    //Parameters  
    pkt.pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE);  
    pkt.dts=pkt.pts;  
    pkt.duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE);  
&#125; </code></pre><h4><span id="sequence">sequence</span></h4><p><img src="http://img.blog.csdn.net/20180113202019583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>代码</p>
<pre><code>/** 
 * 最简单的基于FFmpeg的推流器（推送RTMP） 
 * Simplest FFmpeg Streamer (Send RTMP) 
 *  
 * 雷霄骅 Lei Xiaohua 
 * leixiaohua1020@126.com 
 * 中国传媒大学/数字电视技术 
 * Communication University of China / Digital TV Technology 
 * http://blog.csdn.net/leixiaohua1020 
 *  
 * 本例子实现了推送本地视频至流媒体服务器（以RTMP为例）。 
 * 是使用FFmpeg进行流媒体推送最简单的教程。 
 * 
 * This example stream local media files to streaming media  
 * server (Use RTMP as example).  
 * It&apos;s the simplest FFmpeg streamer. 
 *  
 */  

#include &lt;stdio.h&gt;  

#define __STDC_CONSTANT_MACROS  

#ifdef _WIN32  
//Windows  
extern &quot;C&quot;  
&#123;  
#include &quot;libavformat/avformat.h&quot;  
#include &quot;libavutil/mathematics.h&quot;  
#include &quot;libavutil/time.h&quot;  
&#125;;  
#else  
//Linux...  
#ifdef __cplusplus  
extern &quot;C&quot;  
&#123;  
#endif  
#include &lt;libavformat/avformat.h&gt;  
#include &lt;libavutil/mathematics.h&gt;  
#include &lt;libavutil/time.h&gt;  
#ifdef __cplusplus  
&#125;;  
#endif  
#endif  

int main(int argc, char* argv[])  
&#123;  
    AVOutputFormat *ofmt = NULL;  
    //输入对应一个AVFormatContext，输出对应一个AVFormatContext  
    //（Input AVFormatContext and Output AVFormatContext）  
    AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL;  
    AVPacket pkt;  
    const char *in_filename, *out_filename;  
    int ret, i;  
    int videoindex=-1;  
    int frame_index=0;  
    int64_t start_time=0;  
    //in_filename  = &quot;cuc_ieschool.mov&quot;;  
    //in_filename  = &quot;cuc_ieschool.mkv&quot;;  
    //in_filename  = &quot;cuc_ieschool.ts&quot;;  
    //in_filename  = &quot;cuc_ieschool.mp4&quot;;  
    //in_filename  = &quot;cuc_ieschool.h264&quot;;  
    in_filename  = &quot;cuc_ieschool.flv&quot;;//输入URL（Input file URL）  
    //in_filename  = &quot;shanghai03_p.h264&quot;;  

    out_filename = &quot;rtmp://localhost/publishlive/livestream&quot;;//输出 URL（Output URL）[RTMP]  
    //out_filename = &quot;rtp://233.233.233.233:6666&quot;;//输出 URL（Output URL）[UDP]  

    av_register_all();  
    //Network  
    avformat_network_init();  
    //输入（Input）  
    if ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0)) &lt; 0) &#123;  
        printf( &quot;Could not open input file.&quot;);  
        goto end;  
    &#125;  
    if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &lt; 0) &#123;  
        printf( &quot;Failed to retrieve input stream information&quot;);  
        goto end;  
    &#125;  

    for(i=0; i&lt;ifmt_ctx-&gt;nb_streams; i++)   
        if(ifmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO)&#123;  
            videoindex=i;  
            break;  
        &#125;  

    av_dump_format(ifmt_ctx, 0, in_filename, 0);  

    //输出（Output）  

    avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;flv&quot;, out_filename); //RTMP  
    //avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;mpegts&quot;, out_filename);//UDP  

    if (!ofmt_ctx) &#123;  
        printf( &quot;Could not create output context\n&quot;);  
        ret = AVERROR_UNKNOWN;  
        goto end;  
    &#125;  
    ofmt = ofmt_ctx-&gt;oformat;  
    for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;  
        //根据输入流创建输出流（Create output AVStream according to input AVStream）  
        AVStream *in_stream = ifmt_ctx-&gt;streams[i];  
        AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec);  
        if (!out_stream) &#123;  
            printf( &quot;Failed allocating output stream\n&quot;);  
            ret = AVERROR_UNKNOWN;  
            goto end;  
        &#125;  
        //复制AVCodecContext的设置（Copy the settings of AVCodecContext）  
        ret = avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec);  
        if (ret &lt; 0) &#123;  
            printf( &quot;Failed to copy context from input to output stream codec context\n&quot;);  
            goto end;  
        &#125;  
        out_stream-&gt;codec-&gt;codec_tag = 0;  
        if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)  
            out_stream-&gt;codec-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;  
    &#125;  
    //Dump Format------------------  
    av_dump_format(ofmt_ctx, 0, out_filename, 1);  
    //打开输出URL（Open output URL）  
    if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;  
        ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);  
        if (ret &lt; 0) &#123;  
            printf( &quot;Could not open output URL &apos;%s&apos;&quot;, out_filename);  
            goto end;  
        &#125;  
    &#125;  
    //写文件头（Write file header）  
    ret = avformat_write_header(ofmt_ctx, NULL);  
    if (ret &lt; 0) &#123;  
        printf( &quot;Error occurred when opening output URL\n&quot;);  
        goto end;  
    &#125;  

    start_time=av_gettime();  
    while (1) &#123;  
        AVStream *in_stream, *out_stream;  
        //获取一个AVPacket（Get an AVPacket）  
        ret = av_read_frame(ifmt_ctx, &amp;pkt);  
        if (ret &lt; 0)  
            break;  
        //FIX：No PTS (Example: Raw H.264)  
        //Simple Write PTS  
        if(pkt.pts==AV_NOPTS_VALUE)&#123;  
            //Write PTS  
            AVRational time_base1=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;  
            //Duration between 2 frames (us)  
            int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(ifmt_ctx-&gt;streams[videoindex]-&gt;r_frame_rate);  
            //Parameters  
            pkt.pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE);  
            pkt.dts=pkt.pts;  
            pkt.duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE);  
        &#125;  
        //Important:Delay  
        if(pkt.stream_index==videoindex)&#123;  
            AVRational time_base=ifmt_ctx-&gt;streams[videoindex]-&gt;time_base;  
            AVRational time_base_q=&#123;1,AV_TIME_BASE&#125;;  
            int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q);  
            int64_t now_time = av_gettime() - start_time;  
            if (pts_time &gt; now_time)  
                av_usleep(pts_time - now_time);  

        &#125;  

        in_stream  = ifmt_ctx-&gt;streams[pkt.stream_index];  
        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];  
        /* copy packet */  
        //转换PTS/DTS（Convert PTS/DTS）  
        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));  
        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));  
        pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);  
        pkt.pos = -1;  
        //Print to Screen  
        if(pkt.stream_index==videoindex)&#123;  
            printf(&quot;Send %8d video frames to output URL\n&quot;,frame_index);  
            frame_index++;  
        &#125;  
        //ret = av_write_frame(ofmt_ctx, &amp;pkt);  
        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);  

        if (ret &lt; 0) &#123;  
            printf( &quot;Error muxing packet\n&quot;);  
            break;  
        &#125;  

        av_free_packet(&amp;pkt);  

    &#125;  
    //写文件尾（Write file trailer）  
    av_write_trailer(ofmt_ctx);  
end:  
    avformat_close_input(&amp;ifmt_ctx);  
    /* close output */  
    if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE))  
        avio_close(ofmt_ctx-&gt;pb);  
    avformat_free_context(ofmt_ctx);  
    if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) &#123;  
        printf( &quot;Error occurred.\n&quot;);  
        return -1;  
    &#125;  
    return 0;  
&#125;</code></pre>]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】协程，操作系统线程和 CPU 管理</title>
    <url>/4e717bb5/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210657.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French."></p>
<p>ℹ️ <em>本文运行环境为 Go 1.13</em></p>
<p>对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。</p>
<h2><span id="m-p-g-编排">M, P, G 编排</span></h2><p>为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The main concepts are:</span><br><span class="line">G - goroutine.</span><br><span class="line">M - worker thread, or machine.</span><br><span class="line">P - processor, a resource that is required to execute Go code.</span><br><span class="line">    M must have an associated P to execute Go code[...].</span><br></pre></td></tr></table></figure>

<p><code>P</code>, <code>M</code>, <code>G</code> 模型图解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210733.png" alt="P, M, G diagram"></p>
<p>每个协程（<code>G</code>）运行在与一个逻辑 CPU（<code>P</code>）相关联的 OS 线程（<code>M</code>）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`hello`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">`world`</span>)</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，Go 根据机器逻辑 CPU 的个数来创建不同的 <code>P</code>，并且把它们保存在一个空闲 <code>P</code> 的 list 里。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210931.png" alt="P initialization"></p>
<p>然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 <code>P</code>。这个 <code>P</code> 通过与之相关联的 OS 线程来创建一个 <code>M</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211012.png" alt="OS thread creation"></p>
<p>然而，像 <code>P</code> 那样，系统调用返回的甚至被 gc 强行停止的空闲的 <code>M</code> — 比如没有协程在等待运行 — 也会被加到一个空闲 list：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211040.png" alt="M and P idle list"></p>
<p>在程序启动阶段，Go 就已经创建了一些 OS 线程并与 <code>M</code> 想关联了。在我们的例子中，打印 <code>hello</code> 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 <code>M</code> 和 <code>P</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211126.png" alt="M and P pulled from the idle list"></p>
<p>现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 <code>P</code> 多的 <code>M</code>，在系统调用时怎么管理协程。</p>
<h2><span id="系统调用">系统调用</span></h2><p>Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 <code>P</code> 和线程 <code>M</code> 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   fd, _ := os.Open(<span class="string">&quot;number.txt&quot;</span>)</span><br><span class="line">   fd.Read(buf)</span><br><span class="line">   fd.Close()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="type">string</span>(buf)) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件读取的流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211158.png" alt="Syscall handoffs P"></p>
<p><code>P0</code> 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。</p>
<ul>
<li>尝试去捕获相同的 <code>P</code>，在我们的例子中就是 <code>P0</code>，然后 resume 执行过程</li>
<li>尝试从空闲 list 中捕获一个 <code>P</code>，然后 resume 执行过程</li>
<li>把协程放到全局队列里，把与之相关联的 <code>M</code> 放回空闲 list 去</li>
</ul>
<p>然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 <code>M</code> 不会阻塞：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211227.png" alt="Network poller waiting for the resource"></p>
<p>在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211256.png" alt></p>
<p>如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。</p>
<h2><span id="os-线程方面的限制">OS 线程方面的限制</span></h2><p>在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：</p>
<blockquote>
<p><em>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</em></p>
</blockquote>
<p>译注：<strong>GOMAXPROCS</strong> 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 <strong>GOMAXPROCS</strong> 没有影响。这个包的 <strong><em>GOMAXPROCS</em></strong> 函数查询和修改这个最大数限制。</p>
<p>对这种情形举例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++  &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         http.Get(<span class="string">`https://httpstat.us/200?sleep=10000`</span>)</span><br><span class="line"></span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用追踪工具得到的线程数如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211320.png" alt></p>
<p>由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。</p>
<hr>
<p>via: <a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a">https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a</a></p>
<p>作者：<a href="https://medium.com/@blanchon.vincent">Vincent Blanchon</a> 译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a> 校对：<a href="https://github.com/polaris1119">polaris1119</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25292">Go语言中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FFmpeg的摄像头直播(推流)</title>
    <url>/ae1aac27/</url>
    <content><![CDATA[<p>原文地址: <a href="http://blog.csdn.net/wh8_2011/article/details/73506154">http://blog.csdn.net/wh8_2011/article/details/73506154</a></p>
<p>本文实现: 读取PC摄像头视频数据并以RTMP协议发送为直播流. 示例包含 1. FFmpeg的libavdevice的使用 2. 视频编码, 解码, 推流的基本流程</p>
<p>要使用libavdevice的相关函数, 首先需要注册相关组件 <code>avdevice_register_all()</code></p>
<p>列出电脑中可用的DShow设备</p>
<pre><code>AVFormatContext *pFmtCtx = avformat_alloc_context();  
    AVDeviceInfoList *device_info = NULL;  
    AVDictionary* options = NULL;  
    av_dict_set(&amp;options, &quot;list_devices&quot;, &quot;true&quot;, 0);  
    AVInputFormat *iformat = av_find_input_format(&quot;dshow&quot;);  
    printf(&quot;Device Info=============\n&quot;);  
    avformat_open_input(&amp;pFmtCtx, &quot;video=dummy&quot;, iformat, &amp;options);  
    printf(&quot;========================\n&quot;); </code></pre><p>也可以直接使用FFmpeg的工具 <code>ffmpeg -list_devices true -f dshow -i dummy</code></p>
<p>PS: avdevice有一个avdevice_list_devices函数可以枚举系统的采集设备, 包括设备名和设备描述, 可以让用户选择要使用的设备, 但是不支持DShow设备.</p>
<p>像打开普通文件一样将上面的具体设备名作为输入打开, 并进行相应的初始化设置</p>
<pre><code>av_register_all();  
    //Register Device  
    avdevice_register_all();  
    avformat_network_init();  

    //Show Dshow Device    
    show_dshow_device();  

    printf(&quot;\nChoose capture device: &quot;);  
    if (gets(capture_name) == 0)  
    &#123;  
        printf(&quot;Error in gets()\n&quot;);  
        return -1;  
    &#125;  
    sprintf(device_name, &quot;video=%s&quot;, capture_name);  

    ifmt=av_find_input_format(&quot;dshow&quot;);  

    //Set own video device&apos;s name  
    if (avformat_open_input(&amp;ifmt_ctx, device_name, ifmt, NULL) != 0)&#123;  
        printf(&quot;Couldn&apos;t open input stream.（无法打开输入流）\n&quot;);  
        return -1;  
    &#125;  
    //input initialize  
    if (avformat_find_stream_info(ifmt_ctx, NULL)&lt;0)  
    &#123;  
        printf(&quot;Couldn&apos;t find stream information.（无法获取流信息）\n&quot;);  
        return -1;  
    &#125;  
    videoindex = -1;  
    for (i = 0; i&lt;ifmt_ctx-&gt;nb_streams; i++)  
        if (ifmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)  
        &#123;  
            videoindex = i;  
            break;  
        &#125;  
    if (videoindex == -1)  
    &#123;  
        printf(&quot;Couldn&apos;t find a video stream.（没有找到视频流）\n&quot;);  
        return -1;  
    &#125;  
    if (avcodec_open2(ifmt_ctx-&gt;streams[videoindex]-&gt;codec, avcodec_find_decoder(ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;codec_id), NULL)&lt;0)  
    &#123;  
        printf(&quot;Could not open codec.（无法打开解码器）\n&quot;);  
        return -1;  
    &#125;</code></pre><p>输入设备初始化后, 需要对输出做相应的初始化. FFmpeg将网络协议和文件同等看待, 同时因为使用RTMP协议进行传输, 因此制定输出为flv格式, 编码器使用H.264</p>
<pre><code>//output initialize  
    avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, &quot;flv&quot;, out_path);  
    //output encoder initialize  
    pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);  
    if (!pCodec)&#123;  
        printf(&quot;Can not find encoder! (没有找到合适的编码器！)\n&quot;);  
        return -1;  
    &#125;  
    pCodecCtx=avcodec_alloc_context3(pCodec);  
    pCodecCtx-&gt;pix_fmt = PIX_FMT_YUV420P;  
    pCodecCtx-&gt;width = ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;width;  
    pCodecCtx-&gt;height = ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;height;  
    pCodecCtx-&gt;time_base.num = 1;  
    pCodecCtx-&gt;time_base.den = 25;  
    pCodecCtx-&gt;bit_rate = 400000;  
    pCodecCtx-&gt;gop_size = 250;  
    /* Some formats,for example,flv, want stream headers to be separate. */  
    if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)  
        pCodecCtx-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;  

    //H264 codec param  
    //pCodecCtx-&gt;me_range = 16;  
    //pCodecCtx-&gt;max_qdiff = 4;  
    //pCodecCtx-&gt;qcompress = 0.6;  
    pCodecCtx-&gt;qmin = 10;  
    pCodecCtx-&gt;qmax = 51;  
    //Optional Param  
    pCodecCtx-&gt;max_b_frames = 3;  
    // Set H264 preset and tune  
    AVDictionary *param = 0;  
    av_dict_set(&amp;param, &quot;preset&quot;, &quot;fast&quot;, 0);  
    av_dict_set(&amp;param, &quot;tune&quot;, &quot;zerolatency&quot;, 0);  

    if (avcodec_open2(pCodecCtx, pCodec,&amp;param) &lt; 0)&#123;  
        printf(&quot;Failed to open encoder! (编码器打开失败！)\n&quot;);  
        return -1;  
    &#125;  

    //Add a new stream to output,should be called by the user before avformat_write_header() for muxing  
    video_st = avformat_new_stream(ofmt_ctx, pCodec);  
    if (video_st == NULL)&#123;  
        return -1;  
    &#125;  
    video_st-&gt;time_base.num = 1;  
    video_st-&gt;time_base.den = 25;  
    video_st-&gt;codec = pCodecCtx;  

    //Open output URL,set before avformat_write_header() for muxing  
    if (avio_open(&amp;ofmt_ctx-&gt;pb,out_path, AVIO_FLAG_READ_WRITE) &lt; 0)&#123;  
    printf(&quot;Failed to open output file! (输出文件打开失败！)\n&quot;);  
    return -1;  
    &#125;  

    //Show some Information  
    av_dump_format(ofmt_ctx, 0, out_path, 1);  

    //Write File Header  
    avformat_write_header(ofmt_ctx,NULL); </code></pre><p>完成输入和输出的初始化后, 就可以正式开始解码和编码并推流的流程了. 需要注意的是, 摄像头数据往往是RGB格式的, 需要将其转换为YUV420P格式, 才能推流, 因此要先做如下的准备工作</p>
<pre><code>//prepare before decode and encode  
    dec_pkt = (AVPacket *)av_malloc(sizeof(AVPacket));  
    //enc_pkt = (AVPacket *)av_malloc(sizeof(AVPacket));  
    //camera data has a pix fmt of RGB,convert it to YUV420  
    img_convert_ctx = sws_getContext(ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;width, ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;height,   
        ifmt_ctx-&gt;streams[videoindex]-&gt;codec-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);  
    pFrameYUV = avcodec_alloc_frame();  
    uint8_t *out_buffer = (uint8_t *)av_malloc(avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));  
    avpicture_fill((AVPicture *)pFrameYUV, out_buffer, PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);  </code></pre><p>现在, 就可以正式开始解码, 编码 和推流了</p>
<pre><code>//start decode and encode  
    int64_t start_time=av_gettime();  
    while (av_read_frame(ifmt_ctx, dec_pkt) &gt;= 0)&#123;     
        if (exit_thread)  
            break;  
        av_log(NULL, AV_LOG_DEBUG, &quot;Going to reencode the frame\n&quot;);  
        pframe = av_frame_alloc();  
        if (!pframe) &#123;  
            ret = AVERROR(ENOMEM);  
            return -1;  
        &#125;  
        //av_packet_rescale_ts(dec_pkt, ifmt_ctx-&gt;streams[dec_pkt-&gt;stream_index]-&gt;time_base,  
        //  ifmt_ctx-&gt;streams[dec_pkt-&gt;stream_index]-&gt;codec-&gt;time_base);  
        ret = avcodec_decode_video2(ifmt_ctx-&gt;streams[dec_pkt-&gt;stream_index]-&gt;codec, pframe,  
            &amp;dec_got_frame, dec_pkt);  
        if (ret &lt; 0) &#123;  
            av_frame_free(&amp;pframe);  
            av_log(NULL, AV_LOG_ERROR, &quot;Decoding failed\n&quot;);  
            break;  
        &#125;  
        if (dec_got_frame)&#123;  
            sws_scale(img_convert_ctx, (const uint8_t* const*)pframe-&gt;data, pframe-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);     

            enc_pkt.data = NULL;  
            enc_pkt.size = 0;  
            av_init_packet(&amp;enc_pkt);  
            ret = avcodec_encode_video2(pCodecCtx, &amp;enc_pkt, pFrameYUV, &amp;enc_got_frame);  
            av_frame_free(&amp;pframe);  
            if (enc_got_frame == 1)&#123;  
                //printf(&quot;Succeed to encode frame: %5d\tsize:%5d\n&quot;, framecnt, enc_pkt.size);  
                framecnt++;   
                enc_pkt.stream_index = video_st-&gt;index;  

                //Write PTS  
                AVRational time_base = ofmt_ctx-&gt;streams[videoindex]-&gt;time_base;//&#123; 1, 1000 &#125;;  
                AVRational r_framerate1 = ifmt_ctx-&gt;streams[videoindex]-&gt;r_frame_rate;// &#123; 50, 2 &#125;;  
                AVRational time_base_q = &#123; 1, AV_TIME_BASE &#125;;  
                //Duration between 2 frames (us)  
                int64_t calc_duration = (double)(AV_TIME_BASE)*(1 / av_q2d(r_framerate1));  //内部时间戳  
                //Parameters  
                //enc_pkt.pts = (double)(framecnt*calc_duration)*(double)(av_q2d(time_base_q)) / (double)(av_q2d(time_base));  
                enc_pkt.pts = av_rescale_q(framecnt*calc_duration, time_base_q, time_base);  
                enc_pkt.dts = enc_pkt.pts;  
                enc_pkt.duration = av_rescale_q(calc_duration, time_base_q, time_base); //(double)(calc_duration)*(double)(av_q2d(time_base_q)) / (double)(av_q2d(time_base));  
                enc_pkt.pos = -1;  

                //Delay  
                int64_t pts_time = av_rescale_q(enc_pkt.dts, time_base, time_base_q);  
                int64_t now_time = av_gettime() - start_time;  
                if (pts_time &gt; now_time)  
                    av_usleep(pts_time - now_time);  

                ret = av_interleaved_write_frame(ofmt_ctx, &amp;enc_pkt);  
                av_free_packet(&amp;enc_pkt);  
            &#125;  
        &#125;  
        else &#123;  
            av_frame_free(&amp;pframe);  
        &#125;  
        av_free_packet(dec_pkt);  
    &#125;  </code></pre><p>解码比较简单, 编码部分需要自己计算PTS, DTS, 比较复杂 这里通过帧率计算PTS和DTS, 首先通过帧率计算两帧之间的时间间隔, 但是要换算</p>
]]></content>
      <categories>
        <category>Pic</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>基于zookeeper实现统一配置管理</title>
    <url>/15475898/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p><strong>为什么要用统一配置？</strong></p>
<p>我们做项目时用到的配置比如数据库配置等…我们都是写死在项目里面，如果需要更改，那么也是的修改配置文件然后再投产上去，那么问题来了，如果做集群的呢，有100台机器，这时候做修改那就太不切实际了；那么就需要用到统一配置管理啦。</p>
<p>解决思路</p>
<p>1.把公共配置抽取出来</p>
<p>2.对公共配置进行维护</p>
<p>3.修改公共配置后应用不需要重新部署</p>
<p>采用方案</p>
<p>1.公共配置抽取存放于zookeeper中并落地数据库</p>
<p>2.对公共配置修改后发布到zookeeper中并落地数据库</p>
<p>3.对应用开启配置实时监听，zookeeper配置文件一旦被修改，应用可实时监听到并获取</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310112242.png" alt></p>
<p><strong>下面基于zookeeper粗略实现了一个统一配置管理</strong></p>
<p>需要用到的jar是zkclient</p>
<p>配置文件Config</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cwh.zk.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String userNm;</span><br><span class="line">	<span class="keyword">private</span> String userPw;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Config</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Config</span><span class="params">(String userNm, String userPw)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.userNm = userNm;</span><br><span class="line">		<span class="built_in">this</span>.userPw = userPw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUserNm</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> userNm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserNm</span><span class="params">(String userNm)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.userNm = userNm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUserPw</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> userPw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserPw</span><span class="params">(String userPw)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.userPw = userPw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Config [userNm=&quot;</span> + userNm + <span class="string">&quot;, userPw=&quot;</span> + userPw + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置管理中心ZkConfigMag</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cwh.zk.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkConfigMag</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> Config config;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库加载配置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Config <span class="title function_">downLoadConfigFromDB</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//getDB</span></span><br><span class="line">		config = <span class="keyword">new</span> <span class="title class_">Config</span>(<span class="string">&quot;nm&quot;</span>, <span class="string">&quot;pw&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> config;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 配置文件上传到数据库</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upLoadConfigToDB</span><span class="params">(String nm, String pw)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(config==<span class="literal">null</span>)config = <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">		config.setUserNm(nm);</span><br><span class="line">		config.setUserPw(pw);</span><br><span class="line">		<span class="comment">//updateDB</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 配置文件同步到zookeeper</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncConfigToZk</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">ZkClient</span> <span class="variable">zk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZkClient</span>(<span class="string">&quot;localhost:2181&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(!zk.exists(<span class="string">&quot;/zkConfig&quot;</span>))&#123;</span><br><span class="line">			zk.createPersistent(<span class="string">&quot;/zkConfig&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		zk.writeData(<span class="string">&quot;/zkConfig&quot;</span>, config);</span><br><span class="line">		zk.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>应用监听实现ZkGetConfigClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cwh.zk.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkGetConfigClient</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> Config config;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> Config <span class="title function_">getConfig</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ZkClient</span> <span class="variable">zk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZkClient</span>(<span class="string">&quot;localhost:2181&quot;</span>);</span><br><span class="line">		config = (Config)zk.readData(<span class="string">&quot;/zkConfig&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;加载到配置：&quot;</span>+config.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//监听配置文件修改</span></span><br><span class="line">		zk.subscribeDataChanges(<span class="string">&quot;/zkConfig&quot;</span>, <span class="keyword">new</span> <span class="title class_">IZkDataListener</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataChange</span><span class="params">(String arg0, Object arg1)</span></span><br><span class="line">					<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				config = (Config) arg1;</span><br><span class="line">				System.out.println(<span class="string">&quot;监听到配置文件被修改：&quot;</span>+config.toString());</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataDeleted</span><span class="params">(String arg0)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				config = <span class="literal">null</span>;</span><br><span class="line">				System.out.println(<span class="string">&quot;监听到配置文件被删除&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> config;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ZkGetConfigClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZkGetConfigClient</span>();</span><br><span class="line">		client.getConfig();</span><br><span class="line">		System.out.println(client.config.toString());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			System.out.println(client.config.toString());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试，启动配置管理中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cwh.zkConfig.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.cwh.zk.util.Config;</span><br><span class="line"><span class="keyword">import</span> com.cwh.zk.util.ZkConfigMag;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkConfigTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ZkConfigMag</span> <span class="variable">mag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZkConfigMag</span>();</span><br><span class="line">		<span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> mag.downLoadConfigFromDB();</span><br><span class="line">		System.out.println(<span class="string">&quot;....加载数据库配置....&quot;</span>+config.toString());</span><br><span class="line">		mag.syncConfigToZk();</span><br><span class="line">		System.out.println(<span class="string">&quot;....同步配置文件到zookeeper....&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//歇会，这样看比较清晰</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		mag.upLoadConfigToDB(<span class="string">&quot;cwhcc&quot;</span>, <span class="string">&quot;passwordcc&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;....修改配置文件....&quot;</span>+config.toString());</span><br><span class="line">		mag.syncConfigToZk();</span><br><span class="line">		System.out.println(<span class="string">&quot;....同步配置文件到zookeeper....&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试结果：</p>
<p>配置管理中心打印：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310113057.png" alt></p>
<p>应用监听：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220310113139.png" alt></p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】备忘单：提升你的 MariaDB 和 MySQL 数据库技能</title>
    <url>/3641869e/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#与-mariadb-交互">与 MariaDB 交互</a></li>
<li><a href="#学习-sql-基本知识">学习 SQL 基本知识</a><ul>
<li><a href="#显示数据库的表">显示数据库的表</a></li>
<li><a href="#检查一个表">检查一个表</a></li>
<li><a href="#创建一个新的用户">创建一个新的用户</a></li>
<li><a href="#查看表的字段">查看表的字段</a></li>
<li><a href="#为一个用户赋予权限">为一个用户赋予权限</a></li>
</ul>
</li>
<li><a href="#创建自定义的数据库">创建自定义的数据库</a><ul>
<li><a href="#创建一个-mariadb-数据库">创建一个 MariaDB 数据库</a></li>
<li><a href="#创建一个表">创建一个表</a></li>
<li><a href="#同时增加多行数据">同时增加多行数据</a></li>
</ul>
</li>
<li><a href="#关联多个表">关联多个表</a><ul>
<li><a href="#连接表">连接表</a></li>
</ul>
</li>
<li><a href="#下载-mariadb-和-mysql-备忘单">下载 MariaDB 和 MySQL 备忘单</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>阅读本文并下载我们的免费备忘单，去使用开源的数据库吧。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103221458.png" alt></p>
<p>当你写一个程序或配置一个服务时，你最终都要持久化存储信息。有时候，你只需要一个 INI 或者 <a href="https://www.redhat.com/sysadmin/yaml-tips">YAML</a> 配置文件就够了。而有时候，一个自定义格式的 XML 或者 JSON 或其他类似的文件会更好。</p>
<p>但也有时候你需要校验输入、快速查询信息、关联数据、通常还要熟练地处理你的用户的请求。这就是设计数据库的目的，而 <a href="https://mariadb.org/">MariaDB</a>（由 <a href="https://www.mysql.com/">MySQL</a> 的原始开发人员开发的一个分支） 是一个极佳的选项。在本文中我使用的是 MariaDB，但这些信息同样适用于 MySQL。</p>
<p>通过编程语言与数据库进行交互是很普遍的。正因如此，出现了大量 Java、Python、Lua、PHP、Ruby、C++ 和其他语言的 <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> 库。然而，在使用这些库之前，理解数据库引擎做了什么以及为什么选择数据库是重要的对我们会很有帮助。本文介绍 MariaDB 和 <code>mysql</code> 命令来帮助你熟悉数据库处理数据的基本原理。</p>
<p>如果你还没有安装 MariaDB，请查阅我的文章 <a href="https://opensource.com/article/20/10/install-mariadb-and-mysql-linux">在 Linux 上安装 MariaDB</a>。如果你没有使用 Linux，请参照 MariaDB <a href="https://mariadb.org/download">下载页面</a>提供的指导方法。</p>
<h3><span id="与-mariadb-交互">与 MariaDB 交互</span></h3><p>你可以使用 <code>mysql</code> 命令与 MariaDB 进行交互。首先使用子命令 <code>ping</code> 确认你的服务是运行着的，在提示后输入密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysqladmin -u root -p ping</span><br><span class="line">Enter password:</span><br><span class="line">mysqld is alive</span><br></pre></td></tr></table></figure>

<p>为了易于读者理解，打开一个交互式的 MariaDB 会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MariaDB monitor.</span><br><span class="line">Commands end with ; or \g.</span><br><span class="line">[...]</span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help.</span><br><span class="line">Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure>

<p>你现在是在一个 MariaDB 子 shell 中，提示符是 MariaDB 提示符。普通的 Bash 命令在这里不能使用，只能用 MariaDB 命令。输入 <code>help</code> （或 <code>?</code>）查看命令列表。这些是你的 MariaDB shell 的管理命令，使用它们可以定制你的 shell，但它们不属于 SQL 语言。</p>
<h3><span id="学习-sql-基本知识">学习 SQL 基本知识</span></h3><p><a href="https://publications.opengroup.org/c449">结构化查询语言</a>是基于它们的能力定义的：一种通过有规则且一致的语法来查询数据库中的内容以得到有用的结果的方法。SQL 看起来像是普通的英文语句，有一点点生硬。例如，如果你登入数据库服务器，想查看有哪些库，输入 <code>SHOW DATABASES;</code> 并回车就能看到结果。</p>
<p>SQL 命令以分号作为结尾。如果你忘记输入分号，MariaDB 会认为你是想在下一行继续输入你的查询命令，在下一行你可以继续输入命令也可以输入分号结束命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MariaDB [(NONE)]&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| DATABASE           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">4 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure>

<p>上面的例子显示当前有四个数据库：<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code> 和 <code>test</code>。你必须指定 MariaDB 使用哪个库，才能对该库使用查询语句。指定数据库的命令是 <code>use</code>。当你选择了一个库后，MariaDB 提示框会切换为选择的库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MariaDB [(NONE)]&gt; USE test;</span><br><span class="line">MariaDB [(test)]&gt;</span><br></pre></td></tr></table></figure>

<h4><span id="显示数据库的表">显示数据库的表</span></h4><p>数据库里有<em>表</em>，与电子表格类似：有一系列的行（在数据库中称为<em>记录</em>）和列。一个行和一个列唯一确定一个<em>字段</em>。</p>
<p>查看一个数据库中可用的表（可以理解为多表单电子表格中的一页），使用 SQL 关键字 <code>SHOW</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MariaDB [(test)]&gt; SHOW TABLES;</span><br><span class="line">empty SET</span><br></pre></td></tr></table></figure>

<p><code>test</code> 数据库是空的，所以使用 <code>use</code> 命令切换到 <code>mysql</code> 数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MariaDB [(test)]&gt; USE mysql;</span><br><span class="line">MariaDB [(mysql)]&gt; SHOW TABLES;</span><br><span class="line"></span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql           |</span><br><span class="line">+---------------------------+</span><br><span class="line">| column_stats              |</span><br><span class="line">| columns_priv              |</span><br><span class="line">| db                        |</span><br><span class="line">[...]</span><br><span class="line">| time_zone_transition_type |</span><br><span class="line">| transaction_registry      |</span><br><span class="line">| USER                      |</span><br><span class="line">+---------------------------+</span><br><span class="line">31 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure>

<p>这个数据库中有很多表！<code>mysql</code> 数据库是这个 MariaDB 实例的系统管理数据库。它里面包含重要数据，比如用来管理数据库权限的用户结构。这个数据库很重要，你不需要经常直接与它交互，但是使用 SQL 脚本来操作它却很常见。当你学习 MariaDB 时理解 <code>mysql</code> 数据库很有用，因为它有助于说明一些基本的 SQL 命令。</p>
<h4><span id="检查一个表">检查一个表</span></h4><p>这个实例的 <code>mysql</code> 数据库的最后一个表名为 <code>USER</code>。这个表包含了可以访问这个数据库的用户。当前里面只有一个 root 用户，但是你可以添加不同权限的用户，赋予它们查看、更新或创建数据的权限。你可以查看一个表的列首来了解一个  MariaDB 用户的所有属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SHOW COLUMNS IN USER;</span><br><span class="line">MariaDB [mysql]&gt; SHOW COLUMNS IN USER;</span><br><span class="line">+-------------+---------------+------+-----+----------+</span><br><span class="line">| FIELD       | TYPE          | NULL | KEY | DEFAULT  |</span><br><span class="line">+-------------+---------------+------+-----+----------+</span><br><span class="line">| Host        | CHAR(60)      | NO   | PRI |          |</span><br><span class="line">| USER        | CHAR(80)      | NO   | PRI |          |</span><br><span class="line">| Password    | CHAR(41)      | NO   |     |          |</span><br><span class="line">| Select_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N        |</span><br><span class="line">| Insert_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N        |</span><br><span class="line">| Update_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N        |</span><br><span class="line">| Delete_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N        |</span><br><span class="line">| Create_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N        |</span><br><span class="line">| Drop_priv   | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N        |</span><br><span class="line">[...]</span><br><span class="line">47 ROWS IN SET (0.001 sec)</span><br></pre></td></tr></table></figure>

<h4><span id="创建一个新的用户">创建一个新的用户</span></h4><p>不论你是否需要一个普通的账号来管理数据库或者为计算机配置数据库（例如安装 WordPress、Drupal 或 Joomla时），在 MariaDB 中多建一个用户账号是很普遍的。你可以通过向 <code>mysql</code> 数据库的 <code>USER</code> 表中添加一个用户或使用 SQL 关键字 <code>CREATE</code> 来提示 MariaDB 创建一个 MariaDB 用户。使用 <code>CREATE</code> 来创建新用户会默认执行一些有用的方法，因此你不需要手动生成所有的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; CREATE USER &#x27;tux&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;really_secure_password&#x27;;</span><br></pre></td></tr></table></figure>

<h4><span id="查看表的字段">查看表的字段</span></h4><p>你可以使用 <code>SELECT</code> 关键字来查看数据库表的字段和值。这本例中，你创建了一个名为 <code>tux</code> 的用户，因此查询 <code>USER</code> 表中的列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SELECT USER,host FROM USER;</span><br><span class="line">+------+------------+</span><br><span class="line">| USER | host       |</span><br><span class="line">+------+------------+</span><br><span class="line">| root | localhost  |</span><br><span class="line">[...]</span><br><span class="line">| tux  | localhost  |</span><br><span class="line">+------+------------+</span><br><span class="line">7 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure>

<h4><span id="为一个用户赋予权限">为一个用户赋予权限</span></h4><p>通过查看 <code>USER</code> 表列出的信息，你可以看到用户的状态。例如，新用户 <code>tux</code> 对这个数据库没有任何权限。使用 <code>WHERE</code> 语句你可以只查 <code>tux</code> 那一条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SELECT USER,select_priv,insert_priv,update_priv FROM USER WHERE USER=&#x27;tux&#x27;;</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| USER | select_priv | insert_priv | update_priv |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| tux  | N           | N           | N           |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure>

<p>使用 <code>GRANT</code> 命令修改用户的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; GRANT SELECT ON *.* TO &#x27;tux&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>验证你的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SELECT USER,select_priv,insert_priv,update_priv FROM USER WHERE USER=&#x27;tux&#x27;;</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| USER | select_priv | insert_priv | update_priv |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br><span class="line">| tux  | Y           | N           | N           |</span><br><span class="line">+------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure>

<p><code>tux</code> 用户现在有了从所有表中查询记录的权限。</p>
<h3><span id="创建自定义的数据库">创建自定义的数据库</span></h3><p>到目前为止，你一直在与默认的数据库进行交互。除了用户管理，大部分人很少会与默认的数据库进行交互。通常，你会用自定义的数据来填充创建的数据库。</p>
<h4><span id="创建一个-mariadb-数据库">创建一个 MariaDB 数据库</span></h4><p>你可能已经可以自己在 MariaDB 中创建新数据库了。创建数据库跟新建用户差不多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; CREATE DATABASE example;</span><br><span class="line">Query OK, 1 ROW affected (0.000 sec)</span><br><span class="line">&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| DATABASE           |</span><br><span class="line">+--------------------+</span><br><span class="line">| example            |</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>使用 <code>use</code> 命令来把这个新建的数据库作为当前使用的库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; USE example;</span><br></pre></td></tr></table></figure>

<h4><span id="创建一个表">创建一个表</span></h4><p>创建表比创建数据库要复杂，因为你必须定义列首。MariaDB 提供了很多方便的函数，可以用于创建列，引入数据类型定义，自增选项，对空值的约束，自动时间戳等等。</p>
<p>下面是用来描述一系列用户的一个简单的表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS member (</span><br><span class="line">    -&gt; id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    -&gt; name VARCHAR(128) NOT NULL,</span><br><span class="line">    -&gt; startdate TIMESTAMP DEFAULT CURRENT_TIMESTAMP);</span><br><span class="line">Query OK, 0 ROWS affected (0.030 sec)</span><br></pre></td></tr></table></figure>

<p>这个表通过使用一个自动递增的方法来唯一标识每一行。表示用户名字的字段不能为空（或 <code>null</code>），每一行被创建时会自动生成时间戳。</p>
<p>使用 SQL 关键字 <code>INSERT</code> 向这个表填充一些示例数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; INSERT INTO member (name) VALUES (&#x27;Alice&#x27;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br><span class="line">&gt; INSERT INTO member (name) VALUES (&#x27;Bob&#x27;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br><span class="line">&gt; INSERT INTO member (name) VALUES (&#x27;Carol&#x27;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br><span class="line">&gt; INSERT INTO member (name) VALUES (&#x27;David&#x27;);</span><br><span class="line">Query OK, 1 ROW affected (0.011 sec)</span><br></pre></td></tr></table></figure>

<p>验证一下表里的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM member;</span><br><span class="line">+----+-------+---------------------+</span><br><span class="line">| id | name  | startdate           |</span><br><span class="line">+----+-------+---------------------+</span><br><span class="line">|  1 | Alice | 2020-10-03 15:25:06 |</span><br><span class="line">|  2 | Bob   | 2020-10-03 15:26:43 |</span><br><span class="line">|  3 | Carol | 2020-10-03 15:26:46 |</span><br><span class="line">|  4 | David | 2020-10-03 15:26:51 |</span><br><span class="line">+----+-------+---------------------+</span><br><span class="line">4 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure>

<h4><span id="同时增加多行数据">同时增加多行数据</span></h4><p>再创建一个表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS linux (</span><br><span class="line">    -&gt; id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    -&gt; distro VARCHAR(128) NOT NULL);</span><br><span class="line">Query OK, 0 ROWS affected (0.030 sec)</span><br></pre></td></tr></table></figure>

<p>填充一些示例数据，这次使用 <code>VALUES</code> 快捷方式，这样你可以一次添加多行数据。<code>VALUES</code> 关键字需要一个用括号包围的列表作为参数，也可以用逗号分隔的多个列表作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; INSERT INTO linux (distro)</span><br><span class="line"> -&gt; VALUES (&#x27;Slackware&#x27;), (&#x27;RHEL&#x27;),(&#x27;Fedora&#x27;),(&#x27;Debian&#x27;);</span><br><span class="line">Query OK, 4 ROWS affected (0.011 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line">&gt; SELECT * FROM linux;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | distro    |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  1 | Slackware |</span><br><span class="line">|  2 | RHEL      |</span><br><span class="line">|  3 | Fedora    |</span><br><span class="line">|  4 | Debian    |</span><br><span class="line">+----+-----------+</span><br></pre></td></tr></table></figure>

<h3><span id="关联多个表">关联多个表</span></h3><p>现在你有两个表，之间没有关联。两个表的数据是独立的，但是你可能需要表一中的一个值来识别表二的记录。</p>
<p>你可以在表一中新增一列对应表二中的值。因为两个表都有唯一的标识符（自动递增的 <code>id</code> 字段），关联的它们的最简单的方式是，使用表一中的 <code>id</code> 字段作为表二的查询条件。</p>
<p>在表一中创建一列用来表示表二中的一个值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE member ADD COLUMN (os INT);</span><br><span class="line">Query OK, 0 ROWS affected (0.012 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">&gt; DESCRIBE member;</span><br><span class="line">DESCRIBE member;</span><br><span class="line">+-----------+--------------+------+-----+---------+------+</span><br><span class="line">| FIELD     | TYPE         | NULL | KEY | DEFAULT | Extra|</span><br><span class="line">+-----------+--------------+------+-----+---------+------+</span><br><span class="line">| id        | INT(11)      | NO   | PRI | NULL    | auto_|</span><br><span class="line">| name      | VARCHAR(128) | NO   |     | NULL    |      |</span><br><span class="line">| startdate | TIMESTAMP    | NO   |     | cur[...]|      |</span><br><span class="line">| os        | INT(11)      | YES  |     | NULL    |      |</span><br><span class="line">+-----------+--------------+------+-----+---------+------+</span><br></pre></td></tr></table></figure>

<p>把 <code>linux</code> 表中的唯一 ID 分配给每个成员。因为记录已经存在，使用 <code>UPDATE</code> 关键字而不是 <code>INSERT</code>。尤其是当你想查询某行然后再更新某列值时。语法上，表达方式有点倒装，先更新后查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; UPDATE member SET os=1 WHERE name=&#x27;Alice&#x27;;</span><br><span class="line">Query OK, 1 ROW affected (0.007 sec)</span><br><span class="line">ROWS matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>要填充数据，请对其他名字重复执行这个过程。为了数据的多样性，在四行记录中分配三个不同的值。</p>
<h4><span id="连接表">连接表</span></h4><p>现在这两个表彼此有了关联，你可以使用 SQL 来展示关联的数据。数据库中有很多种连接方式，你可以尽请尝试。下面的例子是关联 <code>member</code> 表中 <code>os</code> 字段和 <code>linux</code> 表中 <code>id</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM member JOIN linux ON member.os=linux.id;</span><br><span class="line">+----+-------+---------------------+------+----+-----------+</span><br><span class="line">| id | name  | startdate           | os   | id | distro    |</span><br><span class="line">+----+-------+---------------------+------+----+-----------+</span><br><span class="line">|  1 | Alice | 2020-10-03 15:25:06 |    1 |  1 | Slackware |</span><br><span class="line">|  2 | Bob   | 2020-10-03 15:26:43 |    3 |  3 | Fedora    |</span><br><span class="line">|  4 | David | 2020-10-03 15:26:51 |    3 |  3 | Fedora    |</span><br><span class="line">|  3 | Carol | 2020-10-03 15:26:46 |    4 |  4 | Debian    |</span><br><span class="line">+----+-------+---------------------+------+----+-----------+</span><br><span class="line">4 ROWS IN SET (0.000 sec)</span><br></pre></td></tr></table></figure>

<p>连接 <code>os</code> 和 <code>id</code> 字段。</p>
<p>在图形化的应用中，你可以想象 <code>os</code> 字段可以在下拉菜单中设置，值的来源是 <code>linux</code> 表中的 <code>distro</code> 字段。通过使用多个表中独立却有关联的数据，你可以保证数据的一致性和有效性，使用 SQL 你可以动态地关联它们。</p>
<h3><span id="下载-mariadb-和-mysql-备忘单">下载 MariaDB 和 MySQL 备忘单</span></h3><p>MariaDB 是企业级的数据库。它是健壮、强大、高效的数据库引擎。学习它是你向管理 web 应用和编写语言库迈出的伟大的一步。你可以<a href="https://opensource.com/downloads/mariadb-mysql-cheat-sheet">下载 MariaDB 和 MySQL 备忘单</a>，在你使用 MariaDB 时可以快速参考。</p>
<hr>
<p>via: <a href="https://opensource.com/article/20/10/mariadb-mysql-cheat-sheet">https://opensource.com/article/20/10/mariadb-mysql-cheat-sheet</a></p>
<p>作者：<a href="https://opensource.com/users/seth">Seth Kenlon</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">lxbwolf</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>大小端</title>
    <url>/7ee0edaa/</url>
    <content><![CDATA[<p>计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构而已），比如C/C++中，short类型一般是2个字节，int类型一般4个字节等。因此这里就存在着一个如何安排多个字节数据中各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。</p>
<h4><span id="1-解释">1. 解释</span></h4><p>假如有一个4字节的数据为 0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址 0x4000 8000中，则有：</p>
<p>内存地址</p>
<p>0x4000 8000（低地址）</p>
<p>0x4000 8001</p>
<p>0x4000 8002</p>
<p>0x4000 8003（高地址）</p>
<p>大端模式</p>
<p>0x12（高字节）</p>
<p>0x34</p>
<p>0x56</p>
<p>0x78（低字节）</p>
<p>小端模式</p>
<p>0x78（低字节）</p>
<p>0x56</p>
<p>0x34</p>
<p>0x12（高字节）</p>
<ul>
<li>大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</li>
<li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</li>
</ul>
<p>为什么截然相反的大小端存储模式能够并存至今？在标准化备受推崇的今天，为什么大小端谁都没有被另外一个所同化？我想这除了历史的惯性使然，还与它们各自的优缺点有关。 大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小 小端模式优点：1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）； 2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持（见1.3节），因此在多字节存储顺序上始终没有一个统一的标准</p>
<ul>
<li>Intel的80×86系列芯片使用小端存储模式</li>
<li>ARM芯片默认采用小端，但可以切换为大端</li>
<li>MIPS芯片采用大端，但可以在大小端之间切换</li>
<li>在网络上传输的数据普遍采用的都是大端</li>
</ul>
<h4><span id="2-判断">2. 判断</span></h4><p>方法一：通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测</p>
<pre><code>// @Ret: 大端，返回true; 小端，返回false
bool IsBigEndian_1()
&#123;
    int nNum = 0x12345678;
    char cLowAddressValue = *(char*)&amp;nNum;

    // 低地址处是高字节，则为大端
    if ( cLowAddressValue == 0x12 )    return true;

    return false; 
&#125;</code></pre><p>方法二：利用联合体union的存放顺序是所有成员都从低地址开始存放这一特性进行检测</p>
<pre><code>// @Ret: 大端，返回true; 小端，返回false
bool isBigEndian_2()
&#123;
    union uendian
    &#123;
       int nNum;
       char cLowAddressValue;
    &#125;;

    uendian u;
    u.nNum = 0x12345678;

    if ( u.cLowAddressValue == 0x12 )     return true;

    return false;
&#125;</code></pre><h4><span id="3-转换">3. 转换</span></h4><p>大小端转换</p>
<pre><code>// 实现16bit的数据之间的大小端转换
#define BLSWITCH16(A)   (  ( ( (uint16)(A) &amp; 0xff00 ) &gt;&gt; 8  )    | \  
                           ( ( (uint16)(A) &amp; 0x00ff ) &lt;&lt; 8  )     )  

// 实现32bit的数据之间的大小端转换
#define BLSWITCH32(A)   (  ( ( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) |\
         (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \
         (((unit32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | \
         (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 32)  )</code></pre><p>由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保证服务稳定性</title>
    <url>/d0f092bd/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-sla">1 SLA</a></li>
<li><a href="#2-单服务稳定性">2 单服务稳定性</a></li>
<li><a href="#3-集群稳定性">3 集群稳定性</a></li>
<li><a href="#4-稳定性专项">4 稳定性专项</a></li>
<li><a href="#5-稳定性建设">5 稳定性建设</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-sla">1 SLA</span></h2><p>业内喜欢用SLA （服务等级协议，全称：service level agreement）来衡量系统的稳定性，对互联网公司来说就是网站服务可用性的一个保证。9越多代表全年服务可用时间越长服务越可靠，停机时间越短。就以一个标准99.99%为例，停机时间52.6分钟，平均到每周也就是只能有差不多1分钟的停机时间，也就是说网络抖动这个时间可能就没了。保证一个系统四个9或者更高的五个9，需要一套全体共识严格标准的规章制度，没有规矩不成方圆。创建的规范有如下几种：</p>
<p>1、研发规范、自身稳定；</p>
<p>2、事务中不能包含远程调用；</p>
<p>3、超时时间和重试次数要合理；</p>
<p>4、表数据操作必须double check，合理利用索引，避免出现慢查询、分库分表不走分表键；</p>
<p>5、没有有效的资源隔离， 避免不同业务共用一个线程池或连接池；</p>
<p>6、合理的系统拓扑，禁止不合理服务依赖，能依赖就依赖，否则同步尽量改成异步弱依赖；</p>
<p>7、精简的代码逻辑；</p>
<p>8、核心路径流程必须进行资源隔离，确保任何突发情况主流程不能受影响。</p>
<h2><span id="2-单服务稳定性">2 单服务稳定性</span></h2><p><strong>关键字：开关可控、单一职责、服务隔离、异常兜底、监控发现！</strong></p>
<p>对于稳定性来说，抛开整体系统架构设计，单就每个业务域服务的稳定性也是非常的重要。只有每个业务环节都稳如泰山，才能保障整个稳定性。单服务稳定可以从以下几个方面来进行：</p>
<p><strong>1、禁用设计</strong>：应该提供控制具体功能是否开启可用的配置，在相应的功能服务出现故障时，快速下线局部功能，以保证整体服务的可用性；</p>
<p><strong>2、必要的缓存</strong>：缓存是解决并发的利器，可以有效的提高系统的吞吐量。按照业务以及技术的纬度必要时可以增加多级缓存来保证其命中率；</p>
<p><strong>3、接口无状态性</strong>：服务接口应是无状态的，当前接口访问不应该依赖上层接口的状态逻辑；</p>
<p><strong>4、接口单一职责性</strong>：对于核心功能的接口，不应该过多的耦合不属于它的功能。如果一个接口做的事情太多应做拆分，保证单接口的稳定性和快速响应；</p>
<p><strong>5、第三方服务隔离性</strong>：任何依赖于第三方的服务（不论接口还是中间件等），都应该做到熔断和降级，不能有强耦合的依赖；</p>
<p><strong>6、业务场景兜底方案</strong>：核心业务场景要做到完整兜底方法，从前端到后端都应有兜底措施；</p>
<p><strong>7、服务监控与及时响应</strong>：每个服务应做好对应监控工作，如有异常应及时响应，不应累积。</p>
<h2><span id="3-集群稳定性">3 集群稳定性</span></h2><p><strong>关键字：系统架构、部署发布、限流熔断、监控体系、压测机制！</strong></p>
<p>对于集群维度的稳定性来说，稳定性保障会更加复杂。单服务是局部，集群是全局。一个见微知著，一个高瞻远瞩。</p>
<p><strong>1、合理的系统架构</strong>：合理的系统架构是稳定的基石；</p>
<p><strong>2、小心的代码逻辑</strong>：代码时刻都要小心，多担心一点这里会不会有性能问题，那里会不会出现并发，代码就不会有多少问题；</p>
<p><strong>3、优秀的集群部署</strong>：一台机器永远会有性能瓶颈，优秀的集群部署，可以将一台机器的稳定放大无限倍，是高并发与大流量的保障；</p>
<p><strong>4、科学的限流熔断</strong>：高并发来临时，科学的限流和熔断是系统稳定的必要条件；</p>
<p><strong>5、精细的监控体系</strong>：没有监控体系，你永远不会知道你的系统到底有多少隐藏的问题和坑，也很难知道瓶颈在哪里；</p>
<p><strong>6、强悍的压测机制</strong>：压测是高并发稳定性的试金石，能提前预知高并发来临时，系统应该出现的模样；</p>
<p><strong>7、胆小的开发人员</strong>：永远需要一群胆小的程序员，他们讨厌bug，害怕error，不放过每一个波动，不信任所有的依赖。</p>
<h2><span id="4-稳定性专项">4 稳定性专项</span></h2><p>专项指的是<strong>针对某些特定场景下的特定问题而梳理出对应的方案</strong>。下面是针对一些常见的稳定性专项的概述：</p>
<p><strong>1、预案</strong>：分为定时预案和紧急预案，定时预案是大促常规操作对于一系列开关的编排，紧急预案是应对突发情况的特殊处理，都依赖于事前梳理；</p>
<p><strong>2、预热</strong>：分为JIT代码预热和数据预热，阿里内部有专门的一个产品负责这块，通过存储线上的常态化流量或者热点流量进行回放来提前预热， 起源于某年双十一零点的毛刺问题，原因是访问了数据库的冷数据rt增高导致的一系列上层限流，现在预热已经成了大促之前的一个必要流程。</p>
<p><strong>3、强弱依赖</strong>:梳理强弱依赖是一个偏人肉的过程，但是非常重要，这是一个系统自查识别潜在风险点并为后续整理开关限流预案和根因分析的一个重要参考，阿里内部有一个强弱依赖检测的平台，通过对测试用例注入RPC调用的延迟或异常来观察链路的依赖变化，自动梳理出强弱依赖关系。</p>
<p><strong>4、限流降级熔断</strong>:应对突发流量防止请求超出自身处理能力系统被击垮的必要手段；</p>
<p><strong>5、监控告警&amp;链路追踪</strong>:监控分为业务监控、系统监控和中间件监控和基础监控，作为线上问题发现和排查工具，重要性不言而喻。</p>
<h2><span id="5-稳定性建设">5 稳定性建设</span></h2><p>稳定性建设，就和基础技术建设一样，是一个<strong>长期迭代和不断调整的过程</strong>，业内常见的稳定性建设类型，主要有如下几种：</p>
<p><strong>1、容量规划</strong>：个人感觉容量规划在大厂里也并没有做的很好，更多依赖的是业务方自己拍脑袋，然后全链路压测期间验证，不够就再加机器。</p>
<p><strong>2、混沌工程</strong>：混沌工程是近几年比较火的名词，通过不断给系统找麻烦来验证并完善系统能力，阿里在这块花了很大的精力建设红蓝军对抗攻防，进行定期和不定期的演练，最后以打分的形式来给各个部门系统做排名，除了系统层面的故障演练外还有资金演练，篡改线上sql语句制造资损来测试业务监控纠错的能力，通过制造小错来避免大错。</p>
<p>跳转门：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/imyalost/p/12271620.html">混沌工程-初识</a></p>
<p><strong>3、流量调度</strong>：通过metric秒级监控和聚类算法实时找出异常单机来降低RPC流量权重，提升集群整体吞吐能力减少异常请求。</p>
<p><strong>4、容灾&amp;异地多活</strong>：起源于15年某施工队将光纤挖断带来的支付宝故障，由此出来的三地五中心和单元化架构，异地多活本身的成本比较高，然后又存在数据同步的延时问题和切流带来的脏数据问题，对于业务和技术都有比较高的要求。常见的容灾有如下几种：</p>
<p>　 1）缓存挂掉，集群重启缓存预热如何处理？本地缓存，多级缓存是否可以替代？</p>
<p>　 2）分布式锁，是否有开关一键切换？比如：ZK/ETCD编写的分布式锁；</p>
<p>　 3）大促峰值流量，如何防止外部ddos攻击？如何识别流量类型？</p>
<p>　 4）资源隔离：资源隔离，服务分组，流量隔离；</p>
<p>　 5）高可用思想：避免单点设计！</p>
<p>　 6）容错：容错上游，防御下游。容错主要需要注意如下几点：</p>
<p>　 　 6-1：外部依赖的地方都要做熔断，避免雪崩；</p>
<p>　　 6-2：对于依赖我们的上游要限流，防止上游突发超过自己系统能够扛住的最大QPS；</p>
<p>　　 6-3：对于下游既要评估好接口超时时间，防止下游接口超时导致自己系统被拖累；</p>
<p>　　 6-4：下游接口要考虑各种异常情况，需要考虑中间状态，通过引入柔性事务，确保数</p>
<p>据最终一致</p>
<p><strong>5、异地多活</strong></p>
<p><strong>异地多活的本质，是数据中心架构的演进</strong>。</p>
<p><strong>1）演进</strong>：单机房——双机房——异地灾备——异地多活；</p>
<p><strong>2）定义</strong>：分多个地域、多个数据中心运行线上的业务，并且每个IDC均提供在线服务；</p>
<p><strong>3）优点</strong>：弹性扩展能力、流量就近接入、灵活调度、提升可用性与用户体验、容灾；</p>
<p><strong>4）步骤</strong>：</p>
<p>　 4-1：基础设施：机房之间专线互联，保证网络质量稳定；</p>
<p>　 4-2：持久存储：一主三从，主IDC同步复制，异地IDC异步复制；</p>
<p>　 4-3：中间件：DB、MQ、分布式存储；</p>
<p>　 4-4：应用部署：根据应用域划分，不同应用部署在不同地域，保持亲缘性；</p>
<p>　 4-5：流量接入与调度：网络协议兼容，DNS，动态调度用户就近访问；</p>
<p>　 4-6：监控与运维保障：专线实时监控，确保发生故障时可以触发Failover（失效备援）和</p>
<p>流量调度。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间56</title>
    <url>/a2b71d73/</url>
    <content><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>



<p>思路: </p>
<ol start="0">
<li>怎么判断重叠: 两区间的最小的右边界 大于或等于 两区间最大的左边界. 如<code>[1,5]</code>和<code>[2,8]</code></li>
<li>入参是切片的切片(intervals), 拿<code>intervals[0]</code>与它后面的所有区间对比, 从<code>intervals[1]</code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给<code>intervals[0]</code>, 并删除参与合并的那个旧区间</li>
<li><code>intervals[0]</code>完成后, 拿``intervals[1]<code>与它后边的所有区间对比, 从</code>intervals[2]<code>开始, 如果有与之重叠的区间, 就把合并后的新区间赋给</code>intervals[1]`, 并删除参与合并的那个就区间</li>
<li>拿<code>intervals[i]</code> 与它后边的所有区间对比, 从<code>intervals[i+1]</code> 开始, 如果有与之重叠的区间intervals[j]   , 就把合并后的新区间赋给 <code>intervals[i]</code> , 并删除参与合并的intervals[j]</li>
<li>如果第3步出现了有重叠的区间<code>intervals[j]</code>, 那么合并后<code>i</code>  的值变了, 就有可能由原来 在<code>i</code> 到<code>j</code> 之间没有重叠的区间 变成 有重叠的区间, 所以需要从头(<code>i+1</code>) 再遍历一次, 直到再也没有重叠的区间</li>
<li>重复, 一直到切片末尾</li>
</ol>
<p>code</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intervals); &#123;</span><br><span class="line">		merged := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(intervals); j++ &#123;</span><br><span class="line">			x, y := intervals[i], intervals[j]</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> min(x[<span class="number">1</span>], y[<span class="number">1</span>]) &gt;= max(x[<span class="number">0</span>], y[<span class="number">0</span>]) &#123;</span><br><span class="line">				merged = <span class="literal">true</span></span><br><span class="line">				<span class="comment">//重新赋值</span></span><br><span class="line">				intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] = min(x[<span class="number">0</span>], y[<span class="number">0</span>]), max(x[<span class="number">1</span>], y[<span class="number">1</span>])</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//删除j</span></span><br><span class="line">				intervals[j] = intervals[<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">				intervals = intervals[:<span class="built_in">len</span>(intervals) - <span class="number">1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> merged &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写好业务代码</title>
    <url>/4c5cb7f3/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#一个复杂业务的处理过程">一个复杂业务的处理过程</a><ul>
<li><a href="#业务背景">业务背景</a></li>
<li><a href="#过程分解">过程分解</a></li>
<li><a href="#过程分解后的两个问题">过程分解后的两个问题</a><ul>
<li><a href="#1-领域知识被割裂肢解">1、领域知识被割裂肢解</a></li>
<li><a href="#2-代码的业务表达能力缺失">2、代码的业务表达能力缺失</a></li>
</ul>
</li>
<li><a href="#过程分解对象模型">过程分解+对象模型</a></li>
</ul>
</li>
<li><a href="#写复杂业务的方法论">写复杂业务的方法论</a><ul>
<li><a href="#上下结合">上下结合</a></li>
<li><a href="#能力下沉">能力下沉</a><ul>
<li><a href="#套概念阶段">套概念阶段</a></li>
<li><a href="#融会贯通阶段">融会贯通阶段</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#业务技术要怎么做">业务技术要怎么做</a></li>
</ul>
<!-- tocstop -->

<p>基于阿里的零售通业务，总结出的方法论。</p>
<h2><span id="一个复杂业务的处理过程">一个复杂业务的处理过程</span></h2><h3><span id="业务背景">业务背景</span></h3><p>零售通是给线下小店供货的B2B模式，我们希望通过数字化重构传统供应链渠道，提升供应链效率，为新零售助力。阿里在中间是一个平台角色，提供的是Bsbc中的service的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105411.png" alt></p>
<p>在商品域，运营会操作一个“上架”动作，上架之后，商品就能在零售通上面对小店进行销售了。<strong>是零售通业务非常关键的业务操作之一，因此涉及很多的数据校验和关联操作</strong>。</p>
<p>针对上架，一个简化的业务流程如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105454.png" alt></p>
<h3><span id="过程分解">过程分解</span></h3><p>像这么复杂的业务，我想应该没有人会写在一个service方法中吧。一个类解决不了，那就分治吧。</p>
<p>说实话，能想到分而治之的工程师，已经做的不错了，至少比没有分治思维要好很多。我也见过复杂程度相当的业务，连分解都没有，就是一堆方法和类的堆砌。</p>
<p>不过，这里存在一个问题：即很多同学过度的依赖工具或是辅助手段来实现分解。比如在我们的商品域中，类似的分解手段至少有3套以上，有自制的<a href="流程引擎">流程引擎</a>，有依赖于数据库配置的流程处理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105631.png" alt></p>
<p>本质上来讲，这些辅助手段做的都是一个pipeline的处理流程，没有其它。因此，我建议此处最好保持KISS（Keep It Simple and Stupid），即<strong>最好是什么工具都不要用，次之是用一个极简的Pipeline模式，最差是使用像流程引擎这样的重方法</strong>。</p>
<p>除非你的应用有极强的流程可视化和编排的诉求，否则我非常不推荐使用流程引擎等工具。第一，它会引入额外的复杂度，特别是那些需要持久化状态的流程引擎；第二，它会割裂代码，导致阅读代码的不顺畅。<strong>大胆断言一下，全天下估计80%对流程引擎的使用都是得不偿失的</strong>。</p>
<p>回到商品上架的问题，这里问题核心是工具吗？是设计模式带来的代码灵活性吗？显然不是，<strong>问题的核心应该是如何分解问题和抽象问题</strong>，知道金<a href="金字塔原理">字塔原理</a>的应该知道，此处，我们可以使用结构化分解将问题解构成一个有层级的金字塔结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105756.png" alt></p>
<p>按照这种分解写的代码，就像一本书，目录和内容清晰明了。</p>
<p>以商品上架为例，程序的入口是一个上架命令（OnSaleCommand）, 它由三个阶段（Phase）组成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Command</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnSaleNormalItemCmdExe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OnSaleContextInitPhase onSaleContextInitPhase;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OnSaleDataCheckPhase onSaleDataCheckPhase;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OnSaleProcessPhase onSaleProcessPhase;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(OnSaleNormalItemCmd cmd)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">OnSaleContext</span> <span class="variable">onSaleContext</span> <span class="operator">=</span> init(cmd);</span><br><span class="line">        </span><br><span class="line">        checkData(onSaleContext);</span><br><span class="line"></span><br><span class="line">        process(onSaleContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response.buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnSaleContext <span class="title function_">init</span><span class="params">(OnSaleNormalItemCmd cmd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onSaleContextInitPhase.init(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkData</span><span class="params">(OnSaleContext onSaleContext)</span> &#123;</span><br><span class="line">        onSaleDataCheckPhase.check(onSaleContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OnSaleContext onSaleContext)</span> &#123;</span><br><span class="line">        onSaleProcessPhase.process(onSaleContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Phase又可以拆解成多个步骤（Step），以<code>OnSaleProcessPhase</code>为例，它是由一系列Step组成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Phase</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnSaleProcessPhase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PublishOfferStep publishOfferStep;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BackOfferBindStep backOfferBindStep;</span><br><span class="line">    <span class="comment">//省略其它step</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(OnSaleContext onSaleContext)</span>&#123;</span><br><span class="line">        <span class="type">SupplierItem</span> <span class="variable">supplierItem</span> <span class="operator">=</span> onSaleContext.getSupplierItem();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成OfferGroupNo</span></span><br><span class="line">        generateOfferGroupNo(supplierItem);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 发布商品</span></span><br><span class="line">        publishOffer(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前后端库存绑定 backoffer域</span></span><br><span class="line">        bindBackOfferStock(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步库存路由 backoffer域</span></span><br><span class="line">        syncStockRoute(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置虚拟商品拓展字段</span></span><br><span class="line">        setVirtualProductExtension(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发货保障打标 offer域</span></span><br><span class="line">        markSendProtection(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录变更内容ChangeDetail</span></span><br><span class="line">        recordChangeDetail(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步供货价到BackOffer</span></span><br><span class="line">        syncSupplyPriceToBackOffer(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是组合商品打标，写扩展信息</span></span><br><span class="line">        setCombineProductExtension(supplierItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去售罄标</span></span><br><span class="line">        removeSellOutTag(offerId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送领域事件</span></span><br><span class="line">        fireDomainEvent(supplierItem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭关联的待办事项</span></span><br><span class="line">        closeIssues(supplierItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吗，这就是商品上架这个复杂业务的业务流程。需要流程引擎吗？不需要，需要设计模式支撑吗？也不需要。对于这种业务流程的表达，简单朴素的组合方法模式（Composed Method）是再合适不过的了。</p>
<p>因此，在做过程分解的时候，我建议工程师不要把太多精力放在工具上，放在设计模式带来的灵活性上。而是应该多花时间在对问题分析，结构化分解，最后通过合理的抽象，形成合适的阶段（Phase）和步骤（Step）上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110024.png" alt></p>
<h3><span id="过程分解后的两个问题">过程分解后的两个问题</span></h3><h4><span id="1-领域知识被割裂肢解">1、领域知识被割裂肢解</span></h4><p>什么叫被肢解？因为我们到目前为止做的都是过程化拆解，导致没有一个聚合领域知识的地方。每个Use Case的代码只关心自己的处理流程，知识没有沉淀。</p>
<p>相同的业务逻辑会在多个Use Case中被重复实现，导致代码重复度高，即使有复用，最多也就是抽取一个util，代码对业务语义的表达能力很弱，从而影响代码的可读性和可理解性。</p>
<h4><span id="2-代码的业务表达能力缺失">2、代码的业务表达能力缺失</span></h4><p>试想下，在过程式的代码中，所做的事情无外乎就是取数据–做计算–存数据，在这种情况下，要如何通过代码显性化的表达我们的业务呢？ 说实话，很难做到，因为我们缺失了模型，以及模型之间的关系。脱离模型的业务表达，是缺少韵律和灵魂的。</p>
<p>举个例子，在上架过程中，有一个校验是检查库存的，其中对于组合品（CombineBackOffer）其库存的处理会和普通品不一样。原来的代码是这么写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isCombineProduct</span> <span class="operator">=</span> supplierItem.getSign().isCombProductQuote();</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplier.usc warehouse needn&#x27;t check</span></span><br><span class="line"><span class="keyword">if</span> (WarehouseTypeEnum.isAliWarehouse(supplierItem.getWarehouseType())) &#123;</span><br><span class="line"><span class="comment">// quote warehosue check</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtil.isEmpty(supplierItem.getWarehouseIdList()) &amp;&amp; !isCombineProduct) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.makeFault(ServiceExceptionCode.SYSTEM_ERROR, <span class="string">&quot;亲，不能发布Offer，请联系仓配运营人员，建立品仓关系！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inventory amount check</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">sellableAmount</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">if</span> (!isCombineProduct) &#123;</span><br><span class="line">    sellableAmount = normalBiz.acquireSellableAmount(supplierItem.getBackOfferId(), supplierItem.getWarehouseIdList());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//组套商品</span></span><br><span class="line">    <span class="type">OfferModel</span> <span class="variable">backOffer</span> <span class="operator">=</span> backOfferQueryService.getBackOffer(supplierItem.getBackOfferId());</span><br><span class="line">    <span class="keyword">if</span> (backOffer != <span class="literal">null</span>) &#123;</span><br><span class="line">        sellableAmount = backOffer.getOffer().getTradeModel().getTradeCondition().getAmountOnSale();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sellableAmount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.makeFault(ServiceExceptionCode.SYSTEM_ERROR, <span class="string">&quot;亲，实仓库存必须大于0才能发布，请确认已补货.\r[id:&quot;</span> + supplierItem.getId() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，如果我们在系统中引入领域模型之后，其代码会简化为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(backOffer.isCloudWarehouse())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (backOffer.isNonInWarehouse())&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;亲，不能发布Offer，请联系仓配运营人员，建立品仓关系！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (backOffer.getStockAmount() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;亲，实仓库存必须大于0才能发布，请确认已补货.\r[id:&quot;</span> + backOffer.getSupplierItem().getCspuCode() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有发现，使用模型的表达要清晰易懂很多，而且也不需要做关于组合品的判断了，因为我们在系统中引入了更加贴近现实的对象模型（CombineBackOffer继承BackOffer），通过对象的多态可以消除我们代码中的大部分的 if-else。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110230.png" alt></p>
<h3><span id="过程分解对象模型">过程分解+对象模型</span></h3><p>通过上面的案例，我们可以看到<strong>有过程分解要好于没有分解</strong>，<strong>过程分解+对象模型要好于仅仅是过程分解</strong>。对于商品上架这个case，如果采用过程分解+对象模型的方式，最终我们会得到一个如下的系统结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110335.png" alt></p>
<h2><span id="写复杂业务的方法论">写复杂业务的方法论</span></h2><p>通过上面案例的讲解，我想说，我已经交代了复杂业务代码要怎么写：<strong>即自上而下的结构化分解+自下而上的<a href="面向对象分析">面向对象分析</a></strong>。</p>
<p>接下来，让我们把上面的案例进行进一步的提炼，形成一个可落地的方法论，从而可以泛化到更多的复杂业务场景。</p>
<h3><span id="上下结合">上下结合</span></h3><p>所谓上下结合，是指我们要<strong>结合自上而下的过程分解和自下而上的对象建模</strong>，螺旋式的构建我们的应用系统。这是一个动态的过程，两个步骤可以交替进行、也可以同时进行。</p>
<p>这两个步骤是相辅相成的，<strong>上面的分析可以帮助我们更好的理清模型之间的关系，而下面的模型表达可以提升我们代码的复用度和业务语义表达能力</strong>。</p>
<p>其过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110449.png" alt></p>
<p>使用这种上下结合的方式，我们就有可能在面对任何复杂的业务场景，都能写出干净整洁、易维护的代码。</p>
<h3><span id="能力下沉">能力下沉</span></h3><p>一般来说实践DDD有两个过程：</p>
<ol>
<li><h4><span id="套概念阶段">套概念阶段</span></h4></li>
</ol>
<p>了解了一些DDD的概念，然后在代码中“使用”Aggregation Root，Bonded Context，Repository等等这些概念。更进一步，也会使用一定的分层策略。然而这种做法一般对<a href="https://www.zhihu.com/search?q=复杂度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a874296743}">复杂度</a>的治理并没有多大作用。</p>
<ol start="2">
<li><h4><span id="融会贯通阶段">融会贯通阶段</span></h4></li>
</ol>
<p>术语已经不再重要，理解DDD的本质是统一语言、边界划分和面向对象分析的方法。</p>
<p>大体上而言，我大概是在1.7的阶段，因为有一个问题一直在困扰我，就是哪些能力应该放在Domain层，是不是按照传统的做法，将所有的业务都收拢到Domain上，这样做合理吗？说实话，这个问题我一直没有想清楚。</p>
<p>因为在现实业务中，很多的功能都是用例特有的（Use case specific）的，如果“盲目”的使用Domain收拢业务并不见得能带来多大的益处。相反，这种收拢会导致Domain层的膨胀过厚，不够纯粹，反而会影响复用性和表达能力。</p>
<p>鉴于此，我最近的思考是我们应该采用<strong>能力下沉</strong>的策略。</p>
<p>所谓的能力下沉，是指我们不强求一次就能设计出Domain的能力，也不需要强制要求把所有的业务功能都放到Domain层，而是采用实用主义的态度，即只对那些需要在多个场景中需要被复用的能力进行抽象下沉，而不需要复用的，就暂时放在App层的Use Case里就好了。</p>
<p>注：Use Case是《架构整洁之道》里面的术语，简单理解就是响应一个Request的处理过程</p>
<p>通过实践，<strong>我发现这种循序渐进的能力下沉策略，应该是一种更符合实际、更敏捷的方法。因为我们承认模型不是一次性设计出来的，而是迭代演化出来的。</strong></p>
<p>下沉的过程如下图所示，假设两个use case中，我们发现uc1的step3和uc2的step1有类似的功能，我们就可以考虑让其下沉到Domain层，从而增加代码的复用性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110552.png" alt></p>
<p><strong>指导下沉有两个关键指标：代码的复用性和内聚性</strong>。</p>
<p>复用性是告诉我们When（什么时候该下沉了），即有重复代码的时候。内聚性是告诉我们How（要下沉到哪里），功能有没有内聚到恰当的实体上，有没有放到合适的层次上（因为Domain层的能力也是有两个层次的，一个是Domain Service这是相对比较粗的粒度，另一个是Domain的Model这个是最细粒度的复用）。</p>
<p>比如，在我们的商品域，经常需要判断一个商品是不是最小单位，是不是中包商品。像这种能力就非常有必要直接挂载在Model上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSPU</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String baseCode;</span><br><span class="line">    <span class="comment">//省略其它属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单品是否为最小单位。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMinimumUnit</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.equals(code, baseCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对中包的特殊处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMidPackage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.equals(code, midPackageCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前，因为老系统中没有领域模型，没有CSPU这个实体。你会发现像判断单品是否为最小单位的逻辑是以<code>StringUtils.equals(code, baseCode)</code>的形式散落在代码的各个角落。这种代码的可理解性是可想而知的，至少我在第一眼看到这个代码的时候，是完全不知道什么意思。</p>
<h2><span id="业务技术要怎么做">业务技术要怎么做</span></h2><p><strong>业务技术到底是在做业务，还是做技术？业务技术的技术性体现在哪里？</strong></p>
<p>通过上面的案例，我们可以看到业务所面临的复杂性并不亚于底层技术，要想写好业务代码也不是一件容易的事情。业务技术和底层技术人员唯一的区别是他们所面临的问题域不一样。</p>
<p>业务技术面对的问题域变化更多、面对的人更加庞杂。而底层技术面对的问题域更加稳定、但对技术的要求更加深。比如，如果你需要去开发Pandora，你就要对Classloader有更加深入的了解才行。</p>
<p>但是，不管是业务技术还是底层技术人员，有一些思维和能力都是共通的。比如，<strong>分解问题的能力，抽象思维，结构化思维</strong>等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110806.png" alt></p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】如何把WordPress网站迁移到新主机</title>
    <url>/ea5f4ef1/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#一个-wordpress-网站的组成部分">一个 WordPress 网站的组成部分</a></li>
<li><a href="#初始配置">初始配置</a></li>
<li><a href="#前期工作">前期工作</a><ul>
<li><a href="#安装-apache-和-mariadb">安装 Apache 和 MariaDB</a></li>
<li><a href="#新服务器防火墙配置">新服务器防火墙配置</a></li>
<li><a href="#httpd-配置">HTTPD 配置</a></li>
</ul>
</li>
<li><a href="#迁移过程">迁移过程</a></li>
<li><a href="#最终的修改">最终的修改</a></li>
<li><a href="#测试和清理">测试和清理</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>使用这个简单的方法来迁移一个网站以及管理防火墙配置。</p>
</blockquote>
<p>你有过把一个 WordPress 网站迁移到一台新主机上的需求吗？我曾经迁移过好多次，迁移过程相当简单。当然，的的市场时候我都不会用通用的推荐方法，这次也不例外 —— 我用更简单的方法，这才是我推荐的方法。</p>
<p>这个迁移方法没有破坏性，因此如果出于某些原因你需要还原到原来的服务器上，很容易可以实现。</p>
<h3><span id="一个-wordpress-网站的组成部分">一个 WordPress 网站的组成部分</span></h3><p>运行一个基于 <a href="#">WordPress</a> 的网站有三个重要组成部分：WordPress 本身，一个 web 服务器，如 <a href="#">Apache</a>（我正在用），以及 <a href="#">MariaDB</a>。MariaDB 是 MySQL 的一个分支，功能相似。</p>
<p>业界有大量的 Web 服务器，由于我使用了 Apache 很长时间，因此我推荐用 Apache。你可能需要把 Apache 的配置方法改成你用的 Web 服务器的方法。</p>
<h3><span id="初始配置">初始配置</span></h3><p>我使用一台 Linux 主机作为防火墙和网络路由。在我的网络中 Web 服务器是另一台主机。我的内部网络使用的是 C 类私有网络地址范围，按 [无类别域间路由][5]Classless Internet Domain Routing（CIDR）方式简单地记作 192.168.0.0/24。</p>
<p>对于防火墙，相比于更复杂的 <code>firewalld</code>，我更喜欢用非常简单的 <a href="#">IPTables</a>。这份防火墙配置中的一行会把 80 端口（HTTP）接收到的包发送给 Web 服务器。在 <code>/etc/sysconfig/iptables</code> 文件中，你可以在注释中看到，我添加了规则，把其他入站服务器连接转发到同一台服务器上合适的端口。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n22" mdtype="fences"> <span role="presentation"># Reroute ports for inbound connections to the appropriate web/email/etc server.</span><br> <span role="presentation"># HTTPD goes to 192.168.0.75</span><br> <span role="presentation">-A PREROUTING -d 45.20.209.41/255.255.255.248 -p tcp -m tcp --dport 80 \</span><br> <span role="presentation"><span cm-text cm-zwsp></span></span><br> <span role="presentation">  -j DNAT --to-destination 192.168.0.75:80</span></pre>

<p>我使用命名虚拟主机named virtual host来配置原来的 Apache Web 服务器，因为我在这个 HTTPD 实例上运行着多个网站。使用命名虚拟主机配置是个不错的方法，因为（像我一样）未来你可能会在运行其他的网站，这个方法可以使其变得容易。</p>
<p><code>/etc/httpd/conf/httpd.conf</code> 中需要迁移的虚拟主机的网站相关部分请参考下面代码。这个片段中不涉及到 IP 地址的修改，因此在新服务器上使用时不需要修改。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n25" mdtype="fences"> <span role="presentation">&lt;VirtualHost *:80&gt;</span><br> <span role="presentation">   ServerName www.website1.org</span><br> <span role="presentation">   ServerAlias server.org</span><br> <span role="presentation"><span cm-text cm-zwsp></span></span><br> <span role="presentation">DocumentRoot &#34;/var/website1/html&#34;</span><br> <span role="presentation">   ErrorLog &#34;logs/error_log&#34;</span><br> <span role="presentation">   ServerAdmin me@website1.org</span><br> <span role="presentation"> </span><br> <span role="presentation">&lt;Directory &#34;/var/website1/html&#34;&gt;</span><br> <span role="presentation">      Options Indexes FollowSymLinks</span><br> <span role="presentation"> </span><br> <span role="presentation">AllowOverride None</span><br> <span role="presentation">      Require all granted</span><br> <span role="presentation"> </span><br> <span role="presentation">&lt;/Directory&gt;</span><br> <span role="presentation">&lt;/VirtualHost&gt;</span></pre>

<p>在迁移之前，你需要在 <code>httpd.conf</code> 的最顶端附近找到 <code>Listen</code> 声明并修改成类似下面这样。这个地址是服务器的真实私有 IP 地址，不是公开 IP 地址。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n27" mdtype="fences"> <span role="presentation">Listen 192.168.0.75:80</span></pre>

<p>你需要修改新主机上 <code>Listen</code> 的 IP 地址。</p>
<h3><span id="前期工作">前期工作</span></h3><p>准备工作分为以下三步：</p>
<ul>
<li>安装服务</li>
<li>配置防火墙</li>
<li>配置 web 服务器</li>
</ul>
<h4><span id="安装-apache-和-mariadb">安装 Apache 和 MariaDB</span></h4><p>如果你的新服务器上还没有 Apache 和 MariaDB，那么就安装它们。WordPress 的安装不是必要的。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n40" mdtype="fences"> <span role="presentation">dnf -y install httpd mariadb</span></pre>

<h4><span id="新服务器防火墙配置">新服务器防火墙配置</span></h4><p>确认下新服务器上的防火墙允许访问 80 端口。你<em>每台</em>电脑上都有一个防火墙，对吗？大部分现代发行版使用的初始化配置包含的防火墙会阻止所有进来的网络流量，以此来提高安全等级。</p>
<p>下面片段的第一行内容可能已经在你的 IPTables 或其他基于防火墙的网络过滤器中存在了。它标识已经被识别为来自可接受来源的入站包，并绕过后面的其它 INPUT 过滤规则，这样可以节省时间和 CPU 周期。片段中最后一行标识并放行 80 端口新进来的请求到 HTTPD 的连接。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n44" mdtype="fences"> <span role="presentation">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br> <span role="presentation">&lt;删节&gt;</span><br> <span role="presentation"># HTTP</span><br> <span role="presentation">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</span></pre>

<p>下面的示例 <code>/etc/sysconfig/iptables</code> 文件是 IPTables 最少规则的例子，可以允许 SSH（端口 22）和 HTTPD（端口 80）连接。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n46" mdtype="fences"> <span role="presentation">*filter</span><br> <span role="presentation">:INPUT ACCEPT [0:0]</span><br> <span role="presentation">:FORWARD ACCEPT [0:0]</span><br> <span role="presentation">:OUTPUT ACCEPT [0:0]</span><br> <span role="presentation">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br> <span role="presentation">-A INPUT -p icmp -j ACCEPT</span><br> <span role="presentation">-A INPUT -i lo -j ACCEPT</span><br> <span role="presentation"># SSHD</span><br> <span role="presentation">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br> <span role="presentation"># HTTP</span><br> <span role="presentation">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</span><br> <span role="presentation"><span cm-text cm-zwsp></span></span><br> <span role="presentation"># Final disposition for unmatched packets</span><br> <span role="presentation">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br> <span role="presentation">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br> <span role="presentation">COMMIT</span></pre>

<p>在新服务器主机上我需要做的就是在 <code>/etc/sysconfig/iptables</code> 文件的防火墙规则里添加上面片段的最后一行，然后重新加载修改后的规则集。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n48" mdtype="fences"> <span role="presentation">iptables-restore /etc/sysconfig/iptables</span></pre>

<p>大部分基于红帽的发行版本，如 Fedora，使用的是 <code>firewalld</code>。我发现对于它的适用场景（如家用、小到中型企业）而言，它过于复杂，因此我不用它。我建议你参照 <a href="#">firewalld 网页</a> 来向 <code>firewalld</code> 添加入站端口 80。</p>
<p>你的防火墙及其配置可能跟这个有些差异，但最终的目的是允许新 Web 服务器 80 端口接收 HTTPD 连接。</p>
<h4><span id="httpd-配置">HTTPD 配置</span></h4><p>在 <code>/etc/httpd/conf/httpd.conf</code> 文件中配置 HTTPD。像下面一样在 <code>Listen</code> 片段中设置 IP 地址。我的新 Web 服务器 IP 地址是 <code>192.168.0.125</code>。</p>
<pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang cid="n53" mdtype="fences"> <span role="presentation">Listen 192.168.0.125:80</span></pre>

<p>复制（对应要迁移的网站的） <code>VirtualHost</code> 片段，粘贴到新服务器上 <code>httpd.conf</code> 文件的末尾。</p>
<h3><span id="迁移过程">迁移过程</span></h3><p>只有两组数据需要迁移到新服务器 —— 数据库本身和网站目录结构。把两个目录打包成 <code>tar</code> 文档。</p>
<pre class="md-fences mock-cm md-end-block md-fences-with-lineno" spellcheck="false" lang cid="n57" mdtype="fences">cd /var ; tar -cvf /tmp/website.tar website1/<br>cd /var/lib ; tar -cvf /tmp/database.tar mysql/</pre>

<p>把两个 tar 文件复制到新服务器。我通常会把这类文件放到 <code>/tmp</code> 下，这个目录就是用来做这种事的。在新服务器上运行下面的命令，把 tar 文档解压到正确的目录。</p>
<pre class="md-fences mock-cm md-end-block md-fences-with-lineno" spellcheck="false" lang cid="n59" mdtype="fences">cd /var ; tar -xvf /tmp/website.tar<br>cd /var/lib ; tar -xvf /tmp/database.tar</pre>

<p>WordPress 的所有文件都在 <code>/var/website1</code> 下，因此不需要在新服务器上安装它。新服务器上不需要执行 WordPress 安装过程。</p>
<p>这个目录就是需要迁移到新服务器上的全部内容。</p>
<p>最后一步是启动（或重启）<code>mysqld</code> 和 <code>httpd</code> 服务守护进程。WrodPress 不是一个服务，因此不使用守护进程的方式来启动。</p>
<pre class="md-fences mock-cm md-end-block md-fences-with-lineno" spellcheck="false" lang cid="n63" mdtype="fences">systemctl start mysqld ; systemctl start httpd</pre>

<p>启动之后，你应该检查下这些服务的状态。</p>
<pre class="md-fences mock-cm md-end-block md-fences-with-lineno" spellcheck="false" lang cid="n65" mdtype="fences">systemctl status mysqld<br>● mariadb.service - MariaDB 10.5 database server<br>    Loaded: loaded (/usr/lib/systemd/system/mariadb.service; enabled; vendor preset: disabled)<br>    Active: active (running) since Sat 2021-08-21 14:03:44 EDT; 4 days ago<br>        Docs: man:mariadbd(8)<br><br>https://mariadb.com/kb/en/library/systemd/<br>   Process: 251783 ExecStartPre=/usr/libexec/mariadb-check-socket (code=exited, status=0/SUCCESS)<br>   Process: 251805 ExecStartPre=/usr/libexec/mariadb-prepare-db-dir mariadb.service (code=exited, status=0/SUCCESS)<br>   Process: 251856 ExecStartPost=/usr/libexec/mariadb-check-upgrade (code=exited, status=0/SUCCESS)<br> Main PID: 251841 (mariadbd)<br>      Status: &#34;Taking your SQL requests now...&#34;<br>      Tasks: 15 (limit: 19003)<br>    Memory: 131.8M<br>        CPU: 1min 31.793s<br>    CGroup: /system.slice/mariadb.service<br>└─251841 /usr/libexec/mariadbd --basedir=/usr<br><br>Aug 21 14:03:43 simba.stmarks-ral.org systemd[1]: Starting MariaDB 10.5 database server...<br>Aug 21 14:03:43 simba.stmarks-ral.org mariadb-prepare-db-dir[251805]: Database MariaDB is probably initialized in /var/lib/mysql already, n&gt;<br>Aug 21 14:03:43 simba.stmarks-ral.org mariadb-prepare-db-dir[251805]: If this is not the case, make sure the /var/lib/mysql is empty before&gt;<br>Aug 21 14:03:44 simba.stmarks-ral.org mariadbd[251841]: 2021-08-21 14:03:44 0 [Note] /usr/libexec/mariadbd (mysqld 10.5.11-MariaDB) startin&gt;<br>Aug 21 14:03:44 simba.stmarks-ral.org systemd[1]: Started MariaDB 10.5 database server.<br><br>systemctl status httpd<br>● httpd.service - The Apache HTTP Server<br>   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)<br>   Drop-In: /usr/lib/systemd/system/httpd.service.d<br>└─php-fpm.conf<br>      Active: active (running) since Sat 2021-08-21 14:08:39 EDT; 4 days ago<br>        Docs: man:httpd.service(8)<br>   Main PID: 252458 (httpd)<br>      Status: &#34;Total requests: 10340; Idle/Busy workers 100/0;Requests/sec: 0.0294; Bytes served/sec: 616 B/sec&#34;<br>        Tasks: 278 (limit: 19003)<br>      Memory: 44.7M<br>        CPU: 2min 31.603s<br>   CGroup: /system.slice/httpd.service<br>├─252458 /usr/sbin/httpd -DFOREGROUND<br>├─252459 /usr/sbin/httpd -DFOREGROUND<br>├─252460 /usr/sbin/httpd -DFOREGROUND<br>├─252461 /usr/sbin/httpd -DFOREGROUND<br>├─252462 /usr/sbin/httpd -DFOREGROUND<br>└─252676 /usr/sbin/httpd -DFOREGROUND<br><br>Aug 21 14:08:39 simba.stmarks-ral.org systemd[1]: Starting The Apache HTTP Server...<br>Aug 21 14:08:39 simba.stmarks-ral.org httpd[252458]: AH00112: Warning: DocumentRoot [/var/teststmarks-ral/html] does not exist<br>Aug 21 14:08:39 simba.stmarks-ral.org httpd[252458]: Server configured, listening on: port 80<br>Aug 21 14:08:39 simba.stmarks-ral.org systemd[1]: Started The Apache HTTP Server.</pre>

<h3><span id="最终的修改">最终的修改</span></h3><p>现在所需的服务都已经运行了，你可以把 <code>/etc/sysconfig/iptables</code> 文件中 HTTDP 的防火墙规则改成下面的样子：</p>
<pre class="md-fences mock-cm md-end-block md-fences-with-lineno" spellcheck="false" lang cid="n68" mdtype="fences">-A PREROUTING -d 45.20.209.41/255.255.255.248 -p tcp -m tcp --dport 80 \<br>  -j DNAT --to-destination 192.168.0.125:80</pre>

<p>然后重新加载设置的 IPTables 规则。</p>
<pre class="md-fences mock-cm md-end-block md-fences-with-lineno" spellcheck="false" lang cid="n70" mdtype="fences">iptables-restore /etc/sysconfig/iptables</pre>

<p>由于防火墙规则是在防火墙主机上，因此不需要把外部 DNS 入口改成指向新服务器。如果你使用的是内部 DNS 服务器，那么你需要把 IP 地址改成内部 DNS 数据库里的 A 记录。如果你没有用内部 DNS 服务器，那么请确保主机 <code>/etc/hosts</code> 文件里新服务器地址设置得没有问题。</p>
<h3><span id="测试和清理">测试和清理</span></h3><p>请确保对新配置进行测试。首先，停止旧服务器上的 <code>mysqld</code> 和 <code>httpd</code> 服务。然后通过浏览器访问网站。如果一切符合预期，那么你可以关掉旧服务器上的 <code>mysqld</code> 和 <code>httpd</code>。如果有失败，你可以把 IPTables 的路由规则改回去到旧服务器上，直到问题解决。</p>
<p>之后我把 MySQL 和 HTTPD 从旧服务器上删除了，这样来确保它们不会意外地被启动。</p>
<h3><span id="总结">总结</span></h3><p>就是这么简单。不需要执行数据库导出和导入的过程，因为 <code>mysql</code> 目录下所有需要的东西都已经复制过去了。需要执行导出/导入过程的场景是：有网站自己的数据库之外的数据库；MariaDB 实例上还有其他网站，而你不想把这些网站复制到新服务器上。</p>
<p>迁移旧服务器上的其他网站也很容易。其他网站依赖的所有数据库都已经随着 MariaDB 的迁移被转移到了新服务器上。你只需要把 <code>/var/website</code> 目录迁移到新服务器，添加合适的虚拟主机片段，然后重启 HTTPD。</p>
<p>我遵循这个过程把很多个网站从一个服务器迁移到另一个服务器，每次都没有问题。</p>
<hr>
<p>via: <a href="https://opensource.com/article/21/9/migrate-wordpress">https://opensource.com/article/21/9/migrate-wordpress</a></p>
<p>作者：<a href="#">David Both</a><br>选题：<a href="#">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
<p>[a]    <a href="https://opensource.com/users/dboth">https://opensource.com/users/dboth</a></p>
<p>[b]    <a href="https://github.com/lujun9972">https://github.com/lujun9972</a></p>
<p>[1]    <a href="https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/browser_blue_text_editor_web.png?itok=lcf-m6N7">https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/browser_blue_text_editor_web.png?itok=lcf-m6N7</a> Text editor on a browser, in blue</p>
<p>[2]    <a href="https://wordpress.org/">https://wordpress.org/</a></p>
<p>[3]    <a href="https://opensource.com/article/18/2/how-configure-apache-web-server">https://opensource.com/article/18/2/how-configure-apache-web-server</a></p>
<p>[4]    <a href="https://mariadb.org/">https://mariadb.org/</a></p>
<p>[5]    <a href="https://opensource.com/article/16/12/cidr-network-notation-configuration-linux">https://opensource.com/article/16/12/cidr-network-notation-configuration-linux</a></p>
<p>[6]    <a href="https://en.wikipedia.org/wiki/Iptables">https://en.wikipedia.org/wiki/Iptables</a></p>
<p>[7]    <a href="http://www.website1.org">http://www.website1.org</a></p>
<p>[8]    mailto:<a href="mailto:me@website1.org">me@website1.org</a></p>
<p>[9]    <a href="https://firewalld.org/documentation/howto/open-a-port-or-service.html">https://firewalld.org/documentation/howto/open-a-port-or-service.html</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用GitHub搜索</title>
    <url>/a813d59a/</url>
    <content><![CDATA[<p><strong>1. 明确搜索仓库标题、仓库描述、README</strong></p>
<p><code>in:name 关键词</code></p>
<p>如果想查找描述的内容，可以使用这样的方式：</p>
<p><code>in:descripton 关键词</code></p>
<p>这里就是搜索上面项目描述的内容。</p>
<p>一般项目，都会有个README文件，如果要查该文件包含特定关键词的话</p>
<p><code>in:readme 关键词</code></p>
<p><strong>2. 明确搜索 star、fork 数大于多少的</strong></p>
<p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。</p>
<p><code>stars:&gt; 数字 关键字</code></p>
<p>比如要找 star 数大于 3000 的Spring Cloud 仓库，就可以这样</p>
<p><code>stars:&gt;3000 spring cloud</code></p>
<p>如果不加 &gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。</p>
<p>如果要找在指定数字区间的话，使用</p>
<p><code>stars: 10..20 关键词</code></p>
<p>fork 数同理，将上面的 stars 换成 <strong>fork</strong>，其它语法相同</p>
<p><strong>3. 明确搜索仓库大小的</strong></p>
<p>比如只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 <strong>size</strong> 。</p>
<p>使用方式：</p>
<p><code>size:&gt;=5000 关键词</code></p>
<p>这里注意下，这个数字代表K, 5000代表着5M。</p>
<p><strong>4. 明确仓库是否还在更新维护</strong></p>
<p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。</p>
<p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定<strong>更新时间</strong>在哪个时间前或后的</p>
<p>通过这样一条搜索 <code>pushed:&gt;2019-01-03 spring cloud</code></p>
<p>就找到了1月3号之后，还在更新的项目</p>
<p>想找指定时间之前或之后创建的仓库也是可以的，把 <strong>pushed</strong> 改成 <strong>created</strong> 就行。</p>
<p><strong>5. 明确搜索仓库的 LICENSE</strong></p>
<p>经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的<strong>LICENSE</strong>。开源不等于一切免费，不同的许可证要求也大不相同。 2018年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。</p>
<p>例如要找协议是最为宽松的 Apache License 2 的代码，可以这样</p>
<p><code>license:apache-2.0 spring cloud</code></p>
<p>其它协议就把 apache-2.0 替换一下即可，比如换成 <strong>mit</strong> 之类的。</p>
<p><strong>6. 明确搜索仓库的语言</strong></p>
<p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：</p>
<p><code>language:java 关键词</code></p>
<p><strong>7.明确搜索某个人或组织的仓库</strong></p>
<p><code>user:joshlong</code></p>
<p>组合使用一下，把 Java 项目过滤出来，多个查询之间「空格」分隔即可。</p>
<p><code>user:joshlong language:java</code></p>
<p>找某个组织的代码话，可以这样：</p>
<p><code>org:spring-cloud</code></p>
<p>就可以列出具体org 的仓库。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>家庭用电插座</title>
    <url>/0565b4f5/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#10a和16a插座的区别">10a和16a插座的区别</a><ul>
<li><a href="#1-外观区别">1、外观区别</a></li>
<li><a href="#2-使用区别">2、使用区别</a></li>
<li><a href="#3-插座金属">3、插座金属</a></li>
<li><a href="#4-承受范围">4、承受范围</a></li>
</ul>
</li>
<li><a href="#哪些电器用16a插座">哪些电器用16a插座</a></li>
</ul>
<!-- tocstop -->

<h2><span id="10a和16a插座的区别">10a和16a插座的区别</span></h2><h3><span id="1-外观区别">1、外观区别</span></h3><p>主要是插孔间距的尺寸区别。16a插座三插孔的孔距比10a插座更大。所以不同标准的插孔和插头并不能适用。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202407112150581.png" alt></p>
<p>10a插座为五眼插：1个三眼、1个二眼，而16a插座是一个三眼插，比10a三眼插宽广些。</p>
<h3><span id="2-使用区别">2、使用区别</span></h3><p>16a插头和10a插头不通用，10a插头插不到16a插座里去，当然反过来也是不行的。</p>
<h3><span id="3-插座金属">3、插座金属</span></h3><p>16a插座承载电流大于10a插座，用到的铜也比较多，而10a插座用的材料也有所不同。</p>
<p>16a插座需要布置4平方毫米以上规格的铜线，而10a插座最好布置2.5平方毫米铜线。</p>
<h3><span id="4-承受范围">4、承受范围</span></h3><p>16a插座可以承受3000瓦以内电器功率，而10a插座功率控制在2200瓦以内，不然容易发生意外。</p>
<h2><span id="哪些电器用16a插座">哪些电器用16a插座</span></h2><p>家里常用的大功率电器主要是空调、电磁炉、热水器</p>
<p>16a插座是承受范围比较大的插座，家居中一般主要在空调电器上使用，所以我们经常可以见到空调的隔壁安装的是一个不一样的插座，这是对用电安全的需求</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>用电</tag>
        <tag>插座</tag>
      </tags>
  </entry>
  <entry>
    <title>开放共享协议</title>
    <url>/c12bcad7/</url>
    <content><![CDATA[<ol>
<li>Creative Commons Attribution 4.0 International License (CC BY 4.0)【署名】</li>
</ol>
<p>注：用户可以复制、发行、展览、表演、放映、广播或通过信息网络传播此作品，但必须按照提交者指定的方式对作品进行署名。</p>
<p>​         </p>
<ol start="2">
<li>Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA4.0)【署名-相同方式共享】</li>
</ol>
<p>注：用户可以复制、发行、展览、表演、放映、广播或通过信息网络传播此作品，但必须按照提交者指定的方式对作品进行署名，若改变、转变或变更本作品，必须遵守与本作品相同的授权条款才能传播由本作品产生的演绎作品。</p>
<p>​         </p>
<ol start="3">
<li>Creative Commons Attribution-Noncommercial 4.0 International License (CC BY-NC 4.0)【署名-非商业使用】</li>
</ol>
<p>注：用户可以复制、发行、展览、表演、放映、广播或通过信息网络传播此作品，但必须按照提交者指定的方式对作品进行署名，并且不得为商业目的使用本作品。</p>
<p>​         </p>
<ol start="4">
<li>Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0) 【署名-非商业使用-相同方式共享】</li>
</ol>
<p>注：用户可以复制、发行、展览、表演、放映、广播或通过信息网络传播此作品，但必须按照提交者指定的方式对作品进行署名，并且不得为商业目的而使用本作品。若改变、转变或变更本作品，必须遵守与本作品相同的授权条款才能传播由本作品产生的演绎作品。</p>
<p>​         </p>
<ol start="5">
<li>Creative Commons Attribution-NoDerivatives 4.0 International License(CC BY-ND 4.0)【署名-禁止演绎】</li>
</ol>
<p>注：用户可以复制、发行、展览、表演、放映、广播或通过信息网络传播此作品，但必须按照提交者指定的方式对作品进行署名。若用户再混合、转换、或者基于该作品进行创作，则不可以传播由本作品产生的演绎作品。</p>
<p>​         </p>
<ol start="6">
<li>Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License(CC BY-NC-ND 4.0)【署名-非商业使用-禁止演绎】</li>
</ol>
<p>注：用户可以复制、发行、展览、表演、放映、广播或通过信息网络传播此作品，但必须按照提交者指定的方式对作品进行署名，并且不得为商业目的使用本作品。若用户再混合、转换、或者基于该作品进行创作，则不可以传播由本作品产生的演绎作品。</p>
<p>​         </p>
<ol start="7">
<li>Creative Commons Public Domain Dedication (CC0 1.0)</li>
</ol>
<p>注：社会公众可以以任何方式、出于任何目的免费使用该作品)。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】微服务中的熔断器和重试</title>
    <url>/c9399f4/</url>
    <content><![CDATA[<p>今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。</p>
<h2><span id="熔断器">熔断器</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204010211.png" alt></p>
<p>想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。</p>
<p>后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204010301.png" alt></p>
<p>熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011033.png" alt></p>
<p>通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 <a href="https://en.wikipedia.org/wiki/Happy_path">wikipedia</a>）可能不会遇到这种网络模式。</p>
<h2><span id="状态">状态</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011142.png" alt></p>
<p>熔断器有三个主要的状态：</p>
<ul>
<li>Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 <strong>Max Concurrency</strong>（最大并发数）和 <strong>Timeout</strong>（超时）。</li>
<li>Open：所有的请求都会返回 <strong>Circuit Open</strong> 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。</li>
<li>Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。</li>
</ul>
<h2><span id="熔断器原理">熔断器原理</span></h2><p>控制熔断的设置共有 5 个主要参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommandConfig is used to tune circuit settings at runtime</span></span><br><span class="line"><span class="keyword">type</span> CommandConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Timeout                <span class="type">int</span> <span class="string">`json:&quot;timeout&quot;`</span></span><br><span class="line">	MaxConcurrentRequests  <span class="type">int</span> <span class="string">`json:&quot;max_concurrent_requests&quot;`</span></span><br><span class="line">	RequestVolumeThreshold <span class="type">int</span> <span class="string">`json:&quot;request_volume_threshold&quot;`</span></span><br><span class="line">	SleepWindow            <span class="type">int</span> <span class="string">`json:&quot;sleep_window&quot;`</span></span><br><span class="line">	ErrorPercentThreshold  <span class="type">int</span> <span class="string">`json:&quot;error_percent_threshold&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go">查看源码</a></p>
<p>可以通过根据两个服务的 SLA（‎ Service Level Agreement，<a href="https://zh.wikipedia.org/zh-hans/服务级别协议">服务级别协议</a>）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。</p>
<p>一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。</p>
<h2><span id="生产上的熔断器">生产上的熔断器</span></h2><p>熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。</p>
<h2><span id="demo">Demo</span></h2><p>这段实例代码用的是 <a href="http://github.com/afex/hystrix-go/hystrix">hystrix-go</a> 库，hystrix Netflix 库在 Golang 的实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandName = <span class="string">&quot;producer_api&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	hystrix.ConfigureCommand(commandName, hystrix.CommandConfig&#123;</span><br><span class="line">		Timeout:                <span class="number">500</span>,</span><br><span class="line">		MaxConcurrentRequests:  <span class="number">100</span>,</span><br><span class="line">		ErrorPercentThreshold:  <span class="number">50</span>,</span><br><span class="line">		RequestVolumeThreshold: <span class="number">3</span>,</span><br><span class="line">		SleepWindow:            <span class="number">1000</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, logger(handle))</span><br><span class="line">	log.Println(<span class="string">&quot;listening on :8080&quot;</span>)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	output := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">	errors := hystrix.Go(commandName, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// talk to other services</span></span><br><span class="line">		err := callChargeProducerAPI()</span><br><span class="line">		<span class="comment">// err := callWithRetryV1()</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			output &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> out := &lt;-output:</span><br><span class="line">		<span class="comment">// success</span></span><br><span class="line">		log.Printf(<span class="string">&quot;success %v&quot;</span>, out)</span><br><span class="line">	<span class="keyword">case</span> err := &lt;-errors:</span><br><span class="line">		<span class="comment">// failure</span></span><br><span class="line">		log.Printf(<span class="string">&quot;failed %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger is Handler wrapper function for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(fn http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		log.Println(r.URL.Path, r.Method)</span><br><span class="line">		fn(w, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callChargeProducerAPI</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(os.Getenv(<span class="string">&quot;SERVER_ERROR&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> os.Getenv(<span class="string">&quot;SERVER_ERROR&quot;</span>) == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;503 error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo 中分别测试了请求调用链 closed 和 open 两种情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* Experiment 1: success path */</span><br><span class="line">// server</span><br><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 10); <span class="keyword">do</span> curl -x <span class="string">&#x27;&#x27;</span> localhost:8080 ;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">/* Experiment 2: circuit open */</span><br><span class="line">// server</span><br><span class="line">SERVER_ERROR=1 Go run main.go</span><br><span class="line"></span><br><span class="line">// client</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 10); <span class="keyword">do</span> curl -x <span class="string">&#x27;&#x27;</span> localhost:8080 ;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><a href="https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh">查看源码</a></p>
<h2><span id="重试问题">重试问题</span></h2><p>在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。</p>
<p>一段简单的重试代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callWithRetryV1</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="number">3</span>; index++ &#123;</span><br><span class="line">		<span class="comment">// call producer API</span></span><br><span class="line">		err := callChargeProducerAPI()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adding backoff</span></span><br><span class="line">	<span class="comment">// adding jitter</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go">查看源码</a></p>
<h2><span id="重试模式">重试模式</span></h2><p>为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。</p>
<p>一起来看下列算法：</p>
<ul>
<li>Exponential: bash * 2<sup>attemp</sup></li>
<li>Full Jitter: sleep = rand(0, base * 2<sup>attempt</sup>)</li>
<li>Equal Jitter: temp = base * 2<sup>attemp</sup>; sleep = temp/2+rand(0, temp/2)</li>
<li>De-corredlated Jitter: sleep = rand(base, sleep*3)</li>
</ul>
<p>【译注】关于这几个算法，可以参考<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/">这篇文章</a> 。<strong>Full Jitter</strong>、 <strong>Equal Jitter</strong>、 <strong>De-corredlated</strong> 等都是原作者自己定义的名词。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204111132.png" alt></p>
<p>客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在<a href="https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/">这篇文章</a>中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。</p>
<h2><span id="两者结合">两者结合</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011245.png" alt="Example configuration of both tools"></p>
<p>熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。</p>
<h2><span id="参考文章">参考文章</span></h2><ol>
<li><a href="https://github.com/afex/hystrix-go/">https://github.com/afex/hystrix-go/</a></li>
<li><a href="https://github.com/eapache/go-resiliency">https://github.com/eapache/go-resiliency</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki">https://github.com/Netflix/Hystrix/wiki</a></li>
<li><a href="https://www.awsarchitectureblog.com/2015/03/backoff.html">https://www.awsarchitectureblog.com/2015/03/backoff.html</a></li>
<li><a href="https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience">https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience</a></li>
</ol>
<hr>
<p>via: <a href="https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6">https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6</a></p>
<p>作者：<a href="https://medium.com/@trongdan_tran">Dan Tran</a> 译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a> 校对：<a href="https://github.com/polaris1119">polaris1119</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/articles/25295">Go语言中文网</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】构建高效的 DevOps 文化的 6 个技巧</title>
    <url>/12428ad2/</url>
    <content><![CDATA[<blockquote>
<p>无论你是刚刚开始在你的组织中使用 DevOps，还是仅仅想改善你现有的文化，请考虑这些技巧以及它们与你组织的未来的关系。</p>
</blockquote>
<p>你为什么要构建 <a href="https://opensource.com/resources/devops">DevOps</a> 文化？开发团队和运维团队的精简协作有很多好处。效率是首要目标：提高新软件部署的速度，减少等待的时间。培养同事之间的信任可以提升员工的满意度，激发新的创新，并对盈利能力产生积极的影响。</p>
<p><a href="https://opensource.com/article/22/2/devops-documentation-maturity">DevOps</a> 是一个很广泛的思想，大家的理解也见仁见智。每个公司对于如何实行 DevOps 也各不相同。这种意见的多样性实际上是一件好事 —— 这么多的观点对于建立更强大的团队是很有用的。本指南将探讨在 DevOps 文化中鼓励同事之间更好地合作的最高技巧。</p>
<p>下面每个部分从不同的视角介绍 DevOps 文化，并探讨了将它引入员工队伍的方法。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230126220527.png" alt="img"></p>
<h3><span id="流程的持续发展">流程的持续发展</span></h3><p>DevOps 文化的这一核心原则使它与许多其他类型的工作场所的风气区别开来。DevOps 哲学说，犯错是有积极意义的，因为这表明你在尝试新的想法。</p>
<p>DevOps 文化的核心是不停地创造。实际上，这意味着当测试结果显示事情由于你的改动而变坏时，不要懊恼。我们要认识到，进化的过程不是线性的，通往成功的道路也从来不是一条直线。</p>
<p>DevOps 专家 <a href="https://enterprisersproject.com/user/gene-kim">Gene Kim</a> 主张勇于承担风险和进行实验。鼓励你的团队尝试不寻常的任务，以得到新的领悟。</p>
<p>你的组织应该以利润为导向吗？你能允许你的团队尝试一些新东西（非指个人兴趣项目）吗？持续的流程发展意味着对升级目前的方法持开放态度。优秀的销售领导懂得，结果比出勤率更重要，因此，关注团队的工作方式而不是工作量的多少始终是关键。</p>
<h3><span id="随时提供反馈并积极寻求反馈">随时提供反馈并积极寻求反馈</span></h3><p>成员之间增加信任是蓬勃发展的 DevOps 文化的另一个关键特征。无论你的员工是在学习如何建立联盟网络联系，还是试图设计他们的下一个 <a href="https://opensource.com/article/22/7/awesome-ux-cli-application">用户体验</a> 调查，每个人都应该对他们工作的反馈持开放态度。但是，除非你的团队成员尊重彼此的意见，并相信反馈是本着善意的精神提出的，否则这永远不会发生。</p>
<p>这种文化听起来可能是很难培养的；事实上，一些公司会比其他公司更努力地实现这一点。诚然，给予和接受反馈的成功很大程度上取决于员工的个性。在招聘过程中，也可以对此进行筛选。</p>
<p>在你期望员工随时向同事提供反馈并主动寻求反馈之前，你应该以身作则。高管应该以身作则，公开要求公司成员对其战略决策提出探究性问题，并提供相应的反馈。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230126220801.png" alt="DevOps is the intersection of development, quality assurance, and operations"></p>
<h3><span id="不断改进">不断改进</span></h3><p>在同事之间增加对智力信任的基础上，你的团队应该寻找方法来改善其工作。DevOps 的性质意味着软件开发团队将比传统方法更迅速地进行部署。</p>
<p>这种开放的改进文化可以对开发和运维以外的部门产生积极的影响。你也可以自己去探索企业还有哪些领域会受到积极的影响。</p>
<p>留意培训和提高技能的机会。即使一个培训课程没有广告上说的那么突出，但有机会与行业专家建立联系，并与未来建立联系，这可以提高你的组织内的思想多样性。</p>
<h3><span id="为以后的开发保存当前的想法">为以后的开发保存当前的想法</span></h3><p>频繁使用的 <a href="https://opensource.com/article/22/11/git-concepts">Git</a> 账户应该是你的 DevOps 工具链的一部分。你可以用 Git 作为软件开发和其他相关项目中产生的脚本的共同仓库。Git 作为 “版本控制” 工具而被熟知，Git 允许程序员保存他们工作的迭代、复用或改进其他人的工作。</p>
<p>你的目标是能够保留好的想法以供将来使用。某个方法由于某种原因没有成功。然而，那套想法在当时是错误的，并不意味着它在未来永远无法成为有用的东西。</p>
<p>由于 DevOps 的整个重点在于生产环境中的软件的端到端所有权，因此节省开发的迭代真正支持这一原则。你希望看到对手头的软件测试项目的持续关注和投入。</p>
<p>一个简单的方法是要求开发者在开发者合同和最终项目报告中包含对未来工作的想法。确保技术服务经理知道他们应该要求提供在建设过程中出现的旁门左道的想法的例子。意识到这些小创新的人越多，在需要的时候就越有可能有人记住一个。</p>
<h3><span id="坐在一起物理上或逻辑上">坐在一起（物理上或逻辑上）</span></h3><p>目标是对彼此的工作角色以及它们之间的相互关系有一个共同的理解。你可以通过几个简单的方法实现这一目标，用一句话概括：坐在一起。邀请其他团队参加你们的会议，完整地分享用户反馈报告。一起吃午饭，一起计划虚拟的快乐时光，一般来说，要确保你的同事都在一起。大约 90% 的拥有成熟的 DevOps 协议的团队报告说，他们清楚地了解自己对其他团队的责任，而在不成熟的 DevOps 团队中，只有大约 46% 的工作者清楚地了解自己的责任。</p>
<p>虽然与志同道合的人结成小团体，只与被雇来执行与你相同任务的员工在一起是很诱人的，但这对整个企业来说是很糟糕的。无论你喜欢与否，所有的人都是多面手，能够在一系列的情况下贡献自己的独特才能。</p>
<p>密切协作的理念是尊重任何人对其周围正在进行的产品或工作流程提出改进建议的能力。如果你与公司内的其他部门保持一定的距离，你将会错过无数次分享智慧想法的机会。毕竟，你往往在交流中学习得最好。</p>
<h3><span id="致力于自动化">致力于自动化</span></h3><p>你应该以提高效率和加速流程的名义，寻求将单调的和重复的任务变为自动化。每个行业都有无聊的 —— 说得直白一点，就是愚蠢的 —— 每天或每周都要进行的工作。</p>
<p>无论是手工将数据从一页复制到另一页，还是手工打出音频记录，每个级别的工作人员都应该坚持让机器在可能的情况下承担这些负担。现实是自动化技术每年都在进步，操作流程也应该如此。<a href="https://opensource.com/article/20/7/open-source-test-automation-frameworks">自动化测试</a> 对 DevOps 非常关键，它是 CALMS 框架的第二个原则（其中的 “C” 代表 “文化”）。</p>
<p>你怎样才能实现这一点？邀请员工公开表达他们认为工作的哪些方面可以自动化，然后 —— 这里是关键的部分 —— 支持实现自动化所需的设施。这可能意味着每年花 600 美元订阅一个软件程序、一套完整的企业应用现代化解决方案，或开发人员用两天时间来建立一个在内部使用新工具。</p>
<p>无论哪种方式，你都应该评估自动化的好处，考虑你可以为每个人节省多少时间。DevOps 的统计数据不断表明，现代公司通过整合这些有益的原则，年复一年地得到了很大的改善。</p>
<h3><span id="探索成功的新工作方式">探索成功的新工作方式</span></h3><p>文化转变不会在一夜之间发生。不过，你越早开始，就越早看到结果。根据我的经验，当变化真正对以前进行了改进时，人们会接受它。DevOps 为这种改进提供了一个框架。无论你是刚刚在你的组织中开始使用 DevOps，还是仅仅想改善你现有的文化，请考虑以上几点以及它们与你组织的未来的关系。</p>
<hr>
<p>via: <a href="https://opensource.com/article/23/1/tips-effective-devops-culture">https://opensource.com/article/23/1/tips-effective-devops-culture</a></p>
<p>作者：<a href="https://opensource.com/users/yauhen-zaremba">Yauhen Zaremba</a><br>选题：<a href="https://github.com/lkxed">lkxed</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派3B+ 安装系统</title>
    <url>/cfbe6b0a/</url>
    <content><![CDATA[<p>安装步骤: <code>官网下载系统 -- 刷入TF卡 -- 设置开启显示器和SSH -- 通电 -- 进入系统</code></p>
<h3><span id="0-很重要">0. 很重要</span></h3><p>装完系统，写完 <code>wpa_supplicant.conf</code> 配置文件后，无论如何不要 <code>reboot</code>，不要 <code>reboot</code>， 不要 <code>reboot</code> ！！！<br>3B+ 有极大的概率，<code>reboot</code> 后无法正常连接 WIFI，只能重新烧录系统。</p>
<h3><span id="1-进入官方网站下载系统镜像">1. 进入官方网站下载系统镜像</span></h3><p>官方系统 raspbian地址 <a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a></p>
<h3><span id="2-windows系统下的安装">2. Windows系统下的安装</span></h3><h4><span id="21-下载sd格式化工具">2.1 下载SD格式化工具</span></h4><p>SDFormatter 地址 <a href="https://www.sdcard.org/downloads/formatter\_4/eula\_windows/">https://www.sdcard.org/downloads/formatter\_4/eula\_windows/</a></p>
<p>安装后直接用默认选项 格式化SD卡</p>
<h4><span id="22-下载写镜像工具">2.2 下载写镜像工具</span></h4><p>Win32 DiskImager 地址 <a href="http://sourceforge.net/projects/win32diskimager/">http://sourceforge.net/projects/win32diskimager/</a></p>
<h3><span id="3-mac系统下的安装">3. MAC系统下的安装</span></h3><h4><span id="31-查看当前已挂载的卷">3.1 查看当前已挂载的卷</span></h4><pre><code>[liuxb@liuxb-mac]$ df -h
Filesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on
/dev/disk1     112Gi   81Gi   30Gi    73% 1014786 4293952493    0%   /
devfs          188Ki  188Ki    0Bi   100%     654          0  100%   /dev
map -hosts       0Bi    0Bi    0Bi   100%       0          0  100%   /net
map auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /home
/dev/disk2s3    92Gi   51Gi   41Gi    56%  336662   42525054    1%   /Volumes/系统
/dev/disk2s4    20Gi   15Gi  4.4Gi    78%   92859    4579733    2%   /Volumes/数据
/dev/disk3s1    29Gi  2.3Mi   29Gi     1%  107876    8373436    2%   /Volumes/未命名</code></pre><p><code>对比Size和Name可以找到SD卡的分区在系统里对应的设备文件（这里是/dev/disk3s1），如果你有多个分区，可能还会有disk3s2之类的</code></p>
<h4><span id="32-使用diskutil-unmount将分区卸载">3.2 使用diskutil unmount将分区卸载</span></h4><pre><code>[liuxb@liuxb-mac]$ diskutil unmount /dev/disk3s1
Volume 未命名 on disk3s1 unmounted</code></pre><h4><span id="33-先对下载的zip压缩包进行解压然后使用dd命令将系统镜像写入需要特别特别注意disk后的数字不能搞错">3.3 先对下载的zip压缩包进行解压，然后使用dd命令将系统镜像写入，需要特别特别注意disk后的数字，不能搞错</span></h4><p>这部分可以参考<a href="#correct">Mac 烧录系统</a></p>
<p>说明：/dev/disk3s1是分区，/dev/disk3是块设备，/dev/rdisk3是原始字符设备</p>
<pre><code>[liuxb@liuxb-mac]$ unzip 2017-09-07-raspbian-stretch.zip
[liuxb@liuxb-mac]$ sudo dd bs=16m if=2017-09-07-raspbian-stretch.img of=/dev/rdisk3
_
输入用户密码</code></pre><p>经过几分钟的等待，出现下面的提示，说明TF卡刷好了：</p>
<pre><code>1172+1 records in
1172+1 records out
4916019200 bytes transferred in 127.253638 secs (9691442 bytes/sec)</code></pre><h3><span id="4-开启ssh">4. 开启SSH</span></h3><p>在TF卡分区里创建一个名为”ssh”的不带后缀的空文件</p>
<h3><span id="5-开启强制hdmi输出">5. 开启强制HDMI输出</span></h3><p>在TF卡分区，打开config.txt文件(开机后位置： /boot/config.txt)，修改如下：</p>
<pre><code>hdmi_safe=1
config_hdmi_boost=4
hdmi_ignore_edid=0xa5000080
hdmi_group=2
hdmi_mode=82</code></pre><p>参数介绍:</p>
<p>项</p>
<p>解释</p>
<p>hdmi_safe=1</p>
<p>安全启动HDMI</p>
<p>config_hdmi_boost=4</p>
<p>开启热插拔</p>
<p>hdmi_group=1</p>
<p>CEA电视显示器</p>
<p>hdmi_group=2</p>
<p>DMT电脑显示器</p>
<p>hdmi_ignore_edid=0xa5000080</p>
<p>忽略自动探测的分辨率</p>
<p>输出分辨率：</p>
<p>hdmi_mode=4</p>
<p>640x480 60Hz</p>
<p>hdmi_mode=9</p>
<p>800x600 60Hz</p>
<p>hdmi_mode=16</p>
<p>1024x768 60Hz</p>
<p>hdmi_mode=82</p>
<p>1080p 60Hz</p>
<h3><span id="6设置无线wi-fi连接假设没有网线而且没能连接显示器">6.设置无线WI-FI连接：（假设没有网线，而且没能连接显示器）</span></h3><p>在TF卡的boot分区，创建wpa_supplicant.conf文件，加入如下内容：</p>
<pre><code>country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network=&#123;
ssid=&quot;lxb-wifi&quot;
psk=&quot;123456789&quot;
priority=1
&#125;</code></pre><p>在树莓派通电后会自动添加到<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>文件里面，进行自动连接。</p>
<pre><code>// 详细介绍：
#ssid:网络的ssid
#psk:密码
#priority:连接优先级，数字越大优先级越高（不可以是负数）
#scan_ssid:连接隐藏WiFi时需要指定该值为1

// 如果WiFi 没有密码
network=&#123;
ssid=&quot;无线网络名称（ssid）&quot;
key_mgmt=NONE
&#125;
// 如果WiFi 使用WEP加密

network=&#123;
ssid=&quot;无线网络名称（ssid）&quot;
key_mgmt=NONE
wep_key0=&quot;wifi密码&quot;
&#125;
// 如果你的 WiFi 使用WPA/WPA2加密

network=&#123;
ssid=&quot;无线网络名称（ssid）&quot;
key_mgmt=WPA-PSK
psk=&quot;wifi密码&quot;
&#125;</code></pre><p>以上设置完成后, TF卡可以插入树莓派了, 通电. 默认登录账号:<code>pi</code> 密码: <code>raspberry</code></p>
<p><a id="correct">Mac 烧录操作：</a>&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心就一行指令</span><br><span class="line">sudo dd bs=4m if=2017-11-29-raspbian-stretch.img of=/dev/rdisk4</span><br><span class="line"></span><br><span class="line">其中if参数为镜像文件，of参数为设备名称。但是烧写系统进sd卡前需要一个准备工作，其一是将sd卡抹掉格式化一下，然后卸载sd卡分区，最后将系统烧进指定sd卡位置。</span><br><span class="line"></span><br><span class="line">抹掉sd卡很简单，mac的磁盘工具，选中sd卡，点抹掉，格式选择MS-DOS(FAT)。</span><br><span class="line">sd卡格式化之后，Mac命令行输入df -h，得到挂载的SD卡位置（卷），比如/dev/disk4s1。</span><br><span class="line">然后使用 diskutil unmount /dev/disk4s1 卸载这个分区</span><br><span class="line">最后，使用 diskutil list 这个命令，获得我们要安装系统的设备。</span><br><span class="line">注意：此处我们看到的是 /dev/disk4，但是写核心指令的时候要加一个字母r，即/dev/rdisk4。</span><br><span class="line">最终得到的就是</span><br><span class="line">sudo dd bs=4m if=2017-11-29-raspbian-stretch.img of=/dev/rdisk4</span><br><span class="line"></span><br><span class="line">最后安全退出sd卡</span><br><span class="line">diskutil unmountDisk /dev/disk4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派做BT下载器</title>
    <url>/fb1d9193/</url>
    <content><![CDATA[<p>可以用 <a href="https://www.transmissionbt.com/">transmission</a>，它提供了 Web 界面</p>
<h4><span id="1-安装-transmission">1. 安装 transmission：</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install transmission-daemon</span><br></pre></td></tr></table></figure>



<h4><span id="2-创建下载目录一个是下载完成的目录一个是未完成的目录">2. 创建下载目录，一个是下载完成的目录，一个是未完成的目录</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Public/bt_complete</span><br><span class="line"><span class="built_in">mkdir</span> Public/bt_incomplete</span><br></pre></td></tr></table></figure>

<h3><span id="3-配置目录权限">3. 配置目录权限</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -a -G debian-transmission pi</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chgrp</span> debian-transmission bt_complete</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chgrp</span> debian-transmission bt_incomplete</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 770 bt_complete</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 770 bt_incomplete</span><br></pre></td></tr></table></figure>

<h4><span id="4-修改配置文件-etctransmission-daemonsettingsjson">4. 修改配置文件 /etc/transmission-daemon/settings.json</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;download-dir&quot;:&quot;/home/pi/Public/bt_complete&quot;</span><br><span class="line">&quot;incomplete-dir&quot;:&quot;/home/pi/Public/bt_incomplete&quot;</span><br><span class="line">&quot;rpc-host-whitelist&quot;: &quot;192.168.1.*&quot;,</span><br></pre></td></tr></table></figure>

<h4><span id="5-重启-transmission">5. 重启 transmission</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service transmission-daemon reload</span><br><span class="line"><span class="built_in">sudo</span> service transmission-daemon restart</span><br></pre></td></tr></table></figure>

<p>两个命令按顺序执行，单独 restart 的话配置不会保存：</p>
<p>浏览器中输入 <code>http://192.168.1.8:9091/</code>，默认用户名密码：<code>transmission</code></p>
<p><strong>修改 transmission 用户名和密码的方法：</strong></p>
<ol>
<li>先停止服务： <code>sudo service transmission-daemon stop</code></li>
<li>修改配置文件，看到这个是加密的密码，直接把密码改为密码明文就可以：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">“rpc-username”: “明文”,</span><br><span class="line">“rpc-password”: “密文”,</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>再此启动服务 ：<code>sudo service transmission-daemon start</code><br>  启动的时候 transmission 会自动把新密码加密。</li>
</ol>
<p><strong>transmission 默认监听 51413 端口，最好在路由器上做个端口转发，把这个端口转到它的 IP 地址</strong></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派基础环境</title>
    <url>/5976aace/</url>
    <content><![CDATA[<h3><span id="修改软件源">修改软件源</span></h3><pre><code>sudo -s
echo -e &quot;deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \n deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi&quot; &amp;gt; /etc/apt/sources.list
echo -e &quot;deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui&quot; &amp;gt; /etc/apt/sources.list.d/raspi.list
exit
sudo apt update &amp;amp;&amp;amp; sudo apt -y upgrade</code></pre><h3><span id="中文输入法">中文输入法</span></h3><pre><code>sudo apt-get install -y ttf-wqy-zenhei
sudo apt-get install -y scim-pinyin</code></pre><h3><span id="看门狗防止树莓派死机的监控">看门狗(防止树莓派死机的监控)</span></h3><p>当利用树莓派来做一些需要长期待机的应用时，如下载机、云储存、家庭影院等应用，我们往往会遇到的一个问题就是树莓派会因为过热而死机，需要我们重新启动树莓派，然后再次开启树莓派上的应用。这会给我们的日常操作带来许多麻烦。 Watchdog（看门狗）就能让树莓派永不死机。</p>
<pre><code>//树莓派自带看门狗模块，我们需要添加进去就好。
sudo modprobe bcm2708_wdog
echo -e &quot;\nbcm2708_wdog&quot; &amp;gt; sudo tee -a /etc/modules
// 安装看门狗软件
sudo apt-get install -y chkconfig watchdog
// 配置
sudo vim /etc/watchdog.conf
// 去掉&quot;watchdog-device=/dev/watchdog&quot;这一行的#注释
// 其它配置参考如下:
# 用于设定CPU温度重启条件
temperature-device = /sys/class/thermal/thermal_zone0/temp
# 最大温度为100度，超过立即重启
max-temperature = 100000
# 1分钟最多进程为24个，超过即重启
max-load-15=12
# 5分钟最多进程为18个，超过即重启
max-load-15=12
# 15分钟最多进程为12个，超过即重启
max-load-15=12

// 完成配置后，启动看门狗
sudo /etc/init.d/watchdog start
// 设置为开机自启
chkconfig watchdog on</code></pre><h3><span id="screen让树莓派永不失联">Screen(让树莓派永不失联)</span></h3><p>利用SSH（Serare Shell，安全外壳协议）来远程控制树莓派应该是我们最常用的 操作树莓派的方式，但在用SSH连接时，我们常常会遇到连接突然断开的问题。连 接一旦断开，原米我们进行的操作也就中断了，若再使用，就得从头再来了。相信你肯定因为电脑待机而中断树莓派的任务而苦恼过。 Screen来让树莓派永不失联的方法。此方法下，就算连接断开了，当我们重新连接后依旧进行原来的操作，而不需要从头再来。</p>
<pre><code>// 直接安装Screen
sudo apt-get install -y screen
// 开启一个后台view（后台的终端，不会因为断开连接而终止）
screen -S 终端名
// 然后就可以继续你的操作了</code></pre>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派搭建GitHub镜像服务</title>
    <url>/2073ae8b/</url>
    <content><![CDATA[<h3><span id="1-树莓派上创建-git-账号创建用于存放代码的目录">1.  树莓派上创建 git 账号，创建用于存放代码的目录</span></h3><p><code>/srv/</code></p>
<h3><span id="2-github-库-clone-到树莓派">2. GitHub 库 clone 到树莓派</span></h3><p><code>git clone git@github.com:user/XXXX.git /srv/</code></p>
<h3><span id="3-添加-remote">3. 添加 remote</span></h3><p><code>git remote add upstream https://github.com/abcd/XXXX</code></p>
<h3><span id="4-修改-hook">4. 修改 hook</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#.git/hooks/post-update</span></span><br><span class="line">param=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">push_branch=<span class="variable">$&#123;param##refs/heads/&#125;</span> <span class="comment">#获取到更新的分支名</span></span><br><span class="line">git push origin <span class="variable">$push_branch</span></span><br></pre></td></tr></table></figure>

<h3><span id="5-添加定时任务">5. 添加定时任务</span></h3><p><code>5,35 * * * * cd /srv/XXXX &amp;&amp; git pull upstream master</code></p>
<h3><span id="6-在本地代码添加-remote">6. 在本地代码添加 remote</span></h3><h4><span id="61-有多个项目时为避免修改每个项目的-remote直接添加-host">6.1 有多个项目时，为避免修改每个项目的 remote，直接添加 host</span></h4><p><code>192.168.1.8 gitsrv</code></p>
<h4><span id="62-在每个项目在添加一次-remote">6.2 在每个项目在添加一次 remote</span></h4><p><code>git remote add pi git@192.168.1.8:/srv/XXXX</code></p>
<p>这样即使以后地址改变，只需要改一次 host 就可以了</p>
<h3><span id="7-推拉代码时从-pi-推拉">7. 推拉代码时，从 pi 推拉</span></h3><p><code>git pull pi branch</code></p>
<p><code>git push pi branch</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派搭建迅雷远程下载服务器</title>
    <url>/1846a864/</url>
    <content><![CDATA[<h3><span id="1-下载路由器固件">1. 下载路由器固件</span></h3><p>从 <a href="http://luyou.xunlei.com/forum-51-1.html">官网</a> 或者 百度网盘</p>
<p>解压到指定目录如 <code>/root/xunlei</code> 进入目录 执行<code>./portal</code> 稍等片刻，会在最后输出一个激活码</p>
<h3><span id="2-在迅雷远程下载页面绑定树莓派">2. 在迅雷远程下载页面绑定树莓派</span></h3><p>登录<a href="http://yuancheng.xunlei.com/login.html">迅雷远程下载</a>主页,登录之后，左侧会有一个添加按钮，点击添加按钮</p>
<p>不需要选择绑定设备类型, 直接将树莓派上获得的激活码填入框中，点击绑定后左侧就会出现树莓派对应的设备列表了，但是，如果我们此时就在右侧点击新建之后会发现,弹出的新建页面中会提示找不到挂载磁盘</p>
<h3><span id="3-自定义迅雷的下载目录">3. 自定义迅雷的下载目录</span></h3><p>进入/mnt目录，创建目录TDDOWNLOAD(名字随意) 执行<code>mount --bind /data/TDDOWNLOAD /mnt/TDDOWNLOAD</code></p>
<p>其中/data/TDDOWNLOAD就是自定义的下载目录，你可以指定为其他任何目录。</p>
<p>然后再刚刚迅雷固件的解压目录下创建目录etc,同时在etc下创建文件thunder_mounts.cfg,编辑此文件, 写入内容</p>
<pre><code>avaliable_mount_path_pattern
&#123;
/mnt/TDDOWNLOAD
&#125;</code></pre><p>重启路由器固件 <code>./root/xunlei/portal</code> 再进入远程下载界面新建下载就没有了没挂载磁盘的提示了</p>
<h3><span id="4-迅雷路由器固件开机启动">4. 迅雷路由器固件开机启动</span></h3><p>在/etc/init.d/下新建xunlei脚本，写入:</p>
<pre><code>#!/bin/sh
#
# Xunlei initscript
#
### BEGIN INIT INFO
# Provides:          xunlei
# Required-Start:    $network $local_fs $remote_fs
# Required-Stop::    $network $local_fs $remote_fs
# Should-Start:      $all
# Should-Stop:       $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start xunlei at boot time
# Description:       A downloader
### END INIT INFO

do_start()
&#123;
./root/xunlei/portal
&#125;

do_stop()
&#123;
./root/xunlei/portal -s
&#125;

case &quot;$1&quot; in
start)
do_start
;;
stop)
do_stop
;;
esac</code></pre><p>然后将该脚本加入默认自启动中 <code>update-rc.d xunlei defaults</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装TT-RSS</title>
    <url>/afdc720c/</url>
    <content><![CDATA[<p><a href="https://tt-rss.org/">Tiny Tiny RSS</a>（TT-RSS）是一个自由开源的基于 Web 的新闻<ruby>馈送<rt>feed</rt></ruby>（RSS/Atom）阅读器和聚合工具。它非常适合那些注重隐私，并且仍然依赖 RSS 来获取日常新闻的人。TT-RSS 是自行托管的软件，因此你可以 100% 的掌控你的服务器、数据以及你的全部隐私。它还支持大量的插件、扩展和主题。你喜欢黑暗模式的界面？没问题。想基于关键词过滤发来的消息？TT-RSS 也能让你得偿所愿。</p>
<p><img src="https://opensource.com/sites/default/files/uploads/tt-rss.jpeg" alt="Tiny Tiny RSS screenshot" title="Tiny Tiny RSS screenshot"></p>
<p>现在你知道 TT-RSS 是什么了，那么为什么你可能会想用它。我会讲述要把它安装到树莓派或 Debian 10 服务器上你需要了解的所有的东西。</p>
<h3><span id="安装和配置-tt-rss">安装和配置 TT-RSS</span></h3><p>要把 TT-RSS 安装到树莓派上，你还需要安装和配置最新版本的 PHP（本文撰写时 PHP 最新版本是 7.3）、后端数据库 PostgreSQL、Nginx web 服务器、Git，最后才是 TT-RSS。</p>
<h4><span id="1-安装-php-7">1、安装 PHP 7</span></h4><p>安装 PHP 7 是整个过程中最复杂的部分。幸运的是，它并不像看起来那样困难。从安装下面的支持包开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y ca-certificates apt-transport-https</span><br></pre></td></tr></table></figure>

<p>现在，添加存储库 PGP 密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget -q https://packages.sury.org/php/apt.gpg -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>下一步，把 PHP 库添加到你的 apt 源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;deb https://packages.sury.org/php/ buster main&quot; | sudo tee /etc/apt/sources.list.d/php.list</span><br></pre></td></tr></table></figure>

<p>然后更新你的存储库索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<p>最后，安装 PHP 7.3（或最新版本）和一些通用组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y php7.3 php7.3-cli php7.3-fpm php7.3-opcache php7.3-curl php7.3-mbstring php7.3-pgsql php7.3-zip php7.3-xml php7.3-gd php7.3-intl</span><br></pre></td></tr></table></figure>

<p>上面的命令默认你使用的后端数据库是 PostgreSQL，会安装 <code>php7.3-pgsql</code>。如果你想用 MySQL 或 MariaDB，你可以把命令参数改为 <code>php7.3-mysql</code>。</p>
<p>下一步，确认 PHP 已安装并在你的树莓派上运行着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ php -v</span><br></pre></td></tr></table></figure>

<p>现在是时候安装和配置 Web 服务器了。</p>
<h4><span id="2-安装-nginx">2、安装 Nginx</span></h4><p>可以用下面的命令安装 Nginx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y nginx</span><br></pre></td></tr></table></figure>

<p>修改默认的 Nginx 虚拟主机配置，这样 Web 服务器才能识别 PHP 文件以及知道如何处理它们。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>你可以安全地删除原文件中的所有内容，用下面的内容替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        server_name _;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">          include snippets/fastcgi-php.conf;</span><br><span class="line">          fastcgi_pass unix:/run/php/php7.3-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按 <code>Ctrl+O</code> 保存修改后的配置文件，然后按 <code>Ctrl+X</code> 退出 Nano。你可以用下面的命令测试你的新配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nginx -t</span><br></pre></td></tr></table></figure>

<p>如果没有报错，重启 Nginx 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ systemctl restart nginx</span><br></pre></td></tr></table></figure>

<h4><span id="3-安装-postgresql">3、安装 PostgreSQL</span></h4><p>接下来是安装数据库服务器。在树莓派上安装 PostgreSQL 超级简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y postgresql postgresql-client postgis</span><br></pre></td></tr></table></figure>

<p>输入下面的命令看一下数据库服务器安装是否成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ psql --version</span><br></pre></td></tr></table></figure>

<h4><span id="4-创建-tiny-tiny-rss-数据库">4、创建 Tiny Tiny RSS 数据库</span></h4><p>在做其他事之前，你需要创建一个数数据库，用来给 TT-RSS 软件保存数据。首先，登录 PostgreSQL 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -u postgres psql</span><br></pre></td></tr></table></figure>

<p>下一步，新建一个用户，设置密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER username WITH PASSWORD &#x27;your_password&#x27; VALID UNTIL &#x27;infinity&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后创建一个给 TT-RSS 用的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE tinyrss;</span><br></pre></td></tr></table></figure>

<p>最后，给新建的用户赋最高权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON DATABASE tinyrss to user_name;</span><br></pre></td></tr></table></figure>

<p>这是安装数据库的步骤。你可以输入 <code>\q</code> 来退出 <code>psql</code> 程序。</p>
<h4><span id="5-安装-git">5、安装 Git</span></h4><p>安装 TT-RSS 需要用 Git，所以输入下面的命令安装 Git：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install git -y</span><br></pre></td></tr></table></figure>

<p>现在，进入到 Nginx 服务器的根目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /var/www/html</span><br></pre></td></tr></table></figure>

<p>下载 TT-RSS 最新源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://git.tt-rss.org/fox/tt-rss.git tt-rss</span><br></pre></td></tr></table></figure>

<p>注意，这一步会创建一个 <code>tt-rss</code> 文件夹。</p>
<h4><span id="6-安装和配置tiny-tiny-rss">6、安装和配置Tiny Tiny RSS</span></h4><p>现在是安装和配置你的新 TT-RSS 服务器的最后时刻了。首先，确认下你在浏览器中能打开 <code>http://your.site/tt-rss/install/index.php</code>。如果浏览器显示 <code>403 Forbidden</code>，那么就证明 <code>/var/www/html</code> 文件夹的权限没有设置正确。下面的命令通常能解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod 755 /var/www/html/ -v</span><br></pre></td></tr></table></figure>

<p>如果一切正常，你会看到 TT-RSS 安装页面，它会让你输入一些数据的信息。你只需要输入前面你创建的数据库用户名和密码；数据库名；主机名填 <code>localhost</code>；端口填 <code>5432</code>。</p>
<p>点击“Test Configuration”。如果一切正常，你会看到一个标记着“Initialize Database”的红色按钮。点击它来开始安装。结束后，你会看到一个配置文件，你可以把它复制到 TT-RSS 的目录，另存为 <code>config.php</code>。</p>
<p>安装过程结束后，浏览器输入 <code>http://yoursite/tt-rss/</code> 打开 TT-RSS，使用默认的凭证登录（用户名：<code>admin</code>，密码：<code>password</code>）。登录后系统会提示你修改密码。我强烈建议你尽快修改密码。</p>
<h3><span id="配置-tt-rss">配置 TT-RSS</span></h3><p>如果一切正常，你现在就可以开始使用 TT-RSS 了。建议你新建一个非管理员用户，使用新用户名登录，并开始导入你的馈送、订阅，按照你的意愿来配置它。</p>
<p>最后，并且是超级重要的事，不要忘了阅读 TT-RSS 维基上的 <a href="https://tt-rss.org/wiki/UpdatingFeeds">Updating Feeds</a> 部分。它讲述了如何创建一个简单的 systemd 服务来更新馈送。如果你跳过了这一步，你的 RSS 馈送就不会自动更新。</p>
<h3><span id="总结">总结</span></h3><p>呵！工作量不小，但是你做完了！你现在有自己的 RSS 聚合服务器了。想了解 TT-RSS 更多的知识？我推荐你去看官方的 <a href="https://tt-rss.org/wiki/FAQ">FAQ</a>、<a href="https://community.tt-rss.org/c/tiny-tiny-rss/support">支持</a>论坛，和详细的<a href="https://tt-rss.org/wiki/InstallationNotes">安装</a>笔记。如果你有任何问题，尽情地在下面评论吧。</p>
<hr>
<p>via: <a href="https://opensource.com/article/20/2/ttrss-raspberry-pi">https://opensource.com/article/20/2/ttrss-raspberry-pi</a></p>
<p>作者：<a href="https://opensource.com/users/pmullins">Patrick H. Mullins</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">lxbwolf</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计原则</title>
    <url>/88049151/</url>
    <content><![CDATA[<h4><span id="grasp-通用职责分配软件模式">GRASP 通用职责分配软件模式</span></h4><p>来自 Craig Larman 的软件设计书《UML 和模式应用》[附录 1]，Larman 在书中提出软件设计的关键任务是职责分配，并提炼总结出 9 种 (5 种核心 +4 种扩展) 软件职责分配模式，这些模式是比 GoF 设计模式更抽象的元模式。</p>
<p><strong>1. 信息专家 (Information Expert)</strong></p>
<p>为对象分配职责的通用原则 – 把职责分配给拥有足够信息可以履行职责的专家</p>
<p><strong>2. 创建者 (Creator)</strong></p>
<p>将创建 A 的职责赋给 B，如果至少下面一种情况为真：</p>
<ul>
<li>B“包含”或者聚合 A</li>
<li>B 记录 A 的实例</li>
<li>B 密切地使用 A</li>
<li>B 拥有 A 的初始化数据</li>
</ul>
<p><strong>3. 低耦合 (Low Coupling)</strong></p>
<p>赋予职责使得对象间的耦合度尽可能低，最小化对象间的依赖和变更影响，最大化重用。</p>
<p><strong>4. 高内聚 (High Cohesion)</strong></p>
<p>赋予职责使得每个对象的职责尽可能保持聚焦和单一，易于管理和理解。</p>
<p><strong>5. 控制器 (Controller)</strong></p>
<p>把职责赋予系统、设备或者子系统的表示类 (门面控制器)，或者某个用例的表示类 (用例控制器)，让控制器接收事件并协调整个系统的运作。</p>
<p><strong>6. 多态 (Polymorphism)</strong></p>
<p>将职责分配给多个具有同名方法的多态子类，运行时根据需要动态切换子类，让系统行为变得可插拔。</p>
<p><strong>7. 纯虚构 (Pure Fabrication)</strong></p>
<p>针对真实问题域中不存在，但是设计建模中有用的概念，设计虚构类并赋予职责。</p>
<p><strong>8. 间接 (Indirection)</strong></p>
<p>在两个或者多个对象间有交互的情况下，为避免直接耦合，提高重用性，创建中间类并赋予职责，对象的交互交由中间类协调。</p>
<p><strong>9. 受保护的变化 (Protected Variation)</strong></p>
<p>简单讲就是封装变化。识别系统中可能的不稳定或者变化，在不稳定组件上创建稳定的抽象接口，将可能的变化封装在接口之后，使得系统内部的不稳定或者变化不会对系统的其它部分产生不良影响。</p>
<h4><span id="solid-面向对象设计原则">SOLID 面向对象设计原则</span></h4><p>S.O.L.I.D 是面向对象设计和编程 (OOD&amp;OOP) 中几个重要原则的首字母缩写，受 Robert Martin 推崇。</p>
<p><strong>1. 单一职责原则 (The Single Responsibility Principle)</strong></p>
<p>修改某个类的理由应该只有一个，如果超过一个，说明类承担不止一个职责，要视情况拆分。</p>
<p><strong>2. 开放封闭原则 (The Open Closed Principle)</strong></p>
<p>软件实体应该对扩展开放，对修改封闭。一般不要直接修改类库源码（即使你有源代码），通过继承等方式扩展。</p>
<p><strong>3. 里氏替代原则 (The Liskov Substitution Principle)</strong></p>
<p>当一个子类的实例能够被替换成任何超类的实例时，它们之间才是真正的 is-a 关系。</p>
<p><strong>4. 依赖倒置原则 (The Dependency Inversion Principle)</strong></p>
<p>高层模块不应该依赖于底层模块，二者都应该依赖于抽象。换句话说，依赖于抽象，不要依赖于具体实现。比方说，你不会把电器电源线焊死在室内电源接口处，而是用标准的插头插在标准的插座 (抽象) 上。</p>
<p><strong>5. 接口分离原则 (The Interface Segregation Principle)</strong></p>
<p>不要强迫用户去依赖它们不使用的接口。换句话说，使用多个专门的接口比使用单一的大而全接口要好。</p>
<p><strong>备注</strong></p>
<ol>
<li>高内聚 + 低耦合，就像道中的一阴一阳，是所有其它 OO 设计原则的原则 (元原则)，其它设计原则都是在这两个基础上泛化衍生出来的。</li>
<li>上述原则虽然是针对 OO 设计和编程提出，但是对于大规模系统架构仍然适用。比如，微服务架构就体现了：</li>
<li><ul>
<li>单一职责：一个微服务尽可能要职责单一，提供的接口也尽可能单一 (接口分离原则)，安全 / 路由 / 限流等跨横切面的关注点 (Cross-Cutting Concerns) 由独立网关负责，体现关注分离 (Separation of Concerns)。</li>
</ul>
</li>
</ol>
<ul>
<li>信息专家：当不确定哪个团队应该负责某个微服务时，一般原则也是谁拥有数据谁负责，基于有界上下文 Bounded Context（一般是边界比较清晰的领域数据源）构建微服务。</li>
<li>松散耦合：服务之间通过 HTTP/JSON 等轻量机制通信，服务之间不强耦合。</li>
<li>受保护的变化和依赖倒置：服务之间只依赖抽象接口，实现可能随时变化。</li>
<li>间接：网关在外面的客户端和内部的服务之间增加了一层间接，使两者不强耦合，可以相互独立演化。</li>
</ul>
<ol>
<li>作为架构师或者设计师，有两个设计能力是需要重点培养的，也是最难和最能体现架构设计水平的：</li>
<li><ul>
<li>合理的职责分配能力，也就是每个类 / 组件 / 子系统应该承担什么职责，如何保证职责单一，它们之间如何协作；</li>
</ul>
</li>
</ol>
<ul>
<li>系统抽象和核心领域建模能力，需要深入一线业务域。</li>
</ul>
<h3><span id="分布式系统架构设计原则和理论">分布式系统架构设计原则和理论</span></h3><h4><span id="akf-架构原则">AKF 架构原则</span></h4><p>这 15 个架构原则来自《架构即未来 (The Art of Scalability)》[附录 2] 一书，作者马丁 L. 阿伯特和迈克尔 T. 费舍尔分别是 eBay 和 PayPal 的前 CTO，他们经历过 eBay 和 PayPal 大规模分布式电商平台的架构演进，在一线实战经验的基础上总结并提炼出 15 条架构原则：</p>
<p><strong>1.N + 1 设计</strong></p>
<p>永远不要少于两个，通常为三个。比方说无状态的 Web/API 一般部署至少&gt;=2 个。</p>
<p><strong>2. 回滚设计</strong></p>
<p>确保系统可以回滚到以前发布过的任何版本。可以通过发布系统保留历史版本，或者代码中引入动态开关切换机制 (Feature Switch)。</p>
<p><strong>3. 禁用设计</strong></p>
<p>能够关闭任何发布的功能。新功能隐藏在动态开关机制 (Feature Switch) 后面，可以按需一键打开，如发现问题随时关闭禁用。</p>
<p><strong>4. 监控设计</strong></p>
<p>在设计阶段就必须考虑监控，而不是在实施完毕之后补充。例如在需求阶段就要考虑关键指标监控项，这就是度量驱动开发 (Metrics Driven Development) 的理念。</p>
<p><strong>5. 设计多活数据中心</strong></p>
<p>不要被一个数据中心的解决方案把自己限制住。当然也要考虑成本和公司规模发展阶段。</p>
<p><strong>6. 使用成熟的技术</strong></p>
<p>只用确实好用的技术。商业组织毕竟不是研究机构，技术要落地实用，成熟的技术一般坑都被踩平了，新技术在完全成熟前一般需要踩坑躺坑。</p>
<p><strong>7. 异步设计</strong></p>
<p>能异步尽量用异步，只有当绝对必要或者无法异步时，才使用同步调用。</p>
<p><strong>8. 无状态系统</strong></p>
<p>尽可能无状态，只有当业务确实需要，才使用状态。无状态系统易于扩展，有状态系统不易扩展且状态复杂时更易出错。</p>
<p><strong>9. 水平扩展而非垂直升级</strong></p>
<p>永远不要依赖更大、更快的系统。一般公司成长到一定阶段普遍经历过买更大、更快系统的阶段，即使淘宝当年也买小型机扛流量，后来扛不住才体会这样做不 scalable，所以才有后来的去 IOE 行动。</p>
<p><strong>10. 设计时至少要有两步前瞻性</strong></p>
<p>在扩展性问题发生前考虑好下一步的行动计划。架构师的价值就体现在这里，架构设计对于流量的增长要有提前量。</p>
<p><strong>11. 非核心则购买</strong></p>
<p>如果不是你最擅长，也提供不了差异化的竞争优势则直接购买。避免 Not Invented Here 症状，避免凡事都要重造轮子，毕竟达成业务目标才是重点。</p>
<p><strong>12. 使用商品化硬件</strong></p>
<p>在大多数情况下，便宜的就是最好的。这点和第 9 点是一致的，通过商品化硬件水平扩展，而不是买更大、更快的系统。</p>
<p><strong>13. 小构建、小发布和快试错</strong></p>
<p>全部研发要小构建，不断迭代，让系统不断成长。这个和微服务理念一致。</p>
<p><strong>14. 隔离故障</strong></p>
<p>实现故障隔离设计，通过断路保护避免故障传播和交叉影响。通过舱壁泳道等机制隔离失败单元 (Failure Unit)，一个单元的失败不至影响其它单元的正常工作。</p>
<p><strong>15. 自动化</strong></p>
<p>设计和构建自动化的过程。如果机器可以做，就不要依赖于人。自动化是 DevOps 的基础。</p>
<p><strong>备注</strong></p>
<ol>
<li>这 15 条架构原则基本上是 eBay 在发展，经历过流量数量级增长冲击过程中，通过不断踩坑踩出来的，是干货中的干货。消化吸收这 15 条原则，基本可保系统架构不会有原则性问题。</li>
<li>这 15 条原则同样适用于现在的微服务架构。eBay 发展较早，它内部其实很早 (差不多 2010 年前) 就已形成完善的微服务生态，只是没有提出微服务这个概念。</li>
<li>这 15 条原则可根据 TTM(Time To Market)，可用性 / 可扩展性 / 质量，成本 / 效率分布在三个环内，如下图所示。</li>
</ol>
<h4><span id="12-要素应用">12 要素应用</span></h4><p>基于上百万应用的托管和运营经验，创始人 Adam Wiggins 提出了 12 要素应用宣言 。简单讲，满足这 12 个要素的应用是比较容易云化并居住在 Heroku 平台上的。</p>
<p><strong>1. 基准代码</strong></p>
<p>一份基准代码，多份部署。如果用镜像部署方式，则一个镜像可以部署到多个环境 (测试，预发，生产)，而不是给每个环境制作一个不同镜像。</p>
<p><strong>2. 依赖</strong></p>
<p>显式声明依赖。如果用镜像部署，则一般依赖被直接打在镜像中，或者声明在 docker file 中。</p>
<p><strong>3. 配置</strong></p>
<p>在环境中存储配置。在 Heroku 或者类似的 PaaS 平台上，配置一般是推荐注入到环境变量中的。现在采用集中式配置中心也是一种流行方式。</p>
<p><strong>4. 后端服务</strong></p>
<p>把后端服务 (例如缓存，数据库，MQ 等) 当作附加资源，相关配置和连接字符串通过环境变量注入，或者采用配置中心。</p>
<p><strong>5. 构建、发布和运行</strong></p>
<p>严格分离构建和运行。如果使用镜像部署，则构建、发布 / 运行是通过镜像这种中间格式严格分离的。</p>
<p><strong>6. 进程</strong></p>
<p>一个或者多个无状态的进程运行应用。容器运行时相当于进程，适用于无状态 Web/API。</p>
<p><strong>7. 端口绑定</strong></p>
<p>通过端口绑定提供服务。容器也是通过端口绑定对外提供服务。</p>
<p><strong>8. 并发</strong></p>
<p>通过进程模型进行扩展。容器运行时相当于进程，通过起多个容器可以任意扩展并发数量。</p>
<p><strong>9. 易处理</strong></p>
<p>快速启动和优雅终止可最大化健壮性。docker 容器支持秒级启动和关闭。</p>
<p><strong>10. 开发环境和线上环境等价</strong></p>
<p>尽可能保持开发、测试、预发和线上环境相同。容器可以保证容器内运行时环境的一致性，还需要保证不同环境的一致性，例如不同环境内的操作系统，负载均衡，服务发现，后台服务，监控告警等要尽可能一致。</p>
<p><strong>11. 日志</strong></p>
<p>把日志当作数据流。Heroku 不支持本地文件，所以必须以流方式把日志输送到后台日志服务。除了日志以外还要补充考虑 metrics 流的采集和输送。</p>
<p><strong>12. 管理进程</strong></p>
<p>后台管理任务当作一次性的进程。其实相当于在 Heroku 上以独立进程方式运行任务 Job。</p>
<p><strong>备注</strong></p>
<ol>
<li>12 要素应用也是当前云原生应用 (Cloud Native App) 的参考标准，也称为云应用迁移原则。满足这 12 个要素的应用，可以比较顺利迁移到各种云平台 (Kubernetes, Marathon, Cloud Foundry 等) 上。</li>
<li>对于面临企业遗留应用改造和云化迁移的架构师，可以重点参考这 12 条迁移原则。</li>
<li>Docker 容器技术可以认为是为云迁移量身定制的技术。容器化是后续云迁移的捷径，所以遗留应用改造可以先想办法做到容器化。</li>
</ol>
<h4><span id="cap-定理">CAP 定理</span></h4><p>2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。</p>
<p>CAP 认为：一个分布式系统最多同时满足一致性 (Consistency)，可用性 (Availability) 和分区容忍性 (Partition Tolerance) 这三项中的两项。</p>
<p><strong>1.一致性 (Consistency)</strong></p>
<p>一致性指“all nodes see the same data at the same time”，即更新操作成功，所有节点在同一时间的数据完全一致。</p>
<p><strong>2.可用性 (Availability)</strong></p>
<p>可用性指“Reads and writes always succeed”，即服务一直可用，而且响应时间正常。</p>
<p><strong>3.分区容忍性 (Partition tolerance)</strong></p>
<p>分区容忍性指“the system continue to operate despite arbitrary message loss or failure of part of the system.”，即分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。</p>
<h4><span id="base-理论">BASE 理论</span></h4><p>eBay 架构师 Dan Pritchett 基于对大规模分布式系统的实践总结，在 ACM 上发表文章提出了 BASE 理论，BASE 理论是对于 CAP 理论的延伸，核心思想是即使无法做到强一致性 (Strong Consistency，CAP 中的一致性指强一致性)，但是可以采用适当的方式达到最终一致性 (Eventual Consistency)。</p>
<p>BASE 指基本可用 (Basically Available)、软状态 (Soft State) 和最终一致性 (Eventual Consistency)。</p>
<p><strong>1.基本可用 (Basically Available)</strong></p>
<p>基本可用是指分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。比如服务降级。</p>
<p><strong>2.软状态 (Soft State)</strong></p>
<p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。分布式存储中一般一份数据至少存三个副本，允许不同节点间副本同步的延迟就是软状态的体现。</p>
<p><strong>3.最终一致性 (Eventual Consistency)</strong></p>
<p>最终一致性是指系统中的所有数据副本经过一段时间后，最终能够达成一致状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
<p><strong>备注</strong></p>
<ol>
<li>CAP 和 BASE 理论可以抠得很深，背后甚至有很复杂的数学证明。我理解得相对简单浅显：性能、高可用、不丢数据和数据一致性对分布式系统来说一般是强需求，随着流量的增长，复制和分区在所难免：</li>
<li><ul>
<li>复制 (replication)：数据在多个节点上存多份保证不丢和高可用；</li>
</ul>
</li>
</ol>
<ul>
<li>分区 (partition)：数据按某个纬度切分分布在不同节点上分摊流量压力保证高性能，同时也是为了降低每个节点的复杂性。例如数据库的分库分表，系统拆分微服务化也是一种分区。这两者都会带来一致性问题，一致性在时间上有一点妥协的余地 - 即是最终一致性；时间上要求强一致的话，只有可用性可以适当折中。系统架构的游戏很大部分是和状态一致性作斗争的游戏。</li>
</ul>
<ol>
<li>选择使用分布式产品时，比如 NoSQL 数据库，你需要了解它在 CAP 环中所在的位置，确保它满足你的场景需要。</li>
</ol>
<h3><span id="组织和系统改进原则">组织和系统改进原则</span></h3><h4><span id="康威法则">康威法则</span></h4><p>Melvin Conway 在 1967 年提出所谓康威法则 ，指出组织架构和系统架构之间有一种隐含的映射关系：</p>
<p>Organization which design system […] are constrained to produce designs which are copies of the communication structures of these organization. 设计系统的组织其产生的设计等价于组织间的沟通结构。</p>
<p>康威法则也可以倒过来阐述：</p>
<p>Conway’s law reversed：You won’t be able to successfully establish an efficient organization structure that is not supported by your system design(architecture)。 如果系统架构不支持，你无法建立一个高效的组织；同样，如果你的组织架构不支持，你也无法建立一个高效的系统架构。</p>
<h4><span id="系统改进三原则">系统改进三原则</span></h4><p>IT 运维管理畅销书《凤凰项目》[附录 8] 的作者 Gene Kim 在调研了众多高效能 IT 组织后总结出支撑 DevOps 运作的三个原理 (The Three Ways: The Principles Underpinning DevOps)[附录 9]，我认为也是系统改进提升的一般性原理 [附录 7]，见下图：</p>
<p><strong>原理一：系统思考 (System Thinking)</strong></p>
<p>开发驱动的组织，其能力不是制作软件，而是持续的交付客户价值。价值从业务需求开始，经过研发测试，到部署运维，依次流动，并最终以服务形式交付到客户手中。整个价值链流速并不依赖单个部分 (团队或个人) 的杰出工作，而是受整个价值链最薄弱环节 (瓶颈) 的限制。所以局部优化通常无效，反而招致全局受损。</p>
<p>Gene Kim 特别指出：Any improvements made anywhere besides the bottleneck are an illusion. 在瓶颈之外的任何优化提升都只是幻象。</p>
<p><strong>原理二：强化反馈环 (Amplify Feedback Loops)</strong></p>
<p>过程改进常常通过加强反馈环来达成。原理二强调企业和客户之间、组织团队间、流程上和系统内的反馈环。没有测量就没有提升，反馈要以测量数据为准，通过反馈数据优化改进系统。</p>
<p><strong>原理三：持续试验和学习的文化 (Culture of Continual Experimentation And Learning)</strong></p>
<p>在企业管理文化层面强调勇于试错和持续试验、学习和改进的文化。</p>
<p><strong>备注</strong></p>
<ol>
<li>康威法则给我们的启示：系统架构和组织架构之间有隐含的映射关系，你不能单方面改变一方的结构，调整时必须两边联动。系统架构如果是耦合的，就很难组织分散式的团队结构，两边映射不起来，团队之间容易摩擦导致生产率下降。所以一般先按业务边界对单块应用进行解耦拆分，同时做相应的团队拆分，使两边可以映射，每个团队可以独立开发、测试和部署各自的微服务，进而提升生产率。这就是近年流行的微服务架构背后的组织原则。详见我之前发表的文章《企业的组织架构是如何影响技术架构的》[附录 6]。</li>
<li>系统思考要求我们加强团队合作，培养流式思维和瓶颈约束思维，找出瓶颈并针对性地优化。在研发型组织中，常见的系统瓶颈如运维机器资源提供 (Provisioning) 缓慢，发布流程繁琐容易出错，开发 / 测试／UAT 环境缺失或不完善，遗留系统耦合历史负担重，基础研发平台薄弱等等。这些瓶颈点特别需要关注优化。</li>
<li>反馈原理要求我们关注基于数据的反馈，技术上的手段包括大数据分析和系统各个层次的测量监控。没有测量就没有反馈，没有反馈就没有提升。</li>
<li>在管理文化层面：</li>
<li><ul>
<li>管理层要承认企业内部近 50% 的创新或流程改进项目是有可能失败的，即使失败，员工不会受到责罚，鼓励持续的试验和从中学习；</li>
</ul>
</li>
</ol>
<ul>
<li>管理层要有技术偿债意识，勿追求 100% 员工利用率，要预留 20%~30% 的时间给员工做创新和系统改进提升项目</li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>流量复制重放工具goreplay</title>
    <url>/8c9efcce/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#goreplay简介">goreplay简介</a></li>
<li><a href="#goreplay工作原理">goreplay工作原理</a></li>
<li><a href="#goreplay常见用法">goreplay常见用法</a></li>
<li><a href="#gor参数">gor参数</a></li>
</ul>
<!-- tocstop -->

<h2><span id="goreplay简介">goreplay简介</span></h2><p><a href="https://github.com/buger/goreplay">https://github.com/buger/goreplay</a></p>
<p><a href="https://goreplay.org/">https://goreplay.org</a></p>
<p>GoReplay是一个开源工具，用于捕获实时HTTP流量并将其重放到测试环境中，以便使用真实数据持续测试系统。<br>GoReplay不是代理，而是监听网络接口上的流量，不需要更改生产基础架构，而是在与服务相同的计算机上运行GoReplay守护程序。</p>
<h2><span id="goreplay工作原理">goreplay工作原理</span></h2><p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206205553.png" alt></p>
<h2><span id="goreplay常见用法">goreplay常见用法</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 简单的 HTTP 流量复制：</span><br><span class="line">gor –input-raw :80 –output-http “http://staging.com”</span><br><span class="line"></span><br><span class="line">2.HTTP 流量复制频率控制：</span><br><span class="line">gor –input-tcp :28020 –output-http “http://staging.com|10″</span><br><span class="line"></span><br><span class="line">3.HTTP 流量复制缩小：</span><br><span class="line">gor –input-raw :80 –output-tcp “replay.local:28020|10%”</span><br><span class="line"></span><br><span class="line">4.HTTP 流量记录到本地文件：</span><br><span class="line">gor –input-raw :80 –output-file requests.gor</span><br><span class="line"></span><br><span class="line">5.HTTP 流量回放和压测：</span><br><span class="line">gor –input-file “requests.gor|200%” –output-http “staging.com”</span><br><span class="line"></span><br><span class="line">6.HTTP 流量过滤复制：</span><br><span class="line">gor –input-raw :8080 –output-http staging.com –output-http-url-regexp ^www.</span><br><span class="line"></span><br><span class="line">7.HTTP指定接口流量复制：</span><br><span class="line">gor --input-raw :80 --http-allow-url <span class="string">&#x27;/api/v1&#x27;</span> --output-stdout      //--output-stdout表示直接在控制台输出</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="gor参数">gor参数</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@~]# gor --<span class="built_in">help</span></span><br><span class="line">Gor is a simple http traffic replication tool written <span class="keyword">in</span> Go. Its main goal is to replay traffic from production servers to staging and dev environments.</span><br><span class="line">Project page: https://github.com/buger/gor</span><br><span class="line">Author: &lt;Leonid Bugaev&gt; leonsbox@gmail.com</span><br><span class="line">Current Version: 1.0.0</span><br><span class="line"></span><br><span class="line">  -copy-buffer-size int</span><br><span class="line">    	Set the buffer size <span class="keyword">for</span> an individual request (default 5M) (default 5242880)</span><br><span class="line">  -cpuprofile string</span><br><span class="line">    	write cpu profile to file</span><br><span class="line">  -debug verbose		//打开debug模式，显示所有接口的流量 </span><br><span class="line">    	Turn on debug output, shows all intercepted traffic. Works only when with verbose flag</span><br><span class="line">  -exit-after duration</span><br><span class="line">    	<span class="built_in">exit</span> after specified duration</span><br><span class="line">  -http-allow-header value      //用一个正则表达式来匹配http头部，如果请求的头部没有匹配上，则被拒绝</span><br><span class="line">    	A regexp to match a specific header against. Requests with non-matching headers will be dropped:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-allow-header api-version:^v1</span><br><span class="line">  -http-allow-method value      // 类似于一个白名单机制来允许通过的http请求方法，除此之外的方法都被拒绝.</span><br><span class="line">    	Whitelist of HTTP methods to replay. Anything <span class="keyword">else</span> will be dropped:</span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com --http-allow-method GET --http-allow-method OPTIONS</span><br><span class="line">  -http-allow-url value             //一个正则表达式用来匹配url， 用来过滤完全匹配的的url，在此之外的都被过滤掉</span><br><span class="line">    	A regexp to match requests against. Filter get matched against full url with domain. Anything <span class="keyword">else</span> will be dropped:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-allow-url ^www.</span><br><span class="line">  -http-basic-auth-filter value         //匹配认证头重放</span><br><span class="line">    	A regexp to match the decoded basic auth string against. Requests with non-matching headers will be dropped:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-basic-auth-filter <span class="string">&quot;^customer[0-9].*&quot;</span></span><br><span class="line">  -http-disallow-header value       //用一个正则表达式来匹配http头部，匹配到的请求会被拒绝掉</span><br><span class="line">    	A regexp to match a specific header against. Requests with matching headers will be dropped:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-disallow-header <span class="string">&quot;User-Agent: Replayed by Gor&quot;</span></span><br><span class="line">  -http-disallow-url value      //用一个正则表达式来匹配url，如果请求匹配上了，则会被拒绝</span><br><span class="line">    	A regexp to match requests against. Filter get matched against full url with domain. Anything <span class="keyword">else</span> will be forwarded:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-disallow-url ^www.</span><br><span class="line">  -http-header-limiter value	//读取请求，基于FNV32-1A散列来拒绝一定比例的特殊请求 </span><br><span class="line">    	Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A <span class="built_in">hash</span> of a specific header:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-header-limiter user-id:25%</span><br><span class="line">  -http-original-host       //在--output-http的输出中，通常gor会使用取代请求的http头，所以应该禁用该选项，保留原始的主机头</span><br><span class="line">    	Normally gor replaces the Host http header with the host supplied with --output-http.  This option disables that behavior, preserving the original Host header.</span><br><span class="line">  -http-param-limiter value</span><br><span class="line">    	Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A <span class="built_in">hash</span> of a specific GET param:</span><br><span class="line">    		 gor --input-raw :8080 --output-http staging.com --http-param-limiter user_id:25%</span><br><span class="line">  -http-pprof :8181</span><br><span class="line">    	Enable profiling. Starts  http server on specified port, exposing special /debug/pprof endpoint. Example: :8181</span><br><span class="line">  -http-rewrite-header value</span><br><span class="line">    	Rewrite the request header based on a mapping:</span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com --http-rewrite-header Host: (.*).example.com,<span class="variable">$1</span>.beta.example.com</span><br><span class="line">  -http-rewrite-url value</span><br><span class="line">    	Rewrite the request url based on a mapping:</span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com --http-rewrite-url /v1/user/([^\/]+)/ping:/v2/user/<span class="variable">$1</span>/ping</span><br><span class="line">  -http-set-header value</span><br><span class="line">    	Inject additional headers to http reqest:</span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com --http-set-header <span class="string">&#x27;User-Agent: Gor&#x27;</span></span><br><span class="line">  -http-set-param value</span><br><span class="line">    	Set request url param, <span class="keyword">if</span> param already exists it will be overwritten:</span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com --http-set-param api_key=1</span><br><span class="line">  -input-dummy value</span><br><span class="line">    	Used <span class="keyword">for</span> testing outputs. Emits <span class="string">&#x27;Get /&#x27;</span> request every 1s</span><br><span class="line">  -input-file value		//从一个文件中读取请求</span><br><span class="line">    	Read requests from file: </span><br><span class="line">    		gor --input-file ./requests.gor --output-http staging.com</span><br><span class="line">  -input-file-loop</span><br><span class="line">    	Loop input files, useful <span class="keyword">for</span> performance testing.</span><br><span class="line">  -input-kafka-host string</span><br><span class="line">    	Send request and response stats to Kafka:</span><br><span class="line">    		gor --output-stdout --input-kafka-host <span class="string">&#x27;192.168.0.1:9092,192.168.0.2:9092&#x27;</span></span><br><span class="line">  -input-kafka-json-format</span><br><span class="line">    	If turned on, it will assume that messages coming <span class="keyword">in</span> JSON format rather than  GoReplay text format.</span><br><span class="line">  -input-kafka-topic string</span><br><span class="line">    	Send request and response stats to Kafka:</span><br><span class="line">    		gor --output-stdout --input-kafka-topic <span class="string">&#x27;kafka-log&#x27;</span></span><br><span class="line">  -input-raw value</span><br><span class="line">    	Capture traffic from given port (use RAW sockets and require *<span class="built_in">sudo</span>* access):</span><br><span class="line">    		<span class="comment"># Capture traffic from 8080 port</span></span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com</span><br><span class="line">  -input-raw-bpf-filter string</span><br><span class="line">    	BPF filter to write custom expressions. Can be useful <span class="keyword">in</span> <span class="keyword">case</span> of non standard network interfaces like tunneling or SPAN port. Example: --input-raw-bpf-filter <span class="string">&#x27;dst port 80&#x27;</span></span><br><span class="line">  -input-raw-buffer-size int</span><br><span class="line">    	Controls size of the OS buffer (<span class="keyword">in</span> bytes) <span class="built_in">which</span> holds packets <span class="keyword">until</span> they dispatched. Default value depends by system: <span class="keyword">in</span> Linux around 2MB. If you see big package drop, increase this value.</span><br><span class="line">  -input-raw-engine libpcap</span><br><span class="line">    	Intercept traffic using libpcap (default), and `raw_socket` (default <span class="string">&quot;libpcap&quot;</span>)</span><br><span class="line">  -input-raw-expire duration</span><br><span class="line">    	How much it should <span class="built_in">wait</span> <span class="keyword">for</span> the last TCP packet, till consider that TCP message complete. (default 2s)</span><br><span class="line">  -input-raw-immediate-mode</span><br><span class="line">    	Set pcap interface to immediate mode.</span><br><span class="line">  -input-raw-override-snaplen</span><br><span class="line">    	Override the capture snaplen to be 64k. Required <span class="keyword">for</span> some Virtualized environments</span><br><span class="line">  -input-raw-realip-header string</span><br><span class="line">    	If not blank, injects header with given name and real IP value to the request payload. Usually this header should be named: X-Real-IP</span><br><span class="line">  -input-raw-timestamp-type string</span><br><span class="line">    	Possible values: PCAP_TSTAMP_HOST, PCAP_TSTAMP_HOST_LOWPREC, PCAP_TSTAMP_HOST_HIPREC, PCAP_TSTAMP_ADAPTER, PCAP_TSTAMP_ADAPTER_UNSYNCED. This values not supported on all systems, GoReplay will tell you available values of you put wrong one.</span><br><span class="line">  -input-raw-track-response</span><br><span class="line">    	If turned on Gor will track responses <span class="keyword">in</span> addition to requests, and they will be available to middleware and file output.</span><br><span class="line">  -input-tcp value		// 用来在多个gor之间流转流量</span><br><span class="line">    	Used <span class="keyword">for</span> internal communication between Gor instances. Example: </span><br><span class="line">    		<span class="comment"># Receive requests from other Gor instances on 28020 port, and redirect output to staging</span></span><br><span class="line">    		gor --input-tcp :28020 --output-http staging.com</span><br><span class="line">  -input-tcp-certificate string</span><br><span class="line">    	Path to PEM encoded certificate file. Used when TLS turned on.</span><br><span class="line">  -input-tcp-certificate-key string</span><br><span class="line">    	Path to PEM encoded certificate key file. Used when TLS turned on.</span><br><span class="line">  -input-tcp-secure</span><br><span class="line">    	Turn on TLS security. Do not forget to specify certificate and key files.</span><br><span class="line">  -memprofile string</span><br><span class="line">    	write memory profile to this file</span><br><span class="line">  -middleware string</span><br><span class="line">    	Used <span class="keyword">for</span> modifying traffic using external <span class="built_in">command</span></span><br><span class="line">  -output-dummy value		//用来测试输入，打印出接收的数据.</span><br><span class="line">    	DEPRECATED: use --output-stdout instead</span><br><span class="line">  -output-file value		//把进入的请求写入一个文件中 </span><br><span class="line">    	Write incoming requests to file: </span><br><span class="line">    		gor --input-raw :80 --output-file ./requests.gor</span><br><span class="line">  -output-file-append</span><br><span class="line">    	The flushed chunk is appended to existence file or not. </span><br><span class="line">  -output-file-flush-interval duration</span><br><span class="line">    	Interval <span class="keyword">for</span> forcing buffer flush to the file, default: 1s. (default 1s)</span><br><span class="line">  -output-file-max-size-limit value</span><br><span class="line">    	Max size of output file, Default: 1TB (default -1)</span><br><span class="line">  -output-file-queue-limit int</span><br><span class="line">    	The length of the chunk queue. Default: 256 (default 256)</span><br><span class="line">  -output-file-size-limit value</span><br><span class="line">    	Size of each chunk. Default: 32mb (default 33554432)</span><br><span class="line">  -output-http value		//转发进入的请求到一个http地址上</span><br><span class="line">    	Forwards incoming requests to given http address.</span><br><span class="line">    		<span class="comment"># Redirect all incoming requests to staging.com address </span></span><br><span class="line">    		gor --input-raw :80 --output-http http://staging.com</span><br><span class="line">  -output-http-compatibility-mode</span><br><span class="line">    	Use standard Go client, instead of built-in implementation. Can be slower, but more compatible.</span><br><span class="line">  -output-http-debug</span><br><span class="line">    	Enables http debug output.</span><br><span class="line">  -output-http-elasticsearch string		//把请求和响应状态发送到ElasticSearch</span><br><span class="line">    	Send request and response stats to ElasticSearch:</span><br><span class="line">    		gor --input-raw :8080 --output-http staging.com --output-http-elasticsearch <span class="string">&#x27;es_host:api_port/index_name&#x27;</span></span><br><span class="line">  -output-http-header --output-http-header</span><br><span class="line">    	WARNING: --output-http-header DEPRECATED, use `--http-set-header` instead</span><br><span class="line">  -output-http-header-filter --output-http-header-filter</span><br><span class="line">    	WARNING: --output-http-header-filter DEPRECATED, use `--http-allow-header` instead</span><br><span class="line">  -output-http-header-hash-filter output-http-header-hash-filter</span><br><span class="line">    	WARNING: output-http-header-hash-filter DEPRECATED, use `--http-header-hash-limiter` instead</span><br><span class="line">  -output-http-method --output-http-method</span><br><span class="line">    	WARNING: --output-http-method DEPRECATED, use `--http-allow-method` instead</span><br><span class="line">  -output-http-queue-len int</span><br><span class="line">    	Number of requests that can be queued <span class="keyword">for</span> output, <span class="keyword">if</span> all workers are busy. default = 1000 (default 1000)</span><br><span class="line">  -output-http-redirects int		//设置多少次重定向被允许</span><br><span class="line">    	Enable how often redirects should be followed.</span><br><span class="line">  -output-http-response-buffer int</span><br><span class="line">    	HTTP response buffer size, all data after this size will be discarded.</span><br><span class="line">  -output-http-rewrite-url --output-http-rewrite-url</span><br><span class="line">    	WARNING: --output-http-rewrite-url DEPRECATED, use `--http-rewrite-url` instead</span><br><span class="line">  -output-http-stats		//每5秒钟输出一次输出队列的状态</span><br><span class="line">    	Report http output queue stats to console every N milliseconds. See output-http-stats-ms</span><br><span class="line">  -output-http-stats-ms int</span><br><span class="line">    	Report http output queue stats to console every N milliseconds. default: 5000 (default 5000)</span><br><span class="line">  -output-http-timeout duration		//指定http的request/response超时时间，默认是5秒 </span><br><span class="line">    	Specify HTTP request/response <span class="built_in">timeout</span>. By default 5s. Example: --output-http-timeout 30s (default 5s)</span><br><span class="line">  -output-http-track-response</span><br><span class="line">    	If turned on, HTTP output responses will be <span class="built_in">set</span> to all outputs like stdout, file and etc.</span><br><span class="line">  -output-http-url-regexp --output-http-url-regexp</span><br><span class="line">    	WARNING: --output-http-url-regexp DEPRECATED, use `--http-allow-url` instead</span><br><span class="line">  -output-http-workers int		// gor默认是动态的扩展工作者数量，你也可以指定固定数量的工作者</span><br><span class="line">    	Gor uses dynamic worker scaling. Enter a number to <span class="built_in">set</span> a maximum number of workers. default = 0 = unlimited.</span><br><span class="line">  -output-http-workers-min int</span><br><span class="line">    	Gor uses dynamic worker scaling. Enter a number to <span class="built_in">set</span> a minimum number of workers. default = 1.</span><br><span class="line">  -output-kafka-host string</span><br><span class="line">    	Read request and response stats from Kafka:</span><br><span class="line">    		gor --input-raw :8080 --output-kafka-host <span class="string">&#x27;192.168.0.1:9092,192.168.0.2:9092&#x27;</span></span><br><span class="line">  -output-kafka-json-format</span><br><span class="line">    	If turned on, it will serialize messages from GoReplay text format to JSON.</span><br><span class="line">  -output-kafka-topic string</span><br><span class="line">    	Read request and response stats from Kafka:</span><br><span class="line">    		gor --input-raw :8080 --output-kafka-topic <span class="string">&#x27;kafka-log&#x27;</span></span><br><span class="line">  -output-null</span><br><span class="line">    	Used <span class="keyword">for</span> testing inputs. Drops all requests.</span><br><span class="line">  -output-stdout</span><br><span class="line">    	Used <span class="keyword">for</span> testing inputs. Just prints to console data coming from inputs.</span><br><span class="line">  -output-tcp value		//用来在多个gor之间流转流量</span><br><span class="line">    	Used <span class="keyword">for</span> internal communication between Gor instances. Example: </span><br><span class="line">    		<span class="comment"># Listen for requests on 80 port and forward them to other Gor instance on 28020 port</span></span><br><span class="line">    		gor --input-raw :80 --output-tcp replay.local:28020</span><br><span class="line">  -output-tcp-secure</span><br><span class="line">    	Use TLS secure connection. --input-file on another end should have TLS turned on as well.</span><br><span class="line">  -output-tcp-stats		//每5秒钟报告一次tcp输出队列的状态</span><br><span class="line">    	Report TCP output queue stats to console every 5 seconds.</span><br><span class="line">  -prettify-http</span><br><span class="line">    	If enabled, will automatically decode requests and responses with: Content-Encodning: gzip and Transfer-Encoding: chunked. Useful <span class="keyword">for</span> debugging, <span class="keyword">in</span> conjuction with --output-stdout</span><br><span class="line">  -split-output <span class="literal">true</span></span><br><span class="line">    	By default each output gets same traffic. If <span class="built_in">set</span> to <span class="literal">true</span> it splits traffic equally among all outputs.</span><br><span class="line">  -stats		//打开输出队列的状态</span><br><span class="line">    	Turn on queue stats output</span><br><span class="line">  -verbose</span><br><span class="line">    	Turn on more verbose output</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表142</title>
    <url>/fb68a62c/</url>
    <content><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p>解题关键是理解 <code>非环部分的长度</code>与<code>相遇点到环起点那部分环的长度</code> 是相等的 这个数学关系</p>
<p>假设非环部分长度为<code>x</code>, 从环起点到相遇点的长度为<code>y</code> , 环的长度为<code>c</code></p>
<p>慢指针(slow)走过的长度可以表示为``ds = x + n1 * c + y<code>, 快指针(fast) 的速度是慢指针的两倍, 意味着 快指针走过的长度为</code>df = 2(x + n1 * c + y)`</p>
<p>还有一个约束是, fast 走过的路程一定比slow走的路程多出环长度的整数倍(记为<code>n2 * c</code>)</p>
<p>所以 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df - ds = n2 * c</span><br><span class="line">2(x + n1 * c + y) - (x + n1 * c + y) = n2 * c</span><br><span class="line">x + n1 * c + y = n2 * c</span><br></pre></td></tr></table></figure>

<p>解读下第三步的等式: 非环部分的长度 + 环起点到相遇点之间的长度 就是环的整数倍</p>
<p>意味着, 当以环的起点为原点时, 已经走过y(即前面<code>从环起点到相遇点的长度</code>)的前提下, 如果再走x , 就刚好走了很多圈(<code>n2 * c</code>). *”很多圈” 的意思, 就是从原点再到原点, 终点的位置和起点的位置重合.* </p>
<p>怎么才能再走x呢? 让一个指针从<code>head</code> 开始走, 另一个指针从相遇点开始走, 等这两个指针相遇, 就是走了x. 如果不能理解为何相遇恰好就在上面说的<strong>原点</strong>处, 应该反复琢磨斜体”很多圈”那句话</p>
<p>code</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	fast, slow := head, head</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		slow = slow.Next</span><br><span class="line">		fast = fast.Next.Next</span><br><span class="line">		<span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">			fast = head</span><br><span class="line">			<span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">				fast = fast.Next</span><br><span class="line">				slow = slow.Next</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fast</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列中的问题| 丢消息| 重复消费| 消息积压</title>
    <url>/ff873094/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-丢消息">1. 丢消息</a><ul>
<li><a href="#检测消息丢失的方法">检测消息丢失的方法</a></li>
<li><a href="#确保消息可靠传递">确保消息可靠传递</a><ul>
<li><a href="#1-生产阶段">1. 生产阶段</a></li>
<li><a href="#2-存储阶段">2. 存储阶段</a></li>
<li><a href="#3-消费阶段">3. 消费阶段</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-重复消息">2. 重复消息</a><ul>
<li><a href="#消息重复的情况必然存在">消息重复的情况必然存在</a></li>
<li><a href="#用幂等性解决重复消息问题">用幂等性解决重复消息问题</a><ul>
<li><a href="#1-利用数据库的唯一约束实现幂等">1. 利用数据库的唯一约束实现幂等</a></li>
<li><a href="#2-为更新的数据设置前置条件">2. 为更新的数据设置前置条件</a></li>
<li><a href="#3-记录并检查操作">3. 记录并检查操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-消息积压问题">3. 消息积压问题</a><ul>
<li><a href="#优化性能来避免消息积压">优化性能来避免消息积压</a><ul>
<li><a href="#1-发送端性能优化">1. 发送端性能优化</a></li>
<li><a href="#2-消费端性能优化">2. 消费端性能优化</a></li>
</ul>
</li>
<li><a href="#消息积压的紧急处理">消息积压的紧急处理</a></li>
</ul>
</li>
<li><a href="#4-如何保证消息的严格顺序">4. 如何保证消息的严格顺序？</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1-丢消息">1. 丢消息</span></h1><h2><span id="检测消息丢失的方法">检测消息丢失的方法</span></h2><p>一般而言，一个新的系统刚刚上线，各方面都不太稳定，需要一个磨合期，这个时候，特别需要监控到你的系统中是否有消息丢失的情况。</p>
<p>如果是 IT 基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。</p>
<p>可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性。</p>
<p>如果没有消息丢失，Consumer 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1。如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。</p>
<p>大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检测的逻辑关闭或者删除。</p>
<p>如果是在一个分布式系统中实现这个检测方法，有几个问题需要你注意。</p>
<p>首先，像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。</p>
<p>如果你的系统中 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。</p>
<p>Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。</p>
<h2><span id="确保消息可靠传递">确保消息可靠传递</span></h2><p>整个消息从生产到消费的过程中，哪些地方可能会导致丢消息，以及应该如何避免消息丢失。一条消息从生产到消费完成这个过程，可以划分三个阶段</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220224160823.png" alt></p>
<ul>
<li>生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。</li>
<li>存储阶段: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。</li>
<li>消费阶段: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。</li>
</ul>
<h3><span id="1-生产阶段">1. 生产阶段</span></h3><p>在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到 Broker，Broker 收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。</p>
<p>只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。</p>
<p>你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。以 Kafka 为例，我们看一下如何可靠地发送消息：</p>
<p><strong>同步发送时，只要注意捕获异常即可</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RecordMetadata metadata = producer.send(record).get();</span><br><span class="line">    System.out.println(<span class="string">&quot; 消息发送成功。&quot;</span>);</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; 消息发送失败！&quot;</span>);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata != null) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 消息发送成功。&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 消息发送失败！&quot;</span>);</span><br><span class="line">        System.out.println(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3><span id="2-存储阶段">2. 存储阶段</span></h3><p>在存储阶段正常情况下，只要 Broker 在正常运行，就不会出现丢失消息的问题，但是如果 Broker 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。</p>
<p>如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。</p>
<p>对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后，<strong>将消息写入磁盘后再给 Producer 返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息</strong>，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。</p>
<p>如果是 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：<strong>至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应</strong>。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失。消息队列<strong>通过消息复制来确保消息的可靠性的</strong>。</p>
<h3><span id="3-消费阶段">3. 消费阶段</span></h3><p>消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，成功后，才会给 Broker 发送消费确认响应。如果 Broker 没有收到消费确认响应，下</p>
<p>次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。</p>
<p>你在编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该<strong>在执行完所有消费业务逻辑之后，再发送消费确认</strong>。</p>
<p>同样，我们以用 Python 语言消费 RabbitMQ 消息为例，来看一下如何实现一段可靠的消费代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] 收到消息 %r&quot;</span> % body)</span><br><span class="line">    <span class="comment"># 在这儿处理收到的消息</span></span><br><span class="line">    database.save(body)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] 消费完成 &quot;</span>)</span><br><span class="line">    <span class="comment"># 完成消费业务逻辑后发送消费确认响应</span></span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"> </span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>, on_message_callback=callback)</span><br></pre></td></tr></table></figure>

<p>在消费的回调方法 callback 中，正确的顺序先是把消息保存到数据库，然后再发送消费确认响应。这样如果保存消息到数据库失败了，就不会执行消费确认的代码，下次拉到的还是这条消息，直到消费成功。</p>
<p><strong>两个消费者先后去拉消息是否能拉到同一条消息？</strong></p>
<p>首先，消息队列一般都会有<strong>协调机制</strong>，不会让这种情况出现，但是由于网络不确定性，这种情况还是在极小概率下会出现的。</p>
<p>在同一个消费组内，A消费者拉走了index=10的这条消息，还没返回确认，这时候这个分区的消费位置还是10，B消费者来拉消息，可能有2种情况：</p>
<ul>
<li>\1. 超时前，Broker认为这个分区还被A占用着，会拒绝B的请求。</li>
<li>\2. 超时后，Broker认为A已经超时没返回，这次消费失败，当前消费位置还是10，B再来拉消息，会给它返回10这条消息。</li>
</ul>
<ul>
<li>在生产阶段，你需要捕获消息发送的错误，并重发消息。</li>
<li>在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。</li>
<li>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。</li>
</ul>
<p>你在理解了这几个阶段的原理后，如果再出现丢消息的情况，应该可以通过在代码中加一些日志的方式，很快定位到是哪个阶段出了问题，然后再进一步深入分析，快速找到问题原因。</p>
<h1><span id="2-重复消息">2. 重复消息</span></h1><p>在消息传递过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。对使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。</p>
<h2><span id="消息重复的情况必然存在">消息重复的情况必然存在</span></h2><p>在 <strong>MQTT 协议</strong>中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：</p>
<ul>
<li>At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li>
<li>At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。</li>
<li>Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。</li>
</ul>
<p>这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。我们<strong>现在常用的绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。也就是说，消息</strong></p>
<p><strong>队**</strong>列很难保证消息不重复。**</p>
<p>Kafka 支持的“Exactly once”和我们刚刚提到的消息传递的服务质量标准“Exactly once”是不一样的，它是 Kafka 提供的另外一个特性，Kafka 中支持的事务也和我们通常意义理解的事务有一定的差异。在 Kafka</p>
<p>中，<strong>事务和 Excactly once 主要是为了配合流计算使用的特性</strong>。巧妙地用了两个所有人都非常熟悉的概念“事务”和“Exactly once”来包装它的新的特性，实际上它实现的这个事务和 Exactly once 并不是我们通常</p>
<p>理解的那两个特性。</p>
<p><strong>为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once？</strong></p>
<p>解决一个问题，往往会引发别的问题。若消息队列实现了exactly once，会引发的问题有：</p>
<p>①消费端在pull消息时，需要检测此消息是否被消费，这个检测机制无疑会拉低消息消费的速度。可以预想到，随着消息的剧增，消费性能势必会急剧下降，导致消息积压；</p>
<p>②检查机制还需要业务端去配合实现，若一条消息长时间未返回ack，消息队列需要去回调看下消费结果（这个类似于事物消息的回查机制）。这样就会增加业务端的压力，与很多的未知因素。</p>
<p>所以，消息队列不实现exactly once，而是at least once + 幂等性，这个幂等性让给我们去处理。</p>
<p>最重要的原因是消息队列即使做到了Exactly once级别，consumer也还是要做幂等。因为在consumer从消息队列取消息这里，如果consumer消费成功，但是ack失败，consumer还是会取到重复的消息，所以消</p>
<p>息队列花大力气做成Exactly once并不能解决业务侧消息重复的问题。</p>
<p>1、At least once + 幂等消费 = Exactly once，所以对于消息队列来讲，要做到Exactly once，其实是需消费端的共同配合（幂等消费）才可完成，消息队列基本只提供At least once的实现；</p>
<p>2、从给的几种幂等消费的方案看，需要引入数据库、条件更新、分布式事务或锁等额外辅助，消息队列如果需要保障Exactly once，会导致消费端代码侵入，例如需要消费端增加消息队列用来处理幂等的client</p>
<p>端，而消费端的形态可是太多了，兼容适配工作量巨大。故这个Exactly once留给用户自己处理，并且具有选择权，毕竟不是所有业务场景都需要Exactly once，例如机房温度上报的案例。</p>
<p><strong>如果队列的实现是At least once，但是为了确保消息不丢失，Broker Service会进行一定的重试，但是不可能一直重试，如果一直重试失败怎么处理了？</strong></p>
<p>有的消息队列会有一个特殊的队列来保存这些总是消费失败的“坏消息”，然后继续消费之后的消息，避免坏消息卡死队列。这种坏消息一般不会是因为网络原因或者消费者死掉导致的，大多都是消息数据本身有</p>
<p>问题，消费者的业务逻辑处理不了导致的。</p>
<h2><span id="用幂等性解决重复消息问题">用幂等性解决重复消息问题</span></h2><p>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。</p>
<p>幂等（Idempotence）是一个数学上的概念，它是这样定义的：</p>
<blockquote>
<p><strong>如果一个函数 f(x) 满足：f(f(x)) = f(x)，则函数 f(x) 满足幂等性。</strong></p>
</blockquote>
<p>这个概念被拓展到计算机领域，被用来描述一个操作、方法或者服务。一个幂等操作的特点是，<strong>其任意多次执行所产生的影响均与一次执行的影响相同。</strong></p>
<p><strong>一个幂等的方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变。</strong></p>
<p>比如在不考虑并发的情况下，“将账户 X 的余额设置为 100 元”，执行一次后对系统的影响是，账户 X 的余额变成了 100 元。只要提供的参数 100 元不变，那即使再执行多少次，账户 X 的余额始终都是 100 元，</p>
<p>不会变化，这个操作就是一个幂等的操作。</p>
<p>再比如“将账户 X 的余额加 100 元”，这个操作它就不是幂等的，每执行一次，账户余额就会增加 100 元，执行多次和执行一次对系统的影响（也就是账户的余额）是不一样的。</p>
<p>如果我们系统<strong>消费消息的业务逻辑具备幂等性</strong>，那就不用担心消息重复的问题了，因为<strong>同一条消息，消费一次和消费多次对系统的影响是完全一样的。也就可以认为，消费多次等于消费一次。</strong></p>
<p><strong>从对系统的影响结果来说：At least once + 幂等消费 = Exactly once。</strong></p>
<p>那么如何实现幂等操作呢？最好的方式就是，从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作。但是，不是所有的业务都能设计成天然幂等的，这里就需要一些方法和技巧来实现幂等。</p>
<p>下面我给你介绍几种常用的设计幂等操作的方法：</p>
<h3><span id="1-利用数据库的唯一约束实现幂等">1. 利用数据库的唯一约束实现幂等</span></h3><p>刚刚提到的那个不具备幂等特性转账的例子：将账户 X 的余额加 100 元。在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。</p>
<p>首先，我们可以限定，对于每个转账单每个账户只可以执行一次变更操作，在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户</p>
<p>ID 和变更金额，然后<strong>给转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束，这样对于相同的转账单 ID 和账户 ID，表里至多只能存在一条记录。</strong></p>
<p>这样，我们消费消息的逻辑可以变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可。”在转账流水表增加一条转账记录这个操作中，由于我们在这个表中预先定义了“账</p>
<p>户 ID 转账单 ID”的唯一约束，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作。我们只要写一个 SQL，正确地实现它就可以了。</p>
<p>基于这个思路，不光是可以使用关系型数据库，<strong>只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等</strong>，</p>
<p>比如， <strong>Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂**</strong>等消费。 （ redis中的hash：<strong>**hsetnx</strong> <strong><key> <field> <value>；</value></field></key></strong> <strong>）</strong></p>
<p><strong>比如，Elasticsearch中的幂等操作：</strong> <strong>PUT /movie_index/movie/3，加上文档 ID</strong> </p>
<h3><span id="2-为更新的数据设置前置条件">2. 为更新的数据设置前置条件</span></h3><p>另外一种实现幂等的思路是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次</p>
<p>更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。</p>
<p>比如，刚刚我们说过，“将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等</p>
<p>性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。</p>
<p>但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，<strong>给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本</strong></p>
<p><strong>号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。</strong></p>
<h3><span id="3-记录并检查操作">3. 记录并检查操作</span></h3><p>如果上面提到的两种实现幂等方法都不能适用于你的场景，我们还有一种通用性最强，适用范围最广的实现幂等性方法：<strong>记录并检查操作</strong>，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别</p>
<p>简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。</p>
<p>具体的实现方法是，<strong>在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。</strong></p>
<p>原理和实现是不是很简单？其实一点儿都不简单，在分布式系统中，这个方法其实是非常难实现的。首先，给每个消息指定一个全局唯一的 ID 就是一件不那么简单的事儿，方法有很多，但都不太好同时满足简</p>
<p>单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug。</p>
<p>比如说，对于同一条消息：“全局 ID 为 8，操作为：给 ID 为 666 账户增加 100 元”，有可能出现这样的情况：</p>
<ul>
<li>t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；</li>
<li>t1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。</li>
</ul>
<p>这样就会导致账户被错误地增加了两次 100 元，这是一个在分布式系统中非常容易犯的错误，一定要引以为戒。</p>
<p>对于这个问题，当然我们可以用事务来实现，也可以用锁来实现，但是在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题。</p>
<p><strong>几种实现幂等操作的方法</strong></p>
<ul>
<li>可以利用数据库的约束来防止重复更新数据，</li>
<li>可以为数据更新设置一次性的前置条件，来防止重复消息，如果这两种方法都不适用于你的场景，</li>
<li>还可以用“记录并检查操作”的方式来保证幂等，这种方法适用范围最广，但是实现难度和复杂度也比较高，一般不推荐使用。</li>
</ul>
<p>这些实现幂等的方法，不仅可以用于解决重复消息的问题，也同样适用于，在其他场景中来<strong>解决重复请求或者重复调用的问题</strong>。比如，我们可以将 HTTP 服务设计成幂等的，解决前端或者 APP 重复提交表单数</p>
<p>据的问题；也可以将一个微服务设计成幂等的，解决 RPC 框架自动重试导致的重复调用问题。这些方法都是通用的。</p>
<h1><span id="3-消息积压问题">3. 消息积压问题</span></h1><p>在使用消息队列遇到的问题中，消息积压这个问题，应该是最常遇到的问题。</p>
<p>消息积压的直接原因，一定是系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压。 所以在使用消息队列时，如何来优化代码的性能，避免出现消息积压。</p>
<h2><span id="优化性能来避免消息积压">优化性能来避免消息积压</span></h2><p>在使用消息队列的系统中，对于性能的优化，主要体现在生产者和消费者这一收一发两部分的业务逻辑中。对于消息队列本身的性能，不需要太关注。</p>
<p>主要原因是，对于绝大多数使用消息队列的业务来说，消息队列本身的处理能力要远大于业务系统的处理能力。主流消息队列的单个节点，消息收发的性能可以达到每秒钟处理几万至几十万条消息的水平，还可</p>
<p>以通过水平扩展 Broker 的实例数成倍地提升处理能力。而一般的业务系统需要处理的业务逻辑远比消息队列要复杂，单个节点每秒钟可以处理几百到几千次请求，已经可以算是性能非常好的了。所以，对于消</p>
<p>息队列的性能优化，我们更关注的是，在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。</p>
<h3><span id="1-发送端性能优化">1. 发送端性能优化</span></h3><p>如果说，代码发送消息的性能上不去，需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的。</p>
<p>对于发送消息的业务逻辑，只需要注意<strong>设置合适的并发和批量大小，就可以达到很好的发送性能</strong>。</p>
<p>Producer 发送消息的过程，Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互。假设这一次交互的平均时延是 1ms，把这 1ms 的时间分解开，它包括了下面这些步骤的耗时：</p>
<ul>
<li>发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时；</li>
<li>发送消息和返回响应在网络传输中的耗时；</li>
<li>Broker 处理消息的时延。</li>
</ul>
<p>如果是单线程发送，每次只发送 1 条消息，那么每秒只能发送 1000ms / 1ms * 1 条 /ms = 1000 条 消息，这种情况下并不能发挥出消息队列的全部实力。</p>
<p>无论是增加每次发送消息的批量大小，还是增加并发，都能成倍地提升发送性能。<strong>至于到底是选择批量发送还是增加并发，主要取决于发送端程序的业务性质</strong>。</p>
<p>比如说，你的<strong>消息发送端是一个微服务</strong>，主要接受 RPC 请求处理在线业务。很自然的，微服务在处理每次请求的时候，就在当前线程直接发送消息就可以了，因为所有 RPC 框架都是多线程支持多并发的，自</p>
<p>然也就实现了并行发送消息。并且在线业务比较在意的是请求响应时延，选择批量发送必然会影响 RPC 服务的时延。这种情况，比较明智的方式就是<strong>通过并发来提升发送性能</strong>。</p>
<p>如果你的<strong>系统是一个离线分析系统</strong>，离线系统在性能上的需求是什么呢？它不关心时延，更注重整个系统的吞吐量。发送端的数据都是来自于数据库，这种情况就更适合批量发送，你可以批量从数据库读取数</p>
<p>据，然后批量来发送消息，同样<strong>用少量的并发就可以获得非常高的吞吐量</strong>。</p>
<h3><span id="2-消费端性能优化">2. 消费端性能优化</span></h3><p>使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题只是暂时的，那问题不大，只要消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的。</p>
<p>要是消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么，消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障。</p>
<p>所以，在设计系统的时候，<strong>一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。</strong></p>
<p><strong>消费端的性能优化除了优化消费业务逻辑以外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能</strong>。特别需要注意的一点是，<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区</strong></p>
<p><strong>（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的</strong>。因为对于消费者，在每个分区上实际只能支持单线程消费。</p>
<p><strong>一个解决消费慢的问题常见的错误：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220224161200.png" alt></p>
<p>它收消息处理的业务逻辑可能比较慢，也很难再优化了，为了避免消息积压，在收到消息的 OnMessage 方法中，不处理任何业务逻辑，把这个消息放到一个内存队列里面就返回了。然后它可以启动很多的业务</p>
<p>线程，这些业务线程里面是真正处理消息的业务逻辑，这些线程从内存队列里取消息处理，这样它就解决了单个 Consumer 不能并行消费的问题。</p>
<p>这个方法是不是很完美地实现了并发消费？错误！ 因为会丢消息。如果收消息的节点发生宕机，在内存队列中还没来及处理的这些消息就会丢失。</p>
<p>在onMessage方法结束后，如果没有抛异常，就自动ACK了。而这个时候，消息只是在内存队列中，并没有被真正处理完。</p>
<p>如果onMessage方法中，收到消息后不确认，等真正处理完消息再确认，就可以了吧，这样就可以用内存队列了</p>
<p>理论上是可以的，但要注意，像RocketMQ，采用默认配置的时候，onMessage方法结束后，如果没抛异常，默认就会自动确认了。</p>
<p><strong>在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？</strong></p>
<p>批量消费即一次取一批消息，等这一批消息都成功了，再提交最后一条消息的位置作为新的消费位置。如果其中任何一条失败，则认为整批都失败。</p>
<p>批量消费应该是与消息处理是需要实时与否有关。如果需要实时处理，如订单相关的，就不能批量，但是发送提醒邮件之类的，就可以。</p>
<p><strong>批量消费有意义的场景要求：</strong></p>
<ul>
<li>1.要么消费端对消息的处理支持批量处理，比如批量入库</li>
<li>\2. 要么消费端支持多线程/协程并发处理，业务上也允许消息无序。</li>
<li>\3. 或者网络带宽在考虑因素内，需要减少消息的overhead。</li>
</ul>
<p><strong>批量消费的局限性：</strong></p>
<ul>
<li>\1. 需要一个整体ack的机制，一旦一条靠前的消息消费失败，可能会引起很多消息重试。</li>
<li>\2. 多线程下批量消费速度受限于最慢的那个线程。</li>
</ul>
<p>但其实以上局限并没有影响主流MQ的实现了批量功能。</p>
<p>1、要求消费端能够批量处理或者开启多线程进行单条处理<br>2、批量消费一旦某一条数据消费失败会导致整批数据重复消费<br>3、对实时性要求不能太高，批量消费需要Broker积累到一定消费数据才会发送到Consumer</p>
<p>消费端进行批量操作，感觉和上面的先将消息放在内存队列中，然后在并发消费消息，如果机器宕机，这些批量消息都会丢失，如果在数据库层面，批量操作在大事务，会导致锁的竞争，并且也会导致主备的不</p>
<p>一致。如果是一些不重要的消息如对日志进行备份，就可以使用批量操作之类的提高消费性能，因为一些日志消息丢失也是可以接受的。</p>
<p>如果使用了批量消费的方式，那么就需要批量确认，如果一次消费十条消息，除了第七条消费失败了，其他的都处理成功了，但是这中情况下broker只能将消费的游标修改成消息7，而之后的消息虽然处理成功</p>
<p>了，但是也只能使用类似于拉回重传的方式再次消费，浪费性能，而且这种批量消费对于消费者的并发我觉得不是很友好，可能消费者1来了取走了十条消息在处理，这时候消费者2过来了也想取十条消息，但是</p>
<p>他需要等待消费者1进行ack才可以取走消息。</p>
<p><strong>如何判断增加多少consumer消费实例的个数？</strong></p>
<p>可以简单计算一下，消费并行度：单实例平均消费tps * 消费并行度 &gt; 生产消息的总tps<br>消费并行度 = min（consumer实例数，分区数量）</p>
<h2><span id="消息积压的紧急处理">消息积压的紧急处理</span></h2><p>还有一种消息积压的情况是，日常系统正常运转的时候，没有积压或者只有少量积压很快就消费掉了，但是某一个时刻，突然就开始积压消息并且积压持续上涨。这种情况下需要你在短时间内找到消息积压的原</p>
<p>因，迅速解决问题才不至于影响业务。</p>
<p>导致突然积压的原因肯定是多种多样的，不同的系统、不同的情况有不同的原因，不能一概而论。但是，排查消息积压原因，是有一些相对固定而且比较有效的方法的。</p>
<p>能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了。</p>
<p>大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位时间发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的</p>
<p>方法是通过扩容消费端的实例数来提升总体的消费能力。</p>
<p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。</p>
<p>还有一种不太常见的情况，你通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候你需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多，这</p>
<p>种情况也会拖慢整个系统的消费速度。</p>
<p>如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先检查一下日志是否有大量的消费错误，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在</p>
<p>什么地方不动了，比如触发了死锁或者卡在等待某些资源上了。</p>
<p><strong>优化消息收发性能，</strong>预防消息积压的方法有两种，增加批量或者是增加并发，在发送端这两种方法都可以使用，在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的。</p>
<p><strong>对于系统发生消息积压的情况</strong>，需要先解决积压，再分析原因，毕竟保证系统的可用性是首先要解决的问题。快速解决积压的方法就是通过水平扩容增加 Consumer 的实例数量。</p>
<p>消息积压处理：<br>1、发送端优化，增加批量和线程并发两种方式处理<br>2、消费端优化，优化业务逻辑代码、水平扩容增加并发并同步扩容分区数量<br>查看消息积压的方法：<br>1、消息队列内置监控，查看发送端发送消息与消费端消费消息的速度变化<br>2、查看日志是否有大量的消费错误<br>3、打印堆栈信息，查看消费线程卡点信息</p>
<p>面试解决消息积压的方法：<br>（1）临时扩容，增加消费端，用硬件提升消费速度。<br>（2）服务降级，关闭一些非核心业务，减少消息生产。<br>（3）通过日志分析，监控等找到挤压原因，消息队列三部分，上游生产者是否异常生产大量数据，中游消息队列存储层是否出现问题，下游消费速度是否变慢，就能确定哪个环节出了问题<br>（4）根据排查解决异常部分。<br>（5）等待积压的消息被消费，恢复到正常状态，撤掉扩容服务器。</p>
<h1><span id="4-如何保证消息的严格顺序">4. 如何保证消息的严格顺序？</span></h1><p>怎么来保证消息的严格顺序？主题层面是无法保证严格顺序的，<strong>只有在队列上才能保证消息的严格顺序。</strong></p>
<p>如果说，<strong>你的业务必须要求全局严格顺序，就只能把消息队列数配置成 1，生产者和消费者也只能是一个实例，这样才能保证全局严格顺序。</strong></p>
<p>大部分情况下，并不需要全局严格顺序，只要保证局部有序就可以满足要求了。比如，在传递账户流水记录的时候，<strong>只要保证每个账户的流水有序就可以了，不同账户之间的流水记录是不需要保证顺序的。</strong></p>
<p>如果需要<strong>保证局部严格顺序</strong>，可以这样来实现。在发送端，我们使用账户 ID 作为 Key，<strong>采用一致性哈希算法计算出队列编号</strong>，<strong>指定队列来发送消息。一致性哈希算法可以保证</strong>，<strong>相同 Key 的消息总是发送到同一</strong></p>
<p><strong>个队列上</strong>，这样可以保证相同 Key 的消息是严格有序的。如果不考虑队列扩容，也可以用队列数量取模的简单方法来计算队列编号。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>流编辑器sed</title>
    <url>/f54357bf/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#命令-选项参数">命令、选项参数</a><ul>
<li><a href="#以行为单位的新增删除">以行为单位的新增/删除</a></li>
<li><a href="#以行为单位的替换与显示">以行为单位的替换与显示</a></li>
<li><a href="#数据的搜寻并显示">数据的搜寻并显示</a></li>
<li><a href="#数据的搜寻并删除">数据的搜寻并删除</a></li>
<li><a href="#数据的搜寻并执行命令">数据的搜寻并执行命令</a></li>
<li><a href="#数据的搜寻并替换">数据的搜寻并替换</a></li>
<li><a href="#多点编辑">多点编辑</a></li>
<li><a href="#直接修改文件内容危险动作">直接修改文件内容(危险动作)</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="简介">简介</span></h2><p>sed 是一种流编辑器， 一次处理一行文件并把输出送往屏幕。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<h2><span id="命令-选项参数">命令、选项参数</span></h2><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>a\</td>
<td>在当前行的后面加入一行或者文本。</td>
</tr>
<tr>
<td>c\</td>
<td>用新的文本改变或者替代本行的文本。</td>
</tr>
<tr>
<td>d</td>
<td>从pattern space位置删除行。</td>
</tr>
<tr>
<td>i\</td>
<td>在当前行的上面插入文本。</td>
</tr>
<tr>
<td>h</td>
<td>拷贝pattern space的内容到holding buffer(特殊缓冲区)。</td>
</tr>
<tr>
<td>H</td>
<td>追加pattern space的内容到holding buffer。</td>
</tr>
<tr>
<td>g</td>
<td>获得holding buffer中的内容，并替代当前pattern space中的文本。</td>
</tr>
<tr>
<td>G</td>
<td>获得holding buffer中的内容，并追加到当前pattern space的后面。</td>
</tr>
<tr>
<td>n</td>
<td>读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</td>
</tr>
<tr>
<td>p</td>
<td>打印pattern space中的行。</td>
</tr>
<tr>
<td>P</td>
<td>打印pattern space中的第一行。</td>
</tr>
<tr>
<td>q</td>
<td>退出sed。</td>
</tr>
<tr>
<td>w file</td>
<td>写并追加pattern space到file的末尾。</td>
</tr>
<tr>
<td>!</td>
<td>表示后面的命令对所有没有被选定的行发生作用。</td>
</tr>
<tr>
<td>s/re/string</td>
<td>用string替换正则表达式re。</td>
</tr>
<tr>
<td>=</td>
<td>打印当前行号码。</td>
</tr>
<tr>
<td><strong>替换标记</strong></td>
<td></td>
</tr>
<tr>
<td>g</td>
<td>行内全面替换，如果没有g，只替换第一个匹配。</td>
</tr>
<tr>
<td>p</td>
<td>打印行。</td>
</tr>
<tr>
<td>x</td>
<td>互换pattern space和holding buffer中的文本。</td>
</tr>
<tr>
<td>y</td>
<td>把一个字符翻译为另一个字符(但是不能用于正则表达式)。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed [-nefr] [动作]</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：取消默认输出。使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑；允许多点编辑。</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line"></span><br><span class="line">动作说明： [n1[,n2]]<span class="keyword">function</span></span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</span><br></pre></td></tr></table></figure>

<h3><span id="以行为单位的新增删除">以行为单位的新增/删除</span></h3><p>将 <code>/etc/passwd</code> 的内容列出并且列印行号，同时，将第 2~5 行删除！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# <span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2,5d&#x27;</span></span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">6 <span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure>
<p>sed 的动作为 <code>&#39;2,5d&#39;</code> ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！</p>
<p>只要删除第 2 行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2d&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>要删除第 3 到最后一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;3,$d&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>在第二行后(亦即是加在第三行)加上『drink tea』字样！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# <span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2a drink tea&#x27;</span></span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure>

<p>那如果是要在第二行前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2i drink tea&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>如果是要增加两行以上，在第二行后面加入两行字，例如『Drink tea or …..』与『drink beer』<br><strong>这里是 <code>\</code> 还是 <code>\&gt;</code> ?</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# <span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2a Drink tea or ......\</span></span><br><span class="line"><span class="string">&gt; drink beer ?&#x27;</span></span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Drink tea or ......</span><br><span class="line">drink beer ?</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure>
<p>每一行之间都必须要以反斜杠『 \ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在。</p>
<h3><span id="以行为单位的替换与显示">以行为单位的替换与显示</span></h3><p>将第2-5行的内容取代成为『No 2-5 number』</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# <span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;2,5c No 2-5 number&#x27;</span></span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">No 2-5 number</span><br><span class="line">6 <span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure>

<p>仅列出 /etc/passwd 文件内的第 5-7 行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# <span class="built_in">nl</span> /etc/passwd | sed -n <span class="string">&#x27;5,7p&#x27;</span></span><br><span class="line">5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">6 <span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></table></figure>

<h3><span id="数据的搜寻并显示">数据的搜寻并显示</span></h3><p>搜索 /etc/passwd有root关键字的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed <span class="string">&#x27;/root/p&#x27;</span></span><br><span class="line">1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">3  bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">4  sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line">5  <span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">....下面忽略</span><br></pre></td></tr></table></figure>
<p>如果root找到，除了输出所有行，还会输出匹配行。</p>
<p>使用-n的时候将只打印包含模板的行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed -n <span class="string">&#x27;/root/p&#x27;</span></span><br><span class="line">1  root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<h3><span id="数据的搜寻并删除">数据的搜寻并删除</span></h3><p>删除/etc/passwd所有包含root的行，其他行输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed  <span class="string">&#x27;/root/d&#x27;</span></span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">3  bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">....下面忽略</span><br><span class="line"><span class="comment">#第一行的匹配root已经删除了</span></span><br></pre></td></tr></table></figure>

<h3><span id="数据的搜寻并执行命令">数据的搜寻并执行命令</span></h3><p>找到匹配模式eastern的行后，<br>搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed -n <span class="string">&#x27;/root/&#123;s/bash/blueshell/;p&#125;&#x27;</span></span><br><span class="line">1  root:x:0:0:root:/root:/bin/blueshell</span><br></pre></td></tr></table></figure>
<p>如果只替换/etc/passwd的第一个bash关键字为blueshell，就退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed -n <span class="string">&#x27;/bash/&#123;s/bash/blueshell/;p;q&#125;&#x27;</span>    </span><br><span class="line">1  root:x:0:0:root:/root:/bin/blueshell</span><br></pre></td></tr></table></figure>
<p>最后的q是退出。</p>
<h3><span id="数据的搜寻并替换">数据的搜寻并替换</span></h3><p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/要被取代的字串/新的字串/g&#x27;</span></span><br></pre></td></tr></table></figure>

<p>先观察原始信息，利用 /sbin/ifconfig 查询 IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# /sbin/ifconfig eth0</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84</span><br><span class="line">inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line">inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link</span><br><span class="line">UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">.....(以下省略).....</span><br></pre></td></tr></table></figure>
<p>本机的ip是192.168.1.100。</p>
<p>将 IP 前面的部分予以删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep <span class="string">&#x27;inet addr&#x27;</span> | sed <span class="string">&#x27;s/^.*addr://g&#x27;</span></span><br><span class="line">192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br></pre></td></tr></table></figure>
<p>接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0<br>将 IP 后面的部分予以删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep <span class="string">&#x27;inet addr&#x27;</span> | sed <span class="string">&#x27;s/^.*addr://g&#x27;</span> | sed <span class="string">&#x27;s/Bcast.*$//g&#x27;</span></span><br><span class="line">192.168.1.100</span><br></pre></td></tr></table></figure>

<h3><span id="多点编辑">多点编辑</span></h3><p>一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nl</span> /etc/passwd | sed -e <span class="string">&#x27;3,$d&#x27;</span> -e <span class="string">&#x27;s/bash/blueshell/&#x27;</span></span><br><span class="line">1  root:x:0:0:root:/root:/bin/blueshell</span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br></pre></td></tr></table></figure>

<p><code>-e</code>表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p>
<h3><span id="直接修改文件内容危险动作">直接修改文件内容(危险动作)</span></h3><p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用下载的 regular_express.txt 文件来测试看看吧！</p>
<p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed -i <span class="string">&#x27;s/\.$/\!/g&#x27;</span> regular_express.txt</span><br></pre></td></tr></table></figure>

<p>利用 sed 直接在 regular_express.txt 最后一行加入『# This is a test』</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sed -i <span class="string">&#x27;$a # This is a test&#x27;</span> regular_express.txt</span><br></pre></td></tr></table></figure>

<p>由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增『# This is a test』！</p>
<p>sed 的『 -i 』选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>理解BNF</title>
    <url>/998d20b7/</url>
    <content><![CDATA[<h2><span id="bnf范式">BNF范式</span></h2><p>下面来自百度百科：</p>
<blockquote>
<p>巴科斯范式（BNF）所描述的语法是与上下文无关的。它具有语法简单，表示明确，便于语法分析和编译的特点。</p>
</blockquote>
<p>例：四则运算的BNF，&lt;&gt;表示非叶子节点，|表示或者关系，:=就是等于的意思。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;         | &lt;expr&gt; - &lt;term&gt;         | &lt;term&gt; &lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;         | &lt;term&gt; / &lt;factor&gt;         | &lt;factor&gt; &lt;factor&gt; ::= ( &lt;expr&gt; )           | Num</span><br></pre></td></tr></table></figure>

<p>可见，BNF本质上就是树形分解，分解成一棵名为AST的抽象语法树。  </p>
<hr>
<h3><span id="产生式">产生式</span></h3><p>BNF中的表达式叫做产生式。产生式就是将语法的分解规则表达出来的等式。如</p>
<blockquote>
<p>句子 = 主 + 谓 + 宾</p>
</blockquote>
<p>将语法规则用产生式描述出来是为了便于计算，产生式可以看作是对语法的数学建模。</p>
<p>产生式的特点是 <strong>不断向下分解</strong>。这种特点和数据结构中的树是一样的。<br>通过类比，有：</p>
<blockquote>
<ul>
<li>每个产生式就是一个子树，在写编译器时，每个子树对应一个解析函数。</li>
<li>叶子节点叫做 <strong>终结符</strong>，非叶子节点叫做 <strong>非终结符</strong>。</li>
</ul>
</blockquote>
<hr>
<h3><span id="递归">递归</span></h3><p>产生式分成递归的和非递归的，如果一个产生式用自己来表示自己就会产生递归。<br>递归地调用自己的定义来定义自己，是无穷尽的。<br>比如：</p>
<ul>
<li>GNU项目的命名GUN NOT UNIX；</li>
<li>A=A’b’（’b’表示字符常量b）。</li>
</ul>
<p><strong>问</strong>：<br>明明代码文本都是有限长的，为什么还要引入递归这种模型来解析，搞得很复杂？</p>
<p><strong>答</strong>：<br>实际的代码文本确实是有限长的。<br>但是，递归产生式只是定义了一个计算公式，通过这个计算公式，可以生成无穷种字符串。例如，四则运算可以用递归产生式来描述，它表示你可以写出无数个任意长的四则运算表达式，它是为了用一个公式来描述所有情况，是对实际规则的抽象与归纳。实际中，我们总不可能对每一种四则运算表达式都写一段解析代码，相反地，是所有四则运算表达式的解析都只用相同的解析程序。</p>
<p>递归又分为左递归和右递归，下面分别用图形的方式直观地进行描述。</p>
<hr>
<h4><span id="左递归">左递归</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202401072126463.png" alt="左递归图解"><br>如上图所示，产生式一直朝左侧延伸，无法结束，永远不会结束，所以叫左递归。<br>显然左递归无法分解出有限的叶子节点。<strong>尤其是，它永远无法得到第一个叶子节点。因为左侧在无限递归产生新的左叶子节点。</strong> 这个结论很重要，要<strong>牢记</strong>。</p>
<hr>
<h4><span id="右递归">右递归</span></h4><p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202401072130458.png" alt="右递归图解"><br>与左递归相反，右递归有第一个叶子节点，没有最后一个叶子节点。</p>
<hr>
<h4><span id="如何判断产生式有递归">如何判断产生式有递归？</span></h4><p>示意图如下：<br><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202401072131207.png" alt="产生式递归"><br>子节点和父节点相同叫<strong>直接左递归</strong>，子节点和非父节点的祖先相同叫<strong>间接左递归</strong>。</p>
<hr>
<h4><span id="递归为什么可以消除">递归为什么可以消除？</span></h4><p>因为<strong>某些</strong>左右递归可以相互转化，注意不是所有左右递归的都可以相互转化。具体是哪些呢，下面会说到，是包含终结符分支的递归表达式，终结符是转化的桥梁。</p>
<hr>
<h4><span id="为什么只需要消除左递归">为什么只需要消除左递归？</span></h4><p>我们需要明确第一个叶子节点的重要含义：第一个节点是语法的起点，所以第一个节点很重要，如果没有第一个叶子节点，那么就永远无法判断此语法是从哪个字符开始的。所以存在左递归的文法，是无法通过程序解析的，<strong>这样的程序无法实现</strong>。</p>
<p>相反地，右递归有第一个叶子节点，没有最后一个叶子节点。有第一个叶子节点就可以判断语法从哪个字符开始，但是不知道语法在何时结束。</p>
<p>但是，在实际解析中，因为被解析的文本是有限长的，所以右递归一定会停止。除此之外，因为右递归一定有起始符号，所以在解析文本时，一旦遇到非起始符的字符串，也会停止解析。也就是说，右递归能自动保证语法的正确性，而且不会无穷递归。</p>
<p>综上，只有左递归需要消除。</p>
<hr>
<h4><span id="如何消除左递归">如何消除左递归</span></h4><p>目前我们连产生式都不会写，怎么消除？所以接下来先把消除左递归的问题放一放，先弄清楚怎么编写产生式。</p>
<hr>
<h4><span id="怎么编写产生式">怎么编写产生式</span></h4><p>要明确一个重要规则：<strong>优先级高的产生式必然是需要先被计算的。</strong> 所以优先级越高（如乘除运算）的产生式，在BNF树中越靠近叶子节点。优先级越低（如加减运算）的产生式，在BNF树中越靠近根节点。所以优先级低的产生式一定会被分解成优先级高的产生式。</p>
<p>另外，产生式中<strong>不可分解的元素一定是在叶子节点</strong>，叶子节点没有子节点，无法分解。</p>
<p>综上：</p>
<blockquote>
<ul>
<li>BNF算法工作过程是，先向下分解到叶子节点，再从叶子节点沿着分解时的路径/调用堆栈向上反向计算。</li>
<li>产生式优先级和在BNF树中的深度成正比。</li>
<li>叶子节点有两种，一种是不可分解的元素，一种是优先级最高的元素。</li>
</ul>
</blockquote>
<p>以四则运算为例，双括号()的优先级最高，乘除运算*/的优先级其次，加减运算的优先级最低。从下面的四则运算的BNF可以看出，一个表达式是先分解成±运算，然后分解成乘除运算 */，最后再分解为Expr，这表明我们的理解是正确的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;         | &lt;expr&gt; - &lt;term&gt;         | &lt;term&gt; </span><br><span class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;         | &lt;term&gt; / &lt;factor&gt;         | &lt;factor&gt; </span><br><span class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )           | Num</span><br></pre></td></tr></table></figure>

<p>根据以上思想，下面具体描述产生式的编写过程。</p>
<h5><span id="四则运算表达式编写">四则运算表达式编写</span></h5><p>问：</p>
<blockquote>
<p>已知Expr支持形如5+3 * (2+1)的运算表达式，即支持运算优先级，乘除高于加减，支持括号括起来的子表达式。求产生式。</p>
</blockquote>
<p>答：</p>
<blockquote>
<ul>
<li>5为Num，3为Num，(2 + 1)为含括号的子表达式(Expr)</li>
<li>Num、(Expr)优先级最高，所以做叶子节点，把他们统称为Factor，即<br>Factor=Num | (Expr)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>次高优先级的运算为乘除运算*/，表达式称为Term，基本运算元素为上一步的Factor，有<ul>
<li>当乘除运算符个数为0时，Term = Factor</li>
<li>当乘除运算符个数为1时，Term = Factor * Factor | Factor / Factor，将上式Term = Factor带入得 Term = Term * Factor | Term / Factor（左递归）。</li>
<li>当乘除运算符个数大于1时，<br>Term = Factor * Factor / Factor …* Factor = (Factor * Factor / Factor…) * Factor =Term * Factor<br>或<br>Term = Factor * Factor / Factor…/ Factor = (Factor * Factor / Factor…) / Factor = Term / Factor。<br>于是运算符个数 &gt;= 1时，具有相同产生式。综合得出：<br>Term = Term * Factor | Term / Factor | Factor</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>最低优先级的运算为加减运算±，表达式称为Expr，基本运算元素为上一步的Term，有<ul>
<li>当加减运算符的个数为0时，Expr = Term</li>
<li>当加减运算符的个数为1时，Expr = Term + Term | Term - Term，把上式代入得，<br>Expr = Expr + Term | Expr - Term</li>
<li>当加减运算符的个数大于1时，Expr = Term + Term - Term…+ Term = (Term + Term - Term…) + Term = Expr + Term，或 Expr = Term + Term - Term…- Term = (Term + Term - Term…) - Term = Expr - Term<br>于是运算符个数 &gt;= 1时，具有相同产生式。综合得出：<br>Expr = Expr + Term | Expr - Term | Term</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h4><span id="消除左递归">消除左递归</span></h4><p>上面我们已经推导出四则运算的产生式了，但是产生式中存在之前说的左递归。具有左递归的产生式是无法用来解析代码的，所以需要消除左递归。<br>如何消除左递归呢？前面说过，用非递归的部分来表示左递归的部分就可以了。如果没有非递归部分，就无法消除左递归。就相当于一条路走不通，绕个弯子走另一条路。如果没有一条路可以走，就是真的无路可走。</p>
<p>消除直接左递归（省略号…表示无数次重复）：</p>
<blockquote>
<p>现有直接左递归：A = Aa | b，<br>即A=A…a ，右边的A用b替换掉，等价于： A = ba…a = ba…<br>消除了左递归，即消除A =…a，只剩下A = ba…。<br>此时A的产生式为：A = bAtail，Atail是除了开始符号b剩下的部分。<br>那剩下的部分是什么呢？Atail = a…（右递归），即Atail = aAtail。右递归是可以处理的。<br>综上直接左递归消除方法是：<br>A = Aa | b =&gt;消除左递归 =&gt; A = bA’， A’=aA’</p>
</blockquote>
<p>由此可见，终结符是转化的桥梁。</p>
<p>消除间接左递归：</p>
<blockquote>
<p>思路就是使用变量代换将间接左递归写成直接左递归，然后消除直接左递归。、</p>
</blockquote>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】用 Tekton 在 Kubernetes 中编写你的第一条 CI/CD 流水线</title>
    <url>/2966fc1/</url>
    <content><![CDATA[<blockquote>
<p>Tekton 是一个用于创建持续集成和持续交付（CI/CD）系统的 Kubernetes 原生开源框架。</p>
</blockquote>
<p><img src="https://img.linux.net.cn/data/attachment/album/202304/01/180822blxgx0c1k43n4kl4.jpg" alt></p>
<p>Tekton 是一个用于创建持续集成和持续交付（CI/CD）系统的 Kubernetes 原生开源框架。通过对底层实施细节的抽象，它还可以帮助你在多个云供应商或企业内部系统中进行端到端（构建、测试、部署）应用开发。</p>
<h3><span id="tekton-介绍">Tekton 介绍</span></h3><p><a href="https://github.com/tektoncd/pipeline">Tekton</a> 最初被称为 <a href="https://github.com/knative/build">Knative Build</a>，后来被重组为独立的开源项目，有自己的 <a href="https://cd.foundation/">治理组织</a>，现在是属于 <a href="https://www.linuxfoundation.org/projects/">Linux 基金会</a> 的项目。Tekton 提供了一个集群内的容器镜像构建和部署工作流程，换句话说，它是一个 <ruby>持续集成<rt>continuous integration</rt></ruby>（CI）和 <ruby>持续交付<rt>continuous delivery</rt></ruby>（CD）服务。它由 Tekton 流水线和几个支持组件如 Tekton CLI、Triggers 和 Catalog 等组成。</p>
<p>Tekton 是一个 Kubernetes 原生应用。它在 Kubernetes 集群中作为扩展被安装和运行，由一套Kubernetes 定制化资源组成，定义了你为流水线创建和复用的构建块。由于 Tekton 是一种 Kubernetes 原生技术，所以它非常容易扩展。当你需要增加你的工作负载时，你只需向你的集群添加节点就可以了。由于其可扩展的设计和社区贡献的组件库，它也很容易定制。</p>
<p>对于需要 CI/CD 系统来开展工作的开发人员，和为其组织内的开发人员建立 CI/CD 系统的平台工程师，Tekton 是理想选择。</p>
<h3><span id="tekton-组件">Tekton 组件</span></h3><p>构建 CI/CD 流水线的过程非常复杂，因此 Tekton 为每一步都提供工具。以下是 Tekton 提供的主要组件：</p>
<ul>
<li><ruby>流水线<rt></rt>Pipeline</ruby>： 定义了一组 Kubernetes <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">自定义资源</a>，作为你用来组装 CI/CD 流水线的构建块。</li>
<li><ruby>触发器<rt>Triggers</rt></ruby>：一种 Kubernetes 自定义资源，允许你根据从事件有效载荷中提取的信息来创建流水线。例如，你可以在每次创建 Git 仓库的合并请求时，触发流水线的实例化和执行。</li>
<li><ruby>命令行<rt>CLI</rt></ruby>：提供一个名为 <code>tkn</code> 的命令行界面，你可以使用它从终端与 Tekton 进行交互。</li>
<li><ruby>仪表盘<rt>Dashboard</rt></ruby>：是 Tekton 流水线的一个基于网页的图形界面，显示流水线的执行信息。</li>
<li><ruby>目录<rt>Catalog</rt></ruby>：是一个高质量的、由社区贡献的 Tekton 构建块（任务、流水线等），可在你自己的流水线中使用。</li>
<li><ruby>中心<rt>Hub</rt></ruby>：是一个基于网页的图形界面，用于访问 Tekton 目录。</li>
<li><ruby>操作员<rt>Operator</rt></ruby>：是一种 Kubernetes <a href="https://operatorhub.io/what-is-an-operator">操作员模式</a>，你可以在 Kubernetes 集群中安装、更新、升级和删除 Tekton 项目。</li>
<li><ruby>链<rt>Chains</rt></ruby>：是一个 Kubernetes <ruby>自定义资源定义<rt>Custom Resource Definition</rt></ruby>（CRD）控制器，使你可以在 Tekton 中处理供应链安全的问题。正在开发中。</li>
<li><ruby>结果<rt>Results</rt></ruby>：旨在帮助用户对 CI/CD 工作负载历史进行逻辑分组，并将长期结果的存储从流水线控制器中分离出来。</li>
</ul>
<h3><span id="tekton-术语">Tekton 术语</span></h3><p><img src="https://opensource.com/sites/default/files/uploads/tekto-terminology.png" alt="Tekton terminology" title="Tekton terminology"></p>
<ul>
<li><ruby>步骤<rt>Step</rt></ruby>：是 CI/CD 工作流程中最基本的实体，例如为 Python 网络应用程序运行一些单元测试或编译一个 Java 程序。Tekton 使用容器镜像执行每个步骤。</li>
<li><ruby>任务<rt>Task</rt></ruby>：:** 是按特定顺序排列的步骤的集合。Tekton 以 <a href="https://kubebyexample.com/en/concept/pods">Kubernetes 容器荚</a> 的形式运行任务，其中每个步骤都成为 <ruby>容器荚<rt>pod</rt></ruby> 中的一个运行容器。<ul>
<li><ruby>流水线<rt>Pipelines</rt></ruby>：是按特定顺序排列的任务的集合。Tekton 把所有任务连接成一个 <ruby>有向无环图<rt>directed acyclic graph</rt></ruby>（DAG），并按顺序执行图。换句话说，它创建了一些 Kubernetes 容器荚，并确保每个容器荚按预期成功运行。</li>
</ul>
</li>
</ul>
<p><img src="https://opensource.com/sites/default/files/uploads/tekton-pipelines.png" alt="Tekton pipelines" title="Tekton pipelines"></p>
<ul>
<li><ruby>流水线运行<rt>PipelineRun</rt></ruby>：顾名思义，是一条流水线的具体执行。</li>
<li><ruby>任务运行<rt>TaskRun</rt></ruby>：是一个任务的具体执行。你可以选择在流水线外运行一次任务运行，可以通过它查看任务中每个步骤执行的具体情况。</li>
</ul>
<h3><span id="创建你的-cicd-流水线">创建你的 CI/CD 流水线</span></h3><p>开始使用 Tekton 的最简单方法是自己编写一个简单的流水线。如果你每天都在使用 Kubernetes，那你可能对 YAML 很熟悉，这正是 Tekton 流水线的定义方式。下面是一个克隆代码库的简单流水线的例子。</p>
<p>首先，创建一个 <code>task.yaml</code> 文件，用你喜欢的文本编辑器打开它。这个文件定义了你要执行的 <ruby>步骤<rt>Step</rt></ruby>。在这个例子中，就是克隆一个仓库，所以我把这个步骤命名为 “clone”。该文件设置了一些环境变量，然后使用一个简单的 shell 脚本来执行克隆。</p>
<p>接下来是 <ruby>任务<rt>Task</rt></ruby>。你可以把步骤看作是一个被任务调用的函数，而任务则设置步骤所需的参数和工作空间。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">tekton.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Task</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">git-clone</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">workspaces:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">output</span></span><br><span class="line">     <span class="attr">description:</span> <span class="string">The</span> <span class="string">git</span> <span class="string">repo</span> <span class="string">will</span> <span class="string">be</span> <span class="string">cloned</span> <span class="string">onto</span> <span class="string">the</span> <span class="string">volume</span> <span class="string">backing</span> <span class="string">this</span> <span class="string">Workspace.</span></span><br><span class="line"> <span class="attr">params:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">url</span></span><br><span class="line">     <span class="attr">description:</span> <span class="string">Repository</span> <span class="string">URL</span> <span class="string">to</span> <span class="string">clone</span> <span class="string">from.</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">revision</span></span><br><span class="line">     <span class="attr">description:</span> <span class="string">Revision</span> <span class="string">to</span> <span class="string">checkout.</span> <span class="string">(branch,</span> <span class="string">tag,</span> <span class="string">sha,</span> <span class="string">ref,</span> <span class="string">etc...)</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">     <span class="attr">default:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="attr">steps:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">clone</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">&quot;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0&quot;</span></span><br><span class="line">     <span class="attr">env:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PARAM_URL</span></span><br><span class="line">         <span class="attr">value:</span> <span class="string">$(params.url)</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PARAM_REVISION</span></span><br><span class="line">         <span class="attr">value:</span> <span class="string">$(params.revision)</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORKSPACE_OUTPUT_PATH</span></span><br><span class="line">         <span class="attr">value:</span> <span class="string">$(workspaces.output.path)</span></span><br><span class="line">     <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line">      <span class="comment">#!/usr/bin/env sh</span></span><br><span class="line">       <span class="string">set</span> <span class="string">-eu</span></span><br><span class="line"></span><br><span class="line">       <span class="string">CHECKOUT_DIR=&quot;$&#123;WORKSPACE_OUTPUT_PATH&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="string">/ko-app/git-init</span> <span class="string">\</span></span><br><span class="line">         <span class="string">-url=&quot;$&#123;PARAM_URL&#125;&quot;</span> <span class="string">\</span></span><br><span class="line">         <span class="string">-revision=&quot;$&#123;PARAM_REVISION&#125;&quot;</span> <span class="string">\</span></span><br><span class="line">         <span class="string">-path=&quot;$&#123;CHECKOUT_DIR&#125;&quot;</span></span><br><span class="line">       <span class="string">cd</span> <span class="string">&quot;$&#123;CHECKOUT_DIR&#125;&quot;</span></span><br><span class="line">       <span class="string">EXIT_CODE=&quot;$?&quot;</span></span><br><span class="line">       <span class="string">if</span> [ <span class="string">&quot;$&#123;EXIT_CODE&#125;&quot;</span> <span class="type">!=</span> <span class="number">0</span> ] <span class="string">;</span> <span class="string">then</span></span><br><span class="line">         <span class="string">exit</span> <span class="string">&quot;$&#123;EXIT_CODE&#125;&quot;</span></span><br><span class="line">       <span class="string">fi</span></span><br><span class="line">       <span class="comment"># Verify clone is success by reading readme file.</span></span><br><span class="line">       <span class="string">cat</span> <span class="string">$&#123;CHECKOUT_DIR&#125;/README.md</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建第二个文件 <code>pipeline.yaml</code>，并用你喜欢的文本编辑器打开它。这个文件通过设置诸如可以运行和处理任务的工作区等重要参数来定义流水线。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">tekton.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pipeline</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">cat-branch-readme</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">params:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">repo-url</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">     <span class="attr">description:</span> <span class="string">The</span> <span class="string">git</span> <span class="string">repository</span> <span class="string">URL</span> <span class="string">to</span> <span class="string">clone</span> <span class="string">from.</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">branch-name</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">     <span class="attr">description:</span> <span class="string">The</span> <span class="string">git</span> <span class="string">branch</span> <span class="string">to</span> <span class="string">clone.</span></span><br><span class="line"> <span class="attr">workspaces:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">     <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">This</span> <span class="string">workspace</span> <span class="string">will</span> <span class="string">receive</span> <span class="string">the</span> <span class="string">cloned</span> <span class="string">git</span> <span class="string">repo</span> <span class="string">and</span> <span class="string">be</span> <span class="string">passed</span></span><br><span class="line">       <span class="string">to</span> <span class="string">the</span> <span class="string">next</span> <span class="string">Task</span> <span class="string">for</span> <span class="string">the</span> <span class="string">repo&#x27;s</span> <span class="string">README.md</span> <span class="string">file</span> <span class="string">to</span> <span class="string">be</span> <span class="string">read.</span></span><br><span class="line"> <span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fetch-repo</span></span><br><span class="line">     <span class="attr">taskRef:</span></span><br><span class="line">       <span class="attr">name:</span> <span class="string">git-clone</span></span><br><span class="line">     <span class="attr">workspaces:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">output</span></span><br><span class="line">         <span class="attr">workspace:</span> <span class="string">shared-data</span></span><br><span class="line">     <span class="attr">params:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">url</span></span><br><span class="line">         <span class="attr">value:</span> <span class="string">$(params.repo-url)</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">revision</span></span><br><span class="line">         <span class="attr">value:</span> <span class="string">$(params.branch-name)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，创建一个 <code>pipelinerun.yaml</code> 文件，用喜欢的文本编辑器打开它。这个文件真正的运行流水线。它调用流水线中定义的参数（继而调用任务文件中定义的任务）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">tekton.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PipelineRun</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">git-clone-checking-out-a-branch</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">pipelineRef:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">cat-branch-readme</span></span><br><span class="line"> <span class="attr">workspaces:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-data</span></span><br><span class="line">     <span class="attr">volumeClaimTemplate:</span></span><br><span class="line">       <span class="attr">spec:</span></span><br><span class="line">         <span class="attr">accessModes:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">         <span class="attr">resources:</span></span><br><span class="line">           <span class="attr">requests:</span></span><br><span class="line">             <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"> <span class="attr">params:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">repo-url</span></span><br><span class="line">     <span class="attr">value:</span> <span class="string">&lt;https://github.com/tektoncd/pipeline.git&gt;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">branch-name</span></span><br><span class="line">     <span class="attr">value:</span> <span class="string">release-v0.12.x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把不同工作分在不同的文件中的好处是，<code>git-clone</code> 任务可以在多条流水线中复用。</p>
<p>例如，假设你想为一个流水线项目做端到端的测试。你可以使用 <code>git-clone</code> 任务 <strong>来让每一次测试都基于最新的代码</strong>。</p>
<h3><span id="总结">总结</span></h3><p>只要你熟悉 Kubernetes，那 Tekton 对你来说就像其他 Kubernetes 原生应用一样简单。它有很多工具可以帮助你创建流水线并与之交互。如果你喜欢自动化，不妨试试 Tekton!</p>
<hr>
<p>via: <a href="https://opensource.com/article/21/11/cicd-pipeline-kubernetes-tekton">https://opensource.com/article/21/11/cicd-pipeline-kubernetes-tekton</a></p>
<p>作者：<a href="https://opensource.com/users/savita-ashture">Savita Ashture</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>目录切换：dirs、pushd、popd命令</title>
    <url>/1ca354f7/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#目录栈指令">目录栈指令</a><ul>
<li><a href="#1-dirs">1 dirs</a><ul>
<li><a href="#11-功能">1.1 功能</a></li>
<li><a href="#12-语法">1.2 语法</a></li>
</ul>
</li>
<li><a href="#2-pushd">2 pushd</a><ul>
<li><a href="#21-功能">2.1 功能</a></li>
<li><a href="#22-语法">2.2 语法</a></li>
</ul>
</li>
<li><a href="#3-popd">3 popd</a><ul>
<li><a href="#31-功能">3.1 功能</a></li>
<li><a href="#32-语法">3.2 语法</a></li>
</ul>
</li>
<li><a href="#4-示例">4 示例</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="目录栈指令">目录栈指令</span></h2><p>目录栈是用户最近访问过的系统目录列表，并以堆栈的形式管理。栈中的内容与Shell环境变量 <code>DIRSTACK</code> 的值对应</p>
<h3><span id="1-dirs">1 dirs</span></h3><h4><span id="11-功能">1.1 功能</span></h4><p>显示当前目录栈中的所有记录（不带参数的dirs命令显示当前目录栈中的记录）</p>
<h4><span id="12-语法">1.2 语法</span></h4><p><strong>格式：</strong></p>
<p><code>dirs [-clpv] [+n] [-n]</code></p>
<p><strong>选项</strong></p>
<ul>
<li>-c  删除目录栈中的所有记录</li>
<li>-l   以完整格式显示(绝对路径)</li>
<li>-p  一个目录一行的方式显示</li>
<li>-v  每行一个目录来显示目录栈的内容，每个目录前加上的编号</li>
<li>+N 显示从左到右的第n个目录，数字从0开始</li>
<li>-N  显示从右到左的第n个日录，数字从0开始</li>
</ul>
<p>注意：dirs始终显示当人们目录, 再是堆栈中的内容；即使目录堆栈为空, dirs命令仍然只显示当前目录</p>
<h3><span id="2-pushd">2 pushd</span></h3><h4><span id="21-功能">2.1 功能</span></h4><p>将目录加入到栈顶部，并切换到该目录；若 <code>pushd</code> 命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置</p>
<h4><span id="22-语法">2.2 语法</span></h4><p><strong>格式：</strong></p>
<p><code>pushd [目录 | -N | +N]  [-n]</code></p>
<p><strong>选项</strong></p>
<ul>
<li>目录  将该目录加入到栈顶，并执行”cd 目录”，切换到该目录</li>
<li>+N  将第N个目录移至栈顶（从左边数起，数字从0开始）</li>
<li>-N  将第N个目录移至栈顶（从右边数起，数字从0开始）</li>
<li>-n  将目录入栈时，不切换目录</li>
</ul>
<h3><span id="3-popd">3 popd</span></h3><h4><span id="31-功能">3.1 功能</span></h4><p>删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录</p>
<h4><span id="32-语法">3.2 语法</span></h4><p><strong>格式：</strong></p>
<p><code>pushd [-N | +N]  [-n]</code></p>
<p><strong>选项</strong></p>
<ul>
<li>+N  将第N个目录删除（从左边数起，数字从0开始）</li>
<li>-N  将第N个目录删除（从右边数起，数字从0开始）</li>
<li>-n  将目录出栈时，不切换目录</li>
</ul>
<h3><span id="4-示例">4 示例</span></h3><p><strong>入栈与出栈</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@root]:~# <span class="built_in">mkdir</span> /root/dir&#123;1,2,3,4&#125;</span><br><span class="line">[root@root]:~# <span class="keyword">for</span> ((i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)); <span class="keyword">do</span> <span class="built_in">pushd</span> /root/dir<span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span></span><br><span class="line">/root/dir1 ~</span><br><span class="line">/root/dir2 /root/dir1 ~</span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]# <span class="built_in">dirs</span> </span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line"><span class="built_in">dirs</span>显出了栈中的所有目录</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]# <span class="built_in">popd</span>（相当于<span class="built_in">popd</span> +0）</span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">[root@root:/root/dir3]# <span class="built_in">dirs</span></span><br><span class="line">/root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">可以看出/root/dir4目录已被清除，此时栈里已经没有了dir4目录，切当前目录切换为dir3</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir3]# <span class="built_in">pushd</span> /root/dir4 </span><br><span class="line">/root/dir4 /root/dir3 /root/dir2 /root/dir1 ~</span><br><span class="line">[root@root:/root/dir4]</span><br><span class="line">不推荐以上面的方法进行切换，因为这种方式和<span class="built_in">cd</span>没有区别。</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]# <span class="built_in">popd</span> +1</span><br><span class="line">/root/dir4 /root/dir2 /root/dir1 ~</span><br><span class="line">推荐以这种方式进行切换，尤其是目录层次比较多时</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir4]# <span class="built_in">popd</span> -2</span><br><span class="line">/root/dir4 /root/dir1 ~</span><br><span class="line"></span><br><span class="line">[root@root:/root/dir2]# <span class="built_in">pushd</span> -1</span><br><span class="line">/root/dir1 ~ /root/dir2 /root/dir3 /root/dir4</span><br><span class="line">[root@root:/root/dir3]</span><br><span class="line">注意：最左边表示栈顶，最右边表示栈底</span><br></pre></td></tr></table></figure>



<p><strong>清空栈</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@root]:~# <span class="built_in">dirs</span></span><br><span class="line">~ /root/dir2 /root/dir3 /root/dir4 /root/dir1</span><br><span class="line">[root@root]:~# <span class="built_in">dirs</span> -c</span><br><span class="line">[root@root](mailto:root@root):~# <span class="built_in">dirs</span></span><br><span class="line">~</span><br></pre></td></tr></table></figure>



<p><strong>列表形式显示的栈的内容</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@root:/root/dir4]# <span class="built_in">dirs</span> -l -v</span><br><span class="line">0 /root/dir4</span><br><span class="line">1 /root/dir3</span><br><span class="line">2 /root/dir2</span><br><span class="line">3 /root/dir1</span><br><span class="line">4 /root</span><br></pre></td></tr></table></figure>



<p>注：如果只是两个目录之间的切换 <code>cd -</code>足矣，而且方便。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止root用户ssh登录机器</title>
    <url>/d29ba5b9/</url>
    <content><![CDATA[<p>1 修改 /etc/ssh/sshd_config <code>#PermitRootLogin yes</code> 取消注释并改为 <code>PermitRootLogin no</code></p>
<p>2 重启ssh <code>/etc/init.d/sshd restart</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统优化思路</title>
    <url>/bcca3074/</url>
    <content><![CDATA[<h3><span id="一-秒杀业务为什么难做">一、秒杀业务为什么难做</span></h3><p>1）im系统，例如qq或者微博，每个人都读自己的数据（好友列表、群列表、个人信息）； 2）微博系统，每个人读你关注的人的数据，一个人读多个人的数据； 3）秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据。</p>
<p>例如：小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。 又例如：12306抢票，票是有限的，库存一份，瞬时流量非常多，都读相同的库存。读写冲突，锁非常严重，这是秒杀业务难的地方。那我们怎么优化秒杀业务的架构呢？</p>
<h3><span id="二-优化方向">二、优化方向</span></h3><p>优化方向有两个（今天就讲这两个点）： （1）将请求尽量拦截在系统上游（不要让锁冲突落到数据库上去）。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小。以12306为例，一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0。</p>
<p>（2）充分利用缓存，秒杀买票，这是一个典型的读多写少的应用场景，大部分请求是车次查询，票查询，下单和支付才是写请求。一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。好，后续讲讲怎么个“将请求尽量拦截在系统上游”法，以及怎么个“缓存”法，讲讲细节。</p>
<h3><span id="三-常见秒杀架构">三、常见秒杀架构</span></h3><p>（1）浏览器端，最上层，会执行到一些JS代码 （2）站点层，这一层会访问后端数据，拼html页面返回给浏览器 （3）服务层，向上游屏蔽底层数据细节，提供数据访问 （4）数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）</p>
<h3><span id="四-各层次优化细节">四、各层次优化细节</span></h3><h4><span id="第一层客户端怎么优化浏览器层app层">第一层，客户端怎么优化（浏览器层，APP层）</span></h4><p>微信的摇一摇抢红包，每次摇一摇，就会往后端发送请求么？下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？</p>
<p>（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求； （b）JS层面，限制用户在x秒之内只能提交一次请求；</p>
<p>APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？</p>
<h4><span id="第二层站点层面的请求拦截">第二层，站点层面的请求拦截</span></h4><p>怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</p>
<p>5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。</p>
<p>页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。</p>
<p>好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p>
<h4><span id="第三层-服务层来拦截反正就是不要让请求落到数据库上去">第三层 服务层来拦截（反正就是不要让请求落到数据库上去）</span></h4><p>服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！</p>
<p>对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）</p>
<p>1w部手机，只透1w个下单请求去db</p>
<p>3k张火车票，只透3k个下单请求去db</p>
<p>如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。</p>
<p>对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。</p>
<p>当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，…每隔半个小时放出一批：将流量摊匀。</p>
<p>其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。</p>
<p>第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。</p>
<h4><span id="第四层-最后是数据库层">第四层 最后是数据库层</span></h4><p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。</p>
<p>全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。</p>
<h3><span id="五-总结">五、总结</span></h3><p>上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路： （1）尽量将请求拦截在系统上游（越上游越好）； （2）读多写少的常用多使用缓存（缓存抗读压力）；</p>
<p>浏览器和APP：做限速</p>
<p>站点层：按照uid做限速，做页面缓存</p>
<p>服务层：按照业务做写请求队列控制流量，做数据缓存</p>
<p>数据层：闲庭信步</p>
<p>并且：结合业务做优化</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理一</title>
    <url>/a66c6839/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#什么是编译原理">什么是编译原理</a></li>
<li><a href="#编译与计算机程序设计语言的关系">编译与计算机程序设计语言的关系</a><ul>
<li><a href="#程序设计语言的转换方式">程序设计语言的转换方式</a></li>
<li><a href="#编译的转换过程">编译的转换过程</a></li>
</ul>
</li>
<li><a href="#编译器在语言处理系统中的位置">编译器在语言处理系统中的位置</a></li>
<li><a href="#编译系统的结构">编译系统的结构</a><ul>
<li><a href="#词法分析扫描">词法分析(扫描)</a></li>
<li><a href="#语法分析parsing">语法分析(parsing)</a><ul>
<li><a href="#语法分析的定义">语法分析的定义</a></li>
<li><a href="#语法分析的规则">语法分析的规则</a></li>
<li><a href="#语法分析的方法">语法分析的方法</a></li>
<li><a href="#语法树">语法树</a></li>
</ul>
</li>
<li><a href="#语义分析">语义分析</a><ul>
<li><a href="#一-收集标识符的属性信息">一. 收集标识符的属性信息</a></li>
<li><a href="#二-语义检查">二. 语义检查</a></li>
</ul>
</li>
<li><a href="#中间代码生成">中间代码生成</a><ul>
<li><a href="#常用的中间代码表示形式">常用的中间代码表示形式</a></li>
</ul>
</li>
<li><a href="#代码优化">代码优化</a></li>
<li><a href="#目标代码生成">目标代码生成</a></li>
<li><a href="#其他">其他</a><ul>
<li><a href="#出错处理">出错处理</a></li>
<li><a href="#遍">遍</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#编译程序生成">编译程序生成</a></li>
</ul>
<!-- tocstop -->

<h2><span id="什么是编译原理">什么是编译原理</span></h2><p>编译原理是介绍如何将高级程序设计语言转换成计算机硬件能识别的机器语言，以便计算机进行处理</p>
<h2><span id="编译与计算机程序设计语言的关系">编译与计算机程序设计语言的关系</span></h2><p>日常开发过程中我们使用的语言一般都是高级语法比如 JAVA、Python、PHP、JavaScript等等，但是计算机只能识别0、1这样的机器码。那么这些高级语言是如何翻译成机器能识别的0、1等呢？这就用的了<strong>编译</strong>，首先我们通过下面这幅图看下编译与计算机程序语言的关系，有助于我们直观的了解编译的作用。  </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242238073.png" alt></p>
<p>注意：每种机器都对应一种汇编语言</p>
<h3><span id="程序设计语言的转换方式">程序设计语言的转换方式</span></h3><p><strong>翻译</strong>：指把某种语言的源程序，<strong>在不改变语义的条件下</strong>，转换成另一种语言程序即目标语言程序</p>
<p>真正的实现有两种方式，编译及解释</p>
<ul>
<li><strong>编译</strong>：专指由高级语言转换为低级语言，<strong>整个程序翻译</strong>。常用的例如： c、c++，delphi,Fortran、Pascal、Ada</li>
<li><strong>解释</strong>：接受某种高级语言的一个语句输入，进行解释并控制计算机执行，马上得到这个句子的执行结果，然后再接受下一个语句。类似口译，<strong>一句一句进行解释</strong>。常用的例如：python 解释以源程序作为输入，<strong>不产生目标程序</strong>，一边解释一边执行。<strong>优点</strong>：直观易懂，结构简单，易于实现人机对话。<strong>缺点</strong>：效率低(不产生目标程序，每次都需要重新执行，速度慢)</li>
</ul>
<h3><span id="编译的转换过程">编译的转换过程</span></h3><ul>
<li>编译-&gt;运行</li>
<li>编译-&gt;汇编-&gt;运行 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242240217.png" alt></p>
<h2><span id="编译器在语言处理系统中的位置">编译器在语言处理系统中的位置</span></h2><p>了解了编译与程序设计语言的关系，那么我们接下来再来看下编译器在语言处理系统中所处位置，如下图 </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242243681.png" alt></p>
<h2><span id="编译系统的结构">编译系统的结构</span></h2><p>那么机器是如何把高级语言翻译为汇编语言程序或机器语言程序的呢？</p>
<p>我们先来看下人工进行英文翻译的例子，这里引用的哈工大编译原理中的图示 </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242245950.png" alt></p>
<p> 图中的<strong>中间表示很重要主要起到了一个桥梁的作用</strong>，比如图中的中间表示可以使用各种语言表示。</p>
<p>根据上图可以看出要进行语义分析首先需要划分句子成分，那么我们是如何划分句子成分的呢？</p>
<ol>
<li>首先通过<strong>词法分析分析出句子中各个单词的词性或者词类</strong></li>
<li>接下来通过<strong>语法分析识别出句子中的各类短语从而获得句子的结构</strong></li>
<li>然后进行<strong>语义分析根据句子结构分析出句子中各个短语在句子中充当什么成分</strong>，从而确定各个名词性成分同各个核心谓语动词间的关系语意关系</li>
<li>最后给出中间表示形式  <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242246694.png" alt>  <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242250835.png" alt> 实际上编译器在工作的时候也是经过了以上几个步骤，我们成为<strong>阶段(计算机的逻辑组织方式，在实现过程中多个阶段可能会被组合在一起实现)</strong>，可以分为两大部分：<strong>分析源语言、生成目标代码</strong>,在编译器中他们分别对应编译器的前端和后端两个部分。编译器的结构如下图   <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242248147.png" alt> 了解了编译器的结构，让我们从编译器的前端开始讲起，看看词法分析、语法分析、语义分析等各个阶段都做了什么。</li>
</ol>
<h3><span id="词法分析扫描">词法分析(扫描)</span></h3><p>编译的第一个阶段，从左到右逐行扫描源程序的字符，识别出各个<strong>单词</strong>(是高级语言中有是在意义的最小语法单元，由字符构成)，<strong>确定单词的类型</strong>。将识别的单词转换成统一的机内表示即<strong>词法单元 简称Token</strong></p>
<p>token:&lt;种别码，属性值&gt;token: &lt;种别码，属性值&gt;</p>
<table>
<thead>
<tr>
<th></th>
<th>单词类型</th>
<th>种别</th>
<th>种别码</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>关键字</td>
<td>program、if、else、then…</td>
<td>一词一码</td>
</tr>
<tr>
<td>2</td>
<td>标识符</td>
<td>变量名、数组名、记录名、过程名…</td>
<td>多词一码</td>
</tr>
<tr>
<td>3</td>
<td>常量</td>
<td>整型、浮点型、字符型、布尔型…</td>
<td>一型一码</td>
</tr>
<tr>
<td>4</td>
<td>运算符</td>
<td>算术（+ - * / ++ –）<br>关系（&gt; &lt; == != &gt;= &lt;=） <br>逻辑（&amp; | ~）</td>
<td>一词一码<br>或<br>一型一码</td>
</tr>
<tr>
<td>5</td>
<td>界限符</td>
<td>; ( ) = { }</td>
<td>一词一码</td>
</tr>
</tbody></table>
<p> <strong>名字解释</strong></p>
<ul>
<li><p><strong>一词一码</strong>：例如，关键字是唯一的且事先可以确定，为每个关键字分配一个种别码</p>
</li>
<li><p><strong>多词一码</strong>：例如，所有的标示符统一作为一类单词分配同一个种别码，为了区分不同的标示符，用token的第二个分量“属性值”存放不同标示符具体的字面值</p>
</li>
<li><p><strong>一型一码</strong>：不同类型的常量他们的构成方式是不同的，例如，我们为每种类型的常量分配一个种别码，为了区分同一类型下的不同常量，也用token的第二个分量“属性值”存放每个常量具体的值 下面图中是一个词法分析后得到的token序列的例子 </p>
</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242300575.png" alt> </p>
<p>  描述词法规则的有效工具是<strong>正规式</strong>和<strong>有限自动机</strong>。<strong>正规式</strong>:用来确定单词是否和程序语言规范。<strong>有限自动机</strong>：通过有限自动机进行单词和正规式比较</p>
<h3><span id="语法分析parsing">语法分析(parsing)</span></h3><h4><span id="语法分析的定义">语法分析的定义</span></h4><p>语法分析器从词法分析器输出的<strong>token序列中识别出各类短语，并构造语法分析树</strong>(parse tree),语法分析树描述了<strong>句子的语法结构</strong></p>
<h4><span id="语法分析的规则">语法分析的规则</span></h4><p>即<strong>语法规则</strong>又称<strong>文法</strong>，规定了单词如何构成短语、句子、过程和程序。</p>
<p>语法规则的标示如下，含义是A定义为B或者C</p>
<p>BNF:A::=B∣CBNF:A::=B|C</p>
<p>&lt;句子&gt;::=&lt;主&gt;&lt;谓&gt;&lt;宾&gt;&lt;句子&gt;::=&lt;主&gt;&lt;谓&gt;&lt;宾&gt;</p>
<p>&lt;主&gt;::=&lt;定&gt;&lt;名&gt;&lt;主&gt;::=&lt;定&gt;&lt;名&gt;</p>
<p>来看下赋值语句的语法规则：</p>
<ul>
<li><strong>A::=V=E</strong></li>
<li><strong>E::=T|E+T</strong></li>
<li><strong>T::=F|T*F</strong></li>
<li><strong>F::=V|(E)|C</strong></li>
<li><strong>V::=标示符</strong></li>
<li><strong>C::=常数</strong> <strong>即由标示符或者常数的表达式进行加减乘除运算</strong></li>
</ul>
<h4><span id="语法分析的方法">语法分析的方法</span></h4><p>推导(derive)和归约(reduce)</p>
<ul>
<li><strong>推导</strong>：最左推导、最右推导</li>
<li><strong>归约</strong>：最右归约、最左归约,推导的逆过程就是归约</li>
</ul>
<p>最右推导、最左归约： </p>
<p> <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242302837.png" alt></p>
<p> 最左推导、最右归约： </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242303370.png" alt></p>
<h4><span id="语法树">语法树</span></h4><p>计算机通过<strong>语法树</strong>来进行分析，即语法分析过程也可以用一颗倒着的树来标示，这颗树叫<strong>语法树</strong>。正确的语法树叶子节点数必须是表达式的符号，例如 </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242303395.png" alt></p>
<p>赋值语句的分析树： </p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242304331.png" alt></p>
<p>变量声明语句的分析树：</p>
<p>首先看下变量声明语句的文法(<strong>文法是由一系列规则构成的</strong>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;D&gt; -&gt; &lt;T&gt; &lt;IDS&gt;;</span><br><span class="line">&lt;T&gt; -&gt; int | real | char | bool</span><br><span class="line">&lt;IDS&gt; -&gt; id | &lt;IDS&gt;, id</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242305150.png" alt></p>
<h3><span id="语义分析">语义分析</span></h3><p>语义的任务主要有两个</p>
<h4><span id="一-收集标识符的属性信息">一. 收集标识符的属性信息</span></h4><h4><span id="二-语义检查">二. 语义检查</span></h4><ol>
<li>变量或过程<strong>未经声明就使用</strong></li>
<li>变量或过程名<strong>重复声明</strong></li>
<li>运算分量<strong>类型不匹配</strong></li>
<li><strong>操作符与操作数之间的类型不匹配</strong><ul>
<li><strong>数组下标</strong>不是整数</li>
<li>对<strong>非数组变量</strong>使用数组访问操作符</li>
<li>对<strong>非过程名</strong>使用过程调用操作符</li>
<li>过程调用的**参数类型或数目不匹配 **</li>
<li>函数<strong>返回类型</strong>有误</li>
</ul>
</li>
</ol>
<h3><span id="中间代码生成">中间代码生成</span></h3><p>通常和语义分析一起实现。对语法分析识别出的各类语法范畴，分析他的含义，进行初步翻译，产生介于源代码和目标代码质检的一种代码</p>
<h4><span id="常用的中间代码表示形式">常用的中间代码表示形式</span></h4><ul>
<li><strong>三地址码</strong> (Three-address Code)：三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)</li>
<li><strong>语法结构树/语法树</strong> (Syntax Trees)</li>
<li><strong>逆波兰式</strong></li>
</ul>
<p><strong>三地址指令的表示：</strong></p>
<ul>
<li><strong>四元式</strong> (Quadruples)，(op, y, z, x)</li>
<li><strong>三元式</strong> (Triples)</li>
<li><strong>间接三元式</strong>(Indirect triples)     </li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242305150.png" alt></p>
<p>下面图中展示了一个中间代码生成的例子 <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242308231.png" alt></p>
<h3><span id="代码优化">代码优化</span></h3><p>对前面生成的中间代码进行加工变换，以便在最后极端产生更为高效的目标代码 ，<strong>需要遵循等价变换的原则</strong>，优化的方面包括：公共子表达式的提取、合并已知量、删除无用语句、循环优化。</p>
<h3><span id="目标代码生成">目标代码生成</span></h3><p>把经过优化的中间代码转化成特定机器上的低级语言</p>
<p>目标代码的形式：</p>
<ol>
<li><ul>
<li>绝对指令代码：可立即执行的目标代码</li>
</ul>
</li>
</ol>
<ul>
<li>汇编指令代码：汇编语言程序，需要经过汇编陈旭汇编后才能运行</li>
<li>可重定位指令代码：先将各目标模块连接起来，确定变量、常数在主存中的位置，装入主存后才能成为可以运行的绝对指令代码</li>
</ul>
<h3><span id="其他">其他</span></h3><h4><span id="出错处理">出错处理</span></h4><p>如果源程序有错误，编译程序应设法发现错误并报告给用户。由专门的出错处理程序来完成。 错误类型：</p>
<ul>
<li>语法错误：在词法分析和语法分析阶段检测出来</li>
<li>语义错误：一般在语义分析阶段检测</li>
<li>逻辑错误：不可检测，比如死循环，一般不处理因为没办法在编译阶段检测出来</li>
</ul>
<h4><span id="遍">遍</span></h4><p>指对源程序或源程序的中间结果从头到尾扫描一次，并做有关的加工处理，生成新的中间结果或目标代码。<strong>遍与阶段的含义毫无关系</strong></p>
<p>多遍扫描： <strong>优点</strong>：节省内存空间，提高目标代码的质量，使编译的逻辑结构清晰。<strong>缺点</strong>：编译时间长。在内存许可的情况下还是遍数尽可能少较好 <img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242309680.png" alt></p>
<h2><span id="编译程序生成">编译程序生成</span></h2><ol>
<li><strong>直接用机器语言编写编译程序</strong></li>
<li><strong>用汇编语言编写编译程序</strong>，编译程序核心部分常用汇编语言编写</li>
<li><strong>用高级语言编写编译程序</strong>，这也是普遍采用的方法</li>
<li><strong>自编译</strong></li>
<li><strong>编译工具</strong> LEX（语法分析）与YACC(用于自动生成LALR分析表)</li>
<li><strong>移植</strong>(同种语言的编译程序在不同类型的机器之 间移植) 在某机器上为某种语言构造编译程序要掌握以下三方面:</li>
</ol>
<ul>
<li>源语言</li>
<li>目标语言</li>
<li>编译方法</li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器工作过程</title>
    <url>/49fab9fa/</url>
    <content><![CDATA[<p>代码要运行，必须先转成二进制的机器码。这是编译器的任务。</p>
<p>比如，下面这段源码（假定文件名叫做test.c）。</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
&#123;
fputs(&quot;Hello, world!\n&quot;, stdout);
return 0;
&#125;
```&lt;/stdio.h&gt;

要先用编译器处理一下，才能运行。

```bash
$ gcc test.c
$ ./a.out
Hello, world!</code></pre><p>对于复杂的项目，编译过程还必须分成三步。</p>
<pre><code>$ ./configure
$ make
$ make install</code></pre><p>这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。</p>
<p>本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了Alex Smith的文章《Building C Projects》。需要声明的是，本文主要针对gcc编译器，也就是针对C和C++，不一定适用于其他语言的编译。</p>
<p><img src="http://img.blog.csdn.net/20170105233325494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4><span id="第一步-配置configure">第一步 配置（configure）</span></h4><p>编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。</p>
<p>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。</p>
<p>configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。</p>
<p><code>$ ./configure --prefix=/www --with-mysql</code></p>
<p>上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。</p>
<h4><span id="第二步-确定标准库和头文件的位置">第二步 确定标准库和头文件的位置</span></h4><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。</p>
<p>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p>
<h4><span id="第三步-确定依赖关系">第三步 确定依赖关系</span></h4><p>对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。</p>
<p>（1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。</p>
<p>编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。</p>
<p>在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</p>
<h4><span id="第四步-头文件的预编译precompilation">第四步 头文件的预编译（precompilation）</span></h4><p>不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。</p>
<p>不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。</p>
<h4><span id="第五步-预处理preprocessing">第五步 预处理（Preprocessing）</span></h4><p>预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。</p>
<pre><code>extern int fputs(const char *, FILE *);
extern FILE *stdout;
int main(void)
&#123;
fputs(&quot;Hello, world!\n&quot;, stdout);
return 0;
&#125;</code></pre><p>为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。</p>
<p>这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。</p>
<h4><span id="第六步-编译compilation">第六步 编译（Compilation）</span></h4><p>预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。</p>
<p>下面是本文开头的那段源码转成的汇编码。</p>
<p>```` .file “test.c” .section .rodata .LC0: .string “Hello, world!\n” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movq stdout(%rip), %rax movq %rax, %rcx movl $14, %edx movl $1, %esi movl $.LC0, %edi call fwrite movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Debian 4.9.1-19) 4.9.1” .section .note.GNU-stack,””,@progbits ```</p>
<p>这种转码后的文件称为对象文件（object file）。</p>
<h4><span id="第七步-连接linking">第七步 连接（Linking）</span></h4><p>对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。</p>
<p>编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。</p>
<p><strong>make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。</strong></p>
<h4><span id="第八步-安装installation">第八步 安装（Installation）</span></h4><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。</p>
<p>表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。</p>
<h4><span id="第九步-操作系统连接">第九步 操作系统连接</span></h4><p>可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。</p>
<p>这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在<code>/usr/share/applications</code>目录下的<code>.desktop</code>文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。</p>
<p>这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。</p>
<h4><span id="第十步-生成安装包">第十步 生成安装包</span></h4><p>写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。</p>
<p>所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。</p>
<h4><span id="第十一步-动态连接dynamic-linking">第十一步 动态连接（Dynamic linking）</span></h4><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p>
<p>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</p>
<p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>用GDB调试程序</title>
    <url>/13b68d49/</url>
    <content><![CDATA[<h3><span id="使用gdb">使用GDB</span></h3><p>一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gcc</span> -g -Wall hello.c -o hello</span><br><span class="line"><span class="variable">$g</span>++ -g -Wall hello.cpp -o hello</span><br></pre></td></tr></table></figure>


<p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 启动GDB的方法有以下几种： <code>gdb &lt;program&gt;</code> program也就是你的执行文件，一般在当前目录下。 <code>gdb &lt;program&gt; core</code> 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。 <code>gdb &lt;program&gt; &lt;pid&gt;</code> 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 以上三种都是进入gdb环境和加载被调试程序同时进行的。也可以先进入gdb环境，在加载被调试程序，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*在终端输入：gdb</span><br><span class="line">*在gdb环境中：file &lt;program&gt;</span><br><span class="line">这两步等价于：gdb &lt;program&gt;</span><br></pre></td></tr></table></figure>


<p>GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下面只例举一些比较常用的参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-symbols &lt;file&gt;</span><br><span class="line">-s &lt;file&gt;</span><br><span class="line">从指定文件中读取符号表。</span><br><span class="line">-se file</span><br><span class="line">从指定文件中读取符号表信息，并把他用在可执行文件中。</span><br><span class="line">-core &lt;file&gt;</span><br><span class="line">-c &lt;file&gt;</span><br><span class="line">调试时core dump的core文件。</span><br><span class="line">-directory &lt;directory&gt;</span><br><span class="line">-d &lt;directory&gt;</span><br><span class="line">加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。</span><br><span class="line">```&lt;/directory&gt;&lt;/directory&gt;&lt;/file&gt;&lt;/file&gt;&lt;/file&gt;&lt;/file&gt;&lt;/program&gt;&lt;/program&gt;&lt;/pid&gt;&lt;/program&gt;&lt;/program&gt;&lt;/program&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">###GDB的命令概貌</span></span><br><span class="line"></span><br><span class="line">启动gdb后，你就被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb的命令可以使用<span class="built_in">help</span>命令来查看，如下所示：</span><br><span class="line">```bash</span><br><span class="line">$ gdb</span><br><span class="line">GNU gdb 6.7.1-debian</span><br><span class="line">Copyright (C) 2007 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http: gnu.org=<span class="string">&quot;&quot;</span> licenses=<span class="string">&quot;&quot;</span> gpl.html=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i486-linux-gnu&quot;</span>.</span><br><span class="line">(gdb) <span class="built_in">help</span></span><br><span class="line">List of classes of commands:&lt;/http:&gt;</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed by a class name <span class="keyword">for</span> a list of commands <span class="keyword">in</span> that class.</span><br><span class="line">Type <span class="string">&quot;help all&quot;</span> <span class="keyword">for</span> the list of all commands.</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed by <span class="built_in">command</span> name <span class="keyword">for</span> full documentation.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.</span><br><span class="line">Command name abbreviations are allowed <span class="keyword">if</span> unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>


<p>gdb 的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用<code>help &lt;class&gt;</code>命令，如：help breakpoints，查看设置断点的所有命令。也可以直接<code>help &lt;command&gt;&lt;/command&gt;</code>来查看命令的帮助。 gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其列出来。</p>
<p><strong>示例一</strong>：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b func</span><br><span class="line">Breakpoint 1 at 0x804837a: file tst.c, line 5.</span><br></pre></td></tr></table></figure>


<p><strong>示例二</strong>：敲入b按两次TAB键，你会看到所有b打头的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b</span><br><span class="line">backtrace <span class="built_in">break</span> bt</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>


<p><strong>示例三</strong>：只记得函数的前缀，可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b make_ &amp;lt;按TAB键&amp;gt;</span><br><span class="line">（再按下一次TAB键，你会看到:）</span><br><span class="line">make_a_section_from_file make_environ</span><br><span class="line">make_abs_section make_function_type</span><br><span class="line">make_blockvector make_pointer_type</span><br><span class="line">make_cleanup make_reference_type</span><br><span class="line">make_command make_symbol_completion_list</span><br><span class="line">(gdb) b make_</span><br><span class="line">GDB把所有make开头的函数全部列出来给你查看。</span><br></pre></td></tr></table></figure>

<p><strong>示例四</strong>：调试C++的程序时，有可以函数名一样。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b <span class="string">&#x27;bubble( M-?</span></span><br><span class="line"><span class="string">bubble(double,double) bubble(int,int)</span></span><br><span class="line"><span class="string">(gdb) b &#x27;</span>bubble(</span><br></pre></td></tr></table></figure>


<p>你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思） 要退出gdb时，只用发quit或命令简称q就行了</p>
<h3><span id="gdb中运行unix的shell程序">GDB中运行UNIX的shell程序</span></h3><p>在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成： <code>shell &lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code> 调用UNIX的shell来执行<code>&lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code>，环境变量SHELL中定义的UNIX的shell将会被用来执行<code>&lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code>，如果SHELL没有定义，那就使用UNIX的标准<code>shell：/bin/sh</code>。（在Windows中使用Command.com或cmd.exe） 还有一个gdb命令是make： <code>make &lt;make-args&gt;</code> 可以在gdb中执行make命令来重新build自己的程序。这个命令等价于<code>shell make &lt;make-args&gt;</code>。</p>
<h3><span id="在gdb中运行程序">在GDB中运行程序</span></h3><p>当以<code>gdb &lt;program&gt;</code>方式启动gdb后，gdb会在PATH路径和当前目录中搜索<code>&lt;program&gt;</code>的源文件。如要确认gdb是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。 在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。 <strong>1、程序运行参数。</strong> set args 可指定运行时参数。（如：set args 10 20 30 40 50） show args 命令可以查看设置好的运行参数。 <strong>2、运行环境。</strong> `path</p>
<p><code>可设定程序的运行路径。 show paths 查看程序的运行路径。 set environment varname [=value] 设置环境变量。如：set env USER=hchen show environment [varname] 查看环境变量。 **3、工作目录。**</code>cd</p>
<p>` 相当于shell的cd命令。 pwd 显示当前的所在目录。 <strong>4、程序的输入输出。</strong> info terminal 显示你程序用到的终端的模式。 使用重定向控制程序输出。如：run &gt; outfile tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb</p>
<h3><span id="调试已运行的程序">调试已运行的程序</span></h3><p>两种方法： 1. 在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用<code>gdb &lt;program&gt; PID</code>格式挂接正在运行的程序。 2. 先用<code>gdb &lt;program&gt;</code>关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。</p>
<h3><span id="暂停恢复程序运行">暂停/恢复程序运行</span></h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。 当进程被gdb停住时，你可以使用<code>info program</code> 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（Watch Point）、捕捉点（Catch Point）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可以使用c或是 continue命令。</p>
<p><strong>下面为重要的使用步骤, 只摘抄了部分必要的信息, 如设置断点, 查看栈信息, 其余操作, 可以在<a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F">wiki.ubuntu</a>查看</strong></p>
<p><strong>设置断点（Break Points）</strong> 我们用break命令来设置断点。下面有几点设置断点的方法： <code>break &lt;function&gt;</code> 在进入指定函数时停住。C++中可以使用<code>class::function</code>或<code>function(type,type)</code>格式来指定函数名。 <code>break &lt;linenum&gt;</code> 在指定行号停住。 <code>break +offset</code> <code>break -offset</code> 在当前行号的前面或后面的offset行停住。offiset为自然数。 <code>break filename：linenum</code> 在源文件filename的linenum行处停住。 <code>break filename：function</code> 在源文件filename的function函数的入口处停住。 <code>break *address</code> 在程序运行的内存地址处停住。 <code>break</code> break命令没有参数时，表示在下一条指令处停住。 <code>break ... if &lt;condition&gt;</code> …可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置<code>break if i==100</code>，表示当i为100时停住程序。 查看断点时，可使用info命令，如下所示：（注：n表示断点号） <code>info breakpoints [n]</code> <code>info break [n]</code></p>
<p><strong>维护停止点</strong> 上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用<code>delete</code>、<code>clear</code>、<code>disable</code>、<code>enable</code>这几个命令来进行维护。 <code>clear</code> 清除所有的已定义的停止点。 <code>clear &lt;function&gt;</code> <code>clear &lt;filename：function&gt;</code> 清除所有设置在函数上的停止点。 <code>clear &lt;linenum&gt;</code> <code>clear &lt;filename：linenum&gt;</code> 清除所有设置在指定行上的停止点。 <code>delete [breakpoints] [range...]</code> 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。&lt;/filename：linenum&gt;&lt;/filename：function&gt;</p>
<p>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。 <code>disable [breakpoints] [range...]</code> disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis. <code>enable [breakpoints] [range...]</code> enable所指定的停止点，breakpoints为停止点号。 <code>enable [breakpoints] once range...</code> enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。 <code>enable [breakpoints] delete range...</code> enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p>
<p><strong>恢复程序运行和单步调试</strong> 当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用step或next命令单步跟踪程序。 <code>continue [ignore-count]</code> <code>c [ignore-count]</code> <code>fg [ignore-count]</code> 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。 <code>step &lt;count&gt;</code> 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 <code>next &lt;count&gt;</code> 同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 <code>set step-mode</code> <code>set step-mode on</code> 打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数很有利于查看机器码。 <code>set step-mode off</code> 关闭step-mode模式。 <code>finish</code> 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。 <code>until 或 u</code> 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 <code>stepi 或 si</code> <code>nexti 或 ni</code> 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是<code>“display/i $pc”</code> ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p>
<p><strong>查看栈信息</strong> 当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。 下面是一些查看函数调用栈信息的GDB命令： <code>backtrace</code> <code>bt</code> 打印当前的函数调用栈的所有信息。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  func (n=250) at tst.c:6</span></span><br><span class="line"><span class="comment">#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30</span></span><br><span class="line"><span class="comment">#2  0x400409ed in __libc_start_main () from /lib/libc.so.6</span></span><br></pre></td></tr></table></figure>


<p>从上可以看出函数的调用栈信息：<code>__libc_start_main --&amp;gt; main() --&amp;gt; func()</code></p>
<p><code>backtrace &lt;n&gt;</code> <code>bt &lt;n&gt;</code> n是一个正整数，表示只打印栈顶上n层的栈信息。 <code>backtrace &amp;lt;-n&amp;gt;</code> <code>bt &amp;lt;-n&amp;gt;</code> -n表一个负整数，表示只打印栈底下n层的栈信息。 如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。 <code>frame &lt;n&gt;</code> <code>f &lt;n&gt;</code> n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。 <code>up &lt;n&gt;</code> 表示向栈的上面移动n层，可以不打n，表示向上移动一层。 <code>down &lt;n&gt;</code> 表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p>
<p>上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令： <code>select-frame &lt;n&gt;</code> 对应于 frame 命令。 <code>up-silently &lt;n&gt;</code>对应于 up 命令。 <code>down-silently &lt;n&gt;</code> 对应于 down 命令。 查看当前栈层的信息，你可以用以下GDB命令： <code>frame</code> 或 <code>f</code> 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。 <code>info frame</code> <code>info f</code> 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如： <code>bash (gdb) info f Stack level 0, frame at 0xbffff5d4: eip = 0x804845d in func (tst.c:6); saved eip 0x8048524 called by frame at 0xbffff60c source language c. Arglist at 0xbffff5d4, args: n=250 Locals at 0xbffff5d4, Previous frame&#39;s sp is 0x0 Saved registers: ebp at 0xbffff5d4, eip at 0xbffff5d8</code></p>
<p><code>info args</code> 打印出当前函数的参数名及其值。 <code>info locals</code> 打印出当前函数中所有局部变量及其值。 <code>info catch</code> 打印出当前的函数中的异常处理信息。</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云音乐破版权</title>
    <url>/c6996379/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p>源码地址: <a href="https://github.com/lxbwolf/UnblockNeteaseMusic">https://github.com/lxbwolf/UnblockNeteaseMusic</a></p>
<p><strong>原理:</strong><br>使用其它音乐平台的歌曲替换网易云音乐无版权歌曲。<br>目前备用的平台有：网易云旧链 、QQ 、 虾米 、 百度 、酷狗 、酷我 、咕咪 、JOOX 音源替换变灰歌曲链接 (默认仅启用前四)。</p>
<p>1、打开网易云音乐客户端的时候，客户端不再直接访问网易云服务器而是访问UnblockNeteaseMusic服务。</p>
<p>2、UnblockNeteaseMusic收到客户端的请求后，透传给网易云音乐的服务器，并再拿到相关的数据后进行检查，如果发现其中的歌曲没有版权，那么去其它平台查询此歌曲的相关信息。</p>
<p>3、将查到的数据返回给网易云客户端。</p>
<p>4、至此完成网易云音乐的解锁。</p>
<p>整个流程要解决两个重要的问题。</p>
<p><strong>核心工作:</strong><br>1、将UnblockNeteaseMusic部署到服务器。可以是本地服务器也可以是云服务器。</p>
<p>2、为网易云客户端设置代理，以达到访问UnblockNeteaseMusic项目的目的。</p>
<p><strong>部署服务部分</strong></p>
<ol>
<li>安装node.js </li>
<li><code>git clone https://github.com/lxbwolf/UnblockNeteaseMusic.git</code></li>
<li>在<code>UnblockNeteaseMusic</code> 目录下, 执行<code>npx @nondanee/unblockneteasemusic(官方)</code> 或者 用docker 启动<code>docker run nondanee/unblockneteasemusic &amp;&amp; docker-compose up</code>, 还有另一种方式:<br>在<code>UnblockNeteaseMusic</code> 目录下, 执行<br><code>node app.js -p 8080:443 -f 59.111.160.195</code><br>其中<code>59.111.160.195</code> 这个地址是通过<br><code>ping music.163.com</code> 测出来的</li>
</ol>
<p>正常情况下, 服务端启动进程, 客户端配置好IP Port, 就可以用了, </p>
<p>此时服务端接收到请求会有log, 如果服务端log一直卡在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Server running @ http://0.0.0.0:8080</span><br><span class="line">HTTPS Server running @ https://0.0.0.0:443</span><br></pre></td></tr></table></figure>

<p>说明客户端的请求并没有打到服务器上, 可能原因是8080和443端口还没有开启</p>
<p>配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ unblockneteasemusic -h</span><br><span class="line">usage: unblockneteasemusic [-v] [-p port] [-a address] [-u url] [-f host]</span><br><span class="line">                           [-o source [source ...]] [-t token] [-e url] [-s]</span><br><span class="line">                           [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -v, --version                   output the version number</span><br><span class="line">  -p port, --port port            specify server port</span><br><span class="line">  -a address, --address address   specify server host</span><br><span class="line">  -u url, --proxy-url url         request through upstream proxy</span><br><span class="line">  -f host, --force-host host      force the netease server ip</span><br><span class="line">  -o source [source ...], --match-order source [source ...]</span><br><span class="line">                                  set priority of sources</span><br><span class="line">  -t token, --token token         set up proxy authentication</span><br><span class="line">  -e url, --endpoint url          replace virtual endpoint with public host</span><br><span class="line">  -s, --strict                    enable proxy limitation</span><br><span class="line">  -h, --help                      output usage information</span><br></pre></td></tr></table></figure>


<p><strong>客户端配置</strong></p>
<p>源码中的<code>README</code> 有详细说明</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>基础设置</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>设置 &gt; 工具 &gt; 自定义代理 (客户端内)</td>
</tr>
<tr>
<td>UWP</td>
<td>Windows 设置 &gt; 网络和 Internet &gt; 代理</td>
</tr>
<tr>
<td>Linux</td>
<td>系统设置 &gt; 网络 &gt; 网络代理</td>
</tr>
<tr>
<td>macOS</td>
<td>系统偏好设置 &gt; 网络 &gt; 高级 &gt; 代理</td>
</tr>
<tr>
<td>Android</td>
<td>WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</td>
</tr>
<tr>
<td>iOS</td>
<td>无线局域网 &gt; HTTP 代理 &gt; 配置代理</td>
</tr>
</tbody></table>
<p><strong>Android 手机详细配置:</strong></p>
<p>设置 &gt; WLAN &gt; 修改网络 &gt; 高级选项 &gt; 代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP: 106.13.86.198</span><br><span class="line">Port: 8080</span><br></pre></td></tr></table></figure>



<p>破解前效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004909.png" alt="pojieqian-163"></p>
<p>破解后效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004946.png" alt="pojiehou-163"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201005015.png" alt="tingge-163"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>网络 IO 模型</title>
    <url>/3af5472b/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#互联网服务端处理网络请求的原理">互联网服务端处理网络请求的原理</a></li>
<li><a href="#io-模型的基本认识">“I/O 模型”的基本认识</a></li>
<li><a href="#网络io模型">网络IO模型</a><ul>
<li><a href="#io模型">IO模型</a><ul>
<li><a href="#阻塞式-io">阻塞式 IO</a></li>
<li><a href="#非阻塞式-io">非阻塞式 IO</a></li>
<li><a href="#多路复用io">多路复用IO</a></li>
<li><a href="#信号驱动-io">信号驱动 IO</a></li>
<li><a href="#异步-io">异步 IO</a></li>
</ul>
</li>
<li><a href="#五大-io-模型比较">五大 IO 模型比较</a><ul>
<li><a href="#blocking和non-blocking区别">blocking和non-blocking区别</a></li>
<li><a href="#synchronous-io和asynchronous-io区别">synchronous IO和asynchronous IO区别</a></li>
</ul>
</li>
<li><a href="#selectpollepoll比较">select，poll，epoll比较</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a></li>
<li><a href="#应用场景">应用场景</a></li>
</ul>
</li>
<li><a href="#web服务器设计模型">web服务器设计模型</a><ul>
<li><a href="#并发并行">并发&amp;并行</a></li>
<li><a href="#reactor模型">Reactor模型</a></li>
<li><a href="#proacotr模型">Proacotr模型</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="互联网服务端处理网络请求的原理">互联网服务端处理网络请求的原理</span></h2><p><strong>一个典型互联网服务端处理网络请求的典型过程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226140211.png" alt></p>
<p><strong>由上图可以看到，主要处理步骤包括：</strong></p>
<p>1）获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）；</p>
<p>2）构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）；</p>
<p>3）返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端（5-7）。</p>
<p><strong>设计服务端并发模型时，主要有如下两个关键点：</strong></p>
<p>1）服务器如何管理连接，获取输入数据；</p>
<p>2）服务器如何处理请求。</p>
<p>以上两个关键点最终都与操作系统的 I/O 模型以及线程(进程)模型相关，这也是本文和下篇《高性能网络编程(六)：一文读懂高性能网络编程中的线程模型》将要介绍的内容。下面先详细介绍这I/O模型。</p>
<h2><span id="io-模型的基本认识">“I/O 模型”的基本认识</span></h2><p><strong>介绍操作系统的 I/O 模型之前，先了解一下几个概念：</strong></p>
<p>1）阻塞调用与非阻塞调用；</p>
<p>2）阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；</p>
<p>3）非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。</p>
<p><strong>阻塞</strong>是指调用方一直在等待而且别的事情什么都不做；<strong>非阻塞</strong>是指调用方先去忙别的事情。</p>
<p><strong>同步处理与异步处理：</strong>同步处理是指被调用方得到最终结果之后才返回给调用方；异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。</p>
<p><strong>阻塞、非阻塞和同步、异步的区别（</strong>阻塞、非阻塞和同步、异步其实针对的对象是不一样的）<strong>：</strong></p>
<p>1）阻塞、非阻塞的讨论对象是调用者；</p>
<p>2）同步、异步的讨论对象是被调用者。</p>
<p><strong>recvfrom 函数：</strong></p>
<p>recvfrom 函数(经 Socket 接收数据)，这里把它视为系统调用。</p>
<p><strong>一个输入操作通常包括两个不同的阶段：</strong></p>
<p>1）等待数据准备好；</p>
<p>2）从内核向进程复制数据。</p>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为 5 种 I/O 模型</p>
<h2><span id="网络io模型">网络IO模型</span></h2><blockquote>
<p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作</p>
</blockquote>
<p>IO其实我们并不陌生，站在操作系统的角度上说，io一般指访问磁盘数据，可以分为两步，以read操作举例的话：</p>
<ol>
<li>第一阶段：等待数据准备 (Waiting for the data to be ready)。</li>
<li>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</li>
</ol>
<p>而网络IO也是如此，只不过它是读取的不是磁盘，而是socket：</p>
<ol>
<li>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>
<li>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</li>
</ol>
<p>在理解网络IO模型之前，我们得先准备些IO模型的基础知识</p>
<h3><span id="io模型">IO模型</span></h3><p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞IO（bloking IO）</li>
<li>非阻塞IO（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li>异步IO（asynchronous IO）</li>
</ul>
<p>每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。下面提供一个简单的图片以供了解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226140555.png" alt></p>
<h4><span id="阻塞式-io">阻塞式 IO</span></h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。</p>
<p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226140921.png" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/16533261-a71605af7a6d472c?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h4><span id="非阻塞式-io">非阻塞式 IO</span></h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率是比较低的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141038.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141052.png" alt></p>
<h4><span id="多路复用io">多路复用IO</span></h4><p>由于阻塞式IO通过轮询得到的只是一个IO任务是否完成，而可能有多个任务在同时进行，因此就想到了能否轮询多个IO任务的状态，只要有任何一个任务完成，就去处理它。这就是所谓的IO多路复用。LINUX下具体的实现方式就是select、poll、epoll。</p>
<p>这种机制可以让单个进程具有处理多个 IO 事件的能力。又被称为 Event Driven IO，即事件驱动 IO。</p>
<p>最实际的应用场景就是web服务器响应连接的方式，IO 复用可支持<strong>更多的连接</strong>，同时不需要进程线程创建和切换的开销，系统开销更小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141126.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141140.png" alt></p>
<blockquote>
<p>多路复用的特点是通过一种机制一个进程能同时等待多个IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p>
</blockquote>
<p>在IO多路复用中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的进程其实是一直被block的。只不过进程是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</p>
<h4><span id="信号驱动-io">信号驱动 IO</span></h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141353.png" alt></p>
<h4><span id="异步-io">异步 IO</span></h4><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 IO 与信号驱动 IO 的区别在于，异步 IO 的信号是通知应用进程 IO 完成，而信号驱动 IO 的信号是通知应用进程可以开始 IO。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141447.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141502.png" alt></p>
<h3><span id="五大-io-模型比较">五大 IO 模型比较</span></h3><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141649.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141702.png" alt></p>
<p>从上图中我们可以看出，越往后，阻塞越少，理论上效率也是最优。</p>
<p>这五种 I/O 模型中，前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。</p>
<h4><span id="blocking和non-blocking区别">blocking和non-blocking区别</span></h4><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h4><span id="synchronous-io和asynchronous-io区别">synchronous IO和asynchronous IO区别</span></h4><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
</blockquote>
<blockquote>
<p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</blockquote>
<ul>
<li>同步 I/O：应用进程在调用 recvfrom 操作时会阻塞。</li>
<li>异步 I/O：不会阻塞。</li>
</ul>
<p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p>
<h3><span id="selectpollepoll比较">select，poll，epoll比较</span></h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<h4><span id="select">select</span></h4><p>select的调用过程如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141946.png" alt></p>
<p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p>
<p>（2）注册回调函数__pollwait</p>
<p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p>
<p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p>
<p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p>
<p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p>
<p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p>
<p>（8）把fd_set从内核空间拷贝到用户空间。</p>
<h5><span id="总结">总结：</span></h5><p>select的几大缺点：</p>
<p>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
<p>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
<p>（3）select支持的文件描述符数量太小了，默认是1024</p>
<h4><span id="poll">poll</span></h4><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。</p>
<h4><span id="epoll">epoll</span></h4><p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</p>
<p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h5><span id="总结">总结</span></h5><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h4><span id="应用场景">应用场景</span></h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h5><span id="1-select-应用场景">1. select 应用场景</span></h5><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h5><span id="2-poll-应用场景">2. poll 应用场景</span></h5><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p>
<h5><span id="3-epoll-应用场景">3. epoll 应用场景</span></h5><p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p>
<h3><span id="web服务器设计模型">web服务器设计模型</span></h3><h4><span id="并发amp并行">并发&amp;并行</span></h4><blockquote>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。<br> 并行需要硬件支持，如多流水线或者多处理器。<br> 操作系统通过引入进程和线程，使得程序能够并发运行。</p>
</blockquote>
<p>对于web服务而言，并发是指同时进行的任务数（如同时服务的 HTTP 请求），而并行是可以同时工作的物理资源数量（如 CPU 核数）。</p>
<p>而针对并发IO而言，Reactor模型是一种常见的处理方式</p>
<h4><span id="reactor模型">Reactor模型</span></h4><p>Reactor的中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有I/O事件到来或是准备就绪(文件描述符或socket可读、写)，多路复用器返回并将事先注册的相应I/O事件分发到对应的处理器中。</p>
<p>Reactor是一种事件驱动机制，用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。<br> Reactor模式与Observer模式在某些方面极为相似：当一个主体发生改变时，所有依属体都得到通知。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。</p>
<p>在Reactor模式中，有5个关键的参与者：</p>
<ul>
<li><strong>描述符（handle）</strong>：由操作系统提供的资源，用于识别每一个事件，如Socket描述符、文件描述符、信号的值等。在Linux中，它用一个整数来表示。事件可以来自外部，如来自客户端的连接请求、数据等。事件也可以来自内部，如信号、定时器事件。</li>
<li><strong>同步事件多路分离器（event demultiplexer）</strong>：事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O复用技术实现。在linux系统上一般是select、poll、epol_waitl等系统调用，用来等待一个或多个事件的发生。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。</li>
<li><strong>事件处理器（event handler）</strong>：I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。这些模板函数描述了和应用程序相关的对某个事件的操作，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般声明为虚函数，以支持用户拓展。</li>
<li><strong>具体的事件处理器（concrete event handler）</strong>：是事件处理器接口的实现。它实现了应用程序提供的某个服务。每个具体的事件处理器总和一个描述符相关。它使用描述符来识别事件、识别应用程序提供的服务。</li>
<li><strong>Reactor 管理器（reactor）</strong>：定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模 板函数来处理这个事件。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142433.png" alt></p>
<p>可以看出，是Reactor管理器并不是应用程序负责等待事件、分离事件和调度事件。Reactor并没有被具体的事件处理器调度，而是管理器调度具体的事件处理器，由事件处理器对发生的事件作出处理，这就是Hollywood原则。应用程序要做的仅仅是实现一个具体的事件处理器，然后把它注册到Reactor管理器中。接下来的工作由管理器来完成：如果有相应的事件发生，Reactor会主动调用具体的事件处理器，由事件处理器对发生的事件作出处理。</p>
<h5><span id="为什么使用reactor">为什么使用Reactor</span></h5><p>有了I/O复用，有了epoll已经可以使服务器并发几十万连接的同时，维持高TPS了，难道这还不够吗？</p>
<p>答案是，技术层面足够了，但在软件工程层面却是不够的。</p>
<p>程序使用IO复用的难点在哪里呢？</p>
<p>1个请求可能由多次IO处理完成，但相比传统的单线程完整处理请求生命期的方法，IO复用在人的大脑思维中并不自然，因为，程序员编程中，处理请求A的时候，假定A请求必须经过多个IO操作A1-An（两次IO间可能间隔很长时间），每经过一次IO操作，再调用IO复用时，IO复用的调用返回里，非常可能不再有A，而是返回了请求B。即请求A会经常被请求B打断，处理请求B时，又被C打断。这种思维下，编程容易出错。</p>
<p><strong>在程序中：</strong><br> 某一瞬间，服务器共有10万个并发连接，此时，一次IO复用接口的调用返回了100个活跃的连接等待处理。先根据这100个连接找出其对应的对象，这并不难，epoll的返回连接数据结构里就有这样的指针可以用。接着，循环的处理每一个连接，找出这个对象此刻的上下文状态，再使用read、write这样的网络IO获取此次的操作内容，结合上下文状态查询此时应当选择哪个业务方法处理，调用相应方法完成操作后，若请求结束，则删除对象及其上下文。</p>
<p>这样，我们就陷入了<strong>面向过程编程</strong>方法之中了，在面向应用、快速响应为王的移动互联网时代，这样做早晚得把自己玩死。我们的主程序需要关注各种不同类型的请求，在不同状态下，对于不同的请求命令选择不同的业务处理方法。这会导致随着请求类型的增加，请求状态的增加，请求命令的增加，<strong>主程序复杂度快速膨胀</strong>，导致维护越来越困难，苦逼的程序员再也不敢轻易接新需求、重构。</p>
<p>反应堆是解决上述软件工程问题的一种途径，它也许并不优雅，开发效率上也不是最高的，但其执行效率与面向过程的使用IO复用却几乎是等价的，所以，无论是nginx、memcached、redis等等这些高性能组件的代名词，都义无反顾的一头扎进了反应堆的怀抱中。</p>
<p>反应堆模式可以在软件工程层面，将事件驱动框架分离出具体业务，将不同类型请求之间用OO的思想分离。通常，反应堆不仅使用IO复用处理网络事件驱动，还会实现定时器来处理时间事件的驱动（请求的超时处理或者定时任务的处理）</p>
<h5><span id="reactor的几种模式">Reactor的几种模式</span></h5><h6><span id="1-单线程模式">1 单线程模式</span></h6><p>这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过这种单线程模型不能充分利用多核资源，所以实际使用的不多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142550.png" alt></p>
<h6><span id="2-多线程模式单reactor">2 多线程模式（单Reactor）</span></h6><p>该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142614.png" alt></p>
<h6><span id="3-多线程模式多个reactor">3 多线程模式（多个Reactor）</span></h6><p>比起第二种模型，它是将Reactor分成两部分，mainReactor负责监听并accept新连接，然后将建立的socket通过多路复用器（Acceptor）分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据；业务处理功能，其交给worker线程池完成。通常，subReactor个数上可与CPU个数等同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142645.png" alt></p>
<h4><span id="proacotr模型">Proacotr模型</span></h4><p>Proactor是和异步I/O相关的。</p>
<h5><span id="比较">比较</span></h5><p>以读操作为例：<br> 在Reactor（同步）中实现读：</p>
<ul>
<li>注册读就绪事件和相应的事件处理器</li>
<li>事件分离器等待事件</li>
<li>事件到来，激活分离器，分离器调用事件对应的处理器。</li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<p>Proactor（异步）中的读：</p>
<ul>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分离器等待操作完成事件</li>
<li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li>
<li>事件分离器呼唤处理器。</li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li>
</ul>
<h3><span id="参考资料">参考资料</span></h3><p><a href="https://zhuanlan.zhihu.com/p/43933717">一文读懂高性能网络编程中的I/O模型 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.cnblogs.com/Zhangyq-yard/p/10114785.html">网络I/O模型–5种常见的网络I/O模型 - QiangAnan - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.jianshu.com/p/ad548bb816ec">如何理解高性能网络模型</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】解决 CI/CD 中的仓库阻抗失配</title>
    <url>/f5fbcabb/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#阻抗失配scm-与镜像仓库">阻抗失配：SCM 与镜像仓库</a></li>
<li><a href="#二进制与部署描述符">二进制与部署描述符</a></li>
<li><a href="#解决阻抗失配">解决阻抗失配</a></li>
<li><a href="#实践中的思考">实践中的思考</a></li>
<li><a href="#结语">结语</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>对齐部署镜像和描述符是很困难的，但是某些策略可以使整个过程更高效。<br><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220326161918.png" alt></p>
</blockquote>
<p>在软件架构中，当两个组件之间有某些概念性或技术上的差异时会出现 <ruby>阻抗失配<rt>impedance mismatch</rt></ruby>。这个术语其实是从电子工程中借用的，表示电路中输入和输出的电子阻抗必须要匹配。</p>
<p>在软件开发中，存储在镜像仓库中的镜像与存储在源码控制管理系统（LCTT 译注：SCM，Source Code Management）中它的<ruby>部署描述符<rt>deployment descriptor</rt></ruby>之间存在阻抗失配。你如何确定存储在 SCM 中的部署描述符表示的是正确的镜像？两个仓库追踪数据的方式并不一致，因此将一个镜像（在镜像仓库中独立存储的不可修改的二进制）和它的部署描述符（Git 中以文本文件形式存储的一系列修改记录）相匹配并不那么直观。</p>
<p><strong>注意</strong>：本文假定读者已经熟悉以下概念：</p>
<ul>
<li><ruby>源码控制管理<rt>Source Control Management</rt></ruby>（SCM）系统和分支</li>
<li>Docker 或符合 OCI 标准的镜像和容器</li>
<li><ruby>容器编排系统<rt>Container Orchestration Platforms</rt></ruby>（COP），如 Kubernetes</li>
<li><ruby>持续集成/持续交付<rt>Continuous Integration/Continuous Delivery</rt></ruby>（CI/CD）</li>
<li><ruby>软件开发生命周期<rt>Software development lifecycle</rt></ruby>（SDLC）环境</li>
</ul>
<h3><span id="阻抗失配scm-与镜像仓库">阻抗失配：SCM 与镜像仓库</span></h3><p>为了更好地理解阻抗失配在什么场景下会成为问题，请考虑任意项目中的软件开发生命周期环境（SDLC），如开发、测试或发布环境。</p>
<p>测试环境不会有阻抗失配。现在使用 CI/CD 的最佳实践中开发分支的最新提交都会对应开发环境中的最新部署。因此，一个典型的、成功的 CI/CD 开发流程如下：</p>
<ol>
<li>向 SCM 的开发分支提交新的修改</li>
<li>新提交触发一次镜像构建</li>
<li>新生成的镜像被推送到镜像仓库，标记为开发中</li>
<li>镜像被部署到容器编排系统（COP）中的开发环境，该镜像的部署描述符也更新为从 SCM 拉取的最新描述符。</li>
</ol>
<p>换句话说，开发环境中最新的镜像永远与最新的部署描述符匹配。回滚到前一个构建的版本也不是问题，因为 SCM 也会跟着回滚。</p>
<p>最终，随着开发流程继续推进，需要进行更多正式的测试，因此某个镜像 —— 镜像对应着 SCM 中的某次提交 —— 被推到测试环境。如果是一次成功的构建，那么不会有大问题，因为从开发环境推过来的镜像应该会与开发分支的最新提交相对应。</p>
<ol>
<li>开发环境的最新部署被允许入库，触发入库过程</li>
<li>最新部署的镜像被标记为测试中</li>
<li>镜像在测试环境中被拉取和部署，（该镜像）对应从 SCM 拉取的最新部署描述符</li>
</ol>
<p>到目前为止,一切都没有问题，对吗？如果出现下面的场景，会有什么问题？</p>
<p><strong>场景 A</strong>：镜像被推到下游环境，如<ruby>用户验收测试<rt>user acceptance testing </rt></ruby>（UAT），或者是生产环境。</p>
<p><strong>场景 B</strong>：测试环境中发现了一个破坏性的 bug，镜像需要回滚到某个确定正常的版本。</p>
<p>在任一场景中，开发过程并没有停止，即开发分支上游有了一次或多次新的提交，而这意味着最新的部署描述符已经发生了变化，最新的镜像与之前部署在测试环境中的镜像不一致。对部署描述符的修改可能会也可能不会对之前版本的镜像起作用，但是它们一定是不可信任的。如果它们有了变化，那么它们就一定与目前为止你测试过的想要部署的镜像的部署描述符不一致。</p>
<p>问题的关键是：<strong>如果部署的镜像不是镜像库中的最新版本，你怎么确定与部署的镜像相对应的是 SCM 中的哪个部署描述符？</strong> 一言以蔽之，无法确定。两个库直接有阻抗失配。如果要详细阐述下，那么是有方法可以解决的，但是你需要做很多工作，这部分内容就是文章接下来的主题了。请注意，下面的方案并不是解决问题的唯一办法，但是已经投入到生产环境并已经对很多项目起了作用，而且已经被构建并部署到生产环境中运行了超过一年。</p>
<h3><span id="二进制与部署描述符">二进制与部署描述符</span></h3><p>源码通常被构建成一个 Docker 镜像或符合 OCI 标准的镜像，该镜像通常被部署到一个容器编排平台（COP）上，如 Kubernetes。部署到 COP 需要部署描述符来定义镜像被如何部署以及作为容器运行，如 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Kubernetes 部署</a> 或 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJobs</a>。这是因为在镜像和它的部署描述符之间有本质差异，在这里可以看到阻抗失配。在这次讨论中，我们认为镜像是存储在镜像仓库中不可修改的二进制。对源码的任何修改都不会修改镜像，而是用另一个新的镜像去替换它。</p>
<p>相比之下，部署描述符是文本文件，因而可以被认为是源码且可修改。如果遵循最佳实践，那么部署描述符是被存储在 SCM，所有修改都会提交，而这很容易回溯。</p>
<h3><span id="解决阻抗失配">解决阻抗失配</span></h3><p>建议的解决方案的第一部分，就是提供一个能匹配镜像仓库中的镜像与对保存部署描述符的 SCM 做的代码提交的方法。最直接的解决方案是用源提交的哈希值标记镜像。这个方法可以区分不同版本的镜像、容易分辨，并且提供足够的信息来查找正确的部署描述符，以便镜像更好地部署到 COP。</p>
<p>再回顾下上面的场景：</p>
<p><strong>场景 A</strong> _镜像被推到下游环境_： 当镜像被从测试环境推到 UAT 环境时，我们可以从镜像的标签中知道应该从 SCM 的哪一次源码提交拉取部署描述符。</p>
<p><strong>场景 B</strong> _当一个镜像需要在某一环节中回滚_：无论我们选择回滚到那个镜像版本，我们都可以知道从 SCM 的哪一次源码提交拉取正确的部署描述符。</p>
<p>在每一种情景中，无论在某个镜像被部署到测试环境后开发分支有多少次提交和构建，对于每一次升级的镜像，我们都可以找到它当初部署时对应的部署描述符。</p>
<p>然而，这并不是阻抗失配的完整解决方案。再考虑两个场景：</p>
<p><strong>场景 C</strong> 在负载测试环境中，会尝试对不同的部署描述符进行多次部署，以此来验证某一次构建的表现。</p>
<p><strong>场景 D</strong> 一个镜像被推送到下游环境，在该环境中部署描述符有一个错误。</p>
<p>在上面的所有场景中，我们都需要修改部署描述符，但是目前为止我们只有一个源码提交哈希。请记住，最佳实践要求我们所有对源码的修改都要先提交到 SCM。某次提交的哈希本身是无法修改的，因此我们需要一个比仅仅追踪原来的源码提交哈希更好地解决方案。</p>
<p>解决方案是基于原来的源码提交哈希新建一个分支。我们把这个分支称为<strong>部署分支</strong>。每当一个镜像被推到下游测试或发布环境时，你应该<strong>基于前一个 SDLC 环境的部署分支的最新提交</strong>创建一个新的部署分支。</p>
<p>这样同一个镜像可以重复多次部署到不同的 SDLC 环境，并在后面每个环境中可以感知前面发现的改动或对镜像做的修改。</p>
<p><strong>注意：</strong> 在某个环境中做的修改是如何影响下一个环境的，是用可以共享数据的工具（如 Helm Charts）还是手动剪切、粘贴到其他目录，都不在本文讨论的范围内。</p>
<p>因此，当一个镜像被从一个 SDLC 环境中推到下一环境时：</p>
<ol>
<li>创建一个部署分支<ol>
<li>如果镜像是从开发环境中推过来的，那么部署分支就基于构建这个镜像的源码提交哈希创建</li>
<li>否则，<em>部署分支基于当前部署分支的最新提交创建</em></li>
</ol>
</li>
<li>镜像被部署到下一个 SDLC 环境，使用的部署描述符是该环境中新创建的部署分支的部署描述符</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220326162117.png" alt="deployment branching tree"></p>
<p><em>图 1：部署分支树</em></p>
<ol>
<li>部署分支</li>
<li>下游环境的第一个部署分支，只有一次提交</li>
<li>下游环境的第二个部署分支，只有一次提交</li>
</ol>
<p>有了部署分支这个解决方案，再回顾下上面的场景 C 和场景 D：</p>
<p><strong>场景 C</strong> 修改已经部署到下游 SDLC 环境中的镜像的部署描述符</p>
<p><strong>场景 D</strong> 修复某个 SDLC 环境中部署描述符的错误</p>
<p>两个场景中，工作流如下：</p>
<ol>
<li>把对部署描述符做的修改提交到 SLDC 环境和镜像对应的部署分支</li>
<li>通过部署分支最新提交对应的部署描述符把镜像重新部署到 SLDC 环境</li>
</ol>
<p>这样，部署分支彻底解决了（存储着代表一次独一无二的构建的单一的、不可修改的镜像的）镜像仓库与（存储着对应一个或多个 SDLC 环境的可修改的部署描述符的）SCM 仓库之间的阻抗失配。</p>
<h3><span id="实践中的思考">实践中的思考</span></h3><p>这看起来像是行得通的解决方案，但同时它也为开发者和运维人员带来了新的实践中的问题，比如：</p>
<p>A. 为了更好地管理部署分支，部署描述符作为资源应该保存在哪里，是否要与构建镜像的源码保存在同一个 SCM 仓库？</p>
<p>到目前为止，我们都在避免谈论应该把部署描述符放在哪个仓库里。在还没有太多细节需要处理时，我们推荐把所有 SDLC 环境的部署描述符与镜像源码放在同一个 SCM 仓库。当部署分支创建后，镜像的源码可以作为方便找到部署的容器中运行的镜像的引用来使用。</p>
<p>上面提到过，可以通过镜像的标签来关联镜像与原始的源码提交。在一个单独的仓库中查找某次提交的源码的引用，会给开发者带来更大的困难（即便借助工具），这就是没有必要把所有资源都分开存储的原因。</p>
<p>B. 应该在部署分支上修改构建镜像的源码吗？</p>
<p>简答：<strong>不应该</strong>。</p>
<p>详细阐述：不应该，因为永远不要在部署分支上构建镜像，它们是在开发分支上构建的。修改部署分支上定义一个镜像的源码会破坏被部署的镜像的构建记录，而且这些修改并不会对镜像的功能生效。在对比两个部署分支的版本时这也会成为问题。这可能会导致两个版本的功能差异有错误的测试结果（这是使用部署分支的一个很小的额外好处）。</p>
<p>C. 为什么使用镜像 <ruby>标签<rt>tag</rt></ruby>？<ruby>标记<rt>label</rt></ruby> 不可以吗？</p>
<p>通过 <ruby>标签<rt>tag</rt></ruby> 可以在仓库中很容易地查找镜像，可读性也很好。在一组镜像中读取和查找 <ruby>标记<rt>label</rt></ruby> 的值需要拉取所有镜像的<ruby>清单文件<rt>manifest</rt></ruby>，而这会增加复杂度、降低性能。而且，考虑到历史记录的追踪和不同版本的查找，对不同版本的镜像添加 <ruby>标签<rt>tag</rt></ruby> 也很有必要，因此使用源码提交哈希是保证唯一性，以及保存能即时生效的有用信息的最简单的解决方案。</p>
<p>D. 创建部署分支的最佳实践是怎样的？</p>
<p>DevOps 最重要的三个原则：自动化、自动化、自动化。</p>
<p>依赖资源来持续地强迫遵循最佳实践，充其量只是碰运气，因此在实现镜像的升级、回滚等 CI/CD 流水线时，把自动化部署分支写到脚本里。</p>
<p>E. 对部署分支的命名规范有建议吗？</p>
<p>&lt;<strong>部署分支标识</strong>&gt;-&lt;<strong>环境</strong>&gt;-&lt;<strong>源码提交哈希</strong>&gt;</p>
<ul>
<li><strong>部署分支标识</strong>： 所有部署分支范围内唯一的字符串；如 “deployment” 或 “deploy”</li>
<li><strong>环境</strong>： 部署分支适用的 SDLC 环境；如 “qa”（测试环境）、 “stg”（预生产环境）、 或 “prod”（生产环境）</li>
<li><strong>源码提交哈希</strong>： 源码提交哈希中包含原来构建被部署的镜像的源码，开发者可以通过它很容易地查找到创建镜像的原始提交，同时也能保证分支名唯一。</li>
</ul>
<p>例如， <code>deployment-qa-asdf78s</code> 表示推到 QA 环境的部署分支， <code>deployment-stg-asdf78s</code> 表示推到 STG 环境的部署分支。</p>
<p>F. 你怎么识别环境中运行的哪个镜像版本？</p>
<p>我们的建议是把最新的部署分支提交哈希和源码提交哈希添加到 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">标记</a> 中。开发者和运维人员可以通过这两个独一无二的标识符查找到部署的所有东西及其来源。在诸如执行回滚或前滚操作时，使用那些不同版本的部署的选择器也能清理资源碎片。</p>
<p>G. 什么时候应该把部署分支的修改合并回开发分支？</p>
<p>这完全取决于开发团队。</p>
<p>如果你修改的目的是为了做负载测试，只是想验证什么情况会让程序崩溃，那么这些修改不应该被合并回开发分支。另一方面，如果你发现和修复了一个错误，或者对下游环境的部署做了调整，那么就应该把部署分支的修改合并回开发分支。</p>
<p>H. 有现成的部署分支示例让我们试水吗？</p>
<p><a href="https://github.com/elcicd">el-CICD</a> 已经在生产上使用这个策略持续一年半应用到超过一百个项目了，覆盖所有的 SDLC 环境，包括管理生产环境的部署。如果你可以访问 <a href="https://www.okd.io/">OKD</a>、Red Hat OpenShift lab cluster 或 <a href="https://cloud.redhat.com/openshift/create/local">Red Hat CodeReady Containers</a>，你可以下载<a href="https://github.com/elcicd/el-CICD-RELEASES">el-CICD 的最新版本</a>，参照 <a href="https://github.com/elcicd/el-CICD-docs/blob/master/tutorial.md">教程</a> 来学习部署分支是何时以怎样的方式创建和使用的。</p>
<h3><span id="结语">结语</span></h3><p>通过实践上面的例子可以帮助你更好的理解开发过程中阻抗失配相关的问题。对齐镜像和部署描述符是成功管理部署的关键部分。</p>
<hr>
<p>via: <a href="https://opensource.com/article/21/8/impedance-mismatch-cicd">https://opensource.com/article/21/8/impedance-mismatch-cicd</a></p>
<p>作者：<a href="https://opensource.com/users/hippyod">Evan “Hippy” Slatis</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ctrl+左右方向键失效</title>
    <url>/1188538d/</url>
    <content><![CDATA[<p>问题：<br>在终端按下 ctrl + 左/右 方向键时，出现以下字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ctrl+ 方向键的结果</span></span><br><span class="line">;5D</span><br><span class="line">;5C</span><br></pre></td></tr></table></figure>

<p>解决：<br>新建 <code>~/.inputrc</code> 文件，新增以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mappings for Ctrl-left-arrow and Ctrl-right-arrow for word moving</span></span><br><span class="line"><span class="string">&quot;\e[1;5C&quot;</span>: forward-word</span><br><span class="line"><span class="string">&quot;\e[1;5D&quot;</span>: backward-word</span><br><span class="line"><span class="string">&quot;\e[5C&quot;</span>: forward-word</span><br><span class="line"><span class="string">&quot;\e[5D&quot;</span>: backward-word</span><br><span class="line"><span class="string">&quot;\e\e[C&quot;</span>: forward-word</span><br><span class="line"><span class="string">&quot;\e\e[D&quot;</span>: backward-word</span><br></pre></td></tr></table></figure>

<p>参考资料<br><a href="https://www.linuxfromscratch.org/lfs/view/11.3/chapter09/inputrc.html">https://www.linuxfromscratch.org/lfs/view/11.3/chapter09/inputrc.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>误删了Mac中Chrome书签后如何恢复</title>
    <url>/ef3fb32/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p>书签误删该如何恢复</p>
<p>1 打开访达，在菜单栏上点击【前往】—【前往文件夹】，或者使用快捷键【Command+Shift+G】即可打开【前往文件夹】</p>
<p>输入以下路径【/Users/用户名/Library/Application Support/Google/Chrome】（注：路径中的用户名就是你电脑用户名称</p>
<p>2 在chrome文件目录下找到 【Default】文件夹，将里面的 【Bookmarks.bak】 的文件复制到桌面，将.bak名的后缀去掉，如下图所示：</p>
<p>注：如果你有多个用户的话，则需要找到对应的用户，一般在文件名为“Profile1、2、3”底下。</p>
<p>3 在同样的文件夹底下，将修改好的 Bookmarks 复制进 去替换，重启chrome即可。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>跑道问题</title>
    <url>/81be14b5/</url>
    <content><![CDATA[<p>25个人，每5个人一个跑道，最少经过几次比赛，得到前三名</p>
<p><strong>初步思路</strong>: </p>
<ol>
<li><p>每5人一组, 全跑完后, 每组的后两名一定不在最终要的”前三名” 结果内, 所以每组可以排除2人, 剩下25-2*5=15人. 共经过5次比赛 </p>
</li>
<li><p>剩下的15人, 每5人一组, 跑完后, 每组淘汰2人, 剩下 15-2*3=9人. 经过3次比赛 </p>
</li>
<li><p>剩下的9个人分两组, A组5人B组4人, 跑完后, A组淘汰2人, B组淘汰1人, 剩下 9-2-1=6人. 经过2次比赛 </p>
</li>
<li><p>剩下的6人分两组, C组5人D组1人, A组跑完后, 淘汰2人, B组1人不需要跑, 剩下 6-2=4人. 经过1次比赛 </p>
</li>
<li><p>剩下的4个人, 跑一次, 得出前三名. 经过1次比赛 共经过 5+3+2+1+1=12次</p>
</li>
</ol>
<p><strong>思路2：</strong></p>
<ol>
<li><p>在第一步中, 5组全跑完后, 每组的第一名再跑一次, 按速度快慢分别标为A1 B1 C1 D1 E1. 则A1 为25人中的第一名. 经过5+1=6次比赛 </p>
</li>
<li><p>在第6次比赛中, 落后的两名D1 和E1, 可以被排除, 进而整个D组和E组都可以排除. C1不可能是第二名. 第二名可能的人员有A2 B1, 第三名可能的人员有 B1 A3 B2 A2 C1. 第二名的集合是第三名集合的子集. 第三名所有可能的5个人跑一次, 得出第二名和第三名.经过1次比赛 共经过7次比赛</p>
</li>
</ol>
<p><strong>另一种思路：</strong></p>
<p>5次跑完后，每组第一名再跑一次，这次跑的第1名，就是25中的第1名；跑完后，这个第1名出去，他原来所在的组的第2名补上，再与第6次中的其他4个人跑，这样决出最快的那个人，就是25中的第2名，同样过程，决出第3名。共 8 次</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表的增删改查</title>
    <url>/942c23ec/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#快速了解跳表">快速了解跳表</a></li>
<li><a href="#跳表的增删改查">跳表的增删改查</a><ul>
<li><a href="#查询操作">查询操作</a></li>
<li><a href="#删除操作">删除操作</a></li>
<li><a href="#插入操作">插入操作</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<h3><span id="快速了解跳表">快速了解跳表</span></h3><p>跳跃表(简称跳表)由美国计算机科学家<strong><em>William Pugh发明于1989年</em></strong>。他在论文《Skip lists: a probabilistic alternative to balanced trees》中详细介绍了跳表的数据结构和插入删除等操作。</p>
<blockquote>
<p>​    跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。</p>
</blockquote>
<p>链表的优势就是更高效的插入、删除。<strong>痛点就是查询很慢很慢</strong>！每次查询都是一种O(n)复杂度的操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011145.png" alt></p>
<p>这是一个带头结点的链表(头结点相当于一个固定的入口，不存储有意义的值)，每次查找都需要一个个枚举，相当的慢，我们能不能稍微优化一下，让它稍微跳一跳呢？答案是可以的，我们知道很多算法和数据结构<strong>以空间换时间</strong>，我们在上面加一层索引，让部分节点在上层能够直接定位到，这样链表的查询时间近乎减少一半</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011307.png" alt></p>
<p>这样，在查询某个节点的时候，首先会从上一层快速定位节点所在的一个范围，如果找到具体范围向下然后查找代价很小，当然在表的结构设计上会增加一个向下的索引(指针)用来查找确定底层节点。平均查找速度平均为O(n/2)。但是当节点数量很大的时候，它依旧很慢很慢。我们都知道二分查找是每次都能折半的去压缩查找范围，要是有序链表也能这么跳起来那就太完美了。没错<strong>跳表就能让链表拥有近乎的接近二分查找的效率的一种数据结构</strong>，其原理依然是给上面加若干层索引，优化查找速度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011343.png" alt></p>
<p>通过上图可以看到，通过这样的一个数据结构对有序链表进行查找都能近乎二分的性能。就是在上面维护那么多层的索引，首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。</p>
<p>对于理想的跳表，每向上一层索引节点数量都是下一层的1/2.那么如果n个节点增加的节点数量(1/2+1/4+…)&lt;n。并且层数较低，对查找效果影响不大。但是对于这么一个结构，你可能会疑惑，这样完美的结构真的存在吗？大概率不存在的，因为作为一个链表，少不了增删该查的一些操作。而删除和插入可能会改变整个结构，所以上面的这些都是理想的结构，在插入的时候是否添加上层索引是个概率问题(1/2的概率)，</p>
<h3><span id="跳表的增删改查">跳表的增删改查</span></h3><p>在实现本跳表的过程为了便于操作，我们将跳表的头结点(head)的key设为int的最小值(一定满足左小右大方便比较)。</p>
<p>对于每个节点的设置，设置成SkipNode类，为了防止初学者将next向下还是向右搞混，直接设置right，down两个指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkipNode</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    T value;</span><br><span class="line">    SkipNode right,down;<span class="comment">//右下个方向的指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipNode</span> <span class="params">(<span class="type">int</span> key,T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key=key;</span><br><span class="line">        <span class="built_in">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跳表的结构和初始化也很重要，其主要参数和初始化方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span> &lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    SkipNode headNode;<span class="comment">//头节点，入口</span></span><br><span class="line">    <span class="type">int</span> highLevel;<span class="comment">//当前跳表索引层数</span></span><br><span class="line">    Random random;<span class="comment">// 用于投掷硬币</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">32</span>;<span class="comment">//最大的层</span></span><br><span class="line"></span><br><span class="line">    SkipList()&#123;</span><br><span class="line">        random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        headNode=<span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE,<span class="literal">null</span>);</span><br><span class="line">        highLevel=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="查询操作">查询操作</span></h4><p>很多时候链表也可能这样相连仅仅是某个元素或者key作为有序的标准。所以有可能链表内部存在一些value。不过修改和查询其实都是一个操作，找到关键数字(key)。并且查找的流程也很简单，设置一个临时节点team=head。当<strong>team不为null</strong>其流程大致如下：</p>
<p>(1) 从team节点出发，<strong>如果当前节点的key与查询的key相等</strong>，那么返回当前节点(如果是修改操作那么一直向下进行修改值即可)。</p>
<p>(2) 如果key不相等，且<strong>右侧为null</strong>，那么证明只能向下(结果可能出现在下右方向)，此时team=team.down</p>
<p>(3) 如果key不相等，且右侧不为null，且<strong>右侧节点key小于待查询的key</strong>。那么说明同级还可向右，此时team=team.right</p>
<p>(4)（否则的情况）如果key不相等，且右侧不为null，且<strong>右侧节点key大于待查询的key</strong> 。那么说明如果有结果的话就在这个索引和下个索引之间，此时team=team.down。</p>
<p>最终将按照这个步骤返回正确的节点或者null(说明没查到)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011553.png" alt></p>
<p>例如上图查询12节点，首先第一步从head出发发现右侧不为空，且7&lt;12,向右；第二步右侧为null向下；第三步节点7的右侧10&lt;12继续向右；第四步10右侧为null向下；第五步右侧12小于等于向右。第六步起始发现相等返回节点结束。</p>
<p>而这块的代码也非常容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SkipNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    SkipNode team=headNode;</span><br><span class="line">    <span class="keyword">while</span> (team!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(team.key==key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  team;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right==<span class="literal">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//右侧比较小向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4><span id="删除操作">删除操作</span></h4><p>删除操作比起查询稍微复杂一丢丢，但是比插入简单。删除需要改变链表结构所以需要处理好节点之间的联系。对于删除操作你需要谨记以下几点：</p>
<p>(1)删除当前节点和这个节点的前后节点都有关系</p>
<p>(2)删除当前层节点之后，下一层该key的节点也要删除，一直删除到最底层</p>
<p>根据这两点分析一下：如果找到当前节点了，<strong>它的前面一个节点怎么查找呢</strong>？这个总不能在遍历一遍吧！有的使用四个方向的指针(上下左右)用来找到左侧节点。是可以的，但是这里可以<strong>特殊处理一下</strong> ，不直接判断和操作节点，先找到<strong>待删除节点的左侧节点</strong>。通过这个节点即可完成删除，然后这个节点直接向下去找下一层待删除的左侧节点。设置一个临时节点team=head，<strong>当team不为null</strong>具体循环流程为：</p>
<p>(1)如果<strong>team右侧为null</strong>，那么team=team.down(之所以敢直接这么判断是因为左侧有头结点在左侧，不用担心特殊情况)</p>
<p>(2)如果team右侧不 为null，并且<strong>右侧的key等于待删除的key</strong>，那么先删除节点，再team向下team=team.down为了删除下层节点。</p>
<p>(3)如果team右侧不 为null，并且<strong>右侧key小于待删除的key</strong>，那么team向右team=team.right。</p>
<p>(4)如果team右侧不 为null，并且<strong>右侧key大于待删除的key</strong>，那么team向下team=team.down，在下层继续查找删除节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011642.png" alt></p>
<p>例如上图删除10节点，首先team=head从team出发，7&lt;10向右(team=team.right后面省略)；第二步右侧为null只能向下；第三部右侧为10在当前层删除10节点然后向下继续查找下一层10节点；第四步8&lt;10向右；第五步右侧为10删除该节点并且team向下。team为null说明删除完毕退出循环。</p>
<p>删除操作实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span><span class="comment">//删除不需要考虑层数</span></span><br><span class="line">&#123;</span><br><span class="line">    SkipNode team=headNode;</span><br><span class="line">    <span class="keyword">while</span> (team!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (team.right == <span class="literal">null</span>) &#123;<span class="comment">//右侧没有了，说明这一层找到，没有只能下降</span></span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key==key)<span class="comment">//找到节点，右侧即为待删除节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            team.right=team.right.right;<span class="comment">//删除右侧节点</span></span><br><span class="line">            team=team.down;<span class="comment">//向下继续查找删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//右侧已经不可能了，向下</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//节点还在右侧</span></span><br><span class="line">            team=team.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="插入操作">插入操作</span></h4><p>插入操作在实现起来是最麻烦的，需要的考虑的东西最多。回顾查询，不需要动索引；回顾删除，每层索引如果有删除就是了。但是插入不一样了，<strong>插入需要考虑是否插入索引，插入几层</strong>等问题。由于需要插入删除所以我们肯定无法维护一个完全理想的索引结构，因为它耗费的代价太高。但我们使用<strong>随机化</strong>的方法去判断是否向上层插入索引。即产生一个[0-1]的随机数如果小于0.5就向上插入索引，插入完毕后再次使用随机数判断是否向上插入索引。运气好这个值可能是多层索引，运气不好只插入最底层(这是100%插入的)。但是索引也不能不限制高度，我们一般会设置索引最高值如果大于这个值就不往上继续添加索引了。</p>
<p>我们一步步剖析该怎么做，其流程为</p>
<p>(1)首先通过上面查找的方式，找到<strong>待插入的左节点</strong>。插入的话最底层肯定是需要插入的，所以通过链表插入节点(需要考虑是否为末尾节点)</p>
<p>(2)插入完这一层，需要考虑上一层是否插入，首先判断当前索引层级，如果大于最大值那么就停止(比如已经到最高索引层了)。否则设置一个随机数1/2的概率向上插入一层索引(因为理想状态下的就是每2个向上建一个索引节点)。</p>
<p>(3)继续(2)的操作，直到概率退出或者索引层数大于最大索引层。</p>
<p>在<strong>具体向上插入</strong>的时候，实质上还有非常重要的细节需要考虑。首先<strong>如何找到上层的待插入节点</strong> ？</p>
<p>这个各个实现方法可能不同，如果有左、上指向的指针那么可以向左向上找到上层需要插入的节点，但是如果只有右指向和下指向的我们也可以<strong>巧妙的借助查询过程中记录下降的节点</strong>。因为曾经下降的节点倒序就是需要插入的节点，最底层也不例外(因为没有匹配值会下降为null结束循环)。在这里我使用<strong>栈</strong>这个数据结构进行存储，当然使用List也可以。下图就是给了一个插入示意图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011750.png" alt></p>
<p>其次如果该层是目前的<strong>最高层索引</strong>，需要<strong>继续向上建立索引</strong>应该怎么办？</p>
<p>首先跳表最初肯定是没索引的，然后慢慢添加节点才有一层、二层索引，但是如果这个节点添加的索引突破当前最高层，该怎么办呢？</p>
<p>这时候<strong>需要注意</strong>了，跳表的head需要改变了，新建一个ListNode节点作为新的head，将它的down指向老head，将这个head节点加入栈中(也就是这个节点作为下次后面要插入的节点)，就比如上面的9节点如果运气够好在往上建立一层节点，会是这样的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011835.png" alt></p>
<p>插入上层的时候注意所有节点要新建(拷贝)，除了right的指向down的指向也不能忘记，down指向上一个节点可以用一个临时节点作为前驱节点。如果层数突破当前最高层，头head节点(入口)需要改变。</p>
<p>这部分更多的细节在代码中注释解释了，详细代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(SkipNode node)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key=node.key;</span><br><span class="line">    SkipNode findNode=search(key);</span><br><span class="line">    <span class="keyword">if</span>(findNode!=<span class="literal">null</span>)<span class="comment">//如果存在这个key的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        findNode.value=node.value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;SkipNode&gt;stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;SkipNode&gt;();<span class="comment">//存储向下的节点，这些节点可能在右侧插入节点</span></span><br><span class="line">    SkipNode team=headNode;<span class="comment">//查找待插入的节点   找到最底层的哪个节点。</span></span><br><span class="line">    <span class="keyword">while</span> (team!=<span class="literal">null</span>) &#123;<span class="comment">//进行查找操作 </span></span><br><span class="line">        <span class="keyword">if</span>(team.right==<span class="literal">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">        &#123;</span><br><span class="line">            stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">        &#123;</span><br><span class="line">            stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">            team=team.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            team=team.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> level=<span class="number">1</span>;<span class="comment">//当前层数，从第一层添加(第一层必须添加，先添加再判断)</span></span><br><span class="line">    SkipNode downNode=<span class="literal">null</span>;<span class="comment">//保持前驱节点(即down的指向，初始为null)</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//在该层插入node</span></span><br><span class="line">        team=stack.pop();<span class="comment">//抛出待插入的左侧节点</span></span><br><span class="line">        SkipNode nodeTeam=<span class="keyword">new</span> <span class="title class_">SkipNode</span>(node.key, node.value);<span class="comment">//节点需要重新创建</span></span><br><span class="line">        nodeTeam.down=downNode;<span class="comment">//处理竖方向</span></span><br><span class="line">        downNode=nodeTeam;<span class="comment">//标记新的节点下次使用</span></span><br><span class="line">        <span class="keyword">if</span>(team.right==<span class="literal">null</span>) &#123;<span class="comment">//右侧为null 说明插入在末尾</span></span><br><span class="line">            team.right=nodeTeam;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//水平方向处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右侧还有节点，插入在两者之间</span></span><br><span class="line">            nodeTeam.right=team.right;</span><br><span class="line">            team.right=nodeTeam;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑是否需要向上</span></span><br><span class="line">        <span class="keyword">if</span>(level&gt;MAX_LEVEL)<span class="comment">//已经到达最高级的节点啦</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">double</span> num=random.nextDouble();<span class="comment">//[0-1]随机数</span></span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0.5</span>)<span class="comment">//运气不好结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;highLevel)<span class="comment">//比当前最大高度要高但是依然在允许范围内 需要改变head节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            highLevel=level;</span><br><span class="line">            <span class="comment">//需要创建一个新的节点</span></span><br><span class="line">            SkipNode highHeadNode=<span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">            highHeadNode.down=headNode;</span><br><span class="line">            headNode=highHeadNode;<span class="comment">//改变head</span></span><br><span class="line">            stack.add(headNode);<span class="comment">//下次抛出head</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3><span id="总结">总结</span></h3><p>对于上面，跳表完整分析就结束啦，当然，你可能看到不同品种跳表的实现，还有的用数组方式表示上下层的关系这样也可以，但本文只定义right和down两个方向的链表更纯正化的讲解跳表。</p>
<p>对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？因为跳表除了查找插入维护和红黑树有着差不多的效率，它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。而JDK中<strong>跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。</strong> 有兴趣的也可以查阅一下源码。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipNode</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    T value;</span><br><span class="line">    SkipNode right,down;<span class="comment">//左右上下四个方向的指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipNode</span> <span class="params">(<span class="type">int</span> key,T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key=key;</span><br><span class="line">        <span class="built_in">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span> &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    SkipNode headNode;<span class="comment">//头节点，入口</span></span><br><span class="line">    <span class="type">int</span> highLevel;<span class="comment">//层数</span></span><br><span class="line">    Random random;<span class="comment">// 用于投掷硬币</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">32</span>;<span class="comment">//最大的层</span></span><br><span class="line">    SkipList()&#123;</span><br><span class="line">        random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        headNode=<span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE,<span class="literal">null</span>);</span><br><span class="line">        highLevel=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SkipNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        SkipNode team=headNode;</span><br><span class="line">        <span class="keyword">while</span> (team!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(team.key==key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>  team;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right==<span class="literal">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//右侧比较小向右</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span><span class="comment">//删除不需要考虑层数</span></span><br><span class="line">    &#123;</span><br><span class="line">        SkipNode team=headNode;</span><br><span class="line">        <span class="keyword">while</span> (team!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (team.right == <span class="literal">null</span>) &#123;<span class="comment">//右侧没有了，说明这一层找到，没有只能下降</span></span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key==key)<span class="comment">//找到节点，右侧即为待删除节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                team.right=team.right.right;<span class="comment">//删除右侧节点</span></span><br><span class="line">                team=team.down;<span class="comment">//向下继续查找删除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//右侧已经不可能了，向下</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//节点还在右侧</span></span><br><span class="line">                team=team.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(SkipNode node)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> key=node.key;</span><br><span class="line">        SkipNode findNode=search(key);</span><br><span class="line">        <span class="keyword">if</span>(findNode!=<span class="literal">null</span>)<span class="comment">//如果存在这个key的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            findNode.value=node.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;SkipNode&gt;stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;SkipNode&gt;();<span class="comment">//存储向下的节点，这些节点可能在右侧插入节点</span></span><br><span class="line">        SkipNode team=headNode;<span class="comment">//查找待插入的节点   找到最底层的哪个节点。</span></span><br><span class="line">        <span class="keyword">while</span> (team!=<span class="literal">null</span>) &#123;<span class="comment">//进行查找操作</span></span><br><span class="line">            <span class="keyword">if</span>(team.right==<span class="literal">null</span>)<span class="comment">//右侧没有了，只能下降</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(team.right.key&gt;key)<span class="comment">//需要下降去寻找</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(team);<span class="comment">//将曾经向下的节点记录一下</span></span><br><span class="line">                team=team.down;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//向右</span></span><br><span class="line">            &#123;</span><br><span class="line">                team=team.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> level=<span class="number">1</span>;<span class="comment">//当前层数，从第一层添加(第一层必须添加，先添加再判断)</span></span><br><span class="line">        SkipNode downNode=<span class="literal">null</span>;<span class="comment">//保持前驱节点(即down的指向，初始为null)</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//在该层插入node</span></span><br><span class="line">            team=stack.pop();<span class="comment">//抛出待插入的左侧节点</span></span><br><span class="line">            SkipNode nodeTeam=<span class="keyword">new</span> <span class="title class_">SkipNode</span>(node.key, node.value);<span class="comment">//节点需要重新创建</span></span><br><span class="line">            nodeTeam.down=downNode;<span class="comment">//处理竖方向</span></span><br><span class="line">            downNode=nodeTeam;<span class="comment">//标记新的节点下次使用</span></span><br><span class="line">            <span class="keyword">if</span>(team.right==<span class="literal">null</span>) &#123;<span class="comment">//右侧为null 说明插入在末尾</span></span><br><span class="line">                team.right=nodeTeam;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//水平方向处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//右侧还有节点，插入在两者之间</span></span><br><span class="line">                nodeTeam.right=team.right;</span><br><span class="line">                team.right=nodeTeam;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//考虑是否需要向上</span></span><br><span class="line">            <span class="keyword">if</span>(level&gt;MAX_LEVEL)<span class="comment">//已经到达最高级的节点啦</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">double</span> num=random.nextDouble();<span class="comment">//[0-1]随机数</span></span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0.5</span>)<span class="comment">//运气不好结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">if</span>(level&gt;highLevel)<span class="comment">//比当前最大高度要高但是依然在允许范围内 需要改变head节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                highLevel=level;</span><br><span class="line">                <span class="comment">//需要创建一个新的节点</span></span><br><span class="line">                SkipNode highHeadNode=<span class="keyword">new</span> <span class="title class_">SkipNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">                highHeadNode.down=headNode;</span><br><span class="line">                headNode=highHeadNode;<span class="comment">//改变head</span></span><br><span class="line">                stack.add(headNode);<span class="comment">//下次抛出head</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">        SkipNode teamNode=headNode;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line">        SkipNode last=teamNode;</span><br><span class="line">        <span class="keyword">while</span> (last.down!=<span class="literal">null</span>)&#123;</span><br><span class="line">            last=last.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (teamNode!=<span class="literal">null</span>) &#123;</span><br><span class="line">            SkipNode enumNode=teamNode.right;</span><br><span class="line">            SkipNode enumLast=last.right;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%-8s&quot;</span>,<span class="string">&quot;head-&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (enumLast!=<span class="literal">null</span>&amp;&amp;enumNode!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(enumLast.key==enumNode.key)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-5s&quot;</span>,enumLast.key+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    enumLast=enumLast.right;</span><br><span class="line">                    enumNode=enumNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    enumLast=enumLast.right;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-5s&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            teamNode=teamNode.down;</span><br><span class="line">            index++;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SkipList&lt;Integer&gt;list=<span class="keyword">new</span> <span class="title class_">SkipList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">SkipNode</span>(i,<span class="number">666</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        list.printList();</span><br><span class="line">        list.delete(<span class="number">4</span>);</span><br><span class="line">        list.delete(<span class="number">8</span>);</span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】通过禁止比较让 Go 二进制文件变小</title>
    <url>/27d7ea27/</url>
    <content><![CDATA[<!-----
![](https://img.linux.net.cn/data/attachment/album/202005/22/101617lcha7vvqzhh7d565.jpg)
------>

<p>大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件就越大。这个符合直觉，毕竟如果你写的代码不去操作定义的类型，那么定义一堆类型就没有意义了。然而，链接器的部分工作就是检测没有被程序引用的函数（比如说它们是一个库的一部分，其中只有一个子集的功能被使用），然后把它们从最后的编译产出中删除。常言道，“类型越多，二进制文件越大”，对于多数 Go 程序还是正确的。</p>
<p>本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么<a href="https://github.com/golang/net/commit/e0ff5e5a1de5b859e2d48a2830d7933b3ab5b75f">像这样</a>的修改会对 Go 程序的大小有重大的影响。</p>
<h3><span id="定义两个值相等">定义两个值相等</span></h3><p>Go 的语法定义了“赋值”和“相等”的概念。赋值是把一个值赋给一个标识符的行为。并不是所有声明的标识符都可以被赋值，如常量和函数就不可以。相等是通过检查标识符的内容是否相等来比较两个标识符的行为。</p>
<p>作为强类型语言，“相同”的概念从根源上被植入标识符的类型中。两个标识符只有是相同类型的前提下，才有可能相同。除此之外，值的类型定义了如何比较该类型的两个值。</p>
<p>例如，整型是用算数方法进行比较的。对于指针类型，是否相等是指它们指向的地址是否相同。映射和通道等引用类型，跟指针类似，如果它们指向相同的地址，那么就认为它们是相同的。</p>
<p>上面都是按位比较相等的例子，即值占用的内存的位模式是相同的，那么这些值就相等。这就是所谓的 memcmp，即内存比较，相等是通过比较两个内存区域的内容来定义的。</p>
<p>记住这个思路，我过会儿再来谈。</p>
<h3><span id="结构体相等">结构体相等</span></h3><p>除了整型、浮点型和指针等标量类型，还有复合类型：结构体。所有的结构体以程序中的顺序被排列在内存中。因此下面这个声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a, b, c, d int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会占用 32 字节的内存空间；<code>a</code> 占用 8 个字节，<code>b</code> 占用 8 个字节，以此类推。Go 的规则说如果结构体所有的字段都是可以比较的，那么结构体的值就是可以比较的。因此如果两个结构体所有的字段都相等，那么它们就相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">b := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">fmt.Println(a == b) // 输出 true</span><br></pre></td></tr></table></figure>

<p>编译器在底层使用 memcmp 来比较 <code>a</code> 的 32 个字节和 <code>b</code> 的 32 个字节。</p>
<h3><span id="填充和对齐">填充和对齐</span></h3><p>然而，在下面的场景下过分简单化的按位比较的策略会返回错误的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a byte</span><br><span class="line">    b uint64</span><br><span class="line">    c int16</span><br><span class="line">    d uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()</span><br><span class="line">    a := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">    b := S&#123;1, 2, 3, 4&#125;</span><br><span class="line">    fmt.Println(a == b) // 输出 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译代码后，这个比较表达式的结果还是 <code>true</code>，但是编译器在底层并不能仅依赖比较 <code>a</code> 和 <code>b</code> 的位模式，因为结构体有<em>填充</em>。</p>
<p>Go 要求结构体的所有字段都对齐。2 字节的值必须从偶数地址开始，4 字节的值必须从 4 的倍数地址开始，以此类推。编译器根据字段的类型和底层平台加入了填充来确保字段都<em>对齐</em>。在填充之后，编译器实际上看到的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">    a byte</span><br><span class="line">    _ [7]byte // 填充</span><br><span class="line">    b uint64</span><br><span class="line">    c int16</span><br><span class="line">    _ [2]int16 // 填充</span><br><span class="line">    d uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充的存在保证了字段正确对齐，而填充确实占用了内存空间，但是填充字节的内容是未知的。你可能会认为在 Go 中 填充字节都是 0，但实际上并不是 — 填充字节的内容是未定义的。由于它们并不是被定义为某个确定的值，因此按位比较会因为分布在 <code>s</code> 的 24 字节中的 9 个填充字节不一样而返回错误结果。</p>
<p>Go 通过生成所谓的相等函数来解决这个问题。在这个例子中，<code>s</code> 的相等函数只比较函数中的字段略过填充部分，这样就能正确比较类型 <code>s</code> 的两个值。</p>
<h3><span id="类型算法">类型算法</span></h3><p>呵，这是个很大的设置，说明了为什么，对于 Go 程序中定义的每种类型，编译器都会生成几个支持函数，编译器内部把它们称作类型的算法。如果类型是一个映射的键，那么除相等函数外，编译器还会生成一个哈希函数。为了维持稳定，哈希函数在计算结果时也会像相等函数一样考虑诸如填充等因素。</p>
<p>凭直觉判断编译器什么时候生成这些函数实际上很难，有时并不明显，（因为）这超出了你的预期，而且链接器也很难消除没有被使用的函数，因为反射往往导致链接器在裁剪类型时变得更保守。</p>
<h3><span id="通过禁止比较来减小二进制文件的大小">通过禁止比较来减小二进制文件的大小</span></h3><p>现在，我们来解释一下 Brad 的修改。向类型添加一个不可比较的字段，结构体也随之变成不可比较的，从而强制编译器不再生成相等函数和哈希函数，规避了链接器对那些类型的消除，在实际应用中减小了生成的二进制文件的大小。作为这项技术的一个例子，下面的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    type t struct &#123;</span><br><span class="line">        // _ [0][]byte // 取消注释以阻止比较</span><br><span class="line">        a byte</span><br><span class="line">        b uint16</span><br><span class="line">        c int32</span><br><span class="line">        d uint64</span><br><span class="line">    &#125;</span><br><span class="line">    var a t</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Go 1.14.2（darwin/amd64）编译，大小从 2174088 降到了 2174056，节省了 32 字节。单独看节省的这 32 字节似乎微不足道，但是考虑到你的程序中每个类型及其传递闭包都会生成相等和哈希函数，还有它们的依赖，这些函数的大小随类型大小和复杂度的不同而不同，禁止它们会大大减小最终的二进制文件的大小，效果比之前使用 <code>-ldflags=&quot;-s -w&quot;</code> 还要好。</p>
<p>最后总结一下，如果你不想把类型定义为可比较的，可以在源码层级强制实现像这样的奇技淫巧，会使生成的二进制文件变小。</p>
<hr>
<p>via: <a href="https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons">https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons</a></p>
<p>作者：<a href="https://dave.cheney.net/author/davecheney">Dave Cheney</a><br>选题：<a href="https://github.com/lujun9972">lujun9972</a><br>译者：<a href="https://github.com/lxbwolf">Xiaobin.Liu</a><br>校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件发送原理</title>
    <url>/b0248f59/</url>
    <content><![CDATA[<p>SMTP(Simple Mail Transfer Protocol)是电子邮件从客户机传输到服务器或从某一个服务器传输到另一个服务器使用的传输协议。SMTP 是请求/响应协议，命令和响应都是基于 ASCII 文本，并以 CR 和 LF 符结束。响应包括一个表示返回状态的三位数字代码。在 TCP 协议 25 端口监听连接请求。其命令如下：</p>
<p>SMTP命令</p>
<p>命令说明</p>
<p>HELO ＜domain＞＜CRLF＞</p>
<p>识别发送方到接收SMTP的一个HELO命令</p>
<p>AUTH LOGIN</p>
<p>登陆服务器的命令。在这条命令之后，要发送用Base64编码后的用户名与密码进行登陆</p>
<p>MAIL FROM:＜reverse-path＞＜CRLF＞</p>
<p>＜reverse-path＞为发送者地址。此命令告诉接收方一个新邮件发送的开始，并对所有的状态和缓冲区进行初始化。此命令开始一个邮件传输处理，最终完成将邮件数据传送到一个或多个邮箱中</p>
<p>RCPT TO:＜forward-path＞＜CRLF＞</p>
<p>＜forward-path＞标识各个邮件接收者的地址</p>
<p>DATA ＜CRLF＞</p>
<p>接收SMTP将把其后的行为看作邮件数据去处理，以＜CRLF＞.＜CRLF＞标识数据的结尾</p>
<p>REST ＜CRLF＞</p>
<p>退出/复位当前的邮件传输</p>
<p>NOOP ＜CRLF＞</p>
<p>要求接收SMTP仅做OK应答。（用于测试）</p>
<p>QUIT ＜CRLF＞</p>
<p>要求接收SMTP返回一个OK应答并关闭传输。</p>
<p>VRFY ＜string＞ ＜CRLF＞</p>
<p>验证指定的邮箱是否存在，由于安全因素，服务器多禁止此命令。</p>
<p>EXPN ＜string＞ ＜CRLF＞</p>
<p>验证给定的邮箱列表是否存在，扩充邮箱列表，也常禁止使用。</p>
<p>HELP ＜CRLF＞</p>
<p>查询服务器支持什么命令</p>
<hr>
<p>邮件交互图</p>
<pre><code>A-&gt;B: 1. 建立TCP连接(host:port, 默认port为25)
B-&gt;A: 220. Anti-spam GT for Coremail System
Note over A: 
A-&gt;B: 2. 向服务器标识用户身份(HELO host\r\/n)
B-&gt;A: 250 OK
Note over A: 
A-&gt;B: 3. 登录服务器(AUTH LOGIN\r\/n)
B-&gt;A: 334. username: (这里是解密后的信息)
A-&gt;B: &lt;my_username&gt;(要用Base64加密)
B-&gt;A: 334. password: (这里是解密后的信息)
A-&gt;B: &lt;my_password&gt;(要用Base64加密)
B-&gt;A: 235. Authentication successful
Note over A: 
A-&gt;B: 4. 指定发信者(MAIL FROM: &lt;my_sender@gmail.com&gt;\r\/n)
B-&gt;A: 250. Mail OK
Note over A: 
A-&gt;B: 5. 指定收信者(RCPT TO: &lt;my_receiver@gmail.com&gt;\r\/n)
B-&gt;A: 250. Mail OK
Note over A: 
A-&gt;B: 6. 发送数据(DATA\r\/n)
B-&gt;A: 354. End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
Note over A: 
A-&gt;B: 7. to: &lt;my_receiver@gmail.com\r\/nsubject:&lt;my_subject&gt;\r\/nSome Context\r\/n.\r\/n&gt;
B-&gt;A: 250. Mail OK
Note over A: 
A-&gt;B: 8. QUIT\r\/n
B-&gt;A: 221. Bye</code></pre><p><strong>因markdown里不能打出”\n”, 因此使用”\/n” 代替”\n”</strong></p>
<hr>
<p>SMTP发信操作及返回码</p>
<pre><code>[crazywill@localhost crazywill]$ telnet smtp.163.com 25 #telnet登录25端口
Trying 202.108.5.81...
Connected to smtp.163.com.
Escape character is &apos;^]&apos;.
220 163.com Coremail SMTP(Anti Spam) System
EHLO smtp.163.com # 握手 :)
250-mail
250-PIPELINING
250-AUTH LOGIN PLAIN
250-AUTH=LOGIN PLAIN
250 8BITMIME
AUTH LOGIN # 开始认证登录
334 dXNlcm5hbWU6
crazywill
334 UGFzc3dvcmQ6
mypassword
535 Error: authentication failed # 直接用户名密码不能登录
AUTH LOGIN
334 dXNlcm5hbWU6
Y3Jhenl3aWxs
334 UGFzc3dvcmQ6
bXlwYXNzd29yZA==
235 Authentication successful # 使用Base64编码则成功登录
MAIL FROM:&lt;test@163.com&gt; # 邮件发送方
553 You are not authorized to send mail, authentication is required # 不可伪造发送邮件 
MAIL FROM:&lt;crazywill@163.com&gt; # 邮件发送方
250 Mail OK
RCPT TO:&lt;crazywill@163.com&gt; # 邮件的接收方，若有多个收件人，则重复这一语句多次。
250 Mail OK
DATA # 邮件体内容
354 Please start mail input.
TO: crazywill@163.com # 此处的TO，FROM，等内容，可以随便造假 :) 可以骗人但骗不了懂得查看邮件源码的。
FROM: cccc@163.com
SUBJECT: test by telnet/smtp 

test, just a test. # 邮件正文内容，与Header部分空一行开始写
. # 邮件写完，以一个句点加回车结果。
250 Mail OK queued as smtp10,wKjADQ2ApxRnnqBE0CWaEw==.38326S3 # 返回250 表示发送成功。
NOOP # 空语句，不执行任何操作，一般用来保持和服务器连接，不要掉线
250 OK
QUIT # 退出
221 Closing connection. Good bye.
Connection closed by foreign host.
[crazywill@localhost crazywill]$</code></pre><hr>
<p>参考资料: <a href="http://www.cnblogs.com/FengYan/archive/2013/01/01/2840982.html">用c++发邮件</a> <a href="http://blog.csdn.net/lishuhuakai/article/details/27503503">电子邮件发送的原理以及简易实现</a> <a href="http://blog.csdn.net/lishuhuakai/article/details/27852009">邮件正文及其附件的发送的C++实现</a> <a href="http://blog.csdn.net/zbird1988/article/details/11592137">C++通过SMTP发送邮件总结</a> <a href="http://blog.csdn.net/zbird1988/article/details/11592137">C++实现向多人发送邮件</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>重定向广告</title>
    <url>/cb9b2c66/</url>
    <content><![CDATA[<h2><span id="为什么在京东搜索的商品会展示在抖音广告上">为什么在京东搜索的商品，会展示在抖音广告上</span></h2><p>不知道你是不是也会遇到这个情况，你刚才说想要个戴森吹风机，头条APP里的广告就展示了戴森的广告。</p>
<p>当你在京东的搜索框里搜索了蒸锅后，你的其他软件可能就被蒸锅攻陷了。</p>
<p>头条广告里看到苏泊尔蒸锅的广告，刷抖音时能看到苏泊尔的广告，上个知乎还能看到苏泊尔的广告……。是不是感觉自己完全陷入了恶性循环，进了套路里。</p>
<p>甚至是，你从两部手机切换过后，还是会看到苏泊尔蒸锅的广告！</p>
<p>如果你认为是巧合，那就大错特错了，其实这是广告界常用的产品，叫做<strong>重定向广告</strong>。</p>
<p>这个操作对广告主来说那是极好的，实际上是却给人带来了极大的恐惧感。就好比你在微信的聊天记录，公开到了所有产品上，被所有人无情鞭策。</p>
<p>互联网时代信息公开透明，但却让人们少了隐私。</p>
<h3><span id="为什么主流产品都这么干">为什么主流产品都这么干</span></h3><p>思考一个场景：</p>
<p>假设你在京东搜索电视机，可能你是有购买意向的，但最后没有下单转化。对于平台来说，损失了一个客户。如果，同时有几万人都有这个行为，那对平台来说就损失很大了。</p>
<p>所以，平台要做两件事。</p>
<p><strong>一是在站内，做二次营销。</strong></p>
<p>比如弹出搜索的专属红包，或专属优惠券，用红包权益进行二次刺激。</p>
<p>如下图每日优鲜的截图，搜索之后，进入商详页，会直接给相关的优惠券，刺激下单转化。据说让利10元，可以提升转化率40%以上。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042139107.png" alt></p>
<p><strong>二是在站外，做重定向广告</strong>。</p>
<p>它就像定位器一样，无时不刻找到你并给你展示广告。假如你离开了网站，平台就会有这个方法牢牢拴住你。</p>
<p>比如在京东搜索蒸锅，马上在头条就会投放蒸锅的广告，而且每次的广告品牌可能也会不一样</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042139685.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042140887.png" alt></p>
<p>据 Google Adwords提供的数据，在30天内为同一个用户展示7~10次广告的转化效果最好，做到这个程度的广告收益可以达到三倍以上。</p>
<p>站内浏览广告并购买的用户仅为5%，有95%的用户流失掉了，拉回并转化这些用户，则是重定向广告的使命。</p>
<p>坦福大学商学院的营销学教授Navdeep Sahni曾经做过一个实验，他利用各种重定向活动对 <a href="http://BuildDirect.com">http://BuildDirect.com</a> 的23w用户进行访问观测。</p>
<p>在观测期间，有的用户零广告观看，有的用户观看15次以上，经过4周的试验后，得出结论：重定向广告增加了他们返回网站的可能性接近15％，很大一部分人因为重定向广告，改变了行为。</p>
<h3><span id="整个过程是什么样子的">整个过程是什么样子的</span></h3><p>其实，整个过程并不复杂</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042141865.png" alt></p>
<p>假如你作为电商网站的产品经理，如果想要接入重定向广告能力，需要做这几步，</p>
<h4><span id="1-在你的网站埋入统计追踪代码">1. 在你的网站埋入统计追踪代码</span></h4><p>有些是广告联盟提供的是插件或者SDK，比如 Avazu DSP提供的就是一个插件，给到其他商家店铺。</p>
<p>这份代码主要目的是为了把用户的信息记录到浏览器或手机本地的cookie里，其投放平台读取这份cookie，其中包含用户id，电话号，基本信息，访问信息等。</p>
<p>当然，cookie不是万能的，还会引入其他的手段继续识别用户身份，比如设备识别码，手机信息，web浏览器、操作系统、屏幕分辨率、时区、语言、插件、字体等</p>
<p>这些信息可以确定唯一的用户身份，当你换设备的时候，其实已经通过这些信息再一次进行了关联。</p>
<p><strong>逃？那是不可能的，细思极恐吧！</strong></p>
<h4><span id="2-在线竞价">2. 在线竞价</span></h4><p>先普及一下广告业务的竞价排名。简单来讲，就是通过价格优势来竞争广告位。</p>
<p>比如百度的广告，你出价“起点学院”的广告词，虽然你是起点学院的负责人老曹，但是并不一定能够拿到这个词，因为友商三节课花的价钱更高，拿到了“起点学院”这个词。</p>
<p>当用户在百度搜索“起点学院”时，出现的是三节课的推广（当然，这并不会发生）。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042141152.png" alt></p>
<p>我们回到重定向广告的竞价，其实一个道理，用户在淘宝搜索蒸锅，也在京东搜索的蒸锅，那到底是展示淘宝的推广还是京东的推广呢？</p>
<p>还是一决雌雄吧，<strong>我们靠竞价说话，谁价格高，广告联盟就出谁的广告</strong>。</p>
<h4><span id="3-展示广告">3. 展示广告</span></h4><p>凡是和广告联盟对接的流量平台， 都可以承接广告。当流量平台识别出用户id后，自动替换掉默认出的广告图，打上个性化广告。</p>
<p>下面的是Avazu DSP可以投放的流量平台，用户在这些流量渠道即可看到重定向广告。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042142982.png" alt></p>
<p>当重定向发展到第二阶段时，由原来的搜索1对1关系，扩散到1对多的关系。算法的引入，可以更精准预测了用户的购买需求。</p>
<p>比如本来搜索的是大疆无人机，那么推荐一些和大疆相关的其他商品，增加购买的可能性。</p>
<h3><span id="细思极恐的东西">细思极恐的东西</span></h3><p>作为一个吃瓜群众，莫名其妙的就被广告主割了韭菜，防不胜防，也无法防。</p>
<p>在2017年，苹果推出了新功能叫<strong>智能反追踪</strong>，并集成在 Safari浏览器中，为了保护用户的隐私不被泄露。</p>
<p>不过，苹果受不住利益的诱惑，在可以保住底裤的同时，今年又推出了隐私保护广告点击归因，其旨在即能保护用户隐私，还能给广告主信息进行广告投放。</p>
<p>简单来说，是用户把自己的信息存储到了cookie中，或者存储到手机设备中，广告主可以识别这些信息对应到人，但是却无法解析到更多其他信息了。</p>
<p>这个做法和阿里的数据银行比较相似，用户的详细数据是明确禁止外部传播的，数据银行给品牌产出的数据仅仅是人群包，人群包只能在内部有权限的业务识别，保障了数据的安全性。</p>
<h2><span id="微信刚聊完就收到商品推荐电商app在监视我吗">微信刚聊完就收到商品推荐，电商App在监视我吗</span></h2><p>当你搜索、点击、浏览、收藏、购买了某件商品后，紧接着就会收到网站或电商平台的相关广告推送，这已经不是什么新鲜事了，你在互联网上的一举一动，在商家眼里就是大数据和用户画像。</p>
<p>但是，当你的微信聊天记录、和同事面对面说话时的聊天内容、手机相册里的照片也会被电商APP用于推荐广告时，你会感到害怕吗？</p>
<p>近日有用户称，自己在微信群聊中讨论过一款雨伞，随后就收到了电商平台的短信推送。不仅如此，不少用户反映自己的手机相册、面对面聊天中的内容都有可能已被“窃听”，因为收到了与此相关的精准广告推送。</p>
<p>事实上，一些应用软件在安装时就获取了用户位置、相机、麦克风等诸多权限，你的所有信息和随后的浏览、搜索行为都会成为一个一个的数据库文件，最终组成有标签、有画像的“另一个自己”。不光地域、性别、消费习惯，商家还能知道你手机里装了哪些APP。</p>
<p>从技术上来看，分析提取文字、图片、语音、视频等内容中的商品信息并做精准推荐并无难度，可能泄露个人信息的“重灾区”主要集中在应用软件、输入法、公开WiFi、运营商等方面。对于电商广告投放平台来说，接入第三方数据库的行为非常普遍，基本可以算是标配。</p>
<h3><span id="1-无处不在的精准推荐">1 无处不在的精准推荐</span></h3><p>近日，用户A称，8月14日下午，有朋友在微信群里询问“赤峰有没有蕉下伞专柜”，他回答称“不太清楚”。第二天上午，他就收到当当网的短信，推送了“蕉下小黑伞清仓99元”的购买链接。</p>
<p>用户A表示，除了在微信群里和朋友互动之外，他没有在任何地方搜索、浏览过雨伞。“收到当当短信的那一刻，直觉告诉我，我被监控了。”</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042145625.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042145049.png" alt></p>
<p>事后，当当网客服表示，当当网每期的推送是根据平台的促销活动随机发出，用户在当当网的搜索和购买记录平台能获取，但在其它平台上的痕迹并不能获取到。微信团队尚未对此事给出回复。</p>
<p>用户A的案例只是“被监控”的一种情况，用户B则是相册信息被读取。她穿了一套新衣服，拍了一些照片存在手机相册里，随后她打开淘宝首页，推荐的商品均是该款衣服或类似款式。</p>
<p>汪雨表示，她有一次在跟淘宝客服进行售后交涉时候需要上传照片，所以打开了淘宝访问相册的权限，“我授权该权限是出于购物沟通服务的目的，并没有同意平台用我的相册内容推送广告，更不知道他会不会转给第三方或用作其它用途。”</p>
<p>类似的情况时有发生，有用户称刚发布一条表示希望阿迪达斯可以把某款鞋的设计师请回来，并配了相关图片，随后就收到了该鞋的推荐广告。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042146371.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042147558.png" alt></p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403042147249.png" alt></p>
<p>以上种种案例表明，除了我们日常搜索、浏览、购物之外，相册照片、微信私人聊天记录和群聊记录、物理对话、在社交平台上发布的文字和图片等，都有可能被广告盯上，在互联网包围下的我们仿佛变成了“透明人”。</p>
<h3><span id="2-应用软件-输入法-wi-fi-成信息泄露重灾区">2 应用软件、输入法、Wi-Fi 成信息泄露重灾区</span></h3><p>电商平台是怎么获取用户数据的？</p>
<p>对于相册照片被读取的情况，淘宝或者这些大平台的隐私协议都写了会获取用户的内容，这中间是有灰色地带的，有可能一些软件借着正当业务需求获得了用户权限之后，再用于广告投放或其它用途，但它用隐私条款巧妙回避了法律责任，打了擦边球。一些软件获取了用户的相册、话筒权限后，识别照片、语音是一件很容易的事。</p>
<p>一些第三方输入法，包括为了提升用户体验开启的云词库等都可能是信息泄露的方式，输入法在免费给用户使用的同时也可能在做一些盈利的事。</p>
<p>公开WiFi也是泄露个人信息的一大风险，很多时候免费连WiFi或者手机开启了WiFi模式，就会自动去检索附近的热点，一旦碰上，WiFi都可以收取一定程度的数据。</p>
<p>此外，安卓手机上的很多应用可以开启特殊权限，是隐私泄露的重灾区。它们可能通过一些应用获取到信息，包括聊天消息上传到云端，AI快速精准识别关键字，推送信息给广告商。</p>
<h3><span id="3-网络行为怎么变成广告推荐">3 网络行为怎么变成广告推荐？</span></h3><p>拿输入法来说，输入法的数据类似于一个第三方DMP（数据管理平台），拿到这个数据后，还要进行一次数据库匹配，例如和一部手机的Device  ID匹配，如果发现用户之前输入过某品牌的雨伞，就可以推送这款产品给用户。而电商广告投放平台接入第三方DMP的行为非常普遍，基本可以算是标配。</p>
<p>百度、阿里、腾讯等都会将平台上的用户行为打标签做成数据库对第三方开放，付费后就能共享信息。</p>
<p>“我们的广告投放主要通过大数据分析，比如通过阿里数据库得到一部分喜欢网购的人的标签，包括他们的购物习惯、消费行为、地域，比如一个用户常浏览汽车、珠宝等品类，消费客单价较高，可能会被定位成高端消费群体，我们找到这些人平时刷什么样的平台，针对性地去投放广告。” </p>
<p>具体的投放方式可以基于地理位置，或是依据数据定向投放。</p>
<p>另一种方式是可以通过一些数据知道这些人的设备里下载了哪些APP，如果很大比例的人下载了某一款，就可以去该平台投放广告。举例来说，假如某平台有5000万注册用户，经检测发现这些人中有大部分下载了知乎、豆瓣，第三方广告商就可以去这两个平台上投放广告，再结合用户在百度的浏览记录、淘宝的购买记录等，就会有一个更加精准的用户画像。</p>
<p>腾讯广告投放包括微信和广点通（覆盖微信之外的QQ、腾讯新闻、QQ浏览器、天天快报等腾讯旗下产品），微信上目前的广告是公众号内文和末尾广告、朋友圈广告、小程序贴片广告，公众号是随机投放，按点击付费一次0.5元起。 </p>
<p>“腾讯大数据会分析用户的行为，比如用户经常会浏览、搜索、点击、购买支付的是哪些内容，腾讯旗下各产品之间的信息是互通的，所有发生的用户行为就会形成一个用户画像，做成一个标签，比如最终得出某用户的健身情况、学历教育、对美妆护肤的喜好等。”</p>
<p>朋友圈广告投放是先根据品牌需求定向筛选用户，再按广告曝光次数收费，北京和上海这样的核心城市是0.1元/次曝光，广州、深圳、苏州、杭州是重点城市，0.06元/次曝光，下一级普通城市0.03元/次曝光。</p>
<p>也就是说，如果刷朋友圈的时候看到了某品牌的广告，不管有没有点击，都算一次广告曝光，北京的用户刷到一个广告就为微信贡献了1毛钱广告费。</p>
<p>“各种拉票软件、会议软件、文献提供者、新闻阅读软件等的第一步都是要得到用户的各种数据获取的授权才能运用，这些APP从诞生之日起都有着强制性、偷窥目的的恶意，不少隐蔽性非常强，或者存在强制性获取个人信息的情况。”</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>广告</tag>
      </tags>
  </entry>
  <entry>
    <title>解决跨域问题</title>
    <url>/97232292/</url>
    <content><![CDATA[<blockquote>
<p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:8000/api/test/‘">http://127.0.0.1:8000/api/test/‘</a> from origin ‘<a href="http://127.0.0.1:3000’">http://127.0.0.1:3000’</a> has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p>
</blockquote>
<h2><span id="什么是跨域">什么是跨域</span></h2><blockquote>
<p>由于开发模式为前后端分离式开发，故而通常情况下，前端和后端可能运行不同的ip或者port下，导致出现跨域问题，故而单独说明</p>
</blockquote>
<p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。<br>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p>
<p>什么是同源策略？</p>
<p>同源策略/SOP(Same origin policy)是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<p>Cookie、LocalStorage 和 IndexDB 无法读取<br>DOM 和 Js对象无法获得<br>AJAX 请求不能发送</p>
<h2><span id="解决方案">解决方案：</span></h2><h3><span id="11-后端允许">1.1 后端允许</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<h3><span id="12-注册应用">1.2 注册应用</span></h3><p>settings.py </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">	...</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,		<span class="comment"># 加入这个应用描述</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3><span id="13-添加中间件">1.3 添加中间件</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,<span class="comment"># 注意顺序！！！(可以放第一个) </span></span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>, </span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3><span id="14-添加允许跨域ip">1.4 添加允许跨域ip</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接允许所有主机跨域</span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span> 默认为<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3><span id="15-允许携带cookie">1.5 允许携带cookie</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CORS_ALLOW_CREDENTIALS = True</span><br></pre></td></tr></table></figure>

<h3><span id="16-添加允许的请求头和方法">1.6 添加允许的请求头和方法</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CORS_ALLOW_METHODS = (</span><br><span class="line">    <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;OPTIONS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PATCH&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;VIEW&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CORS_ALLOW_HEADERS = (</span><br><span class="line">    <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X_FILENAME&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;accept-encoding&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;authorization&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dnt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x-csrftoken&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x-requested-with&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Pragma&#x27;</span>,</span><br><span class="line">	  <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3><span id="17-前端请求添加header">1.7 前端请求添加Header</span></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(myUrl, config).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>



<h3><span id="21-前端配置代理">2.1 前端配置代理</span></h3><p>vite.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">server</span>: &#123; <span class="comment">//同plugins同级</span></span><br><span class="line">    <span class="attr">cors</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">//本地端口号</span></span><br><span class="line">    <span class="attr">proxy</span>: &#123; <span class="comment">//配置代理服务器</span></span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;https://mydomain.com&quot;</span>,    <span class="comment">//目标url</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,    <span class="comment">//允许跨域</span></span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&quot;&quot;</span>),     <span class="comment">//重写路径,替换/api</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当本地开发请求 <a href="http://localhost:3000/api/xxx">http://localhost:3000/api/xxx</a> 时，会被代理到</p>
<p><a href="https://mydomain.com/xxx">https://mydomain.com/xxx</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>非实时信号表</title>
    <url>/c77ce28f/</url>
    <content><![CDATA[<h1><span id="信号类型">信号类型</span></h1><p>Linux系统共定义了64种信号，分为两大类：可靠信号与不可靠信号，前32种信号为不可靠信号，后32种为可靠信号。</p>
<h3><span id="概念">概念</span></h3><p>不可靠信号： 也称为非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为<code>1~31</code>；<br>可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为<code>32~64</code></p>
<h3><span id="信号表">信号表</span></h3><p>在终端，可通过kill -l查看所有的signal信号</p>
<table>
<thead>
<tr>
<th align="left">取值</th>
<th align="left">名称</th>
<th align="left">解释</th>
<th align="left">默认动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIGHUP</td>
<td align="left">挂起</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SIGINT</td>
<td align="left">中断</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SIGQUIT</td>
<td align="left">退出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SIGILL</td>
<td align="left">非法指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">SIGTRAP</td>
<td align="left">断点或陷阱指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SIGABRT</td>
<td align="left">abort发出的信号</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">SIGBUS</td>
<td align="left">非法内存访问</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">SIGFPE</td>
<td align="left">浮点异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">SIGKILL</td>
<td align="left">kill信号</td>
<td align="left">不能被忽略、处理和阻塞</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SIGUSR1</td>
<td align="left">用户信号1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">SIGSEGV</td>
<td align="left">无效内存访问</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">SIGUSR2</td>
<td align="left">用户信号2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">SIGPIPE</td>
<td align="left">管道破损，没有读端的管道写数据</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">SIGALRM</td>
<td align="left">alarm发出的信号</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">SIGTERM</td>
<td align="left">终止信号</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">SIGSTKFLT</td>
<td align="left">栈溢出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">SIGCHLD</td>
<td align="left">子进程退出</td>
<td align="left">默认忽略</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">SIGCONT</td>
<td align="left">进程继续</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">SIGSTOP</td>
<td align="left">进程停止</td>
<td align="left">不能被忽略、处理和阻塞</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">SIGTSTP</td>
<td align="left">进程停止</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">SIGTTIN</td>
<td align="left">进程停止，后台进程从终端读数据时</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">SIGTTOU</td>
<td align="left">进程停止，后台进程想终端写数据时</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">SIGURG</td>
<td align="left">I/O有紧急数据到达当前进程</td>
<td align="left">默认忽略</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">SIGXCPU</td>
<td align="left">进程的CPU时间片到期</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">SIGXFSZ</td>
<td align="left">文件大小的超出上限</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">SIGVTALRM</td>
<td align="left">虚拟时钟超时</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">SIGPROF</td>
<td align="left">profile时钟超时</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">SIGWINCH</td>
<td align="left">窗口大小改变</td>
<td align="left">默认忽略</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">SIGIO</td>
<td align="left">I/O相关</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">SIGPWR</td>
<td align="left">关机</td>
<td align="left">默认忽略</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">SIGSYS</td>
<td align="left">系统调用异常</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>新一代包管理器 PNPM</title>
    <url>/a31a7c10/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#依赖管理的始末">依赖管理的始末</a><ul>
<li><a href="#npm2">npm2</a></li>
<li><a href="#npm3">npm3</a></li>
<li><a href="#结论">结论</a></li>
</ul>
</li>
<li><a href="#pnpm">PNPM</a><ul>
<li><a href="#依赖安装">依赖安装</a></li>
<li><a href="#依赖管理原理">依赖管理原理</a></li>
<li><a href="#pnpm-机制">PNPM 机制</a><ul>
<li><a href="#基于软链接的-node_modules">基于软链接的 node_modules</a></li>
</ul>
</li>
<li><a href="#pnpm-锁文件">PNPM 锁文件</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<h2><span id="依赖管理的始末">依赖管理的始末</span></h2><h3><span id="npm2">npm2</span></h3><p>使用早期的 npm1/2 安装依赖，node_modules 文件夹会以递归的形式呈现，严格按照 package.json 结构以及次级依赖的 package.json 结构将依赖安装到它们各自的 node_modules 中，直到次级依赖不再依赖其它模块。</p>
<p>就像下面这样，tea-app 依赖 tea-component 作为次级依赖，tea-component 会安装到 tea-component 的 node_modules 里面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└─ tea-app</span><br><span class="line">   ├─ index.js</span><br><span class="line">   ├─ package.json</span><br><span class="line">   └─ node_modules</span><br><span class="line">      └─ tea-component</span><br><span class="line">         ├─ index.js</span><br><span class="line">         └─ package.json</span><br></pre></td></tr></table></figure>

<p>假设项目的中的两个依赖同时依赖了相同的次级依赖，那么它们二者的次级依赖将会被重复安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├─ tea-app</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  ├─ package.json</span><br><span class="line">│  └─ node_modules</span><br><span class="line">│      └─ tea-component</span><br><span class="line">│          ├─ index.js</span><br><span class="line">│          └─ package.json</span><br><span class="line">└─ tea-chart</span><br><span class="line">   ├─ index.js</span><br><span class="line">   ├─ package.json</span><br><span class="line">   └─ node_modules</span><br><span class="line">       └─ tea-component</span><br><span class="line">           ├─ index.js</span><br><span class="line">           └─ package.json</span><br></pre></td></tr></table></figure>

<p>这只是简单的例子，那如果 tea-component 还依赖别的包，别的包又依赖另外的包…… 在真实的开发场景中其问题还会更加恶劣：</p>
<ol>
<li>依赖层级太深，会导致文件路径过长</li>
<li>重复的包被安装，导致 node_modules 文件体积巨大，占用过多的磁盘空间</li>
</ol>
<h3><span id="npm3">npm3</span></h3><p>自 <code>npm3/yarn</code> 开始，相比 <code>npm1/2</code> 项目依赖管理的方式有了很大的改变，不再是以往的“嵌套式”而是采用了“扁平化”方式去管理项目依赖。</p>
<p>这里继续拿上面的例子，tea-app 和 tea-chart 都依赖了 tea-component，依赖安装后呈现的是下面的这种扁平化目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├─ tea-component</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  └─ package.json</span><br><span class="line">├─ tea-app</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  └─ package.json</span><br><span class="line">└─ tea-chart</span><br><span class="line">   ├─ index.js</span><br><span class="line">   └─ package.json</span><br></pre></td></tr></table></figure>

<p>扁平化的目录的确解决了上一小节暴露的一些问题，同时也暴露了新的问题：</p>
<ul>
<li>Phantom dependencies</li>
</ul>
<p>称为<strong>幽灵依赖</strong>，指的是在项目内引用未在 package.json 中定义的包。这个问题在 npm3 展现，因为早期的树形结构导致了依赖冗余和路径过深的问题，npm3 之后采用扁平化的结构，一些第三方包的次级依赖提升到了与第三方包同级。</p>
<p>一旦出现幽灵依赖的问题，可能会导致意想不到的错误，所以一定要正视：</p>
<ol>
<li><p>不兼容的版本（例如某一个 api 进行了重大更新)</p>
</li>
<li><p>有可能会丢失依赖（某依赖不再依赖呈现在我们项目中的幽灵依赖)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tea-component 就属于是幽灵依赖，因为它是属于 tea-app、tea-chart 的次级依赖。</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;tea-component&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NPM doppelgangers</p>
</li>
</ol>
<p>称为<strong>分身依赖</strong>依赖的同名包都会被重复安装。</p>
<p>在实际开发中也会出现这样的情景，假设 tea-app、tea-form 依赖 <code>tea-component@2.0.0</code>，tea-chart 依赖 <code>tea-component@3.0.0</code>，这时候会造成依赖冲突，解决冲突的方式会将对应的冲突包放到对应依赖目录的 node_mudules 中，类似下面结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├─ tea-component@3.0.0</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  └─ package.json</span><br><span class="line">├─ tea-app</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  ├─ package.json</span><br><span class="line">│  └─ node_modules</span><br><span class="line">│      └─ tea-component@2.0.0</span><br><span class="line">│          ├─ index.js</span><br><span class="line">│          └─ package.json</span><br><span class="line">├─ tea-form</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  ├─ package.json</span><br><span class="line">│  └─ node_modules</span><br><span class="line">│      └─ tea-component@2.0.0</span><br><span class="line">│          ├─ index.js</span><br><span class="line">│          └─ package.json</span><br><span class="line">└─ tea-chart</span><br><span class="line">   ├─ index.js</span><br><span class="line">   └─ package.json</span><br></pre></td></tr></table></figure>

<p>这时候会发现一个问题，tea-app、tea-form 的 node_modules 下都有重复且版本相同的 <code>tea-component@2.0.0</code>，这个问题就是我们正在所说的“分身依赖”的问题。这个问题就会导致 tea-app 中的 ConfigProvider 组件和 tea-form 的不是一个实例，无法生效。</p>
<p>常见的问题：</p>
<ol>
<li>项目打包会将这些“重身”的依赖都进行打包，增加产物体积</li>
<li>无法共享库实例，引用的得到的是两个独立的实例</li>
<li>重复 TypeScript 类型，可能会造成类型冲突</li>
</ol>
<h3><span id="结论">结论</span></h3><ol>
<li>扁平化的 node_modules 结构允许访问没有在 package.json 中声明的依赖。</li>
<li>安装效率低，大量依赖被重复安装，磁盘空间占用高。</li>
<li>多个项目之间已经安装过的的包不能共享，每次都是重新安装。</li>
</ol>
<h2><span id="pnpm">PNPM</span></h2><blockquote>
<p>Fast, disk space efficient package manager (速度快、节省磁盘空间的软件包管理器)</p>
</blockquote>
<p>当使用 npm 或 Yarn 时，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。然而，如果是使用 pnpm，依赖包将被 存放在一个统一的位置，因此：</p>
<p>如果你对同一依赖包需要使用不同的版本，则仅有 版本之间不同的文件会被存储起来。例如，如果某个依赖包包含 100 个文件，其发布了一个新 版本，并且新版本中只有一个文件有修改，则<code>pnpm update</code>只需要添加一个 新文件到存储中，而不会因为一个文件的修改而保存依赖包的 所有文件。</p>
<p>所有文件都保存在硬盘上的统一的位置。当安装软件包时， 其包含的所有文件都会硬链接自此位置，而不会占用 额外的硬盘空间。这让你可以在项目之间方便地共享相同版本的 依赖包。</p>
<p>最终结果就是以项目和依赖包的比例来看，你节省了大量的硬盘空间， 并且安装速度也大大提高了！</p>
<h3><span id="依赖安装">依赖安装</span></h3><p>使用 pnpm 安装，pnpm 会将依赖存储在位于 <code>.pnpm-store</code> 目录下。只要你在同一机器下，下次安装依赖的时候 pnpm 会先检查 store 目录，如果有你需要的依赖则会通过一个硬链接到你的项目中去，而不是重新安装依赖。</p>
<h3><span id="依赖管理原理">依赖管理原理</span></h3><p>pnpm 会将依赖存储在 <code>store</code> 目录下，通过符号链接的方式仅将项目的直接依赖项添加到 node_modules 的根目录下。</p>
<p>当使用 npm 或 yarn 安装依赖包时，所有软件包都将被提升到 node_modules 的 根目录下。其结果是，源码可以访问 本不属于当前项目所设定的依赖包。</p>
<h3><span id="pnpm-机制">PNPM 机制</span></h3><p>如果 store 目录里面拥有即将需要下载的依赖，下载将会跳过，会向对应项目 node_modules 中去建立硬链接，并非去重新安装它。这里就表明为什么 pnpm 性能这么突出了，最大程度节省了时间消耗和磁盘空间。</p>
<h4><span id="基于软链接的-node_modules">基于软链接的 node_modules</span></h4><p>pnpm 输出的 node_modules 与 npm/yarn 有很大的出入，并非是先者那样的“扁平化目录”而是“非扁平化目录”。</p>
<p>创建两个目录并分别运行 npm add express，pnpm add express。</p>
<p>这是使用 npm 安装 node_modules 的结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">bin</span></span><br><span class="line">accepts</span><br><span class="line">array-flatten</span><br><span class="line">body-parser</span><br><span class="line">bytes</span><br><span class="line">content-disposition</span><br><span class="line">cookie-signature</span><br><span class="line">cookie</span><br><span class="line">debug</span><br><span class="line">depd</span><br><span class="line">destroy</span><br><span class="line">ee-first</span><br><span class="line">encodeurl</span><br><span class="line"><span class="built_in">escape</span>-html</span><br><span class="line">etag</span><br><span class="line">express</span><br></pre></td></tr></table></figure>

<p>这个则是 pnpm 安装 node_modules 的结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">pnpm</span></span><br><span class="line">.<span class="property">modules</span>.<span class="property">yaml</span></span><br><span class="line">express</span><br></pre></td></tr></table></figure>

<p>打开 .pnpm 目录会发现这些依赖都被“扁平化”了，每个包都携带着自己的版本号。pnpm 这样设计的目的我理解其实是为了解决“分身依赖”的问题。</p>
<p>假设我们有这么一个情景，项目中依赖了 <code>tea-app@1.0.0</code>、<code>tea-chart@1.0.0</code> 和 <code>tea-component@2.0.0</code>。tea-chart 和 tea-app 依赖了 <code>tea-component@1.0.0</code> 那它引用关系是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├─tea-app -&gt; ./.<span class="property">pnpm</span>/tea-app@<span class="number">1.0</span><span class="number">.0</span>/node_modules/tea-app</span><br><span class="line">├─tea-chart -&gt; ./.<span class="property">pnpm</span>/tea-chart@<span class="number">1.0</span><span class="number">.0</span>/node_modules/tea-chart</span><br><span class="line">├─tea-component -&gt; ./.<span class="property">pnpm</span>/tea-component@<span class="number">2.0</span><span class="number">.0</span>/node_modules/tea-component</span><br><span class="line">└─.<span class="property">pnpm</span></span><br><span class="line">    ├─ tea-app@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    │   └─ node_modules</span><br><span class="line">    │       ├─ tea-component -&gt; ../tea-component@<span class="number">1.0</span><span class="number">.0</span>/node_modules/tea-component</span><br><span class="line">    │       └─ tea-app -&gt; &lt;store&gt;/tea-app</span><br><span class="line">        ├─ tea-chart@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    │   └─ node_modules</span><br><span class="line">    │       ├─ tea-component -&gt; ../tea-component@<span class="number">1.0</span><span class="number">.0</span>/node_modules/tea-component</span><br><span class="line">    │       └─ tea-chart -&gt; &lt;store&gt;/tea-chart</span><br><span class="line">        ├─ tea-component@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    │   └─ node_modules</span><br><span class="line">    │       └─ tea-component -&gt; &lt;store&gt;/tea-component@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    └─ tea-component@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">        └─ node_modules</span><br><span class="line">            └─ tea-component -&gt; &lt;store&gt;/tea-component@<span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>为什么需要通过软链接的方式去引用实际的依赖？</p>
<p>这样设计的目的是解决“幽灵依赖”的问题，只有声明过的依赖才会以软链接的形式出现在 node_modules 目录中。在实际项目中引用的是软链接，软链接指向的是 .pnpm 的真实依赖，所以在日常开发中不会引用到未在 package.json 声明的包。</p>
<h3><span id="pnpm-锁文件">PNPM 锁文件</span></h3><p>pnpm 产出的是一个 <code>pnpm-lock.yaml</code> 格式的锁文件。</p>
<p>支持通过 <code>pnpm import</code> 从另一个包管理器的锁文件生成一个。支持的源文件：</p>
<ul>
<li>package-lock.json</li>
<li>npm-shrinkwrap.json</li>
<li>yarn.lock</li>
</ul>
<h2><span id="总结">总结</span></h2><p>npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</p>
<p>npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</p>
<p>pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。</p>
<p>这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>pnpm</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 历代版本</title>
    <url>/45c0b51d/</url>
    <content><![CDATA[<!-- toc -->



<!-- tocstop -->

<p>欧洲计算机制造商协会（European Computer Manufacturers Association）或简称 ECMA. ECMA走向全球后，在1994 年更名为：Ecma International。其商标“ECMA”由于历史原因被保留了下来，沿用至今。<br>ECMA-262是一种规范（官网中可以查到各个版本的PDF提案），自然会有满足这种规范的具体的语言被创造出来。最著名的就是JavaScript<br>（现在商标属于Oracle），在1995年由Netscape公司的Brendan Eich，在Netscape导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。其设计思路如下：</p>
<ul>
<li>借鉴 C 语言的基本语法。</li>
<li>借鉴 Java 语言的数据类型和内存管理。</li>
<li>借鉴 Scheme 语言，将函数提升到“第一等公民”（first class）的地位。</li>
<li>借鉴 Self 语言，使用基于原型（prototype）的继承机制。</li>
</ul>
<p>ECMAScript 各版本</p>
<ul>
<li><p>ECMAScript 1.0 (1997)：第一个正式标准，规范化了 JavaScript 的核心语言。</p>
</li>
<li><p>ECMAScript 3.0 (1999)：该版本为语言带来了正则表达式、try/catch 异常处理以及更多的核心改进。</p>
</li>
<li><p>ECMAScript 5.0 (2009)：引入了 strict mode（严格模式），并添加了许多数组方法（如 forEach、map、filter 等）。这次更新被认为是 JavaScript 现代化的重要一步。</p>
</li>
<li><p>ECMAScript 6 (ES2015)：这是 ECMAScript 发展中的里程碑式版本，增加了 let 和 const 变量声明、类和模块系统、箭头函数、解构赋值、模板字符串、Promise、Symbol、迭代器和生成器等新特性。</p>
</li>
<li><p>ECMAScript 7 (ES2016)：主要是增加了两个新特性：Array.prototype.include和取幂运算符。</p>
</li>
<li><p>ECMAScript 8 (ES2017)：主要变化包括：Object.values/Object.entries、字符串填充、Object.getOwnPropertyDescriptor、尾随逗号、异步函数、共享内存和原子，等。</p>
</li>
<li><p>ECMAScript 9 (ES2018)：ECMAScript 2018 主要包含内容：</p>
<ul>
<li>异步迭代器：原生支持在 JavaScript 中对异步获取的数据做迭代。</li>
<li>Object Rest/Spread Properties</li>
<li>Promise.prototype.finally</li>
<li>Template Literal（模板字面量）：取消 Escape-Sequenzen 限制</li>
<li>正则表达式：<ul>
<li>支持 s (dotAll) 模式</li>
<li>Unicode 属性转义（Property Escape）</li>
<li>支持后行断言（Lookbehind Assertions）</li>
<li>命名捕获组（named capture group）</li>
</ul>
</li>
</ul>
</li>
<li><p>ECMAScript 10 (ES2019)：</p>
<ul>
<li>Array.prototype.flat() 和 Array.prototype.flatMap()</li>
<li>Object.fromEntries()</li>
<li>String.prototype.trimStart() 和 String.prototype.trimEnd()</li>
<li>Array.prototype.sort() 改进</li>
<li>Symbol.prototype.description</li>
<li>Function.prototype.toString() 的改进</li>
<li>JSON.prototype.{stringify, parse} 的改进<ul>
<li>JSON.stringify() 现在会忽略 undefined、symbol、函数 等值。</li>
<li>JSON.parse() 对 NaN、Infinity 和 -Infinity 的处理变得更加严格，报错而不是返回这些值。</li>
</ul>
</li>
<li>RegExp.prototype.flags. <code>RegExp.prototype.flags</code> 属性返回正则表达式的标志（如 g, i, m 等），这是一个只读的属性，简化了获取正则标志的方式。</li>
<li>Optional Catch Binding (可选的 catch 绑定). 在 ES10 中，try…catch 语句中的 catch 变量现在是可选的，可以不指定错误对象变量。</li>
<li>Well-formed JSON.stringify() 的改进. ES10 对 JSON.stringify() 进行了改进，确保序列化结果是符合 JSON 格式的，修复了一些潜在的问题。</li>
</ul>
</li>
<li><p>ECMAScript 11 (ES2020)：</p>
<ul>
<li>Optional Chaining（可选链操作符 ?.）</li>
<li>Nullish Coalescing Operator（空值合并操作符 ??）</li>
<li>BigInt</li>
<li>Promise.allSettled()</li>
<li>globalThis</li>
<li>String.prototype.matchAll()</li>
<li>Array.prototype.sort() 的稳定性</li>
<li>模块化的顶层 await</li>
<li>Import.meta</li>
<li>模块内的顶层 await 和新的 import 机制</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Joplin主题样式</title>
    <url>/fdd4fda9/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#joplin主题">Joplin主题</a><ul>
<li><a href="#macos-theme-pluginhttpsgithubcomajilderdajoplin-macos-native-theme">macos theme plugin</a></li>
</ul>
</li>
<li><a href="#markdown渲染样式">Markdown渲染样式</a><ul>
<li><a href="#问题及解决方法">问题及解决方法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="joplin主题">Joplin主题</span></h2><h3><span id="macos-theme-plugin"></span></h3><p>直接在设置中的“插件”选项中搜索 “macos theme”安装，然后重启后打开macos theme 这个插件，打开该插件对应的设置页面，将样式调成_light_模式，同时Joplin本身的外观设置也需要保持_亮色_模式。再次重启Joplin，发现全局主题已经改变。此外，该插件主题也同时支持暗色主题和自定义主题颜色。</p>
<h2><span id="markdown渲染样式">Markdown渲染样式</span></h2><p>将源码复制至Joplin配置中的_userstyle.css_中即可，该配置文件可以从_工具_——&gt;_选项_——&gt;_外观_——&gt;_显示高级选项_——&gt;_适用于已渲染Markdown的自定义样式表_中找到。Mac 下路径为 </p>
<p><code>~/.config/joplin-desktop/userstyle.css</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pre, <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Roboto, <span class="string">&#x27;Courier New&#x27;</span>, Consolas, Inconsolata, Courier, monospace;</span><br><span class="line">  <span class="attribute">margin</span>: auto <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: pre;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span>, <span class="selector-tag">b</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#BF360C</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">em</span>, <span class="selector-tag">i</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#009688</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#BF360C</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span>, pre, <span class="selector-tag">dl</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ul</span>, <span class="selector-tag">ul</span> <span class="selector-tag">ol</span>, <span class="selector-tag">ol</span> <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> <span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> <span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span> &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">2px</span> solid <span class="number">#009688</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#777</span>;</span><br><span class="line">  <span class="attribute">quotes</span>: none;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">blockquote</span><span class="selector-pseudo">::after</span>, <span class="selector-tag">q</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">q</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: bold <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#009688</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">  <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">font</span>: inherit;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">tbody</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#CCC</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F8F8F8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span> <span class="selector-tag">th</span>, <span class="selector-tag">table</span> <span class="selector-tag">tr</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#CCC</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#009688</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#009688</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复制完成后保存，重启Joplin即可。</p>
<h3><span id="问题及解决方法">问题及解决方法</span></h3><p>当使用_macos theme_的插件主题之后，插件中的主题样式会覆盖部分的_自定义CSS样式_，可以通过在_自定义CSS样式_后添上<code>!important</code>强制使用自定义的样式。<br>对上文中的 CSS 进行更改：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">pre, <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Roboto, <span class="string">&#x27;Courier New&#x27;</span>, Consolas, Inconsolata, Courier, monospace <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.4em</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: pre <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: block <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span>, <span class="selector-tag">b</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#BF360C</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">em</span>, <span class="selector-tag">i</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#009688</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#BF360C</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span>, pre, <span class="selector-tag">dl</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ul</span>, <span class="selector-tag">ul</span> <span class="selector-tag">ol</span>, <span class="selector-tag">ol</span> <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: circle <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> <span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> <span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span> &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">2px</span> solid <span class="number">#009688</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#777</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">quotes</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">blockquote</span><span class="selector-pseudo">::after</span>, <span class="selector-tag">q</span><span class="selector-pseudo">::before</span>, <span class="selector-tag">q</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: bold <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#009688</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#eee</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-spacing</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font</span>: inherit <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">tbody</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#CCC</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F8F8F8</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span> <span class="selector-tag">th</span>, <span class="selector-tag">table</span> <span class="selector-tag">tr</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#CCC</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#eee</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#009688</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#009688</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更改后发现自定义的CSS样式不再会被插件主题样式覆盖。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>joplin</tag>
        <tag>markdown</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>webstorm 的 cpu 占用高</title>
    <url>/9af613a6/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#现象">现象</a></li>
<li><a href="#处理">处理</a></li>
</ul>
<!-- tocstop -->

<h2><span id="现象">现象</span></h2><p>前端项目，不管是 vue,react ，就是 cpu 占用长期 400%以上，有时候持续好多天，导致 macbook 温度一直在 70+度以上</p>
<h2><span id="处理">处理</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Applications/Webstorm.app/Contents/jbr/Contents/Home/conf/security</span><br><span class="line">/Applications/IntelliJ IDEA.app/Contents/jbr/Contents/Home/conf/security</span><br><span class="line">/Applications/GoLand.app/Contents/jbr/Contents/Home/conf/security</span><br><span class="line">/Applications/RustRover.app/Contents/jbr/Contents/Home/conf/security</span><br></pre></td></tr></table></figure>



<p>修改以上四个文件夹里的 <code>java.security</code> 文件<br>将 <code>jdk.tls.disabledAlgorithms=SSLv3</code> 替换为 <code>jdk.tls.disabledAlgorithms=TLSv1.3, SSLv3</code></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron的原理</title>
    <url>/295abdb4/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#chromium的原理">Chromium的原理</a></li>
<li><a href="#nodejs的原理">Node.js的原理</a></li>
</ul>
<!-- tocstop -->

<p>Electron是一个集成项目，允许开发者使用前端技术开发桌面端应用。它做了如下几个重要的工作：</p>
<ul>
<li>定制 Chromium，并把定制版本的 Chromium 集成在 Electron 内部；</li>
<li>定制 Node.js，并把定制版本的 Node.js 集成在 Electron 内部；</li>
<li>通过消息轮询机制打通 Node.js 和 Chromium 的消息循环；</li>
<li>通过 Electron 的内置模块向开发者提供桌面应用开发必备的 API；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202502272318170.png" alt></p>
<p>其中 Chromium 基础能力可以让应用渲染 HTML（CSS） 页面，可以执行页面的JavaScript脚本，让应用可以在 Cookie、LocalStorage或 IndexedDB 中存取数据。除此之外，Electron还允许开发者突破同源策略的限制：伪装请求，截获响应，修改session等。</p>
<p>Node.js 基础能力可以让开发者读写本地磁盘的文件、通过 socket 访问网络、创建和控制子进程等。除此之外，还修改了Node的加解密机制让Chromium的BoringSSL和Node的OpenSSL兼容的更好，让Node.js可以加载asar压缩包内的文件等。</p>
<p>Electron 内置模块可以让开发者创建操作系统的托盘图标、访问操作系统的剪切板、屏幕信息、发送系统通知等，除此之外还提供了崩溃报告收集能力、性能问题追踪能力等。</p>
<p>另外，Electron继承了Chromium的多进程架构，也是分一个主进程多个渲染进程的。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202502272319367.png" alt></p>
<p>Electron 应用启动时，首先会加载主进程的逻辑，主进程会创建一个或多个窗口，我们暂时可以粗浅的认为一个窗口就代表一个渲染进程，主进程负责管理所有的渲染进程。具体的多进程概念请看Chromium的原理。</p>
<hr>
<h2><span id="chromium的原理">Chromium的原理</span></h2><p>Chromium是一个多进程架构的浏览器。</p>
<p>以前（大约2008年）浏览器大都是单进程、多线程的架构模式实现的，浏览器中任何一个行为不当的网页或插件都可能让整个浏览器崩溃。</p>
<p>Chromium为了解决这个问题，把每个页面约束在单独的进程中，以保护整个浏览器不受单个页面中的故障所影响。这极大地缓解了浏览器容易崩溃的问题。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202502272320519.png" alt></p>
<p>Chromium把管理页面、管理选项卡和插件的进程称为浏览器进程（Browser Process）。把特定于页面的进程称为渲染进程（Render Process）。</p>
<p>渲染进程使用<a href="https://www.chromium.org/blink">Blink布局引擎</a>来解释和渲染HTML。渲染进程与浏览器进程通过IPC管道进行通信（<a href="https://dev.chromium.org/developers/design-documents/inter-process-communication">详细资料</a>）。</p>
<p>通常每个新窗口或选项卡都会在新进程中打开。浏览器进程（Browser Process）负责创建这些新的进程（Render Process）。一旦渲染进程崩溃或挂起，则浏览器进程控制着界面，提示用户需要重新加载页面，当用户点击重新加载按钮后，浏览器进程则创建一个新的渲染进程来为用户服务。</p>
<p>有的时候创建新窗口或选项卡不会创建新渲染进程。比如开发者使用window.open方法打开新窗口时，就希望这个窗口复用当前的渲染进程，因为两个窗口之间往往需要同步的数据交互。另外还有一些情况需要复用渲染进程，比如打开一个新的渲染进程时，发现系统中已经有一个同样的渲染进程可以复用的情况（<a href="https://dev.chromium.org/developers/design-documents/process-models">详细资料</a>）。</p>
<p>由于渲染进程运行在一个单独的进程中，所有页面脚本都在此进程中运行，当页面脚本尝试访问网络或本地资源时，当前渲染进程会发消息给浏览器进程，由浏览器进程完成相应的工作。此时浏览器进程会判断这些操作是否合法，比如跨越同源策略的请求、突破限制访问Cookie、https页面内嵌http的页面等，这些行为都是不合法的行为，浏览器进程可以拒绝提供服务，这就是浏览器的沙箱模式。</p>
<p>多进程模式还带来了性能上的提升，对于那些不可见的渲染进程，操作系统会在用户可用内存较低时，把它们占用的内存部分或全部交换到磁盘上，以保证用户可见的进程更具响应性。相比之下，单进程浏览器架构将所有页面的数据随机分布在内存中，不可能如此干净地分离使用和未使用的数据，性能表现不佳。</p>
<p>多进程架构模式每个进程都会包含公共基础结构的副本（例如V8引擎的执行环境）、更复杂的通信模型等，这都意味着浏览器会消耗更多的内存、CPU甚至电能。</p>
<hr>
<h2><span id="nodejs的原理">Node.js的原理</span></h2><p>Node.js也是一个集成项目，它允许JavaScript脱离浏览器执行，并提供了一系列的API，供JavaScript访问用户操作系统的资源。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202502272321463.png" alt></p>
<p>它集成的项目：</p>
<ul>
<li>V8：高性能JavaScript的执行引擎，同时拥有解释执行和编译执行的能力，可以将JavaScript代码编译为底层机器码，Node.js通过V8引擎提供的c++ API使V8引擎解析并执行JavaScript代码，并且通过V8引擎公开的接口和类型把自己内置的C++模块和方法转换为可被JavaScript访问的形式；（Chromium网页中解释执行JS脚本用的也是V8引擎）；</li>
<li>libuv：高性能、跨平台事件驱动的I/O库，它提供了文件系统、网络、子进程、管道、信号处理、轮询和流的管控机制。它还包括一个线程池，用于某些不易于在操作系统级别完成的异步工作；</li>
<li>c-ares：异步DNS解析库。用于支持Node.js的DNS模块；</li>
<li>llhttp：一款由TypeScript和C语言编写的轻量级HTTP解析器，内存消耗非常小；</li>
<li>OpenSSL：提供了经过严格测试的各种加密解密算法的实现，用于支持Node.js的crypto模块；</li>
<li>zlib：提供同步的、异步或流式的压缩和解压缩能力，用于支持Node.js的zlib模块；</li>
</ul>
<p>JavaScript在Node.js运行环境中的执行流程</p>
<ol>
<li><strong>初始化自己的执行环境</strong>：在这个阶段Node.js会注册一系列的C++模块以备将来使用。</li>
<li><strong>创建libuv的消息循环</strong>：这个消息循环会伴随着整个应用的生命周期，运行线程退出它才会退出。libuv模块内部持有一个非常复杂的结构体，当用户的代码开始读取文件或发起网络请求时，Node.js就会给这个结构体增加一个回调函数，libuv的消息循环会不断的遍历这个结构体上的回调函数，当读取文件或发起网络请求有数据可用时，就会执行用户的回调函数。</li>
<li><strong>创建V8引擎的运行环境</strong>：这是一个拥有自己的堆栈的隔离环境。</li>
<li><strong>绑定底层模块</strong>：Node.js会使V8引擎执行一个JavaScript脚本（node_bootstrap.js），这是Node.js内置的一个脚本，这个脚本负责绑定Node.js注册的一系列C++模块。</li>
<li><strong>读取并执行用户脚本的内容</strong>：Node.js会把这个文件的内容交给V8引擎运行，并把运行结果返回给用户。</li>
</ol>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的向后兼容和toolchain规则</title>
    <url>/1524043f/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#1-go-121版本之前的向前兼容问题">1. Go 1.21版本之前的向前兼容问题</a></li>
<li><a href="#2-go-121版本后的向前兼容策略">2. Go 1.21版本后的向前兼容策略</a></li>
<li><a href="#3-module依赖的go-toolchain版本的选择过程">3. module依赖的Go toolchain版本的选择过程</a></li>
<li><a href="#4-gotoolchain环境变量与toolchain版本选择">4. GOTOOLCHAIN环境变量与toolchain版本选择</a></li>
<li><a href="#5-小结">5. 小结</a></li>
<li><a href="#6-参考资料">6. 参考资料</a></li>
</ul>
<!-- tocstop -->

<p>Go语言在发展演进过程中一直十分注重向后兼容性(backward compatibility)，在<a href="https://go.dev/blog/go1">Go 1.0版本发布</a>之初就发布了<a href="https://go.dev/doc/go1compat">Go1兼容性承诺</a>，简单来说就是保证使用新版本Go可以正常编译和运行老版本的Go代码语法编写的go代码)，不会出现breaking change(<a href="https://go.dev/blog/compat">其实也不是绝对的不会出现</a>)。</p>
<p>但是在Go 1.21版本之前，Go语言在向前兼容性方面却存在一定的不确定性问题。Go 1.21版本对此进行了改进，并引入了go toolchain规则。</p>
<h2><span id="1-go-121版本之前的向前兼容问题">1. Go 1.21版本之前的向前兼容问题</span></h2><p>在Go 1.21版本之前，Go module中的go directive用于声明建议的Go版本，但并不强制实施。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.20</span><br></pre></td></tr></table></figure>

<p>上面go.mod文件中的go directive表示建议使用<a href="https://tonybai.com/2023/02/08/some-changes-in-go-1-20/">Go 1.20及以上版本</a>编译本module代码，但并不强制禁止使用低于1.20版本的Go对module进行编译。你也可以使用Go 1.19版本，甚至是Go 1.15版本编译这个module的代码。</p>
<p>但Go官方对于这种使用低版本(L)编译器编译go directive为高版本(H)的Go module的结果没有作出任何承诺和保证，<strong>其结果也是不确定的</strong>。</p>
<p>如果你在代码中没有引入高版本(&gt;=L+1)go的新语法特性，那么编译是可以通过的。</p>
<p>如果你的代码没有用到任何高版本(&gt;=L+1)的语法行为变更、bug或安全漏洞的代码，那么编译出的可执行程序运行起来也可以是正常的。</p>
<p>否则，可能会编译失败、运行失败, 或者运行时出现breaking change的问题。</p>
<p>自己的代码可以避免这些问题，但如果你的module有外部依赖，就无法避免了。从Go 1.21版本开始，Go团队在向前兼容方面做了改善，以规避编译结果的不确定性。</p>
<h2><span id="2-go-121版本后的向前兼容策略">2. Go 1.21版本后的向前兼容策略</span></h2><p>Go从Go 1.11版本引入go module，在go 1.16版本，<a href="https://go.dev/ref/mod">go module构建模式</a>正式成为默认构建模式，替代了原先的GOPATH构建模式。</p>
<blockquote>
<p>注：<a href="http://gk.link/a/10AVZ">《Go语言第一课》</a>专栏的<a href="https://time.geekbang.org/column/article/429941">第6讲</a>和<a href="https://time.geekbang.org/column/article/431463">第7讲</a>对Go module构建模式与6类常规操作做了全面系统的讲解。</p>
</blockquote>
<p>通过go module，结合<a href="https://research.swtch.com/vgo-import">语义导入版本(semantic import versioning)</a>、<a href="https://research.swtch.com/vgo-mvs">最小版本选择(Minimal version selection)</a>等机制，go build可以实现精确的依赖管控。</p>
<p>Go 1.21版本后的向前兼容性策略的调整就是参考了go module对依赖的管理方法：即<strong>将go版本和go toolchain版本作为一个module的“依赖”来管理</strong>。如果你真正理解了这个，那理解后面那些具体的规则就容易多了！</p>
<p>如果Russ Cox当初设计Go module就想到了今天这个思路，估计就会直接使用go.mod文件中的require语法像管理依赖module那样来管理go version和go toolchain了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// go.mod (假想的)</span><br><span class="line"></span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    go 1.20.5</span><br><span class="line">    toolchain go1.21.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gomodule/redigo v1.8.5</span><br><span class="line">    github.com/google/gops v0.3.19</span><br><span class="line">    github.com/panjf2000/ants v1.2.1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>但时间无法倒流，历史不能重来，Russ Cox现在只能使用go directive和toolchain directive来提供对go版本和go工具链的依赖信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// go.mod</span><br><span class="line"></span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.20.5</span><br><span class="line">toolchain 1.21.1</span><br></pre></td></tr></table></figure>

<p>同时和使用go get可以改变go.mod的require块中的依赖的版本一样，通过go get也可以修改go.mod中go和toolchain指示的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$go get go@1.21.1</span><br><span class="line">$go get toolchain@go1.22.1</span><br></pre></td></tr></table></figure>

<p>基于上述策略调整，为解决向前兼容不确定性的问题，Go从1.21版本开始，改变了go.mod中go directive的语义：它不再是建议，而是指定了module最小可用的Go版本。</p>
<p>这样在仅使用本地go工具链的情况下，如果Go编译器版本低于go.mod中的go版本，将无法编译代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// go.mod</span><br><span class="line"></span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.21.1 // 指定最小可用版本为Go 1.21.1</span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=local go build</span><br><span class="line">go: go.mod requires go &amp;gt;= 1.21.1 (running go 1.21.0; GOTOOLCHAIN=local)</span><br></pre></td></tr></table></figure>

<p>这里有一个前提：“在仅使用本地go工具链的情况下(即设置了GOTOOLCHAIN=local)”，在Go 1.21版本之前，我们遇到的都属于这种情况。遇到这种情况后，我们一般的作法是手动下载对应版本的Go工具链(比如这里的go 1.21.1)，然后用新版工具链重新编译。</p>
<p>Go团队考虑到手动管理go工具链带来的体验不佳问题，在Go 1.21版本及以后，go还提供了自动Go工具链管理，如果go发现本地工具链版本低于go module要求的最低go版本，那么go会自动下载高版本的go工具链，缓存到go module cache中(不会覆盖本地安装的go工具链)，并用新下载的go工具链对module进行编译构建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// go.mod</span><br><span class="line"></span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.21.1 // 指定最小可用版本为Go 1.21.1</span><br><span class="line"></span><br><span class="line">$go build</span><br><span class="line">go: downloading go1.21.1 (darwin/amd64)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：从兼容性方面考虑，如果go.mod中没有显式的用go指示go版本，那么默认go版本为1.16。</p>
</blockquote>
<p>对应module有依赖的情况，比如下图：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202503032331009.png" alt></p>
<p>这里要正确编译图中的main module，我们至少需要go 1.21.0版本，这个版本是main所有依赖中version最大的那个。</p>
<p>当然最终选择哪个版本的go工具链对module进行编译，则有一个选择决策的过程。</p>
<p>go module构建模式下，go工具链选择依赖module的版本时有一套机制，比如最小版本选择等，Go 1.21以后，go工具链版本的选择，也有一套类似的逻辑。接下来我们就来简单看一下。</p>
<h2><span id="3-module依赖的go-toolchain版本的选择过程">3. module依赖的Go toolchain版本的选择过程</span></h2><p>go module中依赖module的版本选择机制：最小版本选择(mvs)</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202503032332846.png" alt></p>
<p>上图来自<a href="https://go.dev/ref/mod">https://go.dev/ref/mod</a></p>
<p>以module C的版本选择为例，A依赖C 1.3，B依赖C 1.4，那么满足应用依赖需求的最小版本就是1.4。如果选择1.3，则不满足B对依赖的要求。</p>
<p>对Go toolchain的选择过程也遵循mvs方法，我们把前面的那个例子拿过来：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202503032334439.png" alt></p>
<p>现在我们帮这个例子选择go toolchain版本。</p>
<blockquote>
<p>注：如果go.mod中没有显式用toolchain指示工具链版本，那我们可以认为go.mod中有一个隐含的toolchain指示版本，该版本与go directive指示的版本一致。</p>
</blockquote>
<p>上面的例子中对toolchain version的最高要求为module D的go 1.21.0，当startup toolchain(执行的那个go命令的版本)得到这个信息后，就会在当前<strong>可用的toolchain版本列表</strong>中选出满足go 1.21.0的最小版本的go toolchain，然后会有一个叫Go toolchain switches(Go工具链切换)的过程，切换后，选出的新版go toolchain会继续后面的工作(编译和链接)。例如，如果可用的toolchain版本有如下三个：</p>
<ul>
<li>go 1.22.7</li>
<li>go 1.21.3</li>
<li>go 1.21.5</li>
</ul>
<p>那么startup toolchain会根据mvs原则选出满足go 1.21.0的最小版本，即go 1.21.3。</p>
<p>这里大家可能会马上问：什么是可用的toolchain版本？别急！接下来我们就来回答这个问题。</p>
<h2><span id="4-gotoolchain环境变量与toolchain版本选择">4. GOTOOLCHAIN环境变量与toolchain版本选择</span></h2><p>是否执行自动工具链下载和缓存、Go toolchain switches(Go工具链切换)以及切换的工具链的版本取决于GOTOOLCHAIN环境变量的设置、go.mod中go和toolchain指示的版本。</p>
<p>当go命令捆绑的工具链与module的go.mod的go或工具链版本一样时或更新时，go命令会使用自己的捆绑工具链。例如，当在main module的go.mod包含有go 1.21.0时，如果go命令绑定的工具链是Go 1.21.3版本，那么将继续使用初始toolchain的版本，即Go 1.21.3。</p>
<p>而如果go.mod中的go版本写着go 1.21.9，那么go命令捆绑的工具链版本1.21.3显然不能满足要求，那此时就要看GOTOOLCHAIN环境变量的配置。</p>
<p>GOTOOLCHAIN的设置以及对结果的影响略复杂，下面是GOTOOLCHAIN的多种设置形式以及对toolchain选择的影响说明(以下示例中本地go命令捆绑的工具链版本为Go 1.21.0)：</p>
<ul>
<li><code>&lt;name&gt;</code></li>
</ul>
<p>例如，GOTOOLCHAIN=go1.21.0。go命令将始终运行该特定版本的go工具链。如果本地存在该版本工具链，就使用本地的。如果不存在，会下载、缓存起来并使用。如果go.mod中的工具链版本高于name版本，则停止编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line">toolchain go1.23.1 </span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=go1.21.0 go build</span><br><span class="line">go: go.mod requires go &amp;gt;= 1.23.1 (running go 1.21.0; GOTOOLCHAIN=go1.21.0)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;name&gt;+auto</code></li>
</ul>
<p>当GOTOOLCHAIN设置为<code>&lt;name&gt;+auto</code>时，go命令会根据需要选择并运行较新的Go版本。具体来说，它会查询go.mod文件中的工具链版本和go version。如果go.mod 文件中有toolchain行，且toolchain指示的版本比默认的Go工具链(name)新，那么系统就会调用toolchain指示的工具链版本；反之会使用默认工具链。</p>
<p>当本地不存在决策后的工具链版本时，会自动下载、缓存，并使用该缓存工具链进行后续编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line">toolchain go1.23.1 </span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=go1.24.1+auto go build</span><br><span class="line">go: downloading go1.24.1 (darwin/amd64) // 使用name指定工具链，但该工具链本地不存在，于是下载。</span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=go1.20.1+auto go build</span><br><span class="line">go: downloading go1.23.1 (darwin/amd64) // 使用go.mod中的版本的工具链</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;name&gt;+path</code></li>
</ul>
<p>当GOTOOLCHAIN设置为<code>&lt;name&gt;+path</code>时，go命令会根据需要选择并运行较新的Go版本。具体来说，它会查询go.mod文件中的工具链版本和go version。如果go.mod 文件中有toolchain行，且toolchain指示的版本比默认的Go工具链(name)新，那么系统就会调用toolchain指示的工具链版本；反之会使用默认工具链。当使用<code>&lt;name&gt;+path</code>时，如果决策得到的工具链版本在PATH路径下没有找到，那么go命令执行过程将终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line">toolchain go1.23.1 </span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=go1.24.1+path go build // 使用name指定工具链，但该工具链本地不存在，于是编译停止</span><br><span class="line">go: cannot find &quot;go1.24.1&quot; in PATH</span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=go1.20.1+path go build // 使用go.mod中的版本的工具链，但该工具链本地不存在，于是编译停止</span><br><span class="line">go: cannot find &quot;go1.23.1&quot; in PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>auto (等价于 local+auto，这也是默认值)</li>
</ul>
<p>auto的语义是当go.mod中工具链版本低于go命令捆绑的工具链版本，则使用go命令运行捆绑的工具链；反之，自动下载对应的工具链版本，缓存起来并使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line">toolchain go1.23.1 </span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=auto go build</span><br><span class="line">go: downloading go1.23.1 (darwin/amd64)</span><br></pre></td></tr></table></figure>

<ul>
<li>path (等价于 local+path)</li>
</ul>
<p>path的语义是当go.mod中工具链版本低于go命令捆绑的工具链版本，则使用go命令运行捆绑的工具链；反之，在PATH中找到满足go.mod中工具链版本的go版本。如果没找到，则会停止编译过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line">toolchain go1.23.1 </span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=path go build</span><br><span class="line">go: cannot find &quot;go1.23.1&quot; in PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>local</li>
</ul>
<p>当GOTOOLCHAIN设置为local时，go命令总是运行捆绑的 Go 工具链。如果go.mod中工具链版本高于local的版本，则会停止编译过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat go.mod</span><br><span class="line">module demo1</span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line">toolchain go1.23.1 </span><br><span class="line"></span><br><span class="line">$GOTOOLCHAIN=local go build</span><br><span class="line">go: go.mod requires go &amp;gt;= 1.23.1 (running go 1.21.0; GOTOOLCHAIN=local)</span><br></pre></td></tr></table></figure>

<p>当Go工具在编译module依赖项时发现当前go toolchain版本无法满足要求时，会进行go toolchain switches(切换)，切换的过程就是从可用的go toolchain列表中取出一个最适合的。</p>
<p>那么“可用的go toolchain列表”究竟是如何组成的呢？ go命令有三个候选版本(以 Go 1.21.1为例，这些版本也是Go当前承诺提供support的版本)：</p>
<ul>
<li>尚未发布的Go语言版本的最新候选版本（1.22rc1）</li>
<li>最近发布的 Go 语言版本的最新补丁 (1.21.1)</li>
<li>上一个Go语言版本的最新补丁版本(1.20.8)。</li>
</ul>
<p>当GOTOOLCHAIN设置为带auto形式的值的时候，Go会下载这些版本；当GOTOOLCHAIN设置为代path形式的值的时候，Go会在PATH路径搜索适合的go工具链列表。</p>
<p>接下来，go会用mvs(最小版本选择)来确定究竟使用哪个toolchain版本。Go toolchain reference中就有这样一个例子。</p>
<p>假设example.com/widget@v1.2.3需要Go 1.24rc1或更高版本。go命令会获取可用工具链列表，并发现两个最新Go工具链的最新补丁版本是Go 1.28.3和Go 1.27.9，候选版本Go 1.29rc2也可用。在这种情况下，go 命令会选择Go 1.27.9。</p>
<p>如果 widget 需要 Go 1.28或更高版本，go命令会选择 Go 1.28.3，因为 Go 1.27.9 太旧了。如果widget需要Go 1.29或更高版本，go命令会选择Go 1.29rc2，因为Go 1.27.9和Go 1.28.3都太老了。</p>
<h2><span id="5-小结">5. 小结</span></h2><p>Go 1.21通过增强go语句语义和添加工具链管理，大幅改进了Go语言的向前兼容性。开发者可以放心使用新语言特性，无需担心旧版本编译器带来的问题。go命令会自动处理不同module使用不同go版本和不同工具链版本的情况，使用Go语言变得更简单。</p>
<h2><span id="6-参考资料">6. 参考资料</span></h2><ul>
<li><a href="https://go.dev/blog/toolchain">Forward Compatibility and Toolchain Management in Go 1.21</a> – <a href="https://go.dev/blog/toolchain">https://go.dev/blog/toolchain</a></li>
<li><a href="https://go.dev/doc/toolchain">Go Toolchains reference</a> – <a href="https://go.dev/doc/toolchain">https://go.dev/doc/toolchain</a></li>
</ul>
]]></content>
      <categories>
        <category>Lang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
</search>
