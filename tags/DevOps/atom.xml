<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>devops on Xiaobin&#39;s Blog</title>
        <link>http://lxb.wiki/tags/devops/</link>
        <description>Recent content in devops on Xiaobin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 01 Apr 2023 23:09:26 +0000</lastBuildDate><atom:link href="http://lxb.wiki/tags/devops/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>【译】用 Tekton 在 Kubernetes 中编写你的第一条 CI/CD 流水线</title>
        <link>http://lxb.wiki/2966fc1/</link>
        <pubDate>Sat, 01 Apr 2023 23:09:26 +0000</pubDate>
        
        <guid>http://lxb.wiki/2966fc1/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Tekton 是一个用于创建持续集成和持续交付（CI/CD）系统的 Kubernetes 原生开源框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.linux.net.cn/data/attachment/album/202304/01/180822blxgx0c1k43n4kl4.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Tekton 是一个用于创建持续集成和持续交付（CI/CD）系统的 Kubernetes 原生开源框架。通过对底层实施细节的抽象，它还可以帮助你在多个云供应商或企业内部系统中进行端到端（构建、测试、部署）应用开发。&lt;/p&gt;
&lt;h3 id=&#34;tekton-介绍&#34;&gt;Tekton 介绍&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tektoncd/pipeline&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tekton&lt;/a&gt; 最初被称为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/knative/build&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Knative Build&lt;/a&gt;，后来被重组为独立的开源项目，有自己的 &lt;a class=&#34;link&#34; href=&#34;https://cd.foundation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;治理组织&lt;/a&gt;，现在是属于 &lt;a class=&#34;link&#34; href=&#34;https://www.linuxfoundation.org/projects/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 基金会&lt;/a&gt; 的项目。Tekton 提供了一个集群内的容器镜像构建和部署工作流程，换句话说，它是一个 &lt;!-- raw HTML omitted --&gt;持续集成&lt;!-- raw HTML omitted --&gt;continuous integration&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CI）和 &lt;!-- raw HTML omitted --&gt;持续交付&lt;!-- raw HTML omitted --&gt;continuous delivery&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CD）服务。它由 Tekton 流水线和几个支持组件如 Tekton CLI、Triggers 和 Catalog 等组成。&lt;/p&gt;
&lt;p&gt;Tekton 是一个 Kubernetes 原生应用。它在 Kubernetes 集群中作为扩展被安装和运行，由一套Kubernetes 定制化资源组成，定义了你为流水线创建和复用的构建块。由于 Tekton 是一种 Kubernetes 原生技术，所以它非常容易扩展。当你需要增加你的工作负载时，你只需向你的集群添加节点就可以了。由于其可扩展的设计和社区贡献的组件库，它也很容易定制。&lt;/p&gt;
&lt;p&gt;对于需要 CI/CD 系统来开展工作的开发人员，和为其组织内的开发人员建立 CI/CD 系统的平台工程师，Tekton 是理想选择。&lt;/p&gt;
&lt;h3 id=&#34;tekton组件&#34;&gt;Tekton 组件&lt;/h3&gt;
&lt;p&gt;构建 CI/CD 流水线的过程非常复杂，因此 Tekton 为每一步都提供工具。以下是 Tekton 提供的主要组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;流水线&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;Pipeline&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;： 定义了一组 Kubernetes &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义资源&lt;/a&gt;，作为你用来组装 CI/CD 流水线的构建块。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;触发器&lt;!-- raw HTML omitted --&gt;Triggers&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：一种 Kubernetes 自定义资源，允许你根据从事件有效载荷中提取的信息来创建流水线。例如，你可以在每次创建 Git 仓库的合并请求时，触发流水线的实例化和执行。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;命令行&lt;!-- raw HTML omitted --&gt;CLI&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：提供一个名为 &lt;code&gt;tkn&lt;/code&gt; 的命令行界面，你可以使用它从终端与 Tekton 进行交互。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;仪表盘&lt;!-- raw HTML omitted --&gt;Dashboard&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是 Tekton 流水线的一个基于网页的图形界面，显示流水线的执行信息。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;Catalog&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个高质量的、由社区贡献的 Tekton 构建块（任务、流水线等），可在你自己的流水线中使用。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;中心&lt;!-- raw HTML omitted --&gt;Hub&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个基于网页的图形界面，用于访问 Tekton 目录。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;操作员&lt;!-- raw HTML omitted --&gt;Operator&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一种 Kubernetes &lt;a class=&#34;link&#34; href=&#34;https://operatorhub.io/what-is-an-operator&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;操作员模式&lt;/a&gt;，你可以在 Kubernetes 集群中安装、更新、升级和删除 Tekton 项目。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;链&lt;!-- raw HTML omitted --&gt;Chains&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个 Kubernetes &lt;!-- raw HTML omitted --&gt;自定义资源定义&lt;!-- raw HTML omitted --&gt;Custom Resource Definition&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CRD）控制器，使你可以在 Tekton 中处理供应链安全的问题。正在开发中。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;结果&lt;!-- raw HTML omitted --&gt;Results&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：旨在帮助用户对 CI/CD 工作负载历史进行逻辑分组，并将长期结果的存储从流水线控制器中分离出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tekton-术语&#34;&gt;Tekton 术语&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://opensource.com/sites/default/files/uploads/tekto-terminology.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Tekton terminology&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;步骤&lt;!-- raw HTML omitted --&gt;Step&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是 CI/CD 工作流程中最基本的实体，例如为 Python 网络应用程序运行一些单元测试或编译一个 Java 程序。Tekton 使用容器镜像执行每个步骤。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;任务&lt;!-- raw HTML omitted --&gt;Task&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：:** 是按特定顺序排列的步骤的集合。Tekton 以 &lt;a class=&#34;link&#34; href=&#34;https://kubebyexample.com/en/concept/pods&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kubernetes 容器荚&lt;/a&gt; 的形式运行任务，其中每个步骤都成为 &lt;!-- raw HTML omitted --&gt;容器荚&lt;!-- raw HTML omitted --&gt;pod&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 中的一个运行容器。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;流水线&lt;!-- raw HTML omitted --&gt;Pipelines&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是按特定顺序排列的任务的集合。Tekton 把所有任务连接成一个 &lt;!-- raw HTML omitted --&gt;有向无环图&lt;!-- raw HTML omitted --&gt;directed acyclic graph&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（DAG），并按顺序执行图。换句话说，它创建了一些 Kubernetes 容器荚，并确保每个容器荚按预期成功运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://opensource.com/sites/default/files/uploads/tekton-pipelines.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Tekton pipelines&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;流水线运行&lt;!-- raw HTML omitted --&gt;PipelineRun&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：顾名思义，是一条流水线的具体执行。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;任务运行&lt;!-- raw HTML omitted --&gt;TaskRun&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个任务的具体执行。你可以选择在流水线外运行一次任务运行，可以通过它查看任务中每个步骤执行的具体情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建你的-cicd-流水线&#34;&gt;创建你的 CI/CD 流水线&lt;/h3&gt;
&lt;p&gt;开始使用 Tekton 的最简单方法是自己编写一个简单的流水线。如果你每天都在使用 Kubernetes，那你可能对 YAML 很熟悉，这正是 Tekton 流水线的定义方式。下面是一个克隆代码库的简单流水线的例子。&lt;/p&gt;
&lt;p&gt;首先，创建一个 &lt;code&gt;task.yaml&lt;/code&gt; 文件，用你喜欢的文本编辑器打开它。这个文件定义了你要执行的 &lt;!-- raw HTML omitted --&gt;步骤&lt;!-- raw HTML omitted --&gt;Step&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。在这个例子中，就是克隆一个仓库，所以我把这个步骤命名为 “clone”。该文件设置了一些环境变量，然后使用一个简单的 shell 脚本来执行克隆。&lt;/p&gt;
&lt;p&gt;接下来是 &lt;!-- raw HTML omitted --&gt;任务&lt;!-- raw HTML omitted --&gt;Task&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。你可以把步骤看作是一个被任务调用的函数，而任务则设置步骤所需的参数和工作空间。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
 name: git-clone
spec:
 workspaces:
   - name: output
     description: The git repo will be cloned onto the volume backing this Workspace.
 params:
   - name: url
     description: Repository URL to clone from.
     type: string
   - name: revision
     description: Revision to checkout. (branch, tag, sha, ref, etc...)
     type: string
     default: &amp;#34;&amp;#34;
 steps:
   - name: clone
     image: &amp;#34;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0&amp;#34;
     env:
       - name: PARAM_URL
         value: $(params.url)
       - name: PARAM_REVISION
         value: $(params.revision)
       - name: WORKSPACE_OUTPUT_PATH
         value: $(workspaces.output.path)
     script: |
      #!/usr/bin/env sh
       set -eu

       CHECKOUT_DIR=&amp;#34;${WORKSPACE_OUTPUT_PATH}&amp;#34;

       /ko-app/git-init \
         -url=&amp;#34;${PARAM_URL}&amp;#34; \
         -revision=&amp;#34;${PARAM_REVISION}&amp;#34; \
         -path=&amp;#34;${CHECKOUT_DIR}&amp;#34;
       cd &amp;#34;${CHECKOUT_DIR}&amp;#34;
       EXIT_CODE=&amp;#34;$?&amp;#34;
       if [ &amp;#34;${EXIT_CODE}&amp;#34; != 0 ] ; then
         exit &amp;#34;${EXIT_CODE}&amp;#34;
       fi
       # Verify clone is success by reading readme file.
       cat ${CHECKOUT_DIR}/README.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建第二个文件 &lt;code&gt;pipeline.yaml&lt;/code&gt;，并用你喜欢的文本编辑器打开它。这个文件通过设置诸如可以运行和处理任务的工作区等重要参数来定义流水线。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
 name: cat-branch-readme
spec:
 params:
   - name: repo-url
     type: string
     description: The git repository URL to clone from.
   - name: branch-name
     type: string
     description: The git branch to clone.
 workspaces:
   - name: shared-data
     description: |
      This workspace will receive the cloned git repo and be passed
       to the next Task for the repo&amp;#39;s README.md file to be read.
 tasks:
   - name: fetch-repo
     taskRef:
       name: git-clone
     workspaces:
       - name: output
         workspace: shared-data
     params:
       - name: url
         value: $(params.repo-url)
       - name: revision
         value: $(params.branch-name)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，创建一个 &lt;code&gt;pipelinerun.yaml&lt;/code&gt; 文件，用喜欢的文本编辑器打开它。这个文件真正的运行流水线。它调用流水线中定义的参数（继而调用任务文件中定义的任务）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
 name: git-clone-checking-out-a-branch
spec:
 pipelineRef:
   name: cat-branch-readme
 workspaces:
   - name: shared-data
     volumeClaimTemplate:
       spec:
         accessModes:
          - ReadWriteOnce
         resources:
           requests:
             storage: 1Gi
 params:
   - name: repo-url
     value: &amp;lt;https://github.com/tektoncd/pipeline.git&amp;gt;
   - name: branch-name
     value: release-v0.12.x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把不同工作分在不同的文件中的好处是，&lt;code&gt;git-clone&lt;/code&gt; 任务可以在多条流水线中复用。&lt;/p&gt;
&lt;p&gt;例如，假设你想为一个流水线项目做端到端的测试。你可以使用 &lt;code&gt;git-clone&lt;/code&gt; 任务 &lt;strong&gt;来让每一次测试都基于最新的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;只要你熟悉 Kubernetes，那 Tekton 对你来说就像其他 Kubernetes 原生应用一样简单。它有很多工具可以帮助你创建流水线并与之交互。如果你喜欢自动化，不妨试试 Tekton!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/21/11/cicd-pipeline-kubernetes-tekton&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/21/11/cicd-pipeline-kubernetes-tekton&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/savita-ashture&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Savita Ashture&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】构建高效的 DevOps 文化的 6 个技巧</title>
        <link>http://lxb.wiki/12428ad2/</link>
        <pubDate>Mon, 30 Jan 2023 21:58:33 +0000</pubDate>
        
        <guid>http://lxb.wiki/12428ad2/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;无论你是刚刚开始在你的组织中使用 DevOps，还是仅仅想改善你现有的文化，请考虑这些技巧以及它们与你组织的未来的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你为什么要构建 &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/resources/devops&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DevOps&lt;/a&gt; 文化？开发团队和运维团队的精简协作有很多好处。效率是首要目标：提高新软件部署的速度，减少等待的时间。培养同事之间的信任可以提升员工的满意度，激发新的创新，并对盈利能力产生积极的影响。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/2/devops-documentation-maturity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DevOps&lt;/a&gt; 是一个很广泛的思想，大家的理解也见仁见智。每个公司对于如何实行 DevOps 也各不相同。这种意见的多样性实际上是一件好事 —— 这么多的观点对于建立更强大的团队是很有用的。本指南将探讨在 DevOps 文化中鼓励同事之间更好地合作的最高技巧。&lt;/p&gt;
&lt;p&gt;下面每个部分从不同的视角介绍 DevOps 文化，并探讨了将它引入员工队伍的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230126220527.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;流程的持续发展&#34;&gt;流程的持续发展&lt;/h3&gt;
&lt;p&gt;DevOps 文化的这一核心原则使它与许多其他类型的工作场所的风气区别开来。DevOps 哲学说，犯错是有积极意义的，因为这表明你在尝试新的想法。&lt;/p&gt;
&lt;p&gt;DevOps 文化的核心是不停地创造。实际上，这意味着当测试结果显示事情由于你的改动而变坏时，不要懊恼。我们要认识到，进化的过程不是线性的，通往成功的道路也从来不是一条直线。&lt;/p&gt;
&lt;p&gt;DevOps 专家 &lt;a class=&#34;link&#34; href=&#34;https://enterprisersproject.com/user/gene-kim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gene Kim&lt;/a&gt; 主张勇于承担风险和进行实验。鼓励你的团队尝试不寻常的任务，以得到新的领悟。&lt;/p&gt;
&lt;p&gt;你的组织应该以利润为导向吗？你能允许你的团队尝试一些新东西（非指个人兴趣项目）吗？持续的流程发展意味着对升级目前的方法持开放态度。优秀的销售领导懂得，结果比出勤率更重要，因此，关注团队的工作方式而不是工作量的多少始终是关键。&lt;/p&gt;
&lt;h3 id=&#34;随时提供反馈并积极寻求反馈&#34;&gt;随时提供反馈并积极寻求反馈&lt;/h3&gt;
&lt;p&gt;成员之间增加信任是蓬勃发展的 DevOps 文化的另一个关键特征。无论你的员工是在学习如何建立联盟网络联系，还是试图设计他们的下一个 &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/7/awesome-ux-cli-application&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用户体验&lt;/a&gt; 调查，每个人都应该对他们工作的反馈持开放态度。但是，除非你的团队成员尊重彼此的意见，并相信反馈是本着善意的精神提出的，否则这永远不会发生。&lt;/p&gt;
&lt;p&gt;这种文化听起来可能是很难培养的；事实上，一些公司会比其他公司更努力地实现这一点。诚然，给予和接受反馈的成功很大程度上取决于员工的个性。在招聘过程中，也可以对此进行筛选。&lt;/p&gt;
&lt;p&gt;在你期望员工随时向同事提供反馈并主动寻求反馈之前，你应该以身作则。高管应该以身作则，公开要求公司成员对其战略决策提出探究性问题，并提供相应的反馈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230126220801.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;DevOps is the intersection of development, quality assurance, and operations&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;不断改进&#34;&gt;不断改进&lt;/h3&gt;
&lt;p&gt;在同事之间增加对智力信任的基础上，你的团队应该寻找方法来改善其工作。DevOps 的性质意味着软件开发团队将比传统方法更迅速地进行部署。&lt;/p&gt;
&lt;p&gt;这种开放的改进文化可以对开发和运维以外的部门产生积极的影响。你也可以自己去探索企业还有哪些领域会受到积极的影响。&lt;/p&gt;
&lt;p&gt;留意培训和提高技能的机会。即使一个培训课程没有广告上说的那么突出，但有机会与行业专家建立联系，并与未来建立联系，这可以提高你的组织内的思想多样性。&lt;/p&gt;
&lt;h3 id=&#34;为以后的开发保存当前的想法&#34;&gt;为以后的开发保存当前的想法&lt;/h3&gt;
&lt;p&gt;频繁使用的 &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/11/git-concepts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Git&lt;/a&gt; 账户应该是你的 DevOps 工具链的一部分。你可以用 Git 作为软件开发和其他相关项目中产生的脚本的共同仓库。Git 作为 “版本控制” 工具而被熟知，Git 允许程序员保存他们工作的迭代、复用或改进其他人的工作。&lt;/p&gt;
&lt;p&gt;你的目标是能够保留好的想法以供将来使用。某个方法由于某种原因没有成功。然而，那套想法在当时是错误的，并不意味着它在未来永远无法成为有用的东西。&lt;/p&gt;
&lt;p&gt;由于 DevOps 的整个重点在于生产环境中的软件的端到端所有权，因此节省开发的迭代真正支持这一原则。你希望看到对手头的软件测试项目的持续关注和投入。&lt;/p&gt;
&lt;p&gt;一个简单的方法是要求开发者在开发者合同和最终项目报告中包含对未来工作的想法。确保技术服务经理知道他们应该要求提供在建设过程中出现的旁门左道的想法的例子。意识到这些小创新的人越多，在需要的时候就越有可能有人记住一个。&lt;/p&gt;
&lt;h3 id=&#34;坐在一起物理上或逻辑上&#34;&gt;坐在一起（物理上或逻辑上）&lt;/h3&gt;
&lt;p&gt;目标是对彼此的工作角色以及它们之间的相互关系有一个共同的理解。你可以通过几个简单的方法实现这一目标，用一句话概括：坐在一起。邀请其他团队参加你们的会议，完整地分享用户反馈报告。一起吃午饭，一起计划虚拟的快乐时光，一般来说，要确保你的同事都在一起。大约 90% 的拥有成熟的 DevOps 协议的团队报告说，他们清楚地了解自己对其他团队的责任，而在不成熟的 DevOps 团队中，只有大约 46% 的工作者清楚地了解自己的责任。&lt;/p&gt;
&lt;p&gt;虽然与志同道合的人结成小团体，只与被雇来执行与你相同任务的员工在一起是很诱人的，但这对整个企业来说是很糟糕的。无论你喜欢与否，所有的人都是多面手，能够在一系列的情况下贡献自己的独特才能。&lt;/p&gt;
&lt;p&gt;密切协作的理念是尊重任何人对其周围正在进行的产品或工作流程提出改进建议的能力。如果你与公司内的其他部门保持一定的距离，你将会错过无数次分享智慧想法的机会。毕竟，你往往在交流中学习得最好。&lt;/p&gt;
&lt;h3 id=&#34;致力于自动化&#34;&gt;致力于自动化&lt;/h3&gt;
&lt;p&gt;你应该以提高效率和加速流程的名义，寻求将单调的和重复的任务变为自动化。每个行业都有无聊的 —— 说得直白一点，就是愚蠢的 —— 每天或每周都要进行的工作。&lt;/p&gt;
&lt;p&gt;无论是手工将数据从一页复制到另一页，还是手工打出音频记录，每个级别的工作人员都应该坚持让机器在可能的情况下承担这些负担。现实是自动化技术每年都在进步，操作流程也应该如此。&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/20/7/open-source-test-automation-frameworks&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自动化测试&lt;/a&gt; 对 DevOps 非常关键，它是 CALMS 框架的第二个原则（其中的 “C” 代表 “文化”）。&lt;/p&gt;
&lt;p&gt;你怎样才能实现这一点？邀请员工公开表达他们认为工作的哪些方面可以自动化，然后 —— 这里是关键的部分 —— 支持实现自动化所需的设施。这可能意味着每年花 600 美元订阅一个软件程序、一套完整的企业应用现代化解决方案，或开发人员用两天时间来建立一个在内部使用新工具。&lt;/p&gt;
&lt;p&gt;无论哪种方式，你都应该评估自动化的好处，考虑你可以为每个人节省多少时间。DevOps 的统计数据不断表明，现代公司通过整合这些有益的原则，年复一年地得到了很大的改善。&lt;/p&gt;
&lt;h3 id=&#34;探索成功的新工作方式&#34;&gt;探索成功的新工作方式&lt;/h3&gt;
&lt;p&gt;文化转变不会在一夜之间发生。不过，你越早开始，就越早看到结果。根据我的经验，当变化真正对以前进行了改进时，人们会接受它。DevOps 为这种改进提供了一个框架。无论你是刚刚在你的组织中开始使用 DevOps，还是仅仅想改善你现有的文化，请考虑以上几点以及它们与你组织的未来的关系。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/23/1/tips-effective-devops-culture&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/23/1/tips-effective-devops-culture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/yauhen-zaremba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Yauhen Zaremba&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lkxed&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lkxed&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】解决 CI/CD 中的仓库阻抗失配</title>
        <link>http://lxb.wiki/f5fbcabb/</link>
        <pubDate>Sat, 26 Mar 2022 14:32:25 +0000</pubDate>
        
        <guid>http://lxb.wiki/f5fbcabb/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;对齐部署镜像和描述符是很困难的，但是某些策略可以使整个过程更高效。
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220326161918.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在软件架构中，当两个组件之间有某些概念性或技术上的差异时会出现 &lt;!-- raw HTML omitted --&gt;阻抗失配&lt;!-- raw HTML omitted --&gt;impedance mismatch&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。这个术语其实是从电子工程中借用的，表示电路中输入和输出的电子阻抗必须要匹配。&lt;/p&gt;
&lt;p&gt;在软件开发中，存储在镜像仓库中的镜像与存储在源码控制管理系统（LCTT 译注：SCM，Source Code Management）中它的&lt;!-- raw HTML omitted --&gt;部署描述符&lt;!-- raw HTML omitted --&gt;deployment descriptor&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;之间存在阻抗失配。你如何确定存储在 SCM 中的部署描述符表示的是正确的镜像？两个仓库追踪数据的方式并不一致，因此将一个镜像（在镜像仓库中独立存储的不可修改的二进制）和它的部署描述符（Git 中以文本文件形式存储的一系列修改记录）相匹配并不那么直观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文假定读者已经熟悉以下概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;源码控制管理&lt;!-- raw HTML omitted --&gt;Source Control Management&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（SCM）系统和分支&lt;/li&gt;
&lt;li&gt;Docker 或符合 OCI 标准的镜像和容器&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;容器编排系统&lt;!-- raw HTML omitted --&gt;Container Orchestration Platforms&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（COP），如 Kubernetes&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;持续集成/持续交付&lt;!-- raw HTML omitted --&gt;Continuous Integration/Continuous Delivery&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CI/CD）&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;软件开发生命周期&lt;!-- raw HTML omitted --&gt;Software development lifecycle&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（SDLC）环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;阻抗失配scm-与镜像仓库&#34;&gt;阻抗失配：SCM 与镜像仓库&lt;/h3&gt;
&lt;p&gt;为了更好地理解阻抗失配在什么场景下会成为问题，请考虑任意项目中的软件开发生命周期环境（SDLC），如开发、测试或发布环境。&lt;/p&gt;
&lt;p&gt;测试环境不会有阻抗失配。现在使用 CI/CD 的最佳实践中开发分支的最新提交都会对应开发环境中的最新部署。因此，一个典型的、成功的 CI/CD 开发流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向 SCM 的开发分支提交新的修改&lt;/li&gt;
&lt;li&gt;新提交触发一次镜像构建&lt;/li&gt;
&lt;li&gt;新生成的镜像被推送到镜像仓库，标记为开发中&lt;/li&gt;
&lt;li&gt;镜像被部署到容器编排系统（COP）中的开发环境，该镜像的部署描述符也更新为从 SCM 拉取的最新描述符。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;换句话说，开发环境中最新的镜像永远与最新的部署描述符匹配。回滚到前一个构建的版本也不是问题，因为 SCM 也会跟着回滚。&lt;/p&gt;
&lt;p&gt;最终，随着开发流程继续推进，需要进行更多正式的测试，因此某个镜像 —— 镜像对应着 SCM 中的某次提交 —— 被推到测试环境。如果是一次成功的构建，那么不会有大问题，因为从开发环境推过来的镜像应该会与开发分支的最新提交相对应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发环境的最新部署被允许入库，触发入库过程&lt;/li&gt;
&lt;li&gt;最新部署的镜像被标记为测试中&lt;/li&gt;
&lt;li&gt;镜像在测试环境中被拉取和部署，（该镜像）对应从 SCM 拉取的最新部署描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到目前为止,一切都没有问题，对吗？如果出现下面的场景，会有什么问题？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 A&lt;/strong&gt;：镜像被推到下游环境，如&lt;!-- raw HTML omitted --&gt;用户验收测试&lt;!-- raw HTML omitted --&gt;user acceptance testing &lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（UAT），或者是生产环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 B&lt;/strong&gt;：测试环境中发现了一个破坏性的 bug，镜像需要回滚到某个确定正常的版本。&lt;/p&gt;
&lt;p&gt;在任一场景中，开发过程并没有停止，即开发分支上游有了一次或多次新的提交，而这意味着最新的部署描述符已经发生了变化，最新的镜像与之前部署在测试环境中的镜像不一致。对部署描述符的修改可能会也可能不会对之前版本的镜像起作用，但是它们一定是不可信任的。如果它们有了变化，那么它们就一定与目前为止你测试过的想要部署的镜像的部署描述符不一致。&lt;/p&gt;
&lt;p&gt;问题的关键是：&lt;strong&gt;如果部署的镜像不是镜像库中的最新版本，你怎么确定与部署的镜像相对应的是 SCM 中的哪个部署描述符？&lt;/strong&gt; 一言以蔽之，无法确定。两个库直接有阻抗失配。如果要详细阐述下，那么是有方法可以解决的，但是你需要做很多工作，这部分内容就是文章接下来的主题了。请注意，下面的方案并不是解决问题的唯一办法，但是已经投入到生产环境并已经对很多项目起了作用，而且已经被构建并部署到生产环境中运行了超过一年。&lt;/p&gt;
&lt;h3 id=&#34;二进制与部署描述符&#34;&gt;二进制与部署描述符&lt;/h3&gt;
&lt;p&gt;源码通常被构建成一个 Docker 镜像或符合 OCI 标准的镜像，该镜像通常被部署到一个容器编排平台（COP）上，如 Kubernetes。部署到 COP 需要部署描述符来定义镜像被如何部署以及作为容器运行，如 &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kubernetes 部署&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CronJobs&lt;/a&gt;。这是因为在镜像和它的部署描述符之间有本质差异，在这里可以看到阻抗失配。在这次讨论中，我们认为镜像是存储在镜像仓库中不可修改的二进制。对源码的任何修改都不会修改镜像，而是用另一个新的镜像去替换它。&lt;/p&gt;
&lt;p&gt;相比之下，部署描述符是文本文件，因而可以被认为是源码且可修改。如果遵循最佳实践，那么部署描述符是被存储在 SCM，所有修改都会提交，而这很容易回溯。&lt;/p&gt;
&lt;h3 id=&#34;解决阻抗失配&#34;&gt;解决阻抗失配&lt;/h3&gt;
&lt;p&gt;建议的解决方案的第一部分，就是提供一个能匹配镜像仓库中的镜像与对保存部署描述符的 SCM 做的代码提交的方法。最直接的解决方案是用源提交的哈希值标记镜像。这个方法可以区分不同版本的镜像、容易分辨，并且提供足够的信息来查找正确的部署描述符，以便镜像更好地部署到 COP。&lt;/p&gt;
&lt;p&gt;再回顾下上面的场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 A&lt;/strong&gt; &lt;em&gt;镜像被推到下游环境&lt;/em&gt;： 当镜像被从测试环境推到 UAT 环境时，我们可以从镜像的标签中知道应该从 SCM 的哪一次源码提交拉取部署描述符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 B&lt;/strong&gt; &lt;em&gt;当一个镜像需要在某一环节中回滚&lt;/em&gt;：无论我们选择回滚到那个镜像版本，我们都可以知道从 SCM 的哪一次源码提交拉取正确的部署描述符。&lt;/p&gt;
&lt;p&gt;在每一种情景中，无论在某个镜像被部署到测试环境后开发分支有多少次提交和构建，对于每一次升级的镜像，我们都可以找到它当初部署时对应的部署描述符。&lt;/p&gt;
&lt;p&gt;然而，这并不是阻抗失配的完整解决方案。再考虑两个场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 C&lt;/strong&gt; 在负载测试环境中，会尝试对不同的部署描述符进行多次部署，以此来验证某一次构建的表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 D&lt;/strong&gt; 一个镜像被推送到下游环境，在该环境中部署描述符有一个错误。&lt;/p&gt;
&lt;p&gt;在上面的所有场景中，我们都需要修改部署描述符，但是目前为止我们只有一个源码提交哈希。请记住，最佳实践要求我们所有对源码的修改都要先提交到 SCM。某次提交的哈希本身是无法修改的，因此我们需要一个比仅仅追踪原来的源码提交哈希更好地解决方案。&lt;/p&gt;
&lt;p&gt;解决方案是基于原来的源码提交哈希新建一个分支。我们把这个分支称为&lt;strong&gt;部署分支&lt;/strong&gt;。每当一个镜像被推到下游测试或发布环境时，你应该&lt;strong&gt;基于前一个 SDLC 环境的部署分支的最新提交&lt;/strong&gt;创建一个新的部署分支。&lt;/p&gt;
&lt;p&gt;这样同一个镜像可以重复多次部署到不同的 SDLC 环境，并在后面每个环境中可以感知前面发现的改动或对镜像做的修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在某个环境中做的修改是如何影响下一个环境的，是用可以共享数据的工具（如 Helm Charts）还是手动剪切、粘贴到其他目录，都不在本文讨论的范围内。&lt;/p&gt;
&lt;p&gt;因此，当一个镜像被从一个 SDLC 环境中推到下一环境时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个部署分支
&lt;ol&gt;
&lt;li&gt;如果镜像是从开发环境中推过来的，那么部署分支就基于构建这个镜像的源码提交哈希创建&lt;/li&gt;
&lt;li&gt;否则，&lt;em&gt;部署分支基于当前部署分支的最新提交创建&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;镜像被部署到下一个 SDLC 环境，使用的部署描述符是该环境中新创建的部署分支的部署描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220326162117.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;deployment branching tree&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图 1：部署分支树&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署分支&lt;/li&gt;
&lt;li&gt;下游环境的第一个部署分支，只有一次提交&lt;/li&gt;
&lt;li&gt;下游环境的第二个部署分支，只有一次提交&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了部署分支这个解决方案，再回顾下上面的场景 C 和场景 D：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 C&lt;/strong&gt; 修改已经部署到下游 SDLC 环境中的镜像的部署描述符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 D&lt;/strong&gt; 修复某个 SDLC 环境中部署描述符的错误&lt;/p&gt;
&lt;p&gt;两个场景中，工作流如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把对部署描述符做的修改提交到 SLDC 环境和镜像对应的部署分支&lt;/li&gt;
&lt;li&gt;通过部署分支最新提交对应的部署描述符把镜像重新部署到 SLDC 环境&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，部署分支彻底解决了（存储着代表一次独一无二的构建的单一的、不可修改的镜像的）镜像仓库与（存储着对应一个或多个 SDLC 环境的可修改的部署描述符的）SCM 仓库之间的阻抗失配。&lt;/p&gt;
&lt;h3 id=&#34;实践中的思考&#34;&gt;实践中的思考&lt;/h3&gt;
&lt;p&gt;这看起来像是行得通的解决方案，但同时它也为开发者和运维人员带来了新的实践中的问题，比如：&lt;/p&gt;
&lt;p&gt;A. 为了更好地管理部署分支，部署描述符作为资源应该保存在哪里，是否要与构建镜像的源码保存在同一个 SCM 仓库？&lt;/p&gt;
&lt;p&gt;到目前为止，我们都在避免谈论应该把部署描述符放在哪个仓库里。在还没有太多细节需要处理时，我们推荐把所有 SDLC 环境的部署描述符与镜像源码放在同一个 SCM 仓库。当部署分支创建后，镜像的源码可以作为方便找到部署的容器中运行的镜像的引用来使用。&lt;/p&gt;
&lt;p&gt;上面提到过，可以通过镜像的标签来关联镜像与原始的源码提交。在一个单独的仓库中查找某次提交的源码的引用，会给开发者带来更大的困难（即便借助工具），这就是没有必要把所有资源都分开存储的原因。&lt;/p&gt;
&lt;p&gt;B. 应该在部署分支上修改构建镜像的源码吗？&lt;/p&gt;
&lt;p&gt;简答：&lt;strong&gt;不应该&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;详细阐述：不应该，因为永远不要在部署分支上构建镜像，它们是在开发分支上构建的。修改部署分支上定义一个镜像的源码会破坏被部署的镜像的构建记录，而且这些修改并不会对镜像的功能生效。在对比两个部署分支的版本时这也会成为问题。这可能会导致两个版本的功能差异有错误的测试结果（这是使用部署分支的一个很小的额外好处）。&lt;/p&gt;
&lt;p&gt;C. 为什么使用镜像 &lt;!-- raw HTML omitted --&gt;标签&lt;!-- raw HTML omitted --&gt;tag&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;？&lt;!-- raw HTML omitted --&gt;标记&lt;!-- raw HTML omitted --&gt;label&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 不可以吗？&lt;/p&gt;
&lt;p&gt;通过 &lt;!-- raw HTML omitted --&gt;标签&lt;!-- raw HTML omitted --&gt;tag&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 可以在仓库中很容易地查找镜像，可读性也很好。在一组镜像中读取和查找 &lt;!-- raw HTML omitted --&gt;标记&lt;!-- raw HTML omitted --&gt;label&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 的值需要拉取所有镜像的&lt;!-- raw HTML omitted --&gt;清单文件&lt;!-- raw HTML omitted --&gt;manifest&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，而这会增加复杂度、降低性能。而且，考虑到历史记录的追踪和不同版本的查找，对不同版本的镜像添加 &lt;!-- raw HTML omitted --&gt;标签&lt;!-- raw HTML omitted --&gt;tag&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 也很有必要，因此使用源码提交哈希是保证唯一性，以及保存能即时生效的有用信息的最简单的解决方案。&lt;/p&gt;
&lt;p&gt;D. 创建部署分支的最佳实践是怎样的？&lt;/p&gt;
&lt;p&gt;DevOps 最重要的三个原则：自动化、自动化、自动化。&lt;/p&gt;
&lt;p&gt;依赖资源来持续地强迫遵循最佳实践，充其量只是碰运气，因此在实现镜像的升级、回滚等 CI/CD 流水线时，把自动化部署分支写到脚本里。&lt;/p&gt;
&lt;p&gt;E. 对部署分支的命名规范有建议吗？&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;strong&gt;部署分支标识&lt;/strong&gt;&amp;gt;-&amp;lt;&lt;strong&gt;环境&lt;/strong&gt;&amp;gt;-&amp;lt;&lt;strong&gt;源码提交哈希&lt;/strong&gt;&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;部署分支标识&lt;/strong&gt;： 所有部署分支范围内唯一的字符串；如 “deployment” 或 “deploy”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境&lt;/strong&gt;： 部署分支适用的 SDLC 环境；如 “qa”（测试环境）、 “stg”（预生产环境）、 或 “prod”（生产环境）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源码提交哈希&lt;/strong&gt;： 源码提交哈希中包含原来构建被部署的镜像的源码，开发者可以通过它很容易地查找到创建镜像的原始提交，同时也能保证分支名唯一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如， &lt;code&gt;deployment-qa-asdf78s&lt;/code&gt; 表示推到 QA 环境的部署分支， &lt;code&gt;deployment-stg-asdf78s&lt;/code&gt; 表示推到 STG 环境的部署分支。&lt;/p&gt;
&lt;p&gt;F. 你怎么识别环境中运行的哪个镜像版本？&lt;/p&gt;
&lt;p&gt;我们的建议是把最新的部署分支提交哈希和源码提交哈希添加到 &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;标记&lt;/a&gt; 中。开发者和运维人员可以通过这两个独一无二的标识符查找到部署的所有东西及其来源。在诸如执行回滚或前滚操作时，使用那些不同版本的部署的选择器也能清理资源碎片。&lt;/p&gt;
&lt;p&gt;G. 什么时候应该把部署分支的修改合并回开发分支？&lt;/p&gt;
&lt;p&gt;这完全取决于开发团队。&lt;/p&gt;
&lt;p&gt;如果你修改的目的是为了做负载测试，只是想验证什么情况会让程序崩溃，那么这些修改不应该被合并回开发分支。另一方面，如果你发现和修复了一个错误，或者对下游环境的部署做了调整，那么就应该把部署分支的修改合并回开发分支。&lt;/p&gt;
&lt;p&gt;H. 有现成的部署分支示例让我们试水吗？&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/elcicd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;el-CICD&lt;/a&gt; 已经在生产上使用这个策略持续一年半应用到超过一百个项目了，覆盖所有的 SDLC 环境，包括管理生产环境的部署。如果你可以访问 &lt;a class=&#34;link&#34; href=&#34;https://www.okd.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OKD&lt;/a&gt;、Red Hat OpenShift lab cluster 或 &lt;a class=&#34;link&#34; href=&#34;https://cloud.redhat.com/openshift/create/local&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat CodeReady Containers&lt;/a&gt;，你可以下载&lt;a class=&#34;link&#34; href=&#34;https://github.com/elcicd/el-CICD-RELEASES&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;el-CICD 的最新版本&lt;/a&gt;，参照 &lt;a class=&#34;link&#34; href=&#34;https://github.com/elcicd/el-CICD-docs/blob/master/tutorial.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;教程&lt;/a&gt; 来学习部署分支是何时以怎样的方式创建和使用的。&lt;/p&gt;
&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;
&lt;p&gt;通过实践上面的例子可以帮助你更好的理解开发过程中阻抗失配相关的问题。对齐镜像和部署描述符是成功管理部署的关键部分。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/21/8/impedance-mismatch-cicd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/21/8/impedance-mismatch-cicd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/hippyod&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Evan &amp;ldquo;Hippy&amp;rdquo; Slatis&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
