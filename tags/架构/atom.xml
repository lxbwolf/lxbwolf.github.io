<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>架构 on Xiaobin&#39;s Blog</title>
        <link>https://lxb.wiki/tags/%E6%9E%B6%E6%9E%84/</link>
        <description>Recent content in 架构 on Xiaobin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 15 Dec 2021 21:08:32 +0000</lastBuildDate><atom:link href="https://lxb.wiki/tags/%E6%9E%B6%E6%9E%84/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>SLO 和 SLA 的区别</title>
        <link>https://lxb.wiki/ee700d45/</link>
        <pubDate>Wed, 15 Dec 2021 21:08:32 +0000</pubDate>
        
        <guid>https://lxb.wiki/ee700d45/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SLO和SLA是大家常见的两个名词：服务等级目标和服务等级协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云计算时代，各大云服务提供商都发布有自己服务的SLA条款，比如Amazon的EC2和S3服务都有相应的SLA条款。这些大公司的SLA看上去如此的高达上，一般是怎么定义出来的呢？本文就尝试从技术角度解剖一下SLA的制定过程。&lt;/p&gt;
&lt;p&gt;说SLA不能不提SLO，这个是众所周知的，但是还有一个概念知道的人就不多了，那就是SLI（Service Level Indicator），&lt;strong&gt;定义一个可执行的SLA，好的SLO和SLI是必不可少的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再有就是SLI/SLO/SLA都是和服务联系在一起的，脱离了服务这三个概念就没有什么意义了。&lt;/p&gt;
&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是服务？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单说就是一切提供给客户的有用功能都可以称为服务。&lt;/p&gt;
&lt;p&gt;服务一般会由服务提供者提供，提供这个有用功能的组织被称为服务提供者，通常是人加上软件，软件的运行需要计算资源，为了能对外提供有用的功能软件可能会有对其他软件系统的依赖。&lt;/p&gt;
&lt;p&gt;客户是使用服务提供者提供的服务的人或公司。&lt;/p&gt;
&lt;h2 id=&#34;sli&#34;&gt;SLI&lt;/h2&gt;
&lt;p&gt;SLI是经过仔细定义的测量指标，它根据不同系统特点确定要测量什么，SLI的确定是一个非常复杂的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SLI的确定需要回答以下几个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要测量的指标是什么？&lt;/li&gt;
&lt;li&gt;测量时的系统状态？&lt;/li&gt;
&lt;li&gt;如何汇总处理测量的指标？&lt;/li&gt;
&lt;li&gt;测量指标能否准确描述服务质量？&lt;/li&gt;
&lt;li&gt;测量指标的可靠度(trustworthy)？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-常见的测量指标有以下几个方面&#34;&gt;1. 常见的测量指标有以下几个方面：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;响应时间(latency)
&lt;ul&gt;
&lt;li&gt;吞吐量(throughput)&lt;/li&gt;
&lt;li&gt;请求量(qps)&lt;/li&gt;
&lt;li&gt;实效性(freshness)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可用性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;运行时间(uptime)
&lt;ul&gt;
&lt;li&gt;故障时间/频率&lt;/li&gt;
&lt;li&gt;可靠性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;质量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;准确性(accuracy)
&lt;ul&gt;
&lt;li&gt;正确性(correctness)&lt;/li&gt;
&lt;li&gt;完整性(completeness)&lt;/li&gt;
&lt;li&gt;覆盖率(coverage)&lt;/li&gt;
&lt;li&gt;相关性(relevance)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;队列长度(queue length)
&lt;ul&gt;
&lt;li&gt;内存占用(RAM usage)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因素人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;响应时间(time to response)
&lt;ul&gt;
&lt;li&gt;修复时间(time to fix)&lt;/li&gt;
&lt;li&gt;修复率(fraction fixed)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**下面通过一个例子来说明一下：**hotmail的downtime SLI&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误率(error rate)计算的是服务返回给用户的error总数&lt;/li&gt;
&lt;li&gt;如果错误率大于X%，就算是服务down了，开始计算downtime&lt;/li&gt;
&lt;li&gt;如果错误率持续超过Y分钟，这个downtime就会被计算在内&lt;/li&gt;
&lt;li&gt;间断性的小于Y分钟的downtime是不被计算在内的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-测量时的系统状态在什么情况下测量会严重影响测量的结果&#34;&gt;2. 测量时的系统状态，在什么情况下测量会严重影响测量的结果&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;测量异常(badly-formed)请求，还是失败(fail)请求还是超时请求(timeout)&lt;/li&gt;
&lt;li&gt;测量时的系统负载（是否最大负载）&lt;/li&gt;
&lt;li&gt;测量的发起位置，服务器端还是客户端&lt;/li&gt;
&lt;li&gt;测量的时间窗口（仅工作日、还是一周7天、是否包括计划内的维护时间段）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-如何汇总处理测量的指标&#34;&gt;3. 如何汇总处理测量的指标？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;计算的时间区间是什么：是一个滚动时间窗口，还是简单的按照月份计算&lt;/li&gt;
&lt;li&gt;使用平均值还是百分位值，比如：某服务X的ticket处理响应时间SLI的&lt;/li&gt;
&lt;li&gt;测量指标：统计所有成功解决请求，从用户创建ticket到问题被解决的时间&lt;/li&gt;
&lt;li&gt;怎么测量：用ticket自带的时间戳，统计所有用户创建的ticket&lt;/li&gt;
&lt;li&gt;什么情况下的测量：只包括工作时间，不包含法定假日&lt;/li&gt;
&lt;li&gt;用于SLI的数据指标：以一周为滑动窗口，95%分位的解决时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-测量指标能否准确描述服务质量&#34;&gt;4. 测量指标能否准确描述服务质量？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：时效性、是否有偏差&lt;/li&gt;
&lt;li&gt;准确性：精度、覆盖率、数据稳定性&lt;/li&gt;
&lt;li&gt;完整性：数据丢失、无效数据、异常(outlier)数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-测量指标的可靠度&#34;&gt;5. 测量指标的可靠度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是否服务提供者和客户都认可&lt;/li&gt;
&lt;li&gt;是否可被独立验证，比如三方机构&lt;/li&gt;
&lt;li&gt;客户端还是服务器端测量，取样间隔&lt;/li&gt;
&lt;li&gt;错误请求是如何计算的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;slo&#34;&gt;SLO&lt;/h2&gt;
&lt;p&gt;**SLO(服务等级目标)**指定了服务所提供功能的一种期望状态。SLO里面应该包含什么呢？所有能够描述服务应该提供什么样功能的信息。&lt;/p&gt;
&lt;p&gt;服务提供者用它来指定系统的预期状态；开发人员编写代码来实现；客户依赖于SLO进行商业判断。SLO里没有提到，如果目标达不到会怎么样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SLO是用SLI来描述的，一般描述为：&lt;/strong&gt;
比如以下SLO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每分钟平均qps &amp;gt; 100k/s&lt;/li&gt;
&lt;li&gt;99% 访问延迟 &amp;lt; 500ms&lt;/li&gt;
&lt;li&gt;99% 每分钟带宽 &amp;gt; 200MB/s&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设置SLO时的几个最佳实践：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定计算的时间窗口&lt;/li&gt;
&lt;li&gt;使用一致的时间窗口(XX小时滚动窗口、季度滚动窗口)&lt;/li&gt;
&lt;li&gt;要有一个免责条款，比如：95%的时间要能够达到SLO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果Service是第一次设置SLO，可以遵循以下原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测量系统当前状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;设置预期(expectations)，而不是保证(guarantees)
&lt;ul&gt;
&lt;li&gt;初期的SLO不适合作为服务质量的强化工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改进SLO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;设置更低的响应时间、更改的吞吐量等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保持一定的安全缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;内部用的SLO要高于对外宣称的SLO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要超额完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;定期的downtime来使SLO不超额完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置SLO时的目标依赖于系统的不同状态(conditions)，根据不同状态设置不同的SLO：&lt;strong&gt;总SLO = service1.SLO1 *weight1 service2.SLO2* weight2 …&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么要有SLO，设置SLO的好处是什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于客户而言，是可预期的服务质量，可以简化客户端的系统设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于服务提供者而言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;可预期的服务质量
&lt;ul&gt;
&lt;li&gt;更好的取舍成本/收益&lt;/li&gt;
&lt;li&gt;更好的风险控制(当资源受限的时候)&lt;/li&gt;
&lt;li&gt;故障时更快的反应，采取正确措施&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SLO设好了，怎么保证能够达到目标呢？
需要一个控制系统来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控/测量SLIs&lt;/li&gt;
&lt;li&gt;对比检测到的SLIs值是否达到目标&lt;/li&gt;
&lt;li&gt;如果需要，修证目标或者修正系统以满足目标需要&lt;/li&gt;
&lt;li&gt;实施目标的修改或者系统的修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该控制系统需要重复的执行以上动作，以形成一个标准的反馈环路，不断的衡量和改进SLO/服务本身。&lt;/p&gt;
&lt;p&gt;我们讨论了目标以及目标是怎么测量的，还讨论了控制机制来达到设置的目标，但是如果因为某些原因，设置的目标达不到该怎么办呢？&lt;/p&gt;
&lt;p&gt;也许是因为大量的新增负载；也许是因为底层依赖不能达到标称的SLO而影响上次服务的SLO。这就需要SLA出场了。&lt;/p&gt;
&lt;h2 id=&#34;sla&#34;&gt;SLA&lt;/h2&gt;
&lt;p&gt;SLA是一个涉及2方的合约，双方必须都要同意并遵守这个合约。当需要对外提供服务时，SLA是非常重要的一个服务质量信号，需要产品和法务部门的同时介入。&lt;/p&gt;
&lt;p&gt;SLA用一个简单的公式来描述就是： &lt;strong&gt;SLA = SLO 后果&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SLO不能满足的一系列动作，可以是部分不能达到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;比如：达到响应时间SLO 未达到可用性SLO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对动作的具体实施&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;需要一个通用的货币来奖励/惩罚，比如：钱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SLA是一个很好的工具，可以用来帮助合理配置资源。一个有明确SLA的服务最理想的运行状态是：&lt;strong&gt;增加额外资源来改进系统所带来的收益小于把该资源投给其他服务所带来的收益。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个简单的例子就是某服务可用性从99.9%提高到99.99%所需要的资源和带来的收益之比，是决定该服务是否应该提供4个9的重要依据。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何写好业务代码</title>
        <link>https://lxb.wiki/4c5cb7f3/</link>
        <pubDate>Wed, 08 Dec 2021 21:51:01 +0000</pubDate>
        
        <guid>https://lxb.wiki/4c5cb7f3/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;基于阿里的零售通业务，总结出的方法论。&lt;/p&gt;
&lt;h2 id=&#34;一个复杂业务的处理过程&#34;&gt;一个复杂业务的处理过程&lt;/h2&gt;
&lt;h3 id=&#34;业务背景&#34;&gt;业务背景&lt;/h3&gt;
&lt;p&gt;零售通是给线下小店供货的B2B模式，我们希望通过数字化重构传统供应链渠道，提升供应链效率，为新零售助力。阿里在中间是一个平台角色，提供的是Bsbc中的service的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105411.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在商品域，运营会操作一个“上架”动作，上架之后，商品就能在零售通上面对小店进行销售了。&lt;strong&gt;是零售通业务非常关键的业务操作之一，因此涉及很多的数据校验和关联操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;针对上架，一个简化的业务流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105454.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;过程分解&#34;&gt;过程分解&lt;/h3&gt;
&lt;p&gt;像这么复杂的业务，我想应该没有人会写在一个service方法中吧。一个类解决不了，那就分治吧。&lt;/p&gt;
&lt;p&gt;说实话，能想到分而治之的工程师，已经做的不错了，至少比没有分治思维要好很多。我也见过复杂程度相当的业务，连分解都没有，就是一堆方法和类的堆砌。&lt;/p&gt;
&lt;p&gt;不过，这里存在一个问题：即很多同学过度的依赖工具或是辅助手段来实现分解。比如在我们的商品域中，类似的分解手段至少有3套以上，有自制的&lt;a class=&#34;link&#34; href=&#34;%e6%b5%81%e7%a8%8b%e5%bc%95%e6%93%8e&#34; &gt;流程引擎&lt;/a&gt;，有依赖于数据库配置的流程处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105631.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;本质上来讲，这些辅助手段做的都是一个pipeline的处理流程，没有其它。因此，我建议此处最好保持KISS（Keep It Simple and Stupid），即&lt;strong&gt;最好是什么工具都不要用，次之是用一个极简的Pipeline模式，最差是使用像流程引擎这样的重方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除非你的应用有极强的流程可视化和编排的诉求，否则我非常不推荐使用流程引擎等工具。第一，它会引入额外的复杂度，特别是那些需要持久化状态的流程引擎；第二，它会割裂代码，导致阅读代码的不顺畅。&lt;strong&gt;大胆断言一下，全天下估计80%对流程引擎的使用都是得不偿失的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回到商品上架的问题，这里问题核心是工具吗？是设计模式带来的代码灵活性吗？显然不是，&lt;strong&gt;问题的核心应该是如何分解问题和抽象问题&lt;/strong&gt;，知道金&lt;a class=&#34;link&#34; href=&#34;%e9%87%91%e5%ad%97%e5%a1%94%e5%8e%9f%e7%90%86&#34; &gt;字塔原理&lt;/a&gt;的应该知道，此处，我们可以使用结构化分解将问题解构成一个有层级的金字塔结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328105756.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;按照这种分解写的代码，就像一本书，目录和内容清晰明了。&lt;/p&gt;
&lt;p&gt;以商品上架为例，程序的入口是一个上架命令（OnSaleCommand）, 它由三个阶段（Phase）组成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Command&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OnSaleNormalItemCmdExe&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Resource&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; OnSaleContextInitPhase onSaleContextInitPhase&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Resource&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; OnSaleDataCheckPhase onSaleDataCheckPhase&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Resource&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; OnSaleProcessPhase onSaleProcessPhase&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Response &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;OnSaleNormalItemCmd cmd&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        OnSaleContext onSaleContext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; init&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;cmd&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        checkData&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        process&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;buildSuccess&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; OnSaleContext &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;OnSaleNormalItemCmd cmd&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; onSaleContextInitPhase&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;cmd&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;OnSaleContext onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        onSaleDataCheckPhase&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;check&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;OnSaleContext onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        onSaleProcessPhase&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个Phase又可以拆解成多个步骤（Step），以&lt;code&gt;OnSaleProcessPhase&lt;/code&gt;为例，它是由一系列Step组成的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Phase&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OnSaleProcessPhase&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Resource&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; PublishOfferStep publishOfferStep&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Resource&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; BackOfferBindStep backOfferBindStep&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//省略其它step
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;OnSaleContext onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SupplierItem supplierItem &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; onSaleContext&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getSupplierItem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 生成OfferGroupNo
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        generateOfferGroupNo&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// 发布商品
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        publishOffer&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 前后端库存绑定 backoffer域
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        bindBackOfferStock&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 同步库存路由 backoffer域
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        syncStockRoute&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 设置虚拟商品拓展字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        setVirtualProductExtension&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 发货保障打标 offer域
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        markSendProtection&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 记录变更内容ChangeDetail
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        recordChangeDetail&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 同步供货价到BackOffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        syncSupplyPriceToBackOffer&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果是组合商品打标，写扩展信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        setCombineProductExtension&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 去售罄标
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        removeSellOutTag&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;offerId&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 发送领域事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        fireDomainEvent&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭关联的待办事项
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        closeIssues&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看到了吗，这就是商品上架这个复杂业务的业务流程。需要流程引擎吗？不需要，需要设计模式支撑吗？也不需要。对于这种业务流程的表达，简单朴素的组合方法模式（Composed Method）是再合适不过的了。&lt;/p&gt;
&lt;p&gt;因此，在做过程分解的时候，我建议工程师不要把太多精力放在工具上，放在设计模式带来的灵活性上。而是应该多花时间在对问题分析，结构化分解，最后通过合理的抽象，形成合适的阶段（Phase）和步骤（Step）上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110024.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;过程分解后的两个问题&#34;&gt;过程分解后的两个问题&lt;/h3&gt;
&lt;h4 id=&#34;1领域知识被割裂肢解&#34;&gt;1、领域知识被割裂肢解&lt;/h4&gt;
&lt;p&gt;什么叫被肢解？因为我们到目前为止做的都是过程化拆解，导致没有一个聚合领域知识的地方。每个Use Case的代码只关心自己的处理流程，知识没有沉淀。&lt;/p&gt;
&lt;p&gt;相同的业务逻辑会在多个Use Case中被重复实现，导致代码重复度高，即使有复用，最多也就是抽取一个util，代码对业务语义的表达能力很弱，从而影响代码的可读性和可理解性。&lt;/p&gt;
&lt;h4 id=&#34;2代码的业务表达能力缺失&#34;&gt;2、代码的业务表达能力缺失&lt;/h4&gt;
&lt;p&gt;试想下，在过程式的代码中，所做的事情无外乎就是取数据&amp;ndash;做计算&amp;ndash;存数据，在这种情况下，要如何通过代码显性化的表达我们的业务呢？ 说实话，很难做到，因为我们缺失了模型，以及模型之间的关系。脱离模型的业务表达，是缺少韵律和灵魂的。&lt;/p&gt;
&lt;p&gt;举个例子，在上架过程中，有一个校验是检查库存的，其中对于组合品（CombineBackOffer）其库存的处理会和普通品不一样。原来的代码是这么写的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; isCombineProduct &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getSign&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isCombProductQuote&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// supplier.usc warehouse needn&amp;#39;t check
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;WarehouseTypeEnum&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isAliWarehouse&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getWarehouseType&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// quote warehosue check
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;CollectionUtil&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getWarehouseIdList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isCombineProduct&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; ExceptionFactory&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;makeFault&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ServiceExceptionCode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SYSTEM_ERROR&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;亲，不能发布Offer，请联系仓配运营人员，建立品仓关系！&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// inventory amount check
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Long sellableAmount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;L&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;isCombineProduct&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sellableAmount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; normalBiz&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;acquireSellableAmount&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getBackOfferId&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(),&lt;/span&gt; supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getWarehouseIdList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//组套商品
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    OfferModel backOffer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; backOfferQueryService&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getBackOffer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getBackOfferId&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;backOffer &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sellableAmount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; backOffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getOffer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getTradeModel&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getTradeCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getAmountOnSale&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;sellableAmount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; ExceptionFactory&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;makeFault&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ServiceExceptionCode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SYSTEM_ERROR&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;亲，实仓库存必须大于0才能发布，请确认已补货.\r[id:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; supplierItem&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getId&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而，如果我们在系统中引入领域模型之后，其代码会简化为如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;backOffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isCloudWarehouse&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;backOffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isNonInWarehouse&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BizException&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;亲，不能发布Offer，请联系仓配运营人员，建立品仓关系！&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;backOffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getStockAmount&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BizException&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;亲，实仓库存必须大于0才能发布，请确认已补货.\r[id:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; backOffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getSupplierItem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getCspuCode&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有没有发现，使用模型的表达要清晰易懂很多，而且也不需要做关于组合品的判断了，因为我们在系统中引入了更加贴近现实的对象模型（CombineBackOffer继承BackOffer），通过对象的多态可以消除我们代码中的大部分的 if-else。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110230.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;过程分解对象模型&#34;&gt;过程分解+对象模型&lt;/h3&gt;
&lt;p&gt;通过上面的案例，我们可以看到&lt;strong&gt;有过程分解要好于没有分解&lt;/strong&gt;，&lt;strong&gt;过程分解+对象模型要好于仅仅是过程分解&lt;/strong&gt;。对于商品上架这个case，如果采用过程分解+对象模型的方式，最终我们会得到一个如下的系统结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110335.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;写复杂业务的方法论&#34;&gt;写复杂业务的方法论&lt;/h2&gt;
&lt;p&gt;通过上面案例的讲解，我想说，我已经交代了复杂业务代码要怎么写：&lt;strong&gt;即自上而下的结构化分解+自下而上的&lt;a class=&#34;link&#34; href=&#34;%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%88%86%e6%9e%90&#34; &gt;面向对象分析&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来，让我们把上面的案例进行进一步的提炼，形成一个可落地的方法论，从而可以泛化到更多的复杂业务场景。&lt;/p&gt;
&lt;h3 id=&#34;上下结合&#34;&gt;上下结合&lt;/h3&gt;
&lt;p&gt;所谓上下结合，是指我们要&lt;strong&gt;结合自上而下的过程分解和自下而上的对象建模&lt;/strong&gt;，螺旋式的构建我们的应用系统。这是一个动态的过程，两个步骤可以交替进行、也可以同时进行。&lt;/p&gt;
&lt;p&gt;这两个步骤是相辅相成的，&lt;strong&gt;上面的分析可以帮助我们更好的理清模型之间的关系，而下面的模型表达可以提升我们代码的复用度和业务语义表达能力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110449.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用这种上下结合的方式，我们就有可能在面对任何复杂的业务场景，都能写出干净整洁、易维护的代码。&lt;/p&gt;
&lt;h3 id=&#34;能力下沉&#34;&gt;能力下沉&lt;/h3&gt;
&lt;p&gt;一般来说实践DDD有两个过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;套概念阶段&#34;&gt;套概念阶段&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;了解了一些DDD的概念，然后在代码中“使用”Aggregation Root，Bonded Context，Repository等等这些概念。更进一步，也会使用一定的分层策略。然而这种做法一般对&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=%e5%a4%8d%e6%9d%82%e5%ba%a6&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7b%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A874296743%7d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;复杂度&lt;/a&gt;的治理并没有多大作用。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;融会贯通阶段&#34;&gt;融会贯通阶段&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;术语已经不再重要，理解DDD的本质是统一语言、边界划分和面向对象分析的方法。&lt;/p&gt;
&lt;p&gt;大体上而言，我大概是在1.7的阶段，因为有一个问题一直在困扰我，就是哪些能力应该放在Domain层，是不是按照传统的做法，将所有的业务都收拢到Domain上，这样做合理吗？说实话，这个问题我一直没有想清楚。&lt;/p&gt;
&lt;p&gt;因为在现实业务中，很多的功能都是用例特有的（Use case specific）的，如果“盲目”的使用Domain收拢业务并不见得能带来多大的益处。相反，这种收拢会导致Domain层的膨胀过厚，不够纯粹，反而会影响复用性和表达能力。&lt;/p&gt;
&lt;p&gt;鉴于此，我最近的思考是我们应该采用&lt;strong&gt;能力下沉&lt;/strong&gt;的策略。&lt;/p&gt;
&lt;p&gt;所谓的能力下沉，是指我们不强求一次就能设计出Domain的能力，也不需要强制要求把所有的业务功能都放到Domain层，而是采用实用主义的态度，即只对那些需要在多个场景中需要被复用的能力进行抽象下沉，而不需要复用的，就暂时放在App层的Use Case里就好了。&lt;/p&gt;
&lt;p&gt;注：Use Case是《架构整洁之道》里面的术语，简单理解就是响应一个Request的处理过程&lt;/p&gt;
&lt;p&gt;通过实践，&lt;strong&gt;我发现这种循序渐进的能力下沉策略，应该是一种更符合实际、更敏捷的方法。因为我们承认模型不是一次性设计出来的，而是迭代演化出来的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下沉的过程如下图所示，假设两个use case中，我们发现uc1的step3和uc2的step1有类似的功能，我们就可以考虑让其下沉到Domain层，从而增加代码的复用性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110552.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指导下沉有两个关键指标：代码的复用性和内聚性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;复用性是告诉我们When（什么时候该下沉了），即有重复代码的时候。内聚性是告诉我们How（要下沉到哪里），功能有没有内聚到恰当的实体上，有没有放到合适的层次上（因为Domain层的能力也是有两个层次的，一个是Domain Service这是相对比较粗的粒度，另一个是Domain的Model这个是最细粒度的复用）。&lt;/p&gt;
&lt;p&gt;比如，在我们的商品域，经常需要判断一个商品是不是最小单位，是不是中包商品。像这种能力就非常有必要直接挂载在Model上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CSPU&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String code&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String baseCode&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//省略其它属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 单品是否为最小单位。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isMinimumUnit&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; StringUtils&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;code&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; baseCode&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 针对中包的特殊处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isMidPackage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; StringUtils&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;code&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; midPackageCode&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之前，因为老系统中没有领域模型，没有CSPU这个实体。你会发现像判断单品是否为最小单位的逻辑是以&lt;code&gt;StringUtils.equals(code, baseCode)&lt;/code&gt;的形式散落在代码的各个角落。这种代码的可理解性是可想而知的，至少我在第一眼看到这个代码的时候，是完全不知道什么意思。&lt;/p&gt;
&lt;h2 id=&#34;业务技术要怎么做&#34;&gt;业务技术要怎么做&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;业务技术到底是在做业务，还是做技术？业务技术的技术性体现在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上面的案例，我们可以看到业务所面临的复杂性并不亚于底层技术，要想写好业务代码也不是一件容易的事情。业务技术和底层技术人员唯一的区别是他们所面临的问题域不一样。&lt;/p&gt;
&lt;p&gt;业务技术面对的问题域变化更多、面对的人更加庞杂。而底层技术面对的问题域更加稳定、但对技术的要求更加深。比如，如果你需要去开发Pandora，你就要对Classloader有更加深入的了解才行。&lt;/p&gt;
&lt;p&gt;但是，不管是业务技术还是底层技术人员，有一些思维和能力都是共通的。比如，&lt;strong&gt;分解问题的能力，抽象思维，结构化思维&lt;/strong&gt;等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220328110806.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>分布式系统的CAP理论</title>
        <link>https://lxb.wiki/3bdd21ca/</link>
        <pubDate>Fri, 10 Sep 2021 21:54:27 +0000</pubDate>
        
        <guid>https://lxb.wiki/3bdd21ca/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;cap理论概述&#34;&gt;CAP理论概述&lt;/h2&gt;
&lt;p&gt;CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226145516.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CAP理论中的CA和数据库事务中ACID的CA并不是同一回事儿。两者之中的C都是都是一致性(Consistency)。CAP中的A指的是可用性（Availability），而ACID中的A指的是原子性（Atomicity)，切勿混为一谈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cap的定义&#34;&gt;CAP的定义&lt;/h2&gt;
&lt;h3 id=&#34;consistency-一致性&#34;&gt;Consistency 一致性&lt;/h3&gt;
&lt;p&gt;一致性指“&lt;code&gt;all nodes see the same data at the same time&lt;/code&gt;”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。&lt;a class=&#34;link&#34; href=&#34;http://www.hollischuang.com/archives/663&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分布式的一致性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。&lt;/p&gt;
&lt;p&gt;一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。&lt;/p&gt;
&lt;p&gt;从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三种一致性策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。&lt;/p&gt;
&lt;p&gt;如果能容忍后续的部分或者全部访问不到，则是弱一致性。&lt;/p&gt;
&lt;p&gt;如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。&lt;/p&gt;
&lt;p&gt;CAP中说，不可能同时满足的这个一致性指的是强一致性。&lt;/p&gt;
&lt;h3 id=&#34;availability-可用性&#34;&gt;Availability 可用性&lt;/h3&gt;
&lt;p&gt;可用性指“&lt;code&gt;Reads and writes always succeed&lt;/code&gt;”，即服务一直可用，而且是正常响应时间。&lt;/p&gt;
&lt;p&gt;对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;可用性分类&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;可用水平（%）&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;年可容忍停机时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;容错可用性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99.9999&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;1 min&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;极高可用性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99.999&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;5 min&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;具有故障自动恢复能力的可用性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99.99&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;53 min&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高可用性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99.9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;8.8h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;商品可用性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;43.8 min&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 &lt;code&gt;(1-0.99999)*365*24*60 = 5.256 min&lt;/code&gt;，这是一个极高的要求。&lt;/p&gt;
&lt;p&gt;好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。&lt;/p&gt;
&lt;h3 id=&#34;partition-tolerance分区容错性&#34;&gt;Partition Tolerance分区容错性&lt;/h3&gt;
&lt;p&gt;分区容错性指“&lt;code&gt;the system continues to operate despite arbitrary message loss or failure of part of the system&lt;/code&gt;”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。&lt;/p&gt;
&lt;p&gt;分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。&lt;/p&gt;
&lt;p&gt;简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。&lt;/p&gt;
&lt;h2 id=&#34;cap的证明&#34;&gt;CAP的证明&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226154057.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。&lt;/p&gt;
&lt;p&gt;在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226154153.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。&lt;/p&gt;
&lt;p&gt;这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？&lt;/p&gt;
&lt;p&gt;作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226154349.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？&lt;/p&gt;
&lt;p&gt;有二种选择，第一，牺牲数据一致性，保证可用性。响应旧的数据V0给用户；&lt;/p&gt;
&lt;p&gt;第二，牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。&lt;/p&gt;
&lt;p&gt;这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。&lt;/p&gt;
&lt;h2 id=&#34;cap权衡&#34;&gt;CAP权衡&lt;/h2&gt;
&lt;p&gt;通过CAP理论及前面的证明，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？&lt;/p&gt;
&lt;p&gt;我们分三种情况来阐述一下。&lt;/p&gt;
&lt;h3 id=&#34;ca-without-p&#34;&gt;CA without P&lt;/h3&gt;
&lt;p&gt;这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。&lt;/p&gt;
&lt;p&gt;比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。&lt;/p&gt;
&lt;p&gt;其实，在CAP理论中。C，A，P三者并不是平等的，CAP之父在《Spanner，真时，CAP理论》一文中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果说Spanner真有什么特别之处，那就是谷歌的广域网。Google通过建立私有网络以及强大的网络工程能力来保证P，在多年运营改进的基础上，在生产环境中可以最大程度的减少分区发生，从而实现高可用性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从Google的经验中可以得到的结论是，无法通过降低CA来提升P。要想提升系统的分区容错性，需要通过提升基础设施的稳定性来保障。&lt;/p&gt;
&lt;p&gt;所以，对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。&lt;/p&gt;
&lt;h3 id=&#34;cp-without-a&#34;&gt;CP without A&lt;/h3&gt;
&lt;p&gt;如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。&lt;/p&gt;
&lt;p&gt;一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。&lt;/p&gt;
&lt;p&gt;设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。&lt;/p&gt;
&lt;p&gt;无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？&lt;/p&gt;
&lt;p&gt;ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。&lt;/p&gt;
&lt;h3 id=&#34;ap-wihtout-c&#34;&gt;AP wihtout C&lt;/h3&gt;
&lt;p&gt;要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。&lt;/p&gt;
&lt;p&gt;这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。&lt;/p&gt;
&lt;p&gt;你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。&lt;/p&gt;
&lt;p&gt;但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。&lt;/p&gt;
&lt;p&gt;对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>网络 IO 模型</title>
        <link>https://lxb.wiki/3af5472b/</link>
        <pubDate>Mon, 16 Aug 2021 22:52:32 +0000</pubDate>
        
        <guid>https://lxb.wiki/3af5472b/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;互联网服务端处理网络请求的原理&#34;&gt;互联网服务端处理网络请求的原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个典型互联网服务端处理网络请求的典型过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226140211.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由上图可以看到，主要处理步骤包括：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）；&lt;/p&gt;
&lt;p&gt;2）构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）；&lt;/p&gt;
&lt;p&gt;3）返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端（5-7）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计服务端并发模型时，主要有如下两个关键点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）服务器如何管理连接，获取输入数据；&lt;/p&gt;
&lt;p&gt;2）服务器如何处理请求。&lt;/p&gt;
&lt;p&gt;以上两个关键点最终都与操作系统的 I/O 模型以及线程(进程)模型相关，这也是本文和下篇《高性能网络编程(六)：一文读懂高性能网络编程中的线程模型》将要介绍的内容。下面先详细介绍这I/O模型。&lt;/p&gt;
&lt;h2 id=&#34;io-模型的基本认识&#34;&gt;“I/O 模型”的基本认识&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;介绍操作系统的 I/O 模型之前，先了解一下几个概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）阻塞调用与非阻塞调用；&lt;/p&gt;
&lt;p&gt;2）阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；&lt;/p&gt;
&lt;p&gt;3）非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。&lt;/p&gt;
&lt;p&gt;两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞&lt;/strong&gt;是指调用方一直在等待而且别的事情什么都不做；&lt;strong&gt;非阻塞&lt;/strong&gt;是指调用方先去忙别的事情。&lt;/p&gt;
&lt;p&gt;**同步处理与异步处理：**同步处理是指被调用方得到最终结果之后才返回给调用方；异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞、非阻塞和同步、异步的区别（&lt;strong&gt;阻塞、非阻塞和同步、异步其实针对的对象是不一样的）&lt;/strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）阻塞、非阻塞的讨论对象是调用者；&lt;/p&gt;
&lt;p&gt;2）同步、异步的讨论对象是被调用者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;recvfrom 函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;recvfrom 函数(经 Socket 接收数据)，这里把它视为系统调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个输入操作通常包括两个不同的阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）等待数据准备好；&lt;/p&gt;
&lt;p&gt;2）从内核向进程复制数据。&lt;/p&gt;
&lt;p&gt;对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。&lt;/p&gt;
&lt;p&gt;实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为 5 种 I/O 模型&lt;/p&gt;
&lt;h2 id=&#34;网络io模型&#34;&gt;网络IO模型&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IO其实我们并不陌生，站在操作系统的角度上说，io一般指访问磁盘数据，可以分为两步，以read操作举例的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一阶段：等待数据准备 (Waiting for the data to be ready)。&lt;/li&gt;
&lt;li&gt;第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而网络IO也是如此，只不过它是读取的不是磁盘，而是socket：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。&lt;/li&gt;
&lt;li&gt;第二步：把数据从内核缓冲区复制到应用进程缓冲区。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在理解网络IO模型之前，我们得先准备些IO模型的基础知识&lt;/p&gt;
&lt;h3 id=&#34;io模型&#34;&gt;IO模型&lt;/h3&gt;
&lt;p&gt;Unix 有五种 I/O 模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞IO（bloking IO）&lt;/li&gt;
&lt;li&gt;非阻塞IO（non-blocking IO）&lt;/li&gt;
&lt;li&gt;多路复用IO（multiplexing IO）&lt;/li&gt;
&lt;li&gt;信号驱动式IO（signal-driven IO）&lt;/li&gt;
&lt;li&gt;异步IO（asynchronous IO）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。下面提供一个简单的图片以供了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226140555.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;阻塞式-io&#34;&gt;阻塞式 IO&lt;/h4&gt;
&lt;p&gt;应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。&lt;/p&gt;
&lt;p&gt;应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。&lt;/p&gt;
&lt;p&gt;下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226140921.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/16533261-a71605af7a6d472c?imageMogr2/auto-orient/strip%7cimageView2/2/w/640/format/webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;非阻塞式-io&#34;&gt;非阻塞式 IO&lt;/h4&gt;
&lt;p&gt;应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。&lt;/p&gt;
&lt;p&gt;由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率是比较低的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141038.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141052.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;多路复用io&#34;&gt;多路复用IO&lt;/h4&gt;
&lt;p&gt;由于阻塞式IO通过轮询得到的只是一个IO任务是否完成，而可能有多个任务在同时进行，因此就想到了能否轮询多个IO任务的状态，只要有任何一个任务完成，就去处理它。这就是所谓的IO多路复用。LINUX下具体的实现方式就是select、poll、epoll。&lt;/p&gt;
&lt;p&gt;这种机制可以让单个进程具有处理多个 IO 事件的能力。又被称为 Event Driven IO，即事件驱动 IO。&lt;/p&gt;
&lt;p&gt;最实际的应用场景就是web服务器响应连接的方式，IO 复用可支持&lt;strong&gt;更多的连接&lt;/strong&gt;，同时不需要进程线程创建和切换的开销，系统开销更小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141126.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141140.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多路复用的特点是通过一种机制一个进程能同时等待多个IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在IO多路复用中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的进程其实是一直被block的。只不过进程是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。&lt;/p&gt;
&lt;h4 id=&#34;信号驱动-io&#34;&gt;信号驱动 IO&lt;/h4&gt;
&lt;p&gt;应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。&lt;/p&gt;
&lt;p&gt;相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141353.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;异步-io&#34;&gt;异步 IO&lt;/h4&gt;
&lt;p&gt;应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。&lt;/p&gt;
&lt;p&gt;异步 IO 与信号驱动 IO 的区别在于，异步 IO 的信号是通知应用进程 IO 完成，而信号驱动 IO 的信号是通知应用进程可以开始 IO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141447.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141502.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;五大-io-模型比较&#34;&gt;五大 IO 模型比较&lt;/h3&gt;
&lt;p&gt;前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141649.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141702.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上图中我们可以看出，越往后，阻塞越少，理论上效率也是最优。&lt;/p&gt;
&lt;p&gt;这五种 I/O 模型中，前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。&lt;/p&gt;
&lt;h4 id=&#34;blocking和non-blocking区别&#34;&gt;blocking和non-blocking区别&lt;/h4&gt;
&lt;p&gt;调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。&lt;/p&gt;
&lt;h4 id=&#34;synchronous-io和asynchronous-io区别&#34;&gt;synchronous IO和asynchronous IO区别&lt;/h4&gt;
&lt;p&gt;在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An asynchronous I/O operation does not cause the requesting process to be blocked;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;同步 I/O：应用进程在调用 recvfrom 操作时会阻塞。&lt;/li&gt;
&lt;li&gt;异步 I/O：不会阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。&lt;/p&gt;
&lt;h3 id=&#34;selectpollepoll比较&#34;&gt;select，poll，epoll比较&lt;/h3&gt;
&lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。&lt;/p&gt;
&lt;h4 id=&#34;select&#34;&gt;select&lt;/h4&gt;
&lt;p&gt;select的调用过程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226141946.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;（1）使用copy_from_user从用户空间拷贝fd_set到内核空间&lt;/p&gt;
&lt;p&gt;（2）注册回调函数__pollwait&lt;/p&gt;
&lt;p&gt;（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）&lt;/p&gt;
&lt;p&gt;（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。&lt;/p&gt;
&lt;p&gt;（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&amp;gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。&lt;/p&gt;
&lt;p&gt;（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。&lt;/p&gt;
&lt;p&gt;（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。&lt;/p&gt;
&lt;p&gt;（8）把fd_set从内核空间拷贝到用户空间。&lt;/p&gt;
&lt;h5 id=&#34;总结&#34;&gt;总结：&lt;/h5&gt;
&lt;p&gt;select的几大缺点：&lt;/p&gt;
&lt;p&gt;（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大&lt;/p&gt;
&lt;p&gt;（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大&lt;/p&gt;
&lt;p&gt;（3）select支持的文件描述符数量太小了，默认是1024&lt;/p&gt;
&lt;h4 id=&#34;poll&#34;&gt;poll&lt;/h4&gt;
&lt;p&gt;poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。&lt;/p&gt;
&lt;h4 id=&#34;epoll&#34;&gt;epoll&lt;/h4&gt;
&lt;p&gt;epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。&lt;/p&gt;
&lt;p&gt;对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。&lt;/p&gt;
&lt;p&gt;对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。&lt;/p&gt;
&lt;p&gt;对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。&lt;/p&gt;
&lt;h5 id=&#34;总结-1&#34;&gt;总结&lt;/h5&gt;
&lt;p&gt;（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。&lt;/p&gt;
&lt;p&gt;（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。&lt;/p&gt;
&lt;h4 id=&#34;应用场景&#34;&gt;应用场景&lt;/h4&gt;
&lt;p&gt;很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。&lt;/p&gt;
&lt;h5 id=&#34;1-select-应用场景&#34;&gt;1. select 应用场景&lt;/h5&gt;
&lt;p&gt;select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。&lt;/p&gt;
&lt;p&gt;select 可移植性更好，几乎被所有主流平台所支持。&lt;/p&gt;
&lt;h5 id=&#34;2-poll-应用场景&#34;&gt;2. poll 应用场景&lt;/h5&gt;
&lt;p&gt;poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。&lt;/p&gt;
&lt;p&gt;需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。&lt;/p&gt;
&lt;p&gt;需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。&lt;/p&gt;
&lt;h5 id=&#34;3-epoll-应用场景&#34;&gt;3. epoll 应用场景&lt;/h5&gt;
&lt;p&gt;只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。&lt;/p&gt;
&lt;h3 id=&#34;web服务器设计模型&#34;&gt;web服务器设计模型&lt;/h3&gt;
&lt;h4 id=&#34;并发并行&#34;&gt;并发&amp;amp;并行&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
并行需要硬件支持，如多流水线或者多处理器。
操作系统通过引入进程和线程，使得程序能够并发运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于web服务而言，并发是指同时进行的任务数（如同时服务的 HTTP 请求），而并行是可以同时工作的物理资源数量（如 CPU 核数）。&lt;/p&gt;
&lt;p&gt;而针对并发IO而言，Reactor模型是一种常见的处理方式&lt;/p&gt;
&lt;h4 id=&#34;reactor模型&#34;&gt;Reactor模型&lt;/h4&gt;
&lt;p&gt;Reactor的中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有I/O事件到来或是准备就绪(文件描述符或socket可读、写)，多路复用器返回并将事先注册的相应I/O事件分发到对应的处理器中。&lt;/p&gt;
&lt;p&gt;Reactor是一种事件驱动机制，用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。
Reactor模式与Observer模式在某些方面极为相似：当一个主体发生改变时，所有依属体都得到通知。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。&lt;/p&gt;
&lt;p&gt;在Reactor模式中，有5个关键的参与者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;描述符（handle）&lt;/strong&gt;：由操作系统提供的资源，用于识别每一个事件，如Socket描述符、文件描述符、信号的值等。在Linux中，它用一个整数来表示。事件可以来自外部，如来自客户端的连接请求、数据等。事件也可以来自内部，如信号、定时器事件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步事件多路分离器（event demultiplexer）&lt;/strong&gt;：事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O复用技术实现。在linux系统上一般是select、poll、epol_waitl等系统调用，用来等待一个或多个事件的发生。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件处理器（event handler）&lt;/strong&gt;：I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。这些模板函数描述了和应用程序相关的对某个事件的操作，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般声明为虚函数，以支持用户拓展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体的事件处理器（concrete event handler）&lt;/strong&gt;：是事件处理器接口的实现。它实现了应用程序提供的某个服务。每个具体的事件处理器总和一个描述符相关。它使用描述符来识别事件、识别应用程序提供的服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reactor 管理器（reactor）&lt;/strong&gt;：定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模 板函数来处理这个事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142433.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以看出，是Reactor管理器并不是应用程序负责等待事件、分离事件和调度事件。Reactor并没有被具体的事件处理器调度，而是管理器调度具体的事件处理器，由事件处理器对发生的事件作出处理，这就是Hollywood原则。应用程序要做的仅仅是实现一个具体的事件处理器，然后把它注册到Reactor管理器中。接下来的工作由管理器来完成：如果有相应的事件发生，Reactor会主动调用具体的事件处理器，由事件处理器对发生的事件作出处理。&lt;/p&gt;
&lt;h5 id=&#34;为什么使用reactor&#34;&gt;为什么使用Reactor&lt;/h5&gt;
&lt;p&gt;有了I/O复用，有了epoll已经可以使服务器并发几十万连接的同时，维持高TPS了，难道这还不够吗？&lt;/p&gt;
&lt;p&gt;答案是，技术层面足够了，但在软件工程层面却是不够的。&lt;/p&gt;
&lt;p&gt;程序使用IO复用的难点在哪里呢？&lt;/p&gt;
&lt;p&gt;1个请求可能由多次IO处理完成，但相比传统的单线程完整处理请求生命期的方法，IO复用在人的大脑思维中并不自然，因为，程序员编程中，处理请求A的时候，假定A请求必须经过多个IO操作A1-An（两次IO间可能间隔很长时间），每经过一次IO操作，再调用IO复用时，IO复用的调用返回里，非常可能不再有A，而是返回了请求B。即请求A会经常被请求B打断，处理请求B时，又被C打断。这种思维下，编程容易出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在程序中：&lt;/strong&gt;
某一瞬间，服务器共有10万个并发连接，此时，一次IO复用接口的调用返回了100个活跃的连接等待处理。先根据这100个连接找出其对应的对象，这并不难，epoll的返回连接数据结构里就有这样的指针可以用。接着，循环的处理每一个连接，找出这个对象此刻的上下文状态，再使用read、write这样的网络IO获取此次的操作内容，结合上下文状态查询此时应当选择哪个业务方法处理，调用相应方法完成操作后，若请求结束，则删除对象及其上下文。&lt;/p&gt;
&lt;p&gt;这样，我们就陷入了&lt;strong&gt;面向过程编程&lt;/strong&gt;方法之中了，在面向应用、快速响应为王的移动互联网时代，这样做早晚得把自己玩死。我们的主程序需要关注各种不同类型的请求，在不同状态下，对于不同的请求命令选择不同的业务处理方法。这会导致随着请求类型的增加，请求状态的增加，请求命令的增加，&lt;strong&gt;主程序复杂度快速膨胀&lt;/strong&gt;，导致维护越来越困难，苦逼的程序员再也不敢轻易接新需求、重构。&lt;/p&gt;
&lt;p&gt;反应堆是解决上述软件工程问题的一种途径，它也许并不优雅，开发效率上也不是最高的，但其执行效率与面向过程的使用IO复用却几乎是等价的，所以，无论是nginx、memcached、redis等等这些高性能组件的代名词，都义无反顾的一头扎进了反应堆的怀抱中。&lt;/p&gt;
&lt;p&gt;反应堆模式可以在软件工程层面，将事件驱动框架分离出具体业务，将不同类型请求之间用OO的思想分离。通常，反应堆不仅使用IO复用处理网络事件驱动，还会实现定时器来处理时间事件的驱动（请求的超时处理或者定时任务的处理）&lt;/p&gt;
&lt;h5 id=&#34;reactor的几种模式&#34;&gt;Reactor的几种模式&lt;/h5&gt;
&lt;h6 id=&#34;1-单线程模式&#34;&gt;1 单线程模式&lt;/h6&gt;
&lt;p&gt;这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过这种单线程模型不能充分利用多核资源，所以实际使用的不多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142550.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h6 id=&#34;2-多线程模式单reactor&#34;&gt;2 多线程模式（单Reactor）&lt;/h6&gt;
&lt;p&gt;该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h6 id=&#34;3-多线程模式多个reactor&#34;&gt;3 多线程模式（多个Reactor）&lt;/h6&gt;
&lt;p&gt;比起第二种模型，它是将Reactor分成两部分，mainReactor负责监听并accept新连接，然后将建立的socket通过多路复用器（Acceptor）分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据；业务处理功能，其交给worker线程池完成。通常，subReactor个数上可与CPU个数等同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226142645.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;proacotr模型&#34;&gt;Proacotr模型&lt;/h4&gt;
&lt;p&gt;Proactor是和异步I/O相关的。&lt;/p&gt;
&lt;h5 id=&#34;比较&#34;&gt;比较&lt;/h5&gt;
&lt;p&gt;以读操作为例：
在Reactor（同步）中实现读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册读就绪事件和相应的事件处理器&lt;/li&gt;
&lt;li&gt;事件分离器等待事件&lt;/li&gt;
&lt;li&gt;事件到来，激活分离器，分离器调用事件对应的处理器。&lt;/li&gt;
&lt;li&gt;事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proactor（异步）中的读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。&lt;/li&gt;
&lt;li&gt;事件分离器等待操作完成事件&lt;/li&gt;
&lt;li&gt;在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。&lt;/li&gt;
&lt;li&gt;事件分离器呼唤处理器。&lt;/li&gt;
&lt;li&gt;事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/43933717&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文读懂高性能网络编程中的I/O模型 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Zhangyq-yard/p/10114785.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;网络I/O模型&amp;ndash;5种常见的网络I/O模型 - QiangAnan - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/ad548bb816ec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何理解高性能网络模型&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何保证服务稳定性</title>
        <link>https://lxb.wiki/d0f092bd/</link>
        <pubDate>Tue, 25 May 2021 21:57:43 +0000</pubDate>
        
        <guid>https://lxb.wiki/d0f092bd/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;1-sla&#34;&gt;1 SLA&lt;/h2&gt;
&lt;p&gt;业内喜欢用SLA （服务等级协议，全称：service level agreement）来衡量系统的稳定性，对互联网公司来说就是网站服务可用性的一个保证。9越多代表全年服务可用时间越长服务越可靠，停机时间越短。就以一个标准99.99%为例，停机时间52.6分钟，平均到每周也就是只能有差不多1分钟的停机时间，也就是说网络抖动这个时间可能就没了。保证一个系统四个9或者更高的五个9，需要一套全体共识严格标准的规章制度，没有规矩不成方圆。创建的规范有如下几种：&lt;/p&gt;
&lt;p&gt;1、研发规范、自身稳定；&lt;/p&gt;
&lt;p&gt;2、事务中不能包含远程调用；&lt;/p&gt;
&lt;p&gt;3、超时时间和重试次数要合理；&lt;/p&gt;
&lt;p&gt;4、表数据操作必须double check，合理利用索引，避免出现慢查询、分库分表不走分表键；&lt;/p&gt;
&lt;p&gt;5、没有有效的资源隔离， 避免不同业务共用一个线程池或连接池；&lt;/p&gt;
&lt;p&gt;6、合理的系统拓扑，禁止不合理服务依赖，能依赖就依赖，否则同步尽量改成异步弱依赖；&lt;/p&gt;
&lt;p&gt;7、精简的代码逻辑；&lt;/p&gt;
&lt;p&gt;8、核心路径流程必须进行资源隔离，确保任何突发情况主流程不能受影响。&lt;/p&gt;
&lt;h2 id=&#34;2-单服务稳定性&#34;&gt;2 单服务稳定性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关键字：开关可控、单一职责、服务隔离、异常兜底、监控发现！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于稳定性来说，抛开整体系统架构设计，单就每个业务域服务的稳定性也是非常的重要。只有每个业务环节都稳如泰山，才能保障整个稳定性。单服务稳定可以从以下几个方面来进行：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、禁用设计&lt;/strong&gt;：应该提供控制具体功能是否开启可用的配置，在相应的功能服务出现故障时，快速下线局部功能，以保证整体服务的可用性；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、必要的缓存&lt;/strong&gt;：缓存是解决并发的利器，可以有效的提高系统的吞吐量。按照业务以及技术的纬度必要时可以增加多级缓存来保证其命中率；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、接口无状态性&lt;/strong&gt;：服务接口应是无状态的，当前接口访问不应该依赖上层接口的状态逻辑；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、接口单一职责性&lt;/strong&gt;：对于核心功能的接口，不应该过多的耦合不属于它的功能。如果一个接口做的事情太多应做拆分，保证单接口的稳定性和快速响应；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、第三方服务隔离性&lt;/strong&gt;：任何依赖于第三方的服务（不论接口还是中间件等），都应该做到熔断和降级，不能有强耦合的依赖；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、业务场景兜底方案&lt;/strong&gt;：核心业务场景要做到完整兜底方法，从前端到后端都应有兜底措施；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、服务监控与及时响应&lt;/strong&gt;：每个服务应做好对应监控工作，如有异常应及时响应，不应累积。&lt;/p&gt;
&lt;h2 id=&#34;3-集群稳定性&#34;&gt;3 集群稳定性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关键字：系统架构、部署发布、限流熔断、监控体系、压测机制！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于集群维度的稳定性来说，稳定性保障会更加复杂。单服务是局部，集群是全局。一个见微知著，一个高瞻远瞩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、合理的系统架构&lt;/strong&gt;：合理的系统架构是稳定的基石；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、小心的代码逻辑&lt;/strong&gt;：代码时刻都要小心，多担心一点这里会不会有性能问题，那里会不会出现并发，代码就不会有多少问题；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、优秀的集群部署&lt;/strong&gt;：一台机器永远会有性能瓶颈，优秀的集群部署，可以将一台机器的稳定放大无限倍，是高并发与大流量的保障；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、科学的限流熔断&lt;/strong&gt;：高并发来临时，科学的限流和熔断是系统稳定的必要条件；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、精细的监控体系&lt;/strong&gt;：没有监控体系，你永远不会知道你的系统到底有多少隐藏的问题和坑，也很难知道瓶颈在哪里；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、强悍的压测机制&lt;/strong&gt;：压测是高并发稳定性的试金石，能提前预知高并发来临时，系统应该出现的模样；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、胆小的开发人员&lt;/strong&gt;：永远需要一群胆小的程序员，他们讨厌bug，害怕error，不放过每一个波动，不信任所有的依赖。&lt;/p&gt;
&lt;h2 id=&#34;4-稳定性专项&#34;&gt;4 稳定性专项&lt;/h2&gt;
&lt;p&gt;专项指的是&lt;strong&gt;针对某些特定场景下的特定问题而梳理出对应的方案&lt;/strong&gt;。下面是针对一些常见的稳定性专项的概述：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、预案&lt;/strong&gt;：分为定时预案和紧急预案，定时预案是大促常规操作对于一系列开关的编排，紧急预案是应对突发情况的特殊处理，都依赖于事前梳理；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、预热&lt;/strong&gt;：分为JIT代码预热和数据预热，阿里内部有专门的一个产品负责这块，通过存储线上的常态化流量或者热点流量进行回放来提前预热， 起源于某年双十一零点的毛刺问题，原因是访问了数据库的冷数据rt增高导致的一系列上层限流，现在预热已经成了大促之前的一个必要流程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、强弱依赖&lt;/strong&gt;:梳理强弱依赖是一个偏人肉的过程，但是非常重要，这是一个系统自查识别潜在风险点并为后续整理开关限流预案和根因分析的一个重要参考，阿里内部有一个强弱依赖检测的平台，通过对测试用例注入RPC调用的延迟或异常来观察链路的依赖变化，自动梳理出强弱依赖关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、限流降级熔断&lt;/strong&gt;:应对突发流量防止请求超出自身处理能力系统被击垮的必要手段；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、监控告警&amp;amp;链路追踪&lt;/strong&gt;:监控分为业务监控、系统监控和中间件监控和基础监控，作为线上问题发现和排查工具，重要性不言而喻。&lt;/p&gt;
&lt;h2 id=&#34;5-稳定性建设&#34;&gt;5 稳定性建设&lt;/h2&gt;
&lt;p&gt;稳定性建设，就和基础技术建设一样，是一个&lt;strong&gt;长期迭代和不断调整的过程&lt;/strong&gt;，业内常见的稳定性建设类型，主要有如下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、容量规划&lt;/strong&gt;：个人感觉容量规划在大厂里也并没有做的很好，更多依赖的是业务方自己拍脑袋，然后全链路压测期间验证，不够就再加机器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、混沌工程&lt;/strong&gt;：混沌工程是近几年比较火的名词，通过不断给系统找麻烦来验证并完善系统能力，阿里在这块花了很大的精力建设红蓝军对抗攻防，进行定期和不定期的演练，最后以打分的形式来给各个部门系统做排名，除了系统层面的故障演练外还有资金演练，篡改线上sql语句制造资损来测试业务监控纠错的能力，通过制造小错来避免大错。&lt;/p&gt;
&lt;p&gt;跳转门：&lt;a class=&#34;link&#34; href=&#34;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/imyalost/p/12271620.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;混沌工程-初识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、流量调度&lt;/strong&gt;：通过metric秒级监控和聚类算法实时找出异常单机来降低RPC流量权重，提升集群整体吞吐能力减少异常请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、容灾&amp;amp;异地多活&lt;/strong&gt;：起源于15年某施工队将光纤挖断带来的支付宝故障，由此出来的三地五中心和单元化架构，异地多活本身的成本比较高，然后又存在数据同步的延时问题和切流带来的脏数据问题，对于业务和技术都有比较高的要求。常见的容灾有如下几种：&lt;/p&gt;
&lt;p&gt;　 1）缓存挂掉，集群重启缓存预热如何处理？本地缓存，多级缓存是否可以替代？&lt;/p&gt;
&lt;p&gt;　 2）分布式锁，是否有开关一键切换？比如：ZK/ETCD编写的分布式锁；&lt;/p&gt;
&lt;p&gt;　 3）大促峰值流量，如何防止外部ddos攻击？如何识别流量类型？&lt;/p&gt;
&lt;p&gt;　 4）资源隔离：资源隔离，服务分组，流量隔离；&lt;/p&gt;
&lt;p&gt;　 5）高可用思想：避免单点设计！&lt;/p&gt;
&lt;p&gt;　 6）容错：容错上游，防御下游。容错主要需要注意如下几点：&lt;/p&gt;
&lt;p&gt;　 　 6-1：外部依赖的地方都要做熔断，避免雪崩；&lt;/p&gt;
&lt;p&gt;　　 6-2：对于依赖我们的上游要限流，防止上游突发超过自己系统能够扛住的最大QPS；&lt;/p&gt;
&lt;p&gt;　　 6-3：对于下游既要评估好接口超时时间，防止下游接口超时导致自己系统被拖累；&lt;/p&gt;
&lt;p&gt;　　 6-4：下游接口要考虑各种异常情况，需要考虑中间状态，通过引入柔性事务，确保数&lt;/p&gt;
&lt;p&gt;据最终一致&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、异地多活&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异地多活的本质，是数据中心架构的演进&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）演进&lt;/strong&gt;：单机房——双机房——异地灾备——异地多活；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）定义&lt;/strong&gt;：分多个地域、多个数据中心运行线上的业务，并且每个IDC均提供在线服务；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）优点&lt;/strong&gt;：弹性扩展能力、流量就近接入、灵活调度、提升可用性与用户体验、容灾；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　 4-1：基础设施：机房之间专线互联，保证网络质量稳定；&lt;/p&gt;
&lt;p&gt;　 4-2：持久存储：一主三从，主IDC同步复制，异地IDC异步复制；&lt;/p&gt;
&lt;p&gt;　 4-3：中间件：DB、MQ、分布式存储；&lt;/p&gt;
&lt;p&gt;　 4-4：应用部署：根据应用域划分，不同应用部署在不同地域，保持亲缘性；&lt;/p&gt;
&lt;p&gt;　 4-5：流量接入与调度：网络协议兼容，DNS，动态调度用户就近访问；&lt;/p&gt;
&lt;p&gt;　 4-6：监控与运维保障：专线实时监控，确保发生故障时可以触发Failover（失效备援）和&lt;/p&gt;
&lt;p&gt;流量调度。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>可靠性、可用性、稳定性</title>
        <link>https://lxb.wiki/18166f99/</link>
        <pubDate>Mon, 29 Mar 2021 23:01:42 +0000</pubDate>
        
        <guid>https://lxb.wiki/18166f99/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;对比Availability可用性、Reliability可靠性、Stability稳定性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;区分&#34;&gt;区分&lt;/h2&gt;
&lt;p&gt;从事故、稳定方面简单理解如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;不出事故&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;出事故后，快速止损&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;稳定性&lt;/td&gt;
&lt;td&gt;解决故障问题基础上，服务持续稳定、性能稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210509160538.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;总体对比&#34;&gt;总体对比&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;可用性&#34;&gt;可用性&lt;/h2&gt;
&lt;p&gt;可用性指系统在给定时间内可以正常工作的概率，通常用SLA（服务等级协议，service level agreement）指标来表示。&lt;/p&gt;
&lt;p&gt;这是这段时间的总体的可用性指标。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通俗叫法&lt;/th&gt;
&lt;th&gt;可用性级别&lt;/th&gt;
&lt;th&gt;年度宕机时间&lt;/th&gt;
&lt;th&gt;周宕机时间&lt;/th&gt;
&lt;th&gt;每天宕机时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1个9&lt;/td&gt;
&lt;td&gt;90%&lt;/td&gt;
&lt;td&gt;36.5天&lt;/td&gt;
&lt;td&gt;16.8小时&lt;/td&gt;
&lt;td&gt;2.4小时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2个9&lt;/td&gt;
&lt;td&gt;99%&lt;/td&gt;
&lt;td&gt;87.6小时&lt;/td&gt;
&lt;td&gt;1.68小时&lt;/td&gt;
&lt;td&gt;14分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3个9&lt;/td&gt;
&lt;td&gt;99.9%&lt;/td&gt;
&lt;td&gt;8.76小时&lt;/td&gt;
&lt;td&gt;10.1分钟&lt;/td&gt;
&lt;td&gt;86秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4个9&lt;/td&gt;
&lt;td&gt;99.99%&lt;/td&gt;
&lt;td&gt;52.6分钟&lt;/td&gt;
&lt;td&gt;1.01分钟&lt;/td&gt;
&lt;td&gt;8.6秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5个9&lt;/td&gt;
&lt;td&gt;99.999%&lt;/td&gt;
&lt;td&gt;5.26分钟，315.36秒&lt;/td&gt;
&lt;td&gt;6.05秒&lt;/td&gt;
&lt;td&gt;0.86秒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;可靠性&#34;&gt;可靠性&lt;/h2&gt;
&lt;p&gt;可靠性相关的几个指标如下：&lt;/p&gt;
&lt;h3 id=&#34;mtbfmean-time-between-failure&#34;&gt;MTBF（Mean Time Between Failure）&lt;/h3&gt;
&lt;p&gt;即平均无故障时间，是指从新的产品在规定的工作环境条件下开始工作到出现第一个故障的时间的平均值。&lt;/p&gt;
&lt;p&gt;MTBF越长表示可靠性越高，正确工作能力越强 。&lt;/p&gt;
&lt;h3 id=&#34;mttrmean-time-to-repair&#34;&gt;MTTR（Mean Time To Repair）&lt;/h3&gt;
&lt;p&gt;即平均修复时间，是指可修复产品的平均修复时间，就是从出现故障到修复中间的这段时间。&lt;/p&gt;
&lt;p&gt;MTTR越短表示易恢复性越好。&lt;/p&gt;
&lt;h3 id=&#34;mttfmean-time-to-failure&#34;&gt;MTTF（Mean Time To Failure）&lt;/h3&gt;
&lt;p&gt;即平均失效时间。系统平均能够正常运行多长时间，才发生一次故障。&lt;/p&gt;
&lt;p&gt;系统的可靠性越高，平均无故障时间越长。&lt;/p&gt;
&lt;p&gt;这些指标跟可用性关系&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Availability = UpTime/(UpTime+DownTime) = MTBF / (MTBF + MTTR)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;稳定性&#34;&gt;稳定性&lt;/h2&gt;
&lt;p&gt;Stackoverflow 看到这样一段代码来表示稳定性和可靠性的区别，甚为有趣：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Reliable but unstable:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    add(a,b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; randomInt mod &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        throw exception
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Stable but unreliable:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    add(a,b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; randomInt mod &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         print a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         print a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>【译】微服务中的熔断器和重试</title>
        <link>https://lxb.wiki/c9399f4/</link>
        <pubDate>Thu, 12 Dec 2019 23:02:17 +0000</pubDate>
        
        <guid>https://lxb.wiki/c9399f4/</guid>
        <description>&lt;p&gt;今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。&lt;/p&gt;
&lt;h2 id=&#34;熔断器&#34;&gt;熔断器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204010211.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。&lt;/p&gt;
&lt;p&gt;后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204010301.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011033.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Happy_path&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wikipedia&lt;/a&gt;）可能不会遇到这种网络模式。&lt;/p&gt;
&lt;h2 id=&#34;状态&#34;&gt;状态&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011142.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;熔断器有三个主要的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 &lt;strong&gt;Max Concurrency&lt;/strong&gt;（最大并发数）和 &lt;strong&gt;Timeout&lt;/strong&gt;（超时）。&lt;/li&gt;
&lt;li&gt;Open：所有的请求都会返回 &lt;strong&gt;Circuit Open&lt;/strong&gt; 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。&lt;/li&gt;
&lt;li&gt;Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;熔断器原理&#34;&gt;熔断器原理&lt;/h2&gt;
&lt;p&gt;控制熔断的设置共有 5 个主要参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// CommandConfig is used to tune circuit settings at runtime
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CommandConfig&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Timeout&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;timeout&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;MaxConcurrentRequests&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;max_concurrent_requests&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;RequestVolumeThreshold&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;request_volume_threshold&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;SleepWindow&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;sleep_window&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;ErrorPercentThreshold&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;error_percent_threshold&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;查看源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以通过根据两个服务的 SLA（‎ Service Level Agreement，&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/zh-hans/%e6%9c%8d%e5%8a%a1%e7%ba%a7%e5%88%ab%e5%8d%8f%e8%ae%ae&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;服务级别协议&lt;/a&gt;）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。&lt;/p&gt;
&lt;p&gt;一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。&lt;/p&gt;
&lt;h2 id=&#34;生产上的熔断器&#34;&gt;生产上的熔断器&lt;/h2&gt;
&lt;p&gt;熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;这段实例代码用的是 &lt;a class=&#34;link&#34; href=&#34;http://github.com/afex/hystrix-go/hystrix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hystrix-go&lt;/a&gt; 库，hystrix Netflix 库在 Golang 的实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;errors&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/afex/hystrix-go/hystrix&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;commandName&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;producer_api&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;hystrix&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ConfigureCommand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;commandName&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hystrix&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CommandConfig&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Timeout&lt;/span&gt;:                &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;MaxConcurrentRequests&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;ErrorPercentThreshold&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;RequestVolumeThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;SleepWindow&lt;/span&gt;:            &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;handle&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;listening on :8080&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ListenAndServe&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hystrix&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Go&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;commandName&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// talk to other services
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callChargeProducerAPI&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// err := callWithRetryV1()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;output&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// success
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;success %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// failure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;failed %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// logger is Handler wrapper function for logging
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandlerFunc&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandlerFunc&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;URL&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Path&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Method&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callChargeProducerAPI&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Getenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SERVER_ERROR&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Getenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SERVER_ERROR&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;503 error&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;demo 中分别测试了请求调用链 closed 和 open 两种情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/* Experiment 1: success path */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i in &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;seq 10&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; curl -x &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; localhost:8080 ;&lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/* Experiment 2: circuit open */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SERVER_ERROR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; Go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i in &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;seq 10&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; curl -x &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; localhost:8080 ;&lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;查看源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;重试问题&#34;&gt;重试问题&lt;/h2&gt;
&lt;p&gt;在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。&lt;/p&gt;
&lt;p&gt;一段简单的重试代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callWithRetryV1&lt;/span&gt;() (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// call producer API
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callChargeProducerAPI&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// adding backoff
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// adding jitter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;查看源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;重试模式&#34;&gt;重试模式&lt;/h2&gt;
&lt;p&gt;为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。&lt;/p&gt;
&lt;p&gt;一起来看下列算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exponential: bash * 2&lt;!-- raw HTML omitted --&gt;attemp&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Full Jitter: sleep = rand(0, base * 2&lt;!-- raw HTML omitted --&gt;attempt&lt;!-- raw HTML omitted --&gt;)&lt;/li&gt;
&lt;li&gt;Equal Jitter: temp = base * 2&lt;!-- raw HTML omitted --&gt;attemp&lt;!-- raw HTML omitted --&gt;; sleep = temp/2+rand(0, temp/2)&lt;/li&gt;
&lt;li&gt;De-corredlated Jitter: sleep = rand(base, sleep*3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【译注】关于这几个算法，可以参考&lt;a class=&#34;link&#34; href=&#34;https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文章&lt;/a&gt; 。&lt;strong&gt;Full Jitter&lt;/strong&gt;、 &lt;strong&gt;Equal Jitter&lt;/strong&gt;、 &lt;strong&gt;De-corredlated&lt;/strong&gt; 等都是原作者自己定义的名词。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204111132.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在&lt;a class=&#34;link&#34; href=&#34;https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文章&lt;/a&gt;中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。&lt;/p&gt;
&lt;h2 id=&#34;两者结合&#34;&gt;两者结合&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011245.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Example configuration of both tools&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。&lt;/p&gt;
&lt;h2 id=&#34;参考文章&#34;&gt;参考文章&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/afex/hystrix-go/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/afex/hystrix-go/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/eapache/go-resiliency&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/eapache/go-resiliency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Netflix/Hystrix/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Netflix/Hystrix/wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.awsarchitectureblog.com/2015/03/backoff.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.awsarchitectureblog.com/2015/03/backoff.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@trongdan_tran&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dan Tran&lt;/a&gt; 译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt; 校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/25295&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go语言中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>分布式锁高并发优化</title>
        <link>https://lxb.wiki/7db296fb/</link>
        <pubDate>Fri, 18 Oct 2019 22:38:39 +0000</pubDate>
        
        <guid>https://lxb.wiki/7db296fb/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;问题场景&#34;&gt;问题场景:&lt;/h4&gt;
&lt;p&gt;假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？&lt;/p&gt;
&lt;h4 id=&#34;库存超卖现象是怎么产生的&#34;&gt;库存超卖现象是怎么产生的？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004321.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;库存超卖&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;假设订单系统部署两台机器上，不同的用户都要同时买10台iphone，分别发了一个请求给订单系统。
接着每个订单系统实例都去数据库里查了一下，当前iphone库存是12台
于是乎，每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台&lt;/p&gt;
&lt;h4 id=&#34;用分布式锁如何解决库存超卖问题&#34;&gt;用分布式锁如何解决库存超卖问题？&lt;/h4&gt;
&lt;p&gt;分布式锁的实现原理:
同一个锁key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004449.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;分布式锁代码&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004607.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;fenbushisuo_yuanli&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。&lt;/p&gt;
&lt;p&gt;释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的&lt;/p&gt;
&lt;h4 id=&#34;分布式锁的方案在高并发场景下&#34;&gt;分布式锁的方案在高并发场景下&lt;/h4&gt;
&lt;p&gt;分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁key进行加锁。&lt;/p&gt;
&lt;p&gt;比如，对iphone这个商品的下单，都必对“iphone_stock”这个锁key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。&lt;/p&gt;
&lt;p&gt;假设加锁之后，释放锁之前，查库存 -&amp;gt; 创建订单 -&amp;gt; 扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。&lt;/p&gt;
&lt;p&gt;那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。&lt;/p&gt;
&lt;p&gt;比如一秒钟来50个请求，都是对iphone下单的，那么每个请求处理20毫秒，一个一个来，最后1000毫秒正好处理完50个请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004059.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;分布式锁串行&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;所以, 能看出来简单的使用分布式锁来处理库存超卖问题，存在的缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。&lt;/p&gt;
&lt;p&gt;这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。&lt;/p&gt;
&lt;p&gt;因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在一秒内瞬间下1000个订单，因为小电商系统没那场景。&lt;/p&gt;
&lt;h4 id=&#34;如何对分布式锁进行高并发优化&#34;&gt;如何对分布式锁进行高并发优化？&lt;/h4&gt;
&lt;p&gt;现在按照刚才的计算，你一秒钟只能处理针对iphone的50个订单。&lt;/p&gt;
&lt;p&gt;其实说出来也很简单，相信很多人看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁！&lt;/p&gt;
&lt;p&gt;把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。&lt;/p&gt;
&lt;p&gt;另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。&lt;/p&gt;
&lt;p&gt;LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。&lt;/p&gt;
&lt;p&gt;其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。&lt;/p&gt;
&lt;p&gt;但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201004652.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;分段加锁&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。&lt;/p&gt;
&lt;p&gt;总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。&lt;/p&gt;
&lt;p&gt;接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。&lt;/p&gt;
&lt;p&gt;这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&amp;gt; 判断库存是否充足 -&amp;gt; 扣减库存。&lt;/p&gt;
&lt;p&gt;这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。&lt;/p&gt;
&lt;p&gt;一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？&lt;/p&gt;
&lt;p&gt;这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现&lt;/p&gt;
&lt;h4 id=&#34;分布式锁并发优化方案有没有什么不足&#34;&gt;分布式锁并发优化方案有没有什么不足？&lt;/h4&gt;
</description>
        </item>
        <item>
        <title>分布式发号器架构设计</title>
        <link>https://lxb.wiki/3d5a1f1d/</link>
        <pubDate>Fri, 10 May 2019 14:04:04 +0000</pubDate>
        
        <guid>https://lxb.wiki/3d5a1f1d/</guid>
        <description>&lt;h3 id=&#34;一-需求设计&#34;&gt;一 需求设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分布式环境下，保证每个序列号（sequence）是全系统唯一的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;序列号可排序，满足单调递增的规律；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特定场景下，能生成无规则（或者看不出规则）的序列号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成的序列号尽量短；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;序列号可进行二次混淆，提供可扩展的interface，业务方自定义实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二-方案设计&#34;&gt;二 方案设计&lt;/h3&gt;
&lt;p&gt;为了满足上述需求，发号器必须能够支持不同的生成策略，最好是还能支持自定义的生成策略，这就对系统本身的可扩展性提出了要求。 目前，发号器设计了两种比较通用的基础策略，各有优缺点，但结合起来，能达到优势互补的目的。&lt;/p&gt;
&lt;h4 id=&#34;1-segment&#34;&gt;1. segment&lt;/h4&gt;
&lt;p&gt;第一种策略称之为『分段』（segment），下文将对其进行详细阐述： 整个segment发号器有两个重要的角色：Redis和MongoDB，理论上MongoDB是可以被MySQL或其他DB产品所替代的。 segment发号器所产生的号码满足单调递增的规律，短时间内产生的号码不会有过长的问题（可根据实际需要，设置初始值，比如 100）。&lt;/p&gt;
&lt;h5 id=&#34;redis数据结构hash类型&#34;&gt;Redis数据结构（Hash类型）&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;key: &amp;lt;string&amp;gt;，表示业务主键/名称
value: {
  cur: &amp;lt;long&amp;gt;，表示当前序列号
  max: &amp;lt;long&amp;gt;，表示这个号段最大的可用序列号
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取号的大部分操作都集中在Redis，为了保证序列号递增的原子性，取号的功能可以用Lua脚本实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--[[
  由于RedisTemplate设置的HashValueSerializer是GenericToStringSerializer，故此处的HASH结构中的
  VALUE都是string类型，需要使用tonumber函数转换成数字类型。
]]
local max = redis.pcall(&amp;quot;HGET&amp;quot;, KEYS[1], &amp;quot;max&amp;quot;)  --获取一段序列号的max
local cur = redis.pcall(&amp;quot;HGET&amp;quot;, KEYS[1], &amp;quot;cur&amp;quot;)  --获取当前发号位置
if tonumber(cur) &amp;gt;= tonumber(max) then  --没有超过这段序列号的上限
    local step = ARGV[1]
    if (step == nil) then  --没有传入step参数
        step = redis.pcall(&amp;quot;HGET&amp;quot;, KEYS[1], &amp;quot;step&amp;quot;)  --获取这段序列号的step配置参数值
    end
    redis.pcall(&amp;quot;HSET&amp;quot;, KEYS[1], &amp;quot;max&amp;quot;, tonumber(max) + tonumber(step))  --调整max参数值，扩展上限
end
return redis.pcall(&amp;quot;HINCRBY&amp;quot;, KEYS[1], &amp;quot;cur&amp;quot;, 1)  --触发HINCRBY操作，对cur自增，并返回自增后的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;注意：在redis执行lua script期间，redis处于BUSY状态，这个时候对redis的任何形式的访问都会抛出JedisBusyException异常，所以lua script中的处理逻辑不得太复杂。&lt;/p&gt;
&lt;p&gt;值得一提的是，即使切换到一个新的database，或者开启新线程执行lua script，都将会遇到同样的问题，毕竟redis是单进程单线程的。&lt;/p&gt;
&lt;p&gt;如果不幸遇到上述问题，需要使用redis-cli客户端连上redis-server，向其发送SCRIPT KILL命令，即可终止脚本执行。&lt;/p&gt;
&lt;p&gt;如果想避免上述问题，也可以直接使用Springboot提供的RedisTemplate，能支持绝大部分redis command。&lt;/p&gt;
&lt;h5 id=&#34;mongodb-数据结构&#34;&gt;MongoDB 数据结构&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;{
 bizTag: &amp;lt;string&amp;gt;,  表示业务主键/名称
 max: &amp;lt;long&amp;gt;,  表示这个号段最大的可用序列号
 step: &amp;lt;int&amp;gt;, 每次分段的步长
 timestamp: &amp;lt;long&amp;gt;,  更新数据的时间戳（毫秒）
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MongoDB部分主要是对号段的分配进行管理，一个号段不能多发，也可以根据发号情况，适当放缩号段步长（step）。&lt;/p&gt;
&lt;p&gt;到此为止，segment发号器的雏形已经形成了。 一个比较突出的问题是在两个号段衔接的时间点，当一个segment派发完了后，会对MongoDB和Redis中的数据中的max扩容，I/O消耗比正常发号要稍多，会遇到“尖刺”&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210219.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;为了消除“尖刺”，可以使用双Buffer模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210239.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这个模型的核心思想就是“&lt;strong&gt;预分配&lt;/strong&gt;”。可以设置一个阈值（threshold），比如20%，当Buffer-1里面的号段已经消耗了20%，那么立刻根据Buffer-1的max和step，开辟Buffer-2。 当Buffer-1完全消耗了，可以无缝衔接Buffer-2,。&lt;/p&gt;
&lt;p&gt;如果Buffer-2的消耗也达到阈值了，又可以开辟Buffer-1，如此往复。&lt;/p&gt;
&lt;p&gt;接下来，我们来讨论一下&lt;strong&gt;异常/故障&lt;/strong&gt;情况。&lt;/p&gt;
&lt;p&gt;① Redis宕机。因为大部分发号工作都是依靠Redis完成的，所以发生了这种情况是非常糟糕的。如果想有效降低此风险，最行之有效的办法是对Redis进行集群化，通常是1主2从，这样可以挺住非常高的QPS了。 当然也有退而求其次的办法，就是利用上述提到的双Buffer模型。不依赖Redis取号，直接通过程序控制，利用机器内存。所以当需要重启发号服务之前，要确保依赖的组件是运行良好的，不然号段就丢失了。&lt;/p&gt;
&lt;p&gt;② 要不要持久化的问题。这个问题主要是针对Redis，如果没有记录下当前的取号进度，那么随着Redis的宕机，取号现场就变得难以恢复了；如果每次都记录取号进度，那么这种I/O高密度型的作业会对服务性能 造成一定影响，并且随着取号的时间延长，恢复取号现场就变得越来越慢了，甚至到最后是无法忍受的。除了对Redis做高可用之外，引入MongoDB也是出于对Redis持久化功能辅助的考虑。 个人建议：如果Redis已经集群化了，而且还开启了双Buffer的策略，以及MongoDB的加持，可以不用再开启Redis的持久化了。 如果考虑到极端情况下，Redis还是宕机了，我们可以使用MongoDB里面存下来的max，就max+1赋值给cur（避免上个号段取完，正好宕机了）。&lt;/p&gt;
&lt;p&gt;③ MongoDB宕机。这个问题不是很严重，只要将step适当拉长一些（至少取号能支撑20分钟），利用Redis还在正常取号的时间来抢救MongoDB。不过，考虑到实际可能没这么快恢复mongo服务，可以在程序中采取 一些容错措施，比如号段用完了，mongo服务无法到达，直接关闭取号通道，直到MongoDB能正常使用；或者程序给一个默认的step，让MongoDB中的max延长到max+step*n（可能取了N个号段MongoDB才恢复过来）， 这样取号服务也可以继续。依靠程序本身继续服务，那么需要有相关的log，这样才有利于恢复MongoDB中的数据。&lt;/p&gt;
&lt;p&gt;④ 取号服务宕机。这个没什么好说的，只能尽快恢复服务运行了。&lt;/p&gt;
&lt;p&gt;⑤ Redis，MongoDB都宕机了。这种情况已经很极端了，只能利用双Buffer策略，以及程序默认的设置进行工作了，同样要有相关的log，以便恢复Redis和MongoDB。&lt;/p&gt;
&lt;p&gt;⑥ 都宕机了。我有一句mmp不知当讲不当讲……&lt;/p&gt;
&lt;h4 id=&#34;2snowflake&#34;&gt;2、snowflake&lt;/h4&gt;
&lt;p&gt;第二种策略是Twitter出品，算法思想比较巧妙，实现的难度也不大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210341.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;以上示意图描述了一个序列号的二进制组成结构。 第一位不用，恒为0，即表示正整数； 接下来的41位表示时间戳，精确到毫秒。为了节约空间，可以将此时间戳定义为距离某个时间点所经历的毫秒数（Java默认是1970-01-01 00:00:00）； 再后来的10位用来标识工作机器，如果出现了跨IDC的情况，可以将这10位一分为二，一部分用于标识IDC，一部分用于标识服务器； 最后12位是序列号，自增长。&lt;/p&gt;
&lt;p&gt;snowflake的核心思想是64bit的合理分配，但不必要严格按照上图所示的分法。 如果在机器较少的情况下，可以适当缩短机器id的长度，留出来给序列号。&lt;/p&gt;
&lt;p&gt;当然，snowflake的算法将会面临两个挑战：&lt;/p&gt;
&lt;p&gt;① 机器id的指定。这个问题在分布式的环境下会比较突出，通常的解决方案是利用Redis或者Zookeeper进行机器注册，确保注册上去的机器id是唯一的。为了解决 强依赖Redis或者Zookeeper的问题，可以将机器id写入本地文件系统。&lt;/p&gt;
&lt;p&gt;② 机器id的生成规则。这个问题会有一些纠结，因为机器id的生成大致要满足三个条件：a. int类型(10bit)纯数字，b. 相对稳定，c. 与其他机器要有所区别。至于优雅美观，都是其次了。对于机器id的存储，可以使用HASH结构，KEY的规则是“application-name.port.ip”，其中ip是通过算法转换成了一段长整型的纯数字，VALUE则是机器id， 服务id，机房id，其中，可以通过服务id和机房id反推出机器id。&lt;/p&gt;
&lt;p&gt;假设服务id(workerId)占8bit，机房id(rackId)占2bit，从1开始，workerId=00000001，rackId=01，machineId=00000000101 如果用Redis存储，其表现形式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210414.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果存储在文件中（建议properties文件），则文件名是sequence-client:8112:3232235742.properties，文件内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210429.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果发号服务上线，直接按照“application-name.port.ip”的规则取其内容。&lt;/p&gt;
&lt;p&gt;③ 时钟回拨。因为snowflake对系统时间是很依赖的，所以对于时钟的波动是很敏感的，尤其是时钟回拨，很有可能就会出现重复发号的情况。时钟回拨问题解决策略通常是直接拒绝发号，直到时钟正常，必要时进行告警。&lt;/p&gt;
&lt;h3 id=&#34;三-程序设计&#34;&gt;三 程序设计&lt;/h3&gt;
&lt;p&gt;整个发号过程可以分成三个层次：&lt;/p&gt;
&lt;p&gt;1、策略层(strategy layer)：这个层面决定的是发号方法/算法，涵盖了上述所讲的segment和snowflake两种方式，当然，用户也可以自己扩展实现其他发号策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210445.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;最顶上定义Sequence实际上就是发号的结果。bizType是对发号业务场景的定义，比如订单号，用户ID，邀请好友的分享码。 发号策略的init接口是发号前的初始化工作，而generate接口就是调用发号器的主入口了。 当然，考虑到各种异常情况，加入了拒绝发号的处理器（SequenceRejectedHandler），默认实现只是记录日志，用户可根据需求去实现该处理器，然后用set方法设置发号策略的拒绝处理器。&lt;/p&gt;
&lt;p&gt;2、插件层(plugin layer)：此处的插件可以理解是一种拦截器，贯穿SequenceStrategy的发号全周期。引入插件后，无疑是丰富了整个发号的操作过程，用户可以从中干预到发号的整个流程，以便达到其他的目的，比如：记录发号历史，统计发号速率，发号二次混淆等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210511.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以看出，插件被设计成『注册式』的，发号策略只有注册了相关插件之后，插件才能生效， 当然，一个插件能被多个发号策略所注册，一个发号策略也能同时注册多个插件，所以两者是多对多的关系，PluginManager的出现就是解决插件的注册管理问题。 从SequencePlugin的定义中可以发现，插件是有优先级（Order）的，通过getOrder()可以获得，在这套发号系统里，Order值越小，表示该插件越优先执行。此外，插件有三个重要的操作： before，表示发号之前的处理。若返回了false，那么该插件后面的操作都失效了，否则继续执行发号流程。 after，表示发号之后的处理。 doException，表示插件发生异常的处理方法。&lt;/p&gt;
&lt;p&gt;3、持久层(persistence layer)：这个层面指代的是上述所提的MongoDB部分，如果不需要持久化的支持，可以不实现此接口，那么整个发号器就变成纯内存管理的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210529.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;PersistRepository定义了基本的CRUD方法，其中persistId可以理解成上述提到的BizType。 一切的持久化对象都是从PersistModel开始的，上图中的Segment、PersistDocument都是为了实现分段发号器而定义的。&lt;/p&gt;
&lt;h3 id=&#34;四-总结&#34;&gt;四 总结&lt;/h3&gt;
&lt;p&gt;这篇文章详细阐述了分布式发号器系统的设计，旨在能做出一个可扩展，易维护的发号系统。业界比较知名的发号算法似乎也不多，整个发号系统不一定就按照笔者所做的设计，还是要立足于具体的业务需求。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>架构设计原则</title>
        <link>https://lxb.wiki/88049151/</link>
        <pubDate>Fri, 01 Mar 2019 22:52:22 +0000</pubDate>
        
        <guid>https://lxb.wiki/88049151/</guid>
        <description>&lt;h4 id=&#34;grasp-通用职责分配软件模式&#34;&gt;GRASP 通用职责分配软件模式&lt;/h4&gt;
&lt;p&gt;来自 Craig Larman 的软件设计书《UML 和模式应用》[附录 1]，Larman 在书中提出软件设计的关键任务是职责分配，并提炼总结出 9 种 (5 种核心 +4 种扩展) 软件职责分配模式，这些模式是比 GoF 设计模式更抽象的元模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 信息专家 (Information Expert)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为对象分配职责的通用原则 – 把职责分配给拥有足够信息可以履行职责的专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 创建者 (Creator)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将创建 A 的职责赋给 B，如果至少下面一种情况为真：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B“包含”或者聚合 A&lt;/li&gt;
&lt;li&gt;B 记录 A 的实例&lt;/li&gt;
&lt;li&gt;B 密切地使用 A&lt;/li&gt;
&lt;li&gt;B 拥有 A 的初始化数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 低耦合 (Low Coupling)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;赋予职责使得对象间的耦合度尽可能低，最小化对象间的依赖和变更影响，最大化重用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 高内聚 (High Cohesion)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;赋予职责使得每个对象的职责尽可能保持聚焦和单一，易于管理和理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 控制器 (Controller)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把职责赋予系统、设备或者子系统的表示类 (门面控制器)，或者某个用例的表示类 (用例控制器)，让控制器接收事件并协调整个系统的运作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 多态 (Polymorphism)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将职责分配给多个具有同名方法的多态子类，运行时根据需要动态切换子类，让系统行为变得可插拔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 纯虚构 (Pure Fabrication)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对真实问题域中不存在，但是设计建模中有用的概念，设计虚构类并赋予职责。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 间接 (Indirection)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在两个或者多个对象间有交互的情况下，为避免直接耦合，提高重用性，创建中间类并赋予职责，对象的交互交由中间类协调。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 受保护的变化 (Protected Variation)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单讲就是封装变化。识别系统中可能的不稳定或者变化，在不稳定组件上创建稳定的抽象接口，将可能的变化封装在接口之后，使得系统内部的不稳定或者变化不会对系统的其它部分产生不良影响。&lt;/p&gt;
&lt;h4 id=&#34;solid-面向对象设计原则&#34;&gt;SOLID 面向对象设计原则&lt;/h4&gt;
&lt;p&gt;S.O.L.I.D 是面向对象设计和编程 (OOD&amp;amp;OOP) 中几个重要原则的首字母缩写，受 Robert Martin 推崇。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 单一职责原则 (The Single Responsibility Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改某个类的理由应该只有一个，如果超过一个，说明类承担不止一个职责，要视情况拆分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 开放封闭原则 (The Open Closed Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件实体应该对扩展开放，对修改封闭。一般不要直接修改类库源码（即使你有源代码），通过继承等方式扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 里氏替代原则 (The Liskov Substitution Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个子类的实例能够被替换成任何超类的实例时，它们之间才是真正的 is-a 关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 依赖倒置原则 (The Dependency Inversion Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高层模块不应该依赖于底层模块，二者都应该依赖于抽象。换句话说，依赖于抽象，不要依赖于具体实现。比方说，你不会把电器电源线焊死在室内电源接口处，而是用标准的插头插在标准的插座 (抽象) 上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 接口分离原则 (The Interface Segregation Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要强迫用户去依赖它们不使用的接口。换句话说，使用多个专门的接口比使用单一的大而全接口要好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高内聚 + 低耦合，就像道中的一阴一阳，是所有其它 OO 设计原则的原则 (元原则)，其它设计原则都是在这两个基础上泛化衍生出来的。&lt;/li&gt;
&lt;li&gt;上述原则虽然是针对 OO 设计和编程提出，但是对于大规模系统架构仍然适用。比如，微服务架构就体现了：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;单一职责：一个微服务尽可能要职责单一，提供的接口也尽可能单一 (接口分离原则)，安全 / 路由 / 限流等跨横切面的关注点 (Cross-Cutting Concerns) 由独立网关负责，体现关注分离 (Separation of Concerns)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;信息专家：当不确定哪个团队应该负责某个微服务时，一般原则也是谁拥有数据谁负责，基于有界上下文 Bounded Context（一般是边界比较清晰的领域数据源）构建微服务。&lt;/li&gt;
&lt;li&gt;松散耦合：服务之间通过 HTTP/JSON 等轻量机制通信，服务之间不强耦合。&lt;/li&gt;
&lt;li&gt;受保护的变化和依赖倒置：服务之间只依赖抽象接口，实现可能随时变化。&lt;/li&gt;
&lt;li&gt;间接：网关在外面的客户端和内部的服务之间增加了一层间接，使两者不强耦合，可以相互独立演化。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;作为架构师或者设计师，有两个设计能力是需要重点培养的，也是最难和最能体现架构设计水平的：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;合理的职责分配能力，也就是每个类 / 组件 / 子系统应该承担什么职责，如何保证职责单一，它们之间如何协作；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;系统抽象和核心领域建模能力，需要深入一线业务域。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式系统架构设计原则和理论&#34;&gt;分布式系统架构设计原则和理论&lt;/h3&gt;
&lt;h4 id=&#34;akf-架构原则&#34;&gt;AKF 架构原则&lt;/h4&gt;
&lt;p&gt;这 15 个架构原则来自《架构即未来 (The Art of Scalability)》[附录 2] 一书，作者马丁 L. 阿伯特和迈克尔 T. 费舍尔分别是 eBay 和 PayPal 的前 CTO，他们经历过 eBay 和 PayPal 大规模分布式电商平台的架构演进，在一线实战经验的基础上总结并提炼出 15 条架构原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.N + 1 设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;永远不要少于两个，通常为三个。比方说无状态的 Web/API 一般部署至少&amp;gt;=2 个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 回滚设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保系统可以回滚到以前发布过的任何版本。可以通过发布系统保留历史版本，或者代码中引入动态开关切换机制 (Feature Switch)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 禁用设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能够关闭任何发布的功能。新功能隐藏在动态开关机制 (Feature Switch) 后面，可以按需一键打开，如发现问题随时关闭禁用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 监控设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在设计阶段就必须考虑监控，而不是在实施完毕之后补充。例如在需求阶段就要考虑关键指标监控项，这就是度量驱动开发 (Metrics Driven Development) 的理念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 设计多活数据中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要被一个数据中心的解决方案把自己限制住。当然也要考虑成本和公司规模发展阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 使用成熟的技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只用确实好用的技术。商业组织毕竟不是研究机构，技术要落地实用，成熟的技术一般坑都被踩平了，新技术在完全成熟前一般需要踩坑躺坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 异步设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能异步尽量用异步，只有当绝对必要或者无法异步时，才使用同步调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 无状态系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽可能无状态，只有当业务确实需要，才使用状态。无状态系统易于扩展，有状态系统不易扩展且状态复杂时更易出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 水平扩展而非垂直升级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;永远不要依赖更大、更快的系统。一般公司成长到一定阶段普遍经历过买更大、更快系统的阶段，即使淘宝当年也买小型机扛流量，后来扛不住才体会这样做不 scalable，所以才有后来的去 IOE 行动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 设计时至少要有两步前瞻性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在扩展性问题发生前考虑好下一步的行动计划。架构师的价值就体现在这里，架构设计对于流量的增长要有提前量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. 非核心则购买&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不是你最擅长，也提供不了差异化的竞争优势则直接购买。避免 Not Invented Here 症状，避免凡事都要重造轮子，毕竟达成业务目标才是重点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. 使用商品化硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在大多数情况下，便宜的就是最好的。这点和第 9 点是一致的，通过商品化硬件水平扩展，而不是买更大、更快的系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13. 小构建、小发布和快试错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全部研发要小构建，不断迭代，让系统不断成长。这个和微服务理念一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14. 隔离故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现故障隔离设计，通过断路保护避免故障传播和交叉影响。通过舱壁泳道等机制隔离失败单元 (Failure Unit)，一个单元的失败不至影响其它单元的正常工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15. 自动化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计和构建自动化的过程。如果机器可以做，就不要依赖于人。自动化是 DevOps 的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这 15 条架构原则基本上是 eBay 在发展，经历过流量数量级增长冲击过程中，通过不断踩坑踩出来的，是干货中的干货。消化吸收这 15 条原则，基本可保系统架构不会有原则性问题。&lt;/li&gt;
&lt;li&gt;这 15 条原则同样适用于现在的微服务架构。eBay 发展较早，它内部其实很早 (差不多 2010 年前) 就已形成完善的微服务生态，只是没有提出微服务这个概念。&lt;/li&gt;
&lt;li&gt;这 15 条原则可根据 TTM(Time To Market)，可用性 / 可扩展性 / 质量，成本 / 效率分布在三个环内，如下图所示。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;12-要素应用&#34;&gt;12 要素应用&lt;/h4&gt;
&lt;p&gt;基于上百万应用的托管和运营经验，创始人 Adam Wiggins 提出了 12 要素应用宣言 。简单讲，满足这 12 个要素的应用是比较容易云化并居住在 Heroku 平台上的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 基准代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一份基准代码，多份部署。如果用镜像部署方式，则一个镜像可以部署到多个环境 (测试，预发，生产)，而不是给每个环境制作一个不同镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显式声明依赖。如果用镜像部署，则一般依赖被直接打在镜像中，或者声明在 docker file 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在环境中存储配置。在 Heroku 或者类似的 PaaS 平台上，配置一般是推荐注入到环境变量中的。现在采用集中式配置中心也是一种流行方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 后端服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把后端服务 (例如缓存，数据库，MQ 等) 当作附加资源，相关配置和连接字符串通过环境变量注入，或者采用配置中心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 构建、发布和运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;严格分离构建和运行。如果使用镜像部署，则构建、发布 / 运行是通过镜像这种中间格式严格分离的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个或者多个无状态的进程运行应用。容器运行时相当于进程，适用于无状态 Web/API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 端口绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过端口绑定提供服务。容器也是通过端口绑定对外提供服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过进程模型进行扩展。容器运行时相当于进程，通过起多个容器可以任意扩展并发数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 易处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快速启动和优雅终止可最大化健壮性。docker 容器支持秒级启动和关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 开发环境和线上环境等价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽可能保持开发、测试、预发和线上环境相同。容器可以保证容器内运行时环境的一致性，还需要保证不同环境的一致性，例如不同环境内的操作系统，负载均衡，服务发现，后台服务，监控告警等要尽可能一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. 日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把日志当作数据流。Heroku 不支持本地文件，所以必须以流方式把日志输送到后台日志服务。除了日志以外还要补充考虑 metrics 流的采集和输送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. 管理进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台管理任务当作一次性的进程。其实相当于在 Heroku 上以独立进程方式运行任务 Job。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;12 要素应用也是当前云原生应用 (Cloud Native App) 的参考标准，也称为云应用迁移原则。满足这 12 个要素的应用，可以比较顺利迁移到各种云平台 (Kubernetes, Marathon, Cloud Foundry 等) 上。&lt;/li&gt;
&lt;li&gt;对于面临企业遗留应用改造和云化迁移的架构师，可以重点参考这 12 条迁移原则。&lt;/li&gt;
&lt;li&gt;Docker 容器技术可以认为是为云迁移量身定制的技术。容器化是后续云迁移的捷径，所以遗留应用改造可以先想办法做到容器化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;cap-定理&#34;&gt;CAP 定理&lt;/h4&gt;
&lt;p&gt;2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。&lt;/p&gt;
&lt;p&gt;CAP 认为：一个分布式系统最多同时满足一致性 (Consistency)，可用性 (Availability) 和分区容忍性 (Partition Tolerance) 这三项中的两项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.一致性 (Consistency)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一致性指“all nodes see the same data at the same time”，即更新操作成功，所有节点在同一时间的数据完全一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.可用性 (Availability)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可用性指“Reads and writes always succeed”，即服务一直可用，而且响应时间正常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.分区容忍性 (Partition tolerance)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分区容忍性指“the system continue to operate despite arbitrary message loss or failure of part of the system.”，即分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。&lt;/p&gt;
&lt;h4 id=&#34;base-理论&#34;&gt;BASE 理论&lt;/h4&gt;
&lt;p&gt;eBay 架构师 Dan Pritchett 基于对大规模分布式系统的实践总结，在 ACM 上发表文章提出了 BASE 理论，BASE 理论是对于 CAP 理论的延伸，核心思想是即使无法做到强一致性 (Strong Consistency，CAP 中的一致性指强一致性)，但是可以采用适当的方式达到最终一致性 (Eventual Consistency)。&lt;/p&gt;
&lt;p&gt;BASE 指基本可用 (Basically Available)、软状态 (Soft State) 和最终一致性 (Eventual Consistency)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.基本可用 (Basically Available)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本可用是指分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。比如服务降级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.软状态 (Soft State)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软状态是指允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。分布式存储中一般一份数据至少存三个副本，允许不同节点间副本同步的延迟就是软状态的体现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.最终一致性 (Eventual Consistency)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终一致性是指系统中的所有数据副本经过一段时间后，最终能够达成一致状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CAP 和 BASE 理论可以抠得很深，背后甚至有很复杂的数学证明。我理解得相对简单浅显：性能、高可用、不丢数据和数据一致性对分布式系统来说一般是强需求，随着流量的增长，复制和分区在所难免：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;复制 (replication)：数据在多个节点上存多份保证不丢和高可用；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;分区 (partition)：数据按某个纬度切分分布在不同节点上分摊流量压力保证高性能，同时也是为了降低每个节点的复杂性。例如数据库的分库分表，系统拆分微服务化也是一种分区。这两者都会带来一致性问题，一致性在时间上有一点妥协的余地 - 即是最终一致性；时间上要求强一致的话，只有可用性可以适当折中。系统架构的游戏很大部分是和状态一致性作斗争的游戏。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;选择使用分布式产品时，比如 NoSQL 数据库，你需要了解它在 CAP 环中所在的位置，确保它满足你的场景需要。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;组织和系统改进原则&#34;&gt;组织和系统改进原则&lt;/h3&gt;
&lt;h4 id=&#34;康威法则&#34;&gt;康威法则&lt;/h4&gt;
&lt;p&gt;Melvin Conway 在 1967 年提出所谓康威法则 ，指出组织架构和系统架构之间有一种隐含的映射关系：&lt;/p&gt;
&lt;p&gt;Organization which design system […] are constrained to produce designs which are copies of the communication structures of these organization. 设计系统的组织其产生的设计等价于组织间的沟通结构。&lt;/p&gt;
&lt;p&gt;康威法则也可以倒过来阐述：&lt;/p&gt;
&lt;p&gt;Conway’s law reversed：You won’t be able to successfully establish an efficient organization structure that is not supported by your system design(architecture)。 如果系统架构不支持，你无法建立一个高效的组织；同样，如果你的组织架构不支持，你也无法建立一个高效的系统架构。&lt;/p&gt;
&lt;h4 id=&#34;系统改进三原则&#34;&gt;系统改进三原则&lt;/h4&gt;
&lt;p&gt;IT 运维管理畅销书《凤凰项目》[附录 8] 的作者 Gene Kim 在调研了众多高效能 IT 组织后总结出支撑 DevOps 运作的三个原理 (The Three Ways: The Principles Underpinning DevOps)[附录 9]，我认为也是系统改进提升的一般性原理 [附录 7]，见下图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理一：系统思考 (System Thinking)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发驱动的组织，其能力不是制作软件，而是持续的交付客户价值。价值从业务需求开始，经过研发测试，到部署运维，依次流动，并最终以服务形式交付到客户手中。整个价值链流速并不依赖单个部分 (团队或个人) 的杰出工作，而是受整个价值链最薄弱环节 (瓶颈) 的限制。所以局部优化通常无效，反而招致全局受损。&lt;/p&gt;
&lt;p&gt;Gene Kim 特别指出：Any improvements made anywhere besides the bottleneck are an illusion. 在瓶颈之外的任何优化提升都只是幻象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理二：强化反馈环 (Amplify Feedback Loops)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过程改进常常通过加强反馈环来达成。原理二强调企业和客户之间、组织团队间、流程上和系统内的反馈环。没有测量就没有提升，反馈要以测量数据为准，通过反馈数据优化改进系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理三：持续试验和学习的文化 (Culture of Continual Experimentation And Learning)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在企业管理文化层面强调勇于试错和持续试验、学习和改进的文化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;康威法则给我们的启示：系统架构和组织架构之间有隐含的映射关系，你不能单方面改变一方的结构，调整时必须两边联动。系统架构如果是耦合的，就很难组织分散式的团队结构，两边映射不起来，团队之间容易摩擦导致生产率下降。所以一般先按业务边界对单块应用进行解耦拆分，同时做相应的团队拆分，使两边可以映射，每个团队可以独立开发、测试和部署各自的微服务，进而提升生产率。这就是近年流行的微服务架构背后的组织原则。详见我之前发表的文章《企业的组织架构是如何影响技术架构的》[附录 6]。&lt;/li&gt;
&lt;li&gt;系统思考要求我们加强团队合作，培养流式思维和瓶颈约束思维，找出瓶颈并针对性地优化。在研发型组织中，常见的系统瓶颈如运维机器资源提供 (Provisioning) 缓慢，发布流程繁琐容易出错，开发 / 测试／UAT 环境缺失或不完善，遗留系统耦合历史负担重，基础研发平台薄弱等等。这些瓶颈点特别需要关注优化。&lt;/li&gt;
&lt;li&gt;反馈原理要求我们关注基于数据的反馈，技术上的手段包括大数据分析和系统各个层次的测量监控。没有测量就没有反馈，没有反馈就没有提升。&lt;/li&gt;
&lt;li&gt;在管理文化层面：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;管理层要承认企业内部近 50% 的创新或流程改进项目是有可能失败的，即使失败，员工不会受到责罚，鼓励持续的试验和从中学习；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;管理层要有技术偿债意识，勿追求 100% 员工利用率，要预留 20%~30% 的时间给员工做创新和系统改进提升项目&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>秒杀系统优化思路</title>
        <link>https://lxb.wiki/bcca3074/</link>
        <pubDate>Tue, 26 Feb 2019 22:13:12 +0000</pubDate>
        
        <guid>https://lxb.wiki/bcca3074/</guid>
        <description>&lt;h3 id=&#34;一秒杀业务为什么难做&#34;&gt;一、秒杀业务为什么难做&lt;/h3&gt;
&lt;p&gt;1）im系统，例如qq或者微博，每个人都读自己的数据（好友列表、群列表、个人信息）； 2）微博系统，每个人读你关注的人的数据，一个人读多个人的数据； 3）秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据。&lt;/p&gt;
&lt;p&gt;例如：小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。 又例如：12306抢票，票是有限的，库存一份，瞬时流量非常多，都读相同的库存。读写冲突，锁非常严重，这是秒杀业务难的地方。那我们怎么优化秒杀业务的架构呢？&lt;/p&gt;
&lt;h3 id=&#34;二优化方向&#34;&gt;二、优化方向&lt;/h3&gt;
&lt;p&gt;优化方向有两个（今天就讲这两个点）： （1）将请求尽量拦截在系统上游（不要让锁冲突落到数据库上去）。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小。以12306为例，一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0。&lt;/p&gt;
&lt;p&gt;（2）充分利用缓存，秒杀买票，这是一个典型的读多写少的应用场景，大部分请求是车次查询，票查询，下单和支付才是写请求。一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。好，后续讲讲怎么个“将请求尽量拦截在系统上游”法，以及怎么个“缓存”法，讲讲细节。&lt;/p&gt;
&lt;h3 id=&#34;三常见秒杀架构&#34;&gt;三、常见秒杀架构&lt;/h3&gt;
&lt;p&gt;（1）浏览器端，最上层，会执行到一些JS代码 （2）站点层，这一层会访问后端数据，拼html页面返回给浏览器 （3）服务层，向上游屏蔽底层数据细节，提供数据访问 （4）数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）&lt;/p&gt;
&lt;h3 id=&#34;四各层次优化细节&#34;&gt;四、各层次优化细节&lt;/h3&gt;
&lt;h4 id=&#34;第一层客户端怎么优化浏览器层app层&#34;&gt;第一层，客户端怎么优化（浏览器层，APP层）&lt;/h4&gt;
&lt;p&gt;微信的摇一摇抢红包，每次摇一摇，就会往后端发送请求么？下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？&lt;/p&gt;
&lt;p&gt;（a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求； （b）JS层面，限制用户在x秒之内只能提交一次请求；&lt;/p&gt;
&lt;p&gt;APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？&lt;/p&gt;
&lt;h4 id=&#34;第二层站点层面的请求拦截&#34;&gt;第二层，站点层面的请求拦截&lt;/h4&gt;
&lt;p&gt;怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。&lt;/p&gt;
&lt;p&gt;5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。&lt;/p&gt;
&lt;p&gt;页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。&lt;/p&gt;
&lt;p&gt;好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。&lt;/p&gt;
&lt;h4 id=&#34;第三层-服务层来拦截反正就是不要让请求落到数据库上去&#34;&gt;第三层 服务层来拦截（反正就是不要让请求落到数据库上去）&lt;/h4&gt;
&lt;p&gt;服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！&lt;/p&gt;
&lt;p&gt;对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）&lt;/p&gt;
&lt;p&gt;1w部手机，只透1w个下单请求去db&lt;/p&gt;
&lt;p&gt;3k张火车票，只透3k个下单请求去db&lt;/p&gt;
&lt;p&gt;如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。&lt;/p&gt;
&lt;p&gt;对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。&lt;/p&gt;
&lt;p&gt;当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，&amp;hellip;每隔半个小时放出一批：将流量摊匀。&lt;/p&gt;
&lt;p&gt;其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。&lt;/p&gt;
&lt;p&gt;第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。&lt;/p&gt;
&lt;h4 id=&#34;第四层-最后是数据库层&#34;&gt;第四层 最后是数据库层&lt;/h4&gt;
&lt;p&gt;浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。&lt;/p&gt;
&lt;p&gt;全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。&lt;/p&gt;
&lt;h3 id=&#34;五总结&#34;&gt;五、总结&lt;/h3&gt;
&lt;p&gt;上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路： （1）尽量将请求拦截在系统上游（越上游越好）； （2）读多写少的常用多使用缓存（缓存抗读压力）；&lt;/p&gt;
&lt;p&gt;浏览器和APP：做限速&lt;/p&gt;
&lt;p&gt;站点层：按照uid做限速，做页面缓存&lt;/p&gt;
&lt;p&gt;服务层：按照业务做写请求队列控制流量，做数据缓存&lt;/p&gt;
&lt;p&gt;数据层：闲庭信步&lt;/p&gt;
&lt;p&gt;并且：结合业务做优化&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
