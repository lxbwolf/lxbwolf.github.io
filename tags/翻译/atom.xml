<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>翻译 on Xiaobin&#39;s Blog</title>
        <link>https://lxb.wiki/tags/%E7%BF%BB%E8%AF%91/</link>
        <description>Recent content in 翻译 on Xiaobin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 01 Apr 2023 23:09:26 +0000</lastBuildDate><atom:link href="https://lxb.wiki/tags/%E7%BF%BB%E8%AF%91/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>【译】用 Tekton 在 Kubernetes 中编写你的第一条 CI/CD 流水线</title>
        <link>https://lxb.wiki/2966fc1/</link>
        <pubDate>Sat, 01 Apr 2023 23:09:26 +0000</pubDate>
        
        <guid>https://lxb.wiki/2966fc1/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Tekton 是一个用于创建持续集成和持续交付（CI/CD）系统的 Kubernetes 原生开源框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.linux.net.cn/data/attachment/album/202304/01/180822blxgx0c1k43n4kl4.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Tekton 是一个用于创建持续集成和持续交付（CI/CD）系统的 Kubernetes 原生开源框架。通过对底层实施细节的抽象，它还可以帮助你在多个云供应商或企业内部系统中进行端到端（构建、测试、部署）应用开发。&lt;/p&gt;
&lt;h3 id=&#34;tekton-介绍&#34;&gt;Tekton 介绍&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tektoncd/pipeline&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tekton&lt;/a&gt; 最初被称为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/knative/build&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Knative Build&lt;/a&gt;，后来被重组为独立的开源项目，有自己的 &lt;a class=&#34;link&#34; href=&#34;https://cd.foundation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;治理组织&lt;/a&gt;，现在是属于 &lt;a class=&#34;link&#34; href=&#34;https://www.linuxfoundation.org/projects/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 基金会&lt;/a&gt; 的项目。Tekton 提供了一个集群内的容器镜像构建和部署工作流程，换句话说，它是一个 &lt;!-- raw HTML omitted --&gt;持续集成&lt;!-- raw HTML omitted --&gt;continuous integration&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CI）和 &lt;!-- raw HTML omitted --&gt;持续交付&lt;!-- raw HTML omitted --&gt;continuous delivery&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CD）服务。它由 Tekton 流水线和几个支持组件如 Tekton CLI、Triggers 和 Catalog 等组成。&lt;/p&gt;
&lt;p&gt;Tekton 是一个 Kubernetes 原生应用。它在 Kubernetes 集群中作为扩展被安装和运行，由一套Kubernetes 定制化资源组成，定义了你为流水线创建和复用的构建块。由于 Tekton 是一种 Kubernetes 原生技术，所以它非常容易扩展。当你需要增加你的工作负载时，你只需向你的集群添加节点就可以了。由于其可扩展的设计和社区贡献的组件库，它也很容易定制。&lt;/p&gt;
&lt;p&gt;对于需要 CI/CD 系统来开展工作的开发人员，和为其组织内的开发人员建立 CI/CD 系统的平台工程师，Tekton 是理想选择。&lt;/p&gt;
&lt;h3 id=&#34;tekton组件&#34;&gt;Tekton 组件&lt;/h3&gt;
&lt;p&gt;构建 CI/CD 流水线的过程非常复杂，因此 Tekton 为每一步都提供工具。以下是 Tekton 提供的主要组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;流水线&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;Pipeline&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;： 定义了一组 Kubernetes &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自定义资源&lt;/a&gt;，作为你用来组装 CI/CD 流水线的构建块。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;触发器&lt;!-- raw HTML omitted --&gt;Triggers&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：一种 Kubernetes 自定义资源，允许你根据从事件有效载荷中提取的信息来创建流水线。例如，你可以在每次创建 Git 仓库的合并请求时，触发流水线的实例化和执行。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;命令行&lt;!-- raw HTML omitted --&gt;CLI&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：提供一个名为 &lt;code&gt;tkn&lt;/code&gt; 的命令行界面，你可以使用它从终端与 Tekton 进行交互。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;仪表盘&lt;!-- raw HTML omitted --&gt;Dashboard&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是 Tekton 流水线的一个基于网页的图形界面，显示流水线的执行信息。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;目录&lt;!-- raw HTML omitted --&gt;Catalog&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个高质量的、由社区贡献的 Tekton 构建块（任务、流水线等），可在你自己的流水线中使用。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;中心&lt;!-- raw HTML omitted --&gt;Hub&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个基于网页的图形界面，用于访问 Tekton 目录。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;操作员&lt;!-- raw HTML omitted --&gt;Operator&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一种 Kubernetes &lt;a class=&#34;link&#34; href=&#34;https://operatorhub.io/what-is-an-operator&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;操作员模式&lt;/a&gt;，你可以在 Kubernetes 集群中安装、更新、升级和删除 Tekton 项目。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;链&lt;!-- raw HTML omitted --&gt;Chains&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个 Kubernetes &lt;!-- raw HTML omitted --&gt;自定义资源定义&lt;!-- raw HTML omitted --&gt;Custom Resource Definition&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CRD）控制器，使你可以在 Tekton 中处理供应链安全的问题。正在开发中。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;结果&lt;!-- raw HTML omitted --&gt;Results&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：旨在帮助用户对 CI/CD 工作负载历史进行逻辑分组，并将长期结果的存储从流水线控制器中分离出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tekton-术语&#34;&gt;Tekton 术语&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://opensource.com/sites/default/files/uploads/tekto-terminology.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Tekton terminology&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;步骤&lt;!-- raw HTML omitted --&gt;Step&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是 CI/CD 工作流程中最基本的实体，例如为 Python 网络应用程序运行一些单元测试或编译一个 Java 程序。Tekton 使用容器镜像执行每个步骤。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;任务&lt;!-- raw HTML omitted --&gt;Task&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：:** 是按特定顺序排列的步骤的集合。Tekton 以 &lt;a class=&#34;link&#34; href=&#34;https://kubebyexample.com/en/concept/pods&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kubernetes 容器荚&lt;/a&gt; 的形式运行任务，其中每个步骤都成为 &lt;!-- raw HTML omitted --&gt;容器荚&lt;!-- raw HTML omitted --&gt;pod&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 中的一个运行容器。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;流水线&lt;!-- raw HTML omitted --&gt;Pipelines&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是按特定顺序排列的任务的集合。Tekton 把所有任务连接成一个 &lt;!-- raw HTML omitted --&gt;有向无环图&lt;!-- raw HTML omitted --&gt;directed acyclic graph&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（DAG），并按顺序执行图。换句话说，它创建了一些 Kubernetes 容器荚，并确保每个容器荚按预期成功运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://opensource.com/sites/default/files/uploads/tekton-pipelines.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Tekton pipelines&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;流水线运行&lt;!-- raw HTML omitted --&gt;PipelineRun&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：顾名思义，是一条流水线的具体执行。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;任务运行&lt;!-- raw HTML omitted --&gt;TaskRun&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：是一个任务的具体执行。你可以选择在流水线外运行一次任务运行，可以通过它查看任务中每个步骤执行的具体情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建你的-cicd-流水线&#34;&gt;创建你的 CI/CD 流水线&lt;/h3&gt;
&lt;p&gt;开始使用 Tekton 的最简单方法是自己编写一个简单的流水线。如果你每天都在使用 Kubernetes，那你可能对 YAML 很熟悉，这正是 Tekton 流水线的定义方式。下面是一个克隆代码库的简单流水线的例子。&lt;/p&gt;
&lt;p&gt;首先，创建一个 &lt;code&gt;task.yaml&lt;/code&gt; 文件，用你喜欢的文本编辑器打开它。这个文件定义了你要执行的 &lt;!-- raw HTML omitted --&gt;步骤&lt;!-- raw HTML omitted --&gt;Step&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。在这个例子中，就是克隆一个仓库，所以我把这个步骤命名为 “clone”。该文件设置了一些环境变量，然后使用一个简单的 shell 脚本来执行克隆。&lt;/p&gt;
&lt;p&gt;接下来是 &lt;!-- raw HTML omitted --&gt;任务&lt;!-- raw HTML omitted --&gt;Task&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。你可以把步骤看作是一个被任务调用的函数，而任务则设置步骤所需的参数和工作空间。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
 name: git-clone
spec:
 workspaces:
   - name: output
     description: The git repo will be cloned onto the volume backing this Workspace.
 params:
   - name: url
     description: Repository URL to clone from.
     type: string
   - name: revision
     description: Revision to checkout. (branch, tag, sha, ref, etc...)
     type: string
     default: &amp;#34;&amp;#34;
 steps:
   - name: clone
     image: &amp;#34;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0&amp;#34;
     env:
       - name: PARAM_URL
         value: $(params.url)
       - name: PARAM_REVISION
         value: $(params.revision)
       - name: WORKSPACE_OUTPUT_PATH
         value: $(workspaces.output.path)
     script: |
      #!/usr/bin/env sh
       set -eu

       CHECKOUT_DIR=&amp;#34;${WORKSPACE_OUTPUT_PATH}&amp;#34;

       /ko-app/git-init \
         -url=&amp;#34;${PARAM_URL}&amp;#34; \
         -revision=&amp;#34;${PARAM_REVISION}&amp;#34; \
         -path=&amp;#34;${CHECKOUT_DIR}&amp;#34;
       cd &amp;#34;${CHECKOUT_DIR}&amp;#34;
       EXIT_CODE=&amp;#34;$?&amp;#34;
       if [ &amp;#34;${EXIT_CODE}&amp;#34; != 0 ] ; then
         exit &amp;#34;${EXIT_CODE}&amp;#34;
       fi
       # Verify clone is success by reading readme file.
       cat ${CHECKOUT_DIR}/README.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建第二个文件 &lt;code&gt;pipeline.yaml&lt;/code&gt;，并用你喜欢的文本编辑器打开它。这个文件通过设置诸如可以运行和处理任务的工作区等重要参数来定义流水线。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
 name: cat-branch-readme
spec:
 params:
   - name: repo-url
     type: string
     description: The git repository URL to clone from.
   - name: branch-name
     type: string
     description: The git branch to clone.
 workspaces:
   - name: shared-data
     description: |
      This workspace will receive the cloned git repo and be passed
       to the next Task for the repo&amp;#39;s README.md file to be read.
 tasks:
   - name: fetch-repo
     taskRef:
       name: git-clone
     workspaces:
       - name: output
         workspace: shared-data
     params:
       - name: url
         value: $(params.repo-url)
       - name: revision
         value: $(params.branch-name)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，创建一个 &lt;code&gt;pipelinerun.yaml&lt;/code&gt; 文件，用喜欢的文本编辑器打开它。这个文件真正的运行流水线。它调用流水线中定义的参数（继而调用任务文件中定义的任务）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
 name: git-clone-checking-out-a-branch
spec:
 pipelineRef:
   name: cat-branch-readme
 workspaces:
   - name: shared-data
     volumeClaimTemplate:
       spec:
         accessModes:
          - ReadWriteOnce
         resources:
           requests:
             storage: 1Gi
 params:
   - name: repo-url
     value: &amp;lt;https://github.com/tektoncd/pipeline.git&amp;gt;
   - name: branch-name
     value: release-v0.12.x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把不同工作分在不同的文件中的好处是，&lt;code&gt;git-clone&lt;/code&gt; 任务可以在多条流水线中复用。&lt;/p&gt;
&lt;p&gt;例如，假设你想为一个流水线项目做端到端的测试。你可以使用 &lt;code&gt;git-clone&lt;/code&gt; 任务 &lt;strong&gt;来让每一次测试都基于最新的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;只要你熟悉 Kubernetes，那 Tekton 对你来说就像其他 Kubernetes 原生应用一样简单。它有很多工具可以帮助你创建流水线并与之交互。如果你喜欢自动化，不妨试试 Tekton!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/21/11/cicd-pipeline-kubernetes-tekton&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/21/11/cicd-pipeline-kubernetes-tekton&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/savita-ashture&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Savita Ashture&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】构建高效的 DevOps 文化的 6 个技巧</title>
        <link>https://lxb.wiki/12428ad2/</link>
        <pubDate>Mon, 30 Jan 2023 21:58:33 +0000</pubDate>
        
        <guid>https://lxb.wiki/12428ad2/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;无论你是刚刚开始在你的组织中使用 DevOps，还是仅仅想改善你现有的文化，请考虑这些技巧以及它们与你组织的未来的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你为什么要构建 &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/resources/devops&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DevOps&lt;/a&gt; 文化？开发团队和运维团队的精简协作有很多好处。效率是首要目标：提高新软件部署的速度，减少等待的时间。培养同事之间的信任可以提升员工的满意度，激发新的创新，并对盈利能力产生积极的影响。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/2/devops-documentation-maturity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DevOps&lt;/a&gt; 是一个很广泛的思想，大家的理解也见仁见智。每个公司对于如何实行 DevOps 也各不相同。这种意见的多样性实际上是一件好事 —— 这么多的观点对于建立更强大的团队是很有用的。本指南将探讨在 DevOps 文化中鼓励同事之间更好地合作的最高技巧。&lt;/p&gt;
&lt;p&gt;下面每个部分从不同的视角介绍 DevOps 文化，并探讨了将它引入员工队伍的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230126220527.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;流程的持续发展&#34;&gt;流程的持续发展&lt;/h3&gt;
&lt;p&gt;DevOps 文化的这一核心原则使它与许多其他类型的工作场所的风气区别开来。DevOps 哲学说，犯错是有积极意义的，因为这表明你在尝试新的想法。&lt;/p&gt;
&lt;p&gt;DevOps 文化的核心是不停地创造。实际上，这意味着当测试结果显示事情由于你的改动而变坏时，不要懊恼。我们要认识到，进化的过程不是线性的，通往成功的道路也从来不是一条直线。&lt;/p&gt;
&lt;p&gt;DevOps 专家 &lt;a class=&#34;link&#34; href=&#34;https://enterprisersproject.com/user/gene-kim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gene Kim&lt;/a&gt; 主张勇于承担风险和进行实验。鼓励你的团队尝试不寻常的任务，以得到新的领悟。&lt;/p&gt;
&lt;p&gt;你的组织应该以利润为导向吗？你能允许你的团队尝试一些新东西（非指个人兴趣项目）吗？持续的流程发展意味着对升级目前的方法持开放态度。优秀的销售领导懂得，结果比出勤率更重要，因此，关注团队的工作方式而不是工作量的多少始终是关键。&lt;/p&gt;
&lt;h3 id=&#34;随时提供反馈并积极寻求反馈&#34;&gt;随时提供反馈并积极寻求反馈&lt;/h3&gt;
&lt;p&gt;成员之间增加信任是蓬勃发展的 DevOps 文化的另一个关键特征。无论你的员工是在学习如何建立联盟网络联系，还是试图设计他们的下一个 &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/7/awesome-ux-cli-application&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用户体验&lt;/a&gt; 调查，每个人都应该对他们工作的反馈持开放态度。但是，除非你的团队成员尊重彼此的意见，并相信反馈是本着善意的精神提出的，否则这永远不会发生。&lt;/p&gt;
&lt;p&gt;这种文化听起来可能是很难培养的；事实上，一些公司会比其他公司更努力地实现这一点。诚然，给予和接受反馈的成功很大程度上取决于员工的个性。在招聘过程中，也可以对此进行筛选。&lt;/p&gt;
&lt;p&gt;在你期望员工随时向同事提供反馈并主动寻求反馈之前，你应该以身作则。高管应该以身作则，公开要求公司成员对其战略决策提出探究性问题，并提供相应的反馈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/20230126220801.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;DevOps is the intersection of development, quality assurance, and operations&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;不断改进&#34;&gt;不断改进&lt;/h3&gt;
&lt;p&gt;在同事之间增加对智力信任的基础上，你的团队应该寻找方法来改善其工作。DevOps 的性质意味着软件开发团队将比传统方法更迅速地进行部署。&lt;/p&gt;
&lt;p&gt;这种开放的改进文化可以对开发和运维以外的部门产生积极的影响。你也可以自己去探索企业还有哪些领域会受到积极的影响。&lt;/p&gt;
&lt;p&gt;留意培训和提高技能的机会。即使一个培训课程没有广告上说的那么突出，但有机会与行业专家建立联系，并与未来建立联系，这可以提高你的组织内的思想多样性。&lt;/p&gt;
&lt;h3 id=&#34;为以后的开发保存当前的想法&#34;&gt;为以后的开发保存当前的想法&lt;/h3&gt;
&lt;p&gt;频繁使用的 &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/11/git-concepts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Git&lt;/a&gt; 账户应该是你的 DevOps 工具链的一部分。你可以用 Git 作为软件开发和其他相关项目中产生的脚本的共同仓库。Git 作为 “版本控制” 工具而被熟知，Git 允许程序员保存他们工作的迭代、复用或改进其他人的工作。&lt;/p&gt;
&lt;p&gt;你的目标是能够保留好的想法以供将来使用。某个方法由于某种原因没有成功。然而，那套想法在当时是错误的，并不意味着它在未来永远无法成为有用的东西。&lt;/p&gt;
&lt;p&gt;由于 DevOps 的整个重点在于生产环境中的软件的端到端所有权，因此节省开发的迭代真正支持这一原则。你希望看到对手头的软件测试项目的持续关注和投入。&lt;/p&gt;
&lt;p&gt;一个简单的方法是要求开发者在开发者合同和最终项目报告中包含对未来工作的想法。确保技术服务经理知道他们应该要求提供在建设过程中出现的旁门左道的想法的例子。意识到这些小创新的人越多，在需要的时候就越有可能有人记住一个。&lt;/p&gt;
&lt;h3 id=&#34;坐在一起物理上或逻辑上&#34;&gt;坐在一起（物理上或逻辑上）&lt;/h3&gt;
&lt;p&gt;目标是对彼此的工作角色以及它们之间的相互关系有一个共同的理解。你可以通过几个简单的方法实现这一目标，用一句话概括：坐在一起。邀请其他团队参加你们的会议，完整地分享用户反馈报告。一起吃午饭，一起计划虚拟的快乐时光，一般来说，要确保你的同事都在一起。大约 90% 的拥有成熟的 DevOps 协议的团队报告说，他们清楚地了解自己对其他团队的责任，而在不成熟的 DevOps 团队中，只有大约 46% 的工作者清楚地了解自己的责任。&lt;/p&gt;
&lt;p&gt;虽然与志同道合的人结成小团体，只与被雇来执行与你相同任务的员工在一起是很诱人的，但这对整个企业来说是很糟糕的。无论你喜欢与否，所有的人都是多面手，能够在一系列的情况下贡献自己的独特才能。&lt;/p&gt;
&lt;p&gt;密切协作的理念是尊重任何人对其周围正在进行的产品或工作流程提出改进建议的能力。如果你与公司内的其他部门保持一定的距离，你将会错过无数次分享智慧想法的机会。毕竟，你往往在交流中学习得最好。&lt;/p&gt;
&lt;h3 id=&#34;致力于自动化&#34;&gt;致力于自动化&lt;/h3&gt;
&lt;p&gt;你应该以提高效率和加速流程的名义，寻求将单调的和重复的任务变为自动化。每个行业都有无聊的 —— 说得直白一点，就是愚蠢的 —— 每天或每周都要进行的工作。&lt;/p&gt;
&lt;p&gt;无论是手工将数据从一页复制到另一页，还是手工打出音频记录，每个级别的工作人员都应该坚持让机器在可能的情况下承担这些负担。现实是自动化技术每年都在进步，操作流程也应该如此。&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/20/7/open-source-test-automation-frameworks&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自动化测试&lt;/a&gt; 对 DevOps 非常关键，它是 CALMS 框架的第二个原则（其中的 “C” 代表 “文化”）。&lt;/p&gt;
&lt;p&gt;你怎样才能实现这一点？邀请员工公开表达他们认为工作的哪些方面可以自动化，然后 —— 这里是关键的部分 —— 支持实现自动化所需的设施。这可能意味着每年花 600 美元订阅一个软件程序、一套完整的企业应用现代化解决方案，或开发人员用两天时间来建立一个在内部使用新工具。&lt;/p&gt;
&lt;p&gt;无论哪种方式，你都应该评估自动化的好处，考虑你可以为每个人节省多少时间。DevOps 的统计数据不断表明，现代公司通过整合这些有益的原则，年复一年地得到了很大的改善。&lt;/p&gt;
&lt;h3 id=&#34;探索成功的新工作方式&#34;&gt;探索成功的新工作方式&lt;/h3&gt;
&lt;p&gt;文化转变不会在一夜之间发生。不过，你越早开始，就越早看到结果。根据我的经验，当变化真正对以前进行了改进时，人们会接受它。DevOps 为这种改进提供了一个框架。无论你是刚刚在你的组织中开始使用 DevOps，还是仅仅想改善你现有的文化，请考虑以上几点以及它们与你组织的未来的关系。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/23/1/tips-effective-devops-culture&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/23/1/tips-effective-devops-culture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/yauhen-zaremba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Yauhen Zaremba&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lkxed&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lkxed&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】域名末尾带个点</title>
        <link>https://lxb.wiki/a258db2c/</link>
        <pubDate>Wed, 16 Nov 2022 22:20:00 +0000</pubDate>
        
        <guid>https://lxb.wiki/a258db2c/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;大家好！今年早些时候，我在写《[DNS 是如何工作的][1]》 时，有人问我——为什么人们有时在域名的末尾加一个点？例如，如果你通过运行 &lt;code&gt;dig example.com&lt;/code&gt; 查询 &lt;code&gt;example.com&lt;/code&gt; 的 IP，你会看到一下内容：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
$ dig example.com
example.com.        5678    IN  A   93.184.216.34
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完 &lt;code&gt;dig&lt;/code&gt; 命令后，&lt;code&gt;example.com&lt;/code&gt; 有一个 &lt;code&gt;.&lt;/code&gt; ——变成了 &lt;code&gt;example.com.&lt;/code&gt;！发生了什么？&lt;/p&gt;
&lt;p&gt;有些 DNS 工具也要求传给它的域名后加一个 &lt;code&gt;.&lt;/code&gt;：如果你在使用 [miekg/dns][2] 时传给它 &lt;code&gt;example.com&lt;/code&gt;，它会报错：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// trying to send this message will return an error
m := new(dns.Msg)
m.SetQuestion(&amp;#34;example.com&amp;#34;, dns.TypeA)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最初我以为我知道这个问题的答案（“呃，末尾的点意味着域名是完全限定的？”）。这是对的 —— 一个&lt;!-- raw HTML omitted --&gt;完全限定域名&lt;!-- raw HTML omitted --&gt;fully qualified domain name&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（FQDN）是一个末尾有 &lt;code&gt;.&lt;/code&gt; 的域名！&lt;/p&gt;
&lt;p&gt;但是&lt;em&gt;为什么&lt;/em&gt;末尾的点是有用且重要的呢？&lt;/p&gt;
&lt;h3 id=&#34;在-dns-的请求响应中域名的末尾并没有-&#34;&gt;在 DNS 的请求/响应中，域名的末尾并没有 “.”&lt;/h3&gt;
&lt;p&gt;我曾经（错误地）认为 “为什么末尾有一个点？”的答案可能是 “在 DNS 请求/响应中，域名末尾有一个 &lt;code&gt;.&lt;/code&gt;，所以我们把它放进去，以匹配你的计算机实际发送/接收的内容”。但事实并不是这样！&lt;/p&gt;
&lt;p&gt;当计算机发送 DNS 请求/响应时，域名的末尾并没有点。实际上，域名中&lt;em&gt;没有&lt;/em&gt;点。&lt;/p&gt;
&lt;p&gt;域名会被编码成一系列的长度/字符串对。例如，域名 &lt;code&gt;example.com&lt;/code&gt; 被编码为这 13 个字节。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
7example3com0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编码后的内容一个点也没有。一个 ASCII 域名（如 &lt;code&gt;example.com&lt;/code&gt;）被转成了各种 DNS 软件的 DNS 请求/响应中使用的格式。&lt;/p&gt;
&lt;p&gt;今天我们来讨论域名被转成 DNS 响应的一个地方：区域文件。&lt;/p&gt;
&lt;h3 id=&#34;区域文件中域名末尾的-&#34;&gt;区域文件中域名末尾的 “.”&lt;/h3&gt;
&lt;p&gt;一些人管理域名的 DNS 记录的方法是创建一个被称为 “区域文件” 的文本文件，然后配置一些 DNS 服务器软件（如 &lt;code&gt;nsd&lt;/code&gt; 或 &lt;code&gt;bind&lt;/code&gt;）来为该区域文件中指定的 DNS 记录提供服务。&lt;/p&gt;
&lt;p&gt;下面是一个对应 &lt;code&gt;example.com&lt;/code&gt; 的示例区域文件：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
orange  300   IN    A     1.2.3.4
fruit   300   IN    CNAME orange
grape   3000  IN    CNAME example.com.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个文件中，任何不以 &lt;code&gt;.&lt;/code&gt; 结尾的域名（比如 &lt;code&gt;orange&lt;/code&gt;）后都会自动加上 &lt;code&gt;.example.com&lt;/code&gt;。所以 &lt;code&gt;orange&lt;/code&gt; 成了 &lt;code&gt;orange.example.com&lt;/code&gt; 的简称。DNS 服务器从它的配置中得知这是一个 &lt;code&gt;example.com&lt;/code&gt; 的区域文件，所以它知道在所有不以点结尾的名字后面自动添加 &lt;code&gt;example.com&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我想这里的想法只是为了少打几个字符——如果要打出全称，区域文件会是这样：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
    orange.example.com.  300   IN    A     1.2.3.4
    fruit.example.com.   300   IN    CNAME orange.example.com.
    grape.example.com.   3000  IN    CNAME example.com.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确实多了很多字符。&lt;/p&gt;
&lt;h3 id=&#34;你也可以不通过区域文件来使用-dns&#34;&gt;你也可以不通过区域文件来使用 DNS&lt;/h3&gt;
&lt;p&gt;尽管官方的 DNS RFC（[RFC 1035][3]）中定义了区域文件格式，但你也可以不通过区域文件来使用 DNS。例如，AWS Route 53 就不用区域文件来存储 DNS 记录！你可以通过 Web 界面或 API 来创建记录，我猜他们是用某种数据库而不是一堆文本文件来存储记录。&lt;/p&gt;
&lt;p&gt;不过，Route 53（像许多其他 DNS 工具一样）确实支持导入和导出区域文件，这个功能或许在你更换 DNS 提供商时很有用。&lt;/p&gt;
&lt;h3 id=&#34;dig-命令输出中末尾的-&#34;&gt;dig 命令输出中末尾的 “.”&lt;/h3&gt;
&lt;p&gt;现在我们来讨论下 &lt;code&gt;dig&lt;/code&gt; 命令的输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
$ dig example.com
; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.18.1-1ubuntu1.1-Ubuntu &amp;lt;&amp;lt;&amp;gt;&amp;gt; +all example.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 10712
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;example.com.           IN  A

;; ANSWER SECTION:
example.com.        81239   IN  A   93.184.216.34
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一件奇怪的事是，几乎每一行都以 &lt;code&gt;;;&lt;/code&gt; 开头，这是怎么回事？&lt;code&gt;;&lt;/code&gt; 是区域文件中的注释字符！&lt;/p&gt;
&lt;p&gt;我想 &lt;code&gt;dig&lt;/code&gt; 以这种奇怪的方式输出的原因可能是为了方便你粘贴这些内容到区域文件时，不用修改就可以直接用。&lt;/p&gt;
&lt;p&gt;这也是 &lt;code&gt;example.com&lt;/code&gt; 末尾有个 &lt;code&gt;.&lt;/code&gt; 的原因 —— 区域文件要求域名末尾必须有点（否则它们会被解释为是相对于该区域的）。因此 &lt;code&gt;dig&lt;/code&gt; 也这么处理了。&lt;/p&gt;
&lt;p&gt;我真的希望 dig 有一个 &lt;code&gt;+human&lt;/code&gt; 选项，以更人性化的方式打印出这些信息，但现在我太懒了，懒得花工夫去实际贡献代码来做这件事（而且我并不擅长 C），所以我只能在我的博客上抱怨一下 :)&lt;/p&gt;
&lt;h3 id=&#34;curl-命令输出中末尾的-&#34;&gt;curl 命令输出中末尾的 “.”&lt;/h3&gt;
&lt;p&gt;我们来看下另一个末尾有 &lt;code&gt;.&lt;/code&gt; 的例子：&lt;code&gt;curl&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;我家里有台计算机名为 &lt;code&gt;grapefruit&lt;/code&gt;，其上运行着 Web 服务器。当我执行 &lt;code&gt;curl grapefruit&lt;/code&gt; 时，会输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
$ curl grapefruit

&amp;lt;!DOCTYPE HTML PUBLIC &amp;#34;-//W3C//DTD HTML 4.01//EN&amp;#34; &amp;#34;http://www.w3.org/TR/html4/strict.dtd&amp;#34;&amp;gt;

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
......
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样运行没问题！但是如果我在域名后加一个 &lt;code&gt;.&lt;/code&gt; 会怎样呢？它报错了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ curl grapefruit.
curl: (6) Could not resolve host: grapefruit.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发生了什么？为了搞清楚，我们需要先来学习下搜索域：&lt;/p&gt;
&lt;h3 id=&#34;初识搜索域&#34;&gt;初识搜索域&lt;/h3&gt;
&lt;p&gt;当我执行 &lt;code&gt;curl grapefrult&lt;/code&gt; 时，它是怎么被转成一个 DNS 请求的？你可能会认为我的计算机会向域名 &lt;code&gt;grapefruit&lt;/code&gt; 发送一个请求，对吗？但事实并不是这样。&lt;/p&gt;
&lt;p&gt;让我们用 &lt;code&gt;tcpdump&lt;/code&gt; 来看看到底是什么域名在被查询。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo tcpdump -i any port 53
[...] A? grapefruit.lan. (32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际上是向 &lt;code&gt;grapefruit.lan.&lt;/code&gt; 发送的请求。为什么呢？&lt;/p&gt;
&lt;p&gt;解释一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;curl&lt;/code&gt; 调用函数 &lt;code&gt;getaddrinfo&lt;/code&gt; 来查询 &lt;code&gt;grapefruit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getaddrinfo&lt;/code&gt; 查询了我计算机上的文件 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 包含两行内容：
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nameserver 127.0.0.53
search lan
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;因为有 &lt;code&gt;search lan&lt;/code&gt; 这行内容，所以 &lt;code&gt;getaddrinfo&lt;/code&gt; 在 &lt;code&gt;grapefruit&lt;/code&gt; 的末尾添加了一个 &lt;code&gt;lan&lt;/code&gt;，去查询 &lt;code&gt;grapefruit.lan&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;什么时候搜索域被使用&#34;&gt;什么时候搜索域被使用?&lt;/h3&gt;
&lt;p&gt;现在我们知道了一些奇怪的事情：当我们查询一个域名时，有时会有一个额外的东西（如 &lt;code&gt;lan&lt;/code&gt;）被加到最后。但是什么时候会发生这种情况呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果我们在域名&lt;strong&gt;末尾&lt;/strong&gt;添加一个 &lt;code&gt;.&lt;/code&gt;，那么这时不会用到搜索域&lt;/li&gt;
&lt;li&gt;如果域名&lt;strong&gt;中间包含&lt;/strong&gt;一个 &lt;code&gt;.&lt;/code&gt;（如 &lt;code&gt;example.com&lt;/code&gt;），那么默认也不会用到搜索域。但是可以通过修改配置来改变处理逻辑（在 [ndots][4] 里有更详细的说明）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们现在知道了 &lt;code&gt;curl grapefruit.&lt;/code&gt; 与 &lt;code&gt;curl grapefruit&lt;/code&gt; 结果不一样的原因——因为一个查询的是 &lt;code&gt;grapefruit.&lt;/code&gt;，而另一个查询的是 &lt;code&gt;grapefruit.lan.&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;我的计算机怎么知道使用哪个搜索域呢&#34;&gt;我的计算机怎么知道使用哪个搜索域呢？&lt;/h3&gt;
&lt;p&gt;当我连接路由时，它会通过 DHCP 告诉我它的搜索域是 &lt;code&gt;lan&lt;/code&gt; —— 它也是通过这个方式给我的计算机分配 IP。&lt;/p&gt;
&lt;h3 id=&#34;所以为什么要在域名末尾加一个点呢&#34;&gt;所以为什么要在域名末尾加一个点呢？&lt;/h3&gt;
&lt;p&gt;现在我们已经了解了区域文件和搜索域，下面是我认为的人们要在域名末尾加点的原因：&lt;/p&gt;
&lt;p&gt;有两种情况下，域名会被修改，并在末尾添加其他东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;example.com&lt;/code&gt; 的区域文件中，&lt;code&gt;grapefruit&lt;/code&gt; 会被转为 &lt;code&gt;grapefruit.example.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在我的本地网络（我的计算机已经配置了使用搜索域 &lt;code&gt;lan&lt;/code&gt;），&lt;code&gt;grapefruit&lt;/code&gt; 被转为 &lt;code&gt;grapefruit.lan&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，由于域名在某些情况下实际上可能被转成其他名字，人们就在结尾处加一个 &lt;code&gt;.&lt;/code&gt;，以此来表示 “&lt;strong&gt;这是域名，末尾不需要添加任何东西，这就是全部内容&lt;/strong&gt;”。否则会引起混乱。&lt;/p&gt;
&lt;p&gt;“这就是全部内容”的技术术语是**“完全限定域名”&lt;strong&gt;，简称为&lt;/strong&gt;“FQDN”**。所以 &lt;code&gt;google.com.&lt;/code&gt; 是一个完全限定域名，而 &lt;code&gt;google.com&lt;/code&gt; 不是。&lt;/p&gt;
&lt;p&gt;我总是要提醒自己这样做的原因，因为我很少使用区域文件和搜索域，所以我经常觉得——“我当然是指 &lt;code&gt;google.com&lt;/code&gt; 而不是 &lt;code&gt;google.com.something.else&lt;/code&gt;! 我为什么要指其他东西？那太傻了！”&lt;/p&gt;
&lt;p&gt;但是有些人确实在使用区域文件和搜索域（例如 Kubernetes 中使用了搜索域！），所以结尾的 &lt;code&gt;.&lt;/code&gt; 很有用，可以让人确切的知道，不应该再添加其他东西。&lt;/p&gt;
&lt;h3 id=&#34;什么时候在末尾添加-&#34;&gt;什么时候在末尾添加 “.”？&lt;/h3&gt;
&lt;p&gt;以下是关于何时在域名末尾加 &amp;ldquo;. &amp;quot; 的几个简单说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要添加：配置 DNS 时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在配置 DNS 时，使用完全限定域名从来都不是坏事。你不一定要这样做：非完全限定域名通常也能正常工作，但我从来没有遇到过不接受完全限定域名的 DNS 软件。&lt;/p&gt;
&lt;p&gt;有些 DNS 软件需要这样做：现在我为 &lt;code&gt;jvns.ca&lt;/code&gt; 使用的 DNS 服务器让我在域名的末尾加上 &lt;code&gt;.&lt;/code&gt;（例如在 CNAME 记录中），并提示如果我不添加，它将在我输入的内容末尾加上 &lt;code&gt;.jvns.ca&lt;/code&gt;。我不同意这个设计决定，但这不是什么大问题，我只是在最后加一个 &lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不需要加：在浏览器中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令人困惑的是，在浏览器中，在域名结尾处加一个 &lt;code&gt;.&lt;/code&gt; &lt;em&gt;不能&lt;/em&gt;正常运行。例如，如果我在浏览器中输入 &lt;code&gt;https://twitter.com.&lt;/code&gt;，它就会报错。它会返回 404。&lt;/p&gt;
&lt;p&gt;我认为这里发生的事情是，它将 HTTP &lt;code&gt;Host&lt;/code&gt; 标头设置为 &lt;code&gt;Host：twitter.com.&lt;/code&gt;，而对端的 Web 服务器则期望 &lt;code&gt;Host：twitter.com&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样地，&lt;code&gt;https://jvns.ca.&lt;/code&gt; 由于某种原因，返回了一个 SSL 错误。&lt;/p&gt;
&lt;h3 id=&#34;我认为相对域名在过去是比较常见的&#34;&gt;我认为相对域名在过去是比较常见的&lt;/h3&gt;
&lt;p&gt;最后一件事：我认为“相对”域名（比如我用 &lt;code&gt;grapefruit&lt;/code&gt; 来指代我家的另一台计算机 &lt;code&gt;grapefruit.lan&lt;/code&gt;）在过去更常用，因为 DNS 是在大学或其他有大型内部网络的大机构中开发的。&lt;/p&gt;
&lt;p&gt;在今天的互联网上，使用“绝对”域名（如 &lt;code&gt;example.com&lt;/code&gt;）似乎更为普遍。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://jvns.ca/blog/2022/09/12/why-do-domain-names-end-with-a-dot-/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://jvns.ca/blog/2022/09/12/why-do-domain-names-end-with-a-dot-/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://jvns.ca/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Julia Evans&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>【译】10大静态网站生成工具</title>
        <link>https://lxb.wiki/690c8418/</link>
        <pubDate>Sun, 02 Oct 2022 18:26:55 +0000</pubDate>
        
        <guid>https://lxb.wiki/690c8418/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;在寻找部署静态网页的方法吗？这几个开源的静态网站生成工具可以帮你迅速部署界面优美、功能强大的静态网站，无需掌握复杂的 HTML 和 CSS 技能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;静态网站是什么&#34;&gt;静态网站是什么？&lt;/h3&gt;
&lt;p&gt;技术上来讲，静态网站是指网页不是由服务器动态生成的。HTML、CSS 和 JavaScript 文件就静静地躺在服务器的某个路径下，它们的内容与终端用户接收到的版本是一样的。原始的源码文件已经提前编译好了，源码在每次请求后都不会变化。&lt;/p&gt;
&lt;p&gt;Linux.CN 是一个依赖多个数据库的动态网站，当有浏览器的请求时，网页就会生成并提供服务。大部分网站是动态的，你与这些网站互动时，大量的内容会经常改变。&lt;/p&gt;
&lt;p&gt;静态网站有一些好处，比如加载时间更短，请求的服务器资源更少、更安全（值得商榷）。&lt;/p&gt;
&lt;p&gt;传统上，静态网站更适合于创建只有少量网页、内容变化不频繁的小网站。&lt;/p&gt;
&lt;p&gt;然而，随着静态网站生成工具出现后，静态网站的适用范围越来越大。你还可以使用这些工具搭建博客网站。&lt;/p&gt;
&lt;p&gt;我整理了几个开源的静态网站生成工具，这些工具可以帮你搭建界面优美的网站。&lt;/p&gt;
&lt;h3 id=&#34;最好的开源静态网站生成工具&#34;&gt;最好的开源静态网站生成工具&lt;/h3&gt;
&lt;p&gt;请注意，静态网站不会提供很复杂的功能。如果你需要复杂的功能，那么你可以参考适用于动态网站的&lt;a class=&#34;link&#34; href=&#34;https://itsfoss.com/open-source-cms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最佳开源 CMS&lt;/a&gt;列表。&lt;/p&gt;
&lt;h4 id=&#34;1jekyll&#34;&gt;1、Jekyll&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i1.wp.com/itsfoss.com/wp-content/uploads/2018/01/jekyll-screenshot.jpg?resize=800%2C450&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Jekyll 是用 &lt;a class=&#34;link&#34; href=&#34;https://www.ruby-lang.org/en/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ruby&lt;/a&gt; 写的最受欢迎的开源静态生成工具之一。实际上，Jekyll 是 &lt;a class=&#34;link&#34; href=&#34;https://pages.github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt; 的引擎，它可以让你免费用 GitHub 托管网站。&lt;/p&gt;
&lt;p&gt;你可以很轻松地跨平台配置 Jekyll，包括 Ubuntu。它利用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/Shopify/liquid/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Markdown&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/Shopify/liquid/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Liquid&lt;/a&gt;（模板语言）、HTML 和 CSS 来生成静态的网页文件。如果你要搭建一个没有广告或推广自己工具或服务的产品页的博客网站，它是个不错的选择。&lt;/p&gt;
&lt;p&gt;它还支持从常见的 CMS（&lt;!-- raw HTML omitted --&gt;内容管理系统&lt;!-- raw HTML omitted --&gt;Content management system&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;）如 Ghost、WordPress、Drupal 7 迁移你的博客。你可以管理永久链接、类别、页面、文章，还可以自定义布局，这些功能都很强大。因此，即使你已经有了一个网站，如果你想转成静态网站，Jekyll 会是一个完美的解决方案。你可以参考&lt;a class=&#34;link&#34; href=&#34;https://jekyllrb.com/docs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;或 &lt;a class=&#34;link&#34; href=&#34;https://github.com/jekyll/jekyll&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;了解更多内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jekyllrb.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Jekyll&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2hugo&#34;&gt;2、Hugo&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hugo.jpg?resize=800%2C414&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Hugo 是另一个很受欢迎的用于搭建静态网站的开源框架。它是用 &lt;a class=&#34;link&#34; href=&#34;https://golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 语言&lt;/a&gt;写的。&lt;/p&gt;
&lt;p&gt;它运行速度快、使用简单、可靠性高。如果你需要，它也可以提供更高级的主题。它还提供了一些有用的快捷方式来帮助你轻松完成任务。无论是组合展示网站还是博客网站，Hogo 都有能力管理大量的内容类型。&lt;/p&gt;
&lt;p&gt;如果你想使用 Hugo，你可以参照它的&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;或它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/gohugoio/hugo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;来安装以及了解更多相关的使用方法。如果需要的话，你还可以将 Hugo 部署在 GitHub 页面或任何 CDN 上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3hexo&#34;&gt;3、Hexo&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/hexo.jpg?resize=800%2C213&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Hexo 是一个有趣的开源框架，基于 &lt;a class=&#34;link&#34; href=&#34;https://nodejs.org/en/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Node.js&lt;/a&gt;。像其他的工具一样，你可以用它搭建相当快速的网站，不仅如此，它还提供了丰富的主题和插件。&lt;/p&gt;
&lt;p&gt;它还根据用户的每个需求提供了强大的 API 来扩展功能。如果你已经有一个网站，你可以用它的&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/api/migrator.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;迁移&lt;/a&gt;扩展轻松完成迁移工作。&lt;/p&gt;
&lt;p&gt;你可以参照&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/docs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;或 &lt;a class=&#34;link&#34; href=&#34;https://github.com/hexojs/hexo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt; 来使用 Hexo。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hexo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4gatsby&#34;&gt;4、Gatsby&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/gatsbyjs.png?resize=800%2C388&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Gatsby 是一个越来越流行的开源网站生成框架。它使用 &lt;a class=&#34;link&#34; href=&#34;https://reactjs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;React.js&lt;/a&gt; 来生成快速、界面优美的网站。&lt;/p&gt;
&lt;p&gt;几年前在一个实验性的项目中，我曾经非常想尝试一下这个工具，它提供的成千上万的新插件和主题的能力让我印象深刻。与其他静态网站生成工具不同的是，你可以使用 Gatsby 生成一个网站，并在不损失任何功能的情况下获得静态网站的好处。&lt;/p&gt;
&lt;p&gt;它提供了与很多流行的服务的整合功能。当然，你可以不使用它的复杂的功能，或将其与你选择的流行 CMS 配合使用，这也会很有趣。你可以查看他们的&lt;a class=&#34;link&#34; href=&#34;https://www.gatsbyjs.com/docs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;或它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/gatsbyjs/gatsby&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;了解更多内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.gatsbyjs.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gatsby&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5vuepress&#34;&gt;5、VuePress&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/VuePress.jpg?resize=800%2C498&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;VuePress 是由 &lt;a class=&#34;link&#34; href=&#34;https://vuejs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Vue.js&lt;/a&gt; 支持的静态网站生成工具，而 Vue.js 是一个开源的渐进式 JavaScript 框架。&lt;/p&gt;
&lt;p&gt;如果你了解 HTML、CSS 和 JavaScript，那么你可以无压力地使用 VuePress。你应该可以找到几个有用的插件和主题来为你的网站建设开个头。此外，看起来 Vue.js 的更新一直很活跃，很多开发者都在关注 Vue.js，这是一件好事。&lt;/p&gt;
&lt;p&gt;你可以参照他们的&lt;a class=&#34;link&#34; href=&#34;https://vuepress.vuejs.org/guide/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;和 &lt;a class=&#34;link&#34; href=&#34;https://github.com/vuejs/vuepress&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;了解更多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://vuepress.vuejs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VuePress&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6nuxtjs&#34;&gt;6、Nuxt.js&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/nuxtjs.jpg?resize=800%2C415&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Nuxt.js 使用了 Vue.js 和 Node.js，但它致力于模块化，并且有能力依赖服务端而非客户端。不仅如此，它的目标是为开发者提供直观的体验，并提供描述性错误，以及详细的文档等。&lt;/p&gt;
&lt;p&gt;正如它声称的那样，在你用来搭建静态网站的所有工具中，Nuxt.js 可以做到功能和灵活性两全其美。他们还提供了一个 &lt;a class=&#34;link&#34; href=&#34;https://template.nuxtjs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Nuxt 线上沙盒&lt;/a&gt;，让你不费吹灰之力就能直接测试它。&lt;/p&gt;
&lt;p&gt;你可以查看它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/nuxt/nuxt.js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://nuxtjs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方网站&lt;/a&gt;了解更多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://nuxtjs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Nuxt.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;7docusaurus&#34;&gt;7、Docusaurus&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i2.wp.com/itsfoss.com/wp-content/uploads/2020/09/docusaurus.jpg?resize=800%2C278&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Docusaurus 是一个有趣的开源静态网站生成工具，为搭建文档类网站量身定制。它还是 &lt;a class=&#34;link&#34; href=&#34;https://opensource.facebook.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Facebook 开源计划&lt;/a&gt;的一个项目。&lt;/p&gt;
&lt;p&gt;Docusaurus 是用 React 构建的。你可以使用所有的基本功能，像文档版本管理、文档搜索和翻译大多是预先配置的。如果你想为你的产品或服务搭建一个文档网站，那么可以试试 Docusaurus。&lt;/p&gt;
&lt;p&gt;你可以从它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/facebook/docusaurus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;和它的&lt;a class=&#34;link&#34; href=&#34;https://docusaurus.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;获取更多信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docusaurus.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docusaurus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;8eleventy&#34;&gt;8、Eleventy&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/eleventy.png?resize=800%2C375&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Eleventy 自称是 Jekyll 的替代品，旨在以更简单的方法来制作更快的静态网站。&lt;/p&gt;
&lt;p&gt;它似乎很容易上手，而且它还提供了适当的文档来帮助你。如果你想找一个简单的静态网站生成工具，Eleventy 似乎会是一个有趣的选择。&lt;/p&gt;
&lt;p&gt;你可以参照它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/11ty/eleventy/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://www.11ty.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;来了解更多的细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.11ty.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Eleventy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;9publii&#34;&gt;9、Publii&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i0.wp.com/itsfoss.com/wp-content/uploads/2020/09/publii.jpg?resize=800%2C311&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Publii 是一个令人印象深刻的开源 CMS，它能使生成一个静态网站变得很容易。它是用 &lt;a class=&#34;link&#34; href=&#34;https://www.electronjs.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Electron&lt;/a&gt; 和 Vue.js 构建的。如果有需要，你也可以把你的文章从 WorkPress 网站迁移过来。此外，它还提供了与 GitHub 页面、Netlify 及其它类似服务的一键同步功能。&lt;/p&gt;
&lt;p&gt;如果你利用 Publii 生成一个静态网站，你还可以得到一个所见即所得的编辑器。你可以从&lt;a class=&#34;link&#34; href=&#34;https://getpublii.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;下载它，或者从它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/GetPublii/Publii&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;了解更多信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://getpublii.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Publii&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;10primo&#34;&gt;10、Primo&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i1.wp.com/itsfoss.com/wp-content/uploads/2020/09/primo-af.jpg?resize=800%2C394&amp;amp;ssl=1&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;一个有趣的开源静态网站生成工具，目前开发工作仍很活跃。虽然与其他的静态生成工具相比，它还不是一个成熟的解决方案，有些功能还不完善，但它是一个独特的项目。&lt;/p&gt;
&lt;p&gt;Primo 旨在使用可视化的构建器帮你构建和搭建网站，这样你就可以轻松编辑和部署到任意主机上。&lt;/p&gt;
&lt;p&gt;你可以参照&lt;a class=&#34;link&#34; href=&#34;https://primo.af/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;或查看它的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/primo-app/primo-desktop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 页面&lt;/a&gt;了解更多信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://primo.af/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Primo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;
&lt;p&gt;还有很多文章中没有列出的网站生成工具。然而，我试图提到最好的静态生成器，为您提供最快的加载时间，最好的安全性和令人印象深刻的灵活性。&lt;/p&gt;
&lt;p&gt;列表中没有你最喜欢的工具？在下面的评论中告诉我。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://itsfoss.com/open-source-static-site-generators/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://itsfoss.com/open-source-static-site-generators/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://itsfoss.com/author/ankush/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ankush Das&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】如何把WordPress网站迁移到新主机</title>
        <link>https://lxb.wiki/ea5f4ef1/</link>
        <pubDate>Sun, 24 Apr 2022 21:36:34 +0000</pubDate>
        
        <guid>https://lxb.wiki/ea5f4ef1/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;使用这个简单的方法来迁移一个网站以及管理防火墙配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你有过把一个 WordPress 网站迁移到一台新主机上的需求吗？我曾经迁移过好多次，迁移过程相当简单。当然，的的市场时候我都不会用通用的推荐方法，这次也不例外 —— 我用更简单的方法，这才是我推荐的方法。&lt;/p&gt;
&lt;p&gt;这个迁移方法没有破坏性，因此如果出于某些原因你需要还原到原来的服务器上，很容易可以实现。&lt;/p&gt;
&lt;h3 id=&#34;一个-wordpress-网站的组成部分&#34;&gt;一个 WordPress 网站的组成部分&lt;/h3&gt;
&lt;p&gt;运行一个基于 &lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;WordPress&lt;/a&gt; 的网站有三个重要组成部分：WordPress 本身，一个 web 服务器，如 &lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;Apache&lt;/a&gt;（我正在用），以及 &lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;MariaDB&lt;/a&gt;。MariaDB 是 MySQL 的一个分支，功能相似。&lt;/p&gt;
&lt;p&gt;业界有大量的 Web 服务器，由于我使用了 Apache 很长时间，因此我推荐用 Apache。你可能需要把 Apache 的配置方法改成你用的 Web 服务器的方法。&lt;/p&gt;
&lt;h3 id=&#34;初始配置&#34;&gt;初始配置&lt;/h3&gt;
&lt;p&gt;我使用一台 Linux 主机作为防火墙和网络路由。在我的网络中 Web 服务器是另一台主机。我的内部网络使用的是 C 类私有网络地址范围，按 [无类别域间路由][5]Classless Internet Domain Routing（CIDR）方式简单地记作 192.168.0.0/24。&lt;/p&gt;
&lt;p&gt;对于防火墙，相比于更复杂的 &lt;code&gt;firewalld&lt;/code&gt;，我更喜欢用非常简单的 &lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;IPTables&lt;/a&gt;。这份防火墙配置中的一行会把 80 端口（HTTP）接收到的包发送给 Web 服务器。在 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 文件中，你可以在注释中看到，我添加了规则，把其他入站服务器连接转发到同一台服务器上合适的端口。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我使用命名虚拟主机named virtual host来配置原来的 Apache Web 服务器，因为我在这个 HTTPD 实例上运行着多个网站。使用命名虚拟主机配置是个不错的方法，因为（像我一样）未来你可能会在运行其他的网站，这个方法可以使其变得容易。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt; 中需要迁移的虚拟主机的网站相关部分请参考下面代码。这个片段中不涉及到 IP 地址的修改，因此在新服务器上使用时不需要修改。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;在迁移之前，你需要在 &lt;code&gt;httpd.conf&lt;/code&gt; 的最顶端附近找到 &lt;code&gt;Listen&lt;/code&gt; 声明并修改成类似下面这样。这个地址是服务器的真实私有 IP 地址，不是公开 IP 地址。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;你需要修改新主机上 &lt;code&gt;Listen&lt;/code&gt; 的 IP 地址。&lt;/p&gt;
&lt;h3 id=&#34;前期工作&#34;&gt;前期工作&lt;/h3&gt;
&lt;p&gt;准备工作分为以下三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装服务&lt;/li&gt;
&lt;li&gt;配置防火墙&lt;/li&gt;
&lt;li&gt;配置 web 服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;安装-apache-和-mariadb&#34;&gt;安装 Apache 和 MariaDB&lt;/h4&gt;
&lt;p&gt;如果你的新服务器上还没有 Apache 和 MariaDB，那么就安装它们。WordPress 的安装不是必要的。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;新服务器防火墙配置&#34;&gt;新服务器防火墙配置&lt;/h4&gt;
&lt;p&gt;确认下新服务器上的防火墙允许访问 80 端口。你&lt;em&gt;每台&lt;/em&gt;电脑上都有一个防火墙，对吗？大部分现代发行版使用的初始化配置包含的防火墙会阻止所有进来的网络流量，以此来提高安全等级。&lt;/p&gt;
&lt;p&gt;下面片段的第一行内容可能已经在你的 IPTables 或其他基于防火墙的网络过滤器中存在了。它标识已经被识别为来自可接受来源的入站包，并绕过后面的其它 INPUT 过滤规则，这样可以节省时间和 CPU 周期。片段中最后一行标识并放行 80 端口新进来的请求到 HTTPD 的连接。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;下面的示例 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 文件是 IPTables 最少规则的例子，可以允许 SSH（端口 22）和 HTTPD（端口 80）连接。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;在新服务器主机上我需要做的就是在 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 文件的防火墙规则里添加上面片段的最后一行，然后重新加载修改后的规则集。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;大部分基于红帽的发行版本，如 Fedora，使用的是 &lt;code&gt;firewalld&lt;/code&gt;。我发现对于它的适用场景（如家用、小到中型企业）而言，它过于复杂，因此我不用它。我建议你参照 &lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;firewalld 网页&lt;/a&gt; 来向 &lt;code&gt;firewalld&lt;/code&gt; 添加入站端口 80。&lt;/p&gt;
&lt;p&gt;你的防火墙及其配置可能跟这个有些差异，但最终的目的是允许新 Web 服务器 80 端口接收 HTTPD 连接。&lt;/p&gt;
&lt;h4 id=&#34;httpd-配置&#34;&gt;HTTPD 配置&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt; 文件中配置 HTTPD。像下面一样在 &lt;code&gt;Listen&lt;/code&gt; 片段中设置 IP 地址。我的新 Web 服务器 IP 地址是 &lt;code&gt;192.168.0.125&lt;/code&gt;。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;复制（对应要迁移的网站的） &lt;code&gt;VirtualHost&lt;/code&gt; 片段，粘贴到新服务器上 &lt;code&gt;httpd.conf&lt;/code&gt; 文件的末尾。&lt;/p&gt;
&lt;h3 id=&#34;迁移过程&#34;&gt;迁移过程&lt;/h3&gt;
&lt;p&gt;只有两组数据需要迁移到新服务器 —— 数据库本身和网站目录结构。把两个目录打包成 &lt;code&gt;tar&lt;/code&gt; 文档。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;把两个 tar 文件复制到新服务器。我通常会把这类文件放到 &lt;code&gt;/tmp&lt;/code&gt; 下，这个目录就是用来做这种事的。在新服务器上运行下面的命令，把 tar 文档解压到正确的目录。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;WordPress 的所有文件都在 &lt;code&gt;/var/website1&lt;/code&gt; 下，因此不需要在新服务器上安装它。新服务器上不需要执行 WordPress 安装过程。&lt;/p&gt;
&lt;p&gt;这个目录就是需要迁移到新服务器上的全部内容。&lt;/p&gt;
&lt;p&gt;最后一步是启动（或重启）&lt;code&gt;mysqld&lt;/code&gt; 和 &lt;code&gt;httpd&lt;/code&gt; 服务守护进程。WrodPress 不是一个服务，因此不使用守护进程的方式来启动。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;启动之后，你应该检查下这些服务的状态。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;最终的修改&#34;&gt;最终的修改&lt;/h3&gt;
&lt;p&gt;现在所需的服务都已经运行了，你可以把 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 文件中 HTTDP 的防火墙规则改成下面的样子：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;然后重新加载设置的 IPTables 规则。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;由于防火墙规则是在防火墙主机上，因此不需要把外部 DNS 入口改成指向新服务器。如果你使用的是内部 DNS 服务器，那么你需要把 IP 地址改成内部 DNS 数据库里的 A 记录。如果你没有用内部 DNS 服务器，那么请确保主机 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件里新服务器地址设置得没有问题。&lt;/p&gt;
&lt;h3 id=&#34;测试和清理&#34;&gt;测试和清理&lt;/h3&gt;
&lt;p&gt;请确保对新配置进行测试。首先，停止旧服务器上的 &lt;code&gt;mysqld&lt;/code&gt; 和 &lt;code&gt;httpd&lt;/code&gt; 服务。然后通过浏览器访问网站。如果一切符合预期，那么你可以关掉旧服务器上的 &lt;code&gt;mysqld&lt;/code&gt; 和 &lt;code&gt;httpd&lt;/code&gt;。如果有失败，你可以把 IPTables 的路由规则改回去到旧服务器上，直到问题解决。&lt;/p&gt;
&lt;p&gt;之后我把 MySQL 和 HTTPD 从旧服务器上删除了，这样来确保它们不会意外地被启动。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;就是这么简单。不需要执行数据库导出和导入的过程，因为 &lt;code&gt;mysql&lt;/code&gt; 目录下所有需要的东西都已经复制过去了。需要执行导出/导入过程的场景是：有网站自己的数据库之外的数据库；MariaDB 实例上还有其他网站，而你不想把这些网站复制到新服务器上。&lt;/p&gt;
&lt;p&gt;迁移旧服务器上的其他网站也很容易。其他网站依赖的所有数据库都已经随着 MariaDB 的迁移被转移到了新服务器上。你只需要把 &lt;code&gt;/var/website&lt;/code&gt; 目录迁移到新服务器，添加合适的虚拟主机片段，然后重启 HTTPD。&lt;/p&gt;
&lt;p&gt;我遵循这个过程把很多个网站从一个服务器迁移到另一个服务器，每次都没有问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/21/9/migrate-wordpress&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/21/9/migrate-wordpress&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;David Both&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;#&#34; &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
&lt;p&gt;[a]    &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/dboth&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/users/dboth&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[b]    &lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/lujun9972&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[1]    &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/browser_blue_text_editor_web.png?itok=lcf-m6N7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/browser_blue_text_editor_web.png?itok=lcf-m6N7&lt;/a&gt; Text editor on a browser, in blue&lt;/p&gt;
&lt;p&gt;[2]    &lt;a class=&#34;link&#34; href=&#34;https://wordpress.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wordpress.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]    &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/18/2/how-configure-apache-web-server&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/18/2/how-configure-apache-web-server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4]    &lt;a class=&#34;link&#34; href=&#34;https://mariadb.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mariadb.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]    &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/16/12/cidr-network-notation-configuration-linux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/16/12/cidr-network-notation-configuration-linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]    &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Iptables&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Iptables&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7]    &lt;a class=&#34;link&#34; href=&#34;http://www.website1.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.website1.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8]    mailto:me@website1.org&lt;/p&gt;
&lt;p&gt;[9]    &lt;a class=&#34;link&#34; href=&#34;https://firewalld.org/documentation/howto/open-a-port-or-service.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://firewalld.org/documentation/howto/open-a-port-or-service.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Go中的模糊测试</title>
        <link>https://lxb.wiki/dfd7f257/</link>
        <pubDate>Tue, 19 Apr 2022 21:30:29 +0000</pubDate>
        
        <guid>https://lxb.wiki/dfd7f257/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 团队接受了新增对模糊测试的支持的提议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go&lt;/a&gt; 的应用越来越广泛。现在它是云原生软件、容器软件、命令行工具和数据库等等的首选语言。Go 很早之前就已经有了内建的 &lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;对测试的支持&lt;/a&gt;。这使得写测试代码和运行都相当简单。&lt;/p&gt;
&lt;h3 id=&#34;什么是模糊测试&#34;&gt;什么是模糊测试？&lt;/h3&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;模糊测试&lt;!-- raw HTML omitted --&gt;fuzz testing&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（fuzzing）是指向你的软件输入非预期的数据。理想情况下，这种测试会让你的应用程序崩溃或有非预期的表现。抛开最终的结果，从程序对非预期的输入数据的处理结果中你可以得到很多信息，这样你就可以增加一些合适的错误处理。&lt;/p&gt;
&lt;p&gt;任何一个软件都有对不同来源的输入或数据的接收说明，软件会对这些数据进行处理并返回适当的结果。软件开发后，测试工程师团队对其进行测试，找出软件中的错误，给出测试报告，并（由开发者）修复。通常测试的目的是验证软件的行为是否符合预期。测试又可以细分为不同的类型，如功能测试、集成测试、性能测试等等。每种测试方法关注软件功能的某一个方面，以便发现错误或者提升可靠性或性能。&lt;/p&gt;
&lt;p&gt;模糊测试在这一测试过程上更进一步，尝试向软件程序输入一些“无效”或“随机”的数据。这种输入是故意的，期望得到的结果就是程序崩溃或输出异常，这样就可以暴露程序中的错误以便由开发者来修复它们。与其他测试类似，很少需要手动进行模糊测试，业界有大量的模糊测试工具可以将这个过程自动化。&lt;/p&gt;
&lt;h3 id=&#34;go-中的软件测试&#34;&gt;Go 中的软件测试&lt;/h3&gt;
&lt;p&gt;举个例子，假如你想测试 &lt;code&gt;add.go&lt;/code&gt; 中的 &lt;code&gt;Add()&lt;/code&gt; 函数，你可以在 &lt;code&gt;add_test.go&lt;/code&gt; 中导入 &lt;code&gt;testing&lt;/code&gt; 包并把测试体写在以 &lt;code&gt;TestXXX()&lt;/code&gt;  开头的函数内。&lt;/p&gt;
&lt;p&gt;考虑如下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Add(num1, num2 int) int {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;add_test.go&lt;/code&gt; 文件中，你可能有如下测试代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import &amp;#34;testing&amp;#34;

func TestAdd(t *testing.T) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行测试：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go test
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;新增对模糊测试的支持&#34;&gt;新增对模糊测试的支持&lt;/h3&gt;
&lt;p&gt;Go 团队已经接受了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/44551&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;新增对模糊测试的支持的提议&lt;/a&gt;，以进一步推动这项工作。这涉及到新增一个 &lt;code&gt;testing.F&lt;/code&gt; 类型，在 &lt;code&gt;_test.go&lt;/code&gt; 文件中新增 &lt;code&gt;FuzzXXX()&lt;/code&gt; 函数，在 Go 工具中会新增一个 &lt;code&gt;-fuzz&lt;/code&gt; 选项来执行这些测试。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;add_test.go&lt;/code&gt; 文件中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func FuzzAdd(f *testing.F) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行以下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go test -fuzz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在本文编写时，这个 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/fuzz-beta&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;功能还是试验性的&lt;/a&gt;，但是应该会在 1.18 发布版本中包含。（LCTT 译注：&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/go1.18&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 1.18&lt;/a&gt; 刚刚发布，已经包含了对模糊测试的支持）目前很多功能如 &lt;code&gt;-keepfuzzing&lt;/code&gt;、&lt;code&gt;-race&lt;/code&gt; 等也还没有支持。Go 团队最近发布了一篇 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/doc/tutorial/fuzz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;模糊测试教程&lt;/a&gt;，值得读一下。&lt;/p&gt;
&lt;h3 id=&#34;安装-gotip-来获取最新的功能&#34;&gt;安装 gotip 来获取最新的功能&lt;/h3&gt;
&lt;p&gt;如果你极度渴望在正式发布之前尝试这些功能，你可以使用 &lt;code&gt;gotip&lt;/code&gt; 来测试即将正式发布的 Go 功能并反馈给他们。你可以使用下面的命令来安装 &lt;code&gt;gotip&lt;/code&gt;。安装之后，你可以用 &lt;code&gt;gotip&lt;/code&gt; 程序代替以前的 &lt;code&gt;go&lt;/code&gt; 程序来编译和运行程序。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go install golang.org/dl/gotip@latest
$ gotip download

$ gotip version
go version devel go1.18-f009910 Thu Jan 6 16:22:21 2022 +0000 linux/amd64
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;社区对于模糊测试的观点&#34;&gt;社区对于模糊测试的观点&lt;/h3&gt;
&lt;p&gt;软件社区中经常会讨论模糊测试，不同的人对模糊测试有不同的看法。有些人认为这是一种有用的技术，可以找到错误，尤其是在安全方面。然而考虑到模糊测试所需要的资源（CPU、内存），有人就认为这是一种浪费，而他们更愿意用其他的测试方法。即使在 Go 团队内部，意见也不统一。我们可以看到 Go 的联合创始人 Rob Pike 对模糊测试的使用和在 Go 中的实现是持轻微的怀疑态度的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;&lt;em&gt;虽然模糊测试有助于发现某类错误，但是它会占用大量的 CPU 和存储资源，并且效益成本比率也不明确。我担心为了写模糊测试浪费精力，或者 git 仓库中充斥大量无用的测试数据&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;~&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/44551#issuecomment-784584785&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rob Pike&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，Go 安全团队的另一个成员，Filo Sottile，似乎对 Go 新增支持模糊测试很乐观，举了很多例子来支持，也希望模糊测试能成为开发过程中的一部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;我想说模糊测试可以发现极端情况下的错误。这是我们作为安全团队对其感兴趣的原因：在极端情况下发现的错误可以避免在生产环境中成为弱点。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们希望模糊测试能成为开发的一部分 —— 不只是构建或安全方面 —— 而是整个开发过程：它能提升相关代码的质量&amp;hellip;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;~&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/44551#issuecomment-784655571&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Filo Sottile&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;现实中的模糊测试&#34;&gt;现实中的模糊测试&lt;/h3&gt;
&lt;p&gt;对我而言，模糊测试在发现错误以及让系统变得更安全和更有弹性方面似乎非常有效。举个例子，Linux 内核也会使用名为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/google/syzkaller&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;syzkaller&lt;/a&gt; 的工具进行模糊测试，这个工具已经发现了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/google/syzkaller/blob/master/docs/linux/found_bugs.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;大量&lt;/a&gt; 错误。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/google/AFL&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AFL&lt;/a&gt; 也是比较流行的模糊测试工具，用来测试 C/C++ 写的程序。&lt;/p&gt;
&lt;p&gt;之前也有对 Go 程序进行模糊测试的观点，其中之一就是 Filo 在 GitHub 评论中提到的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/dvyukov/go-fuzz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go-fuzz&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;go-fuzz 的记录提供了相当惊人的证据，证明模糊处理能很好地找到人类没有发现的错误。根据我的经验，我们只需要消耗一点点 CPU 的时间就可以得到极端情况下非常高效的测试结果。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么在-go-中新增对模糊测试的原生支持&#34;&gt;为什么在 Go 中新增对模糊测试的原生支持&lt;/h3&gt;
&lt;p&gt;如果我们的需求是对 Go 程序进行模糊测试，之前的工具像 &lt;code&gt;go-fuzz&lt;/code&gt; 就可以完成，那么为什么要在这种语言中增加原生支持呢？&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/master/design/draft-fuzzing.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 模糊测试设计草案&lt;/a&gt; 中说明了这样做的一些根本原因。设计的思路是让开发过程更简单，因为前面说的工具增加了开发者的工作量，还有功能缺失。如果你没有接触过模糊测试，那么我建议你读一下设计草案文档。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开发者可以使用诸如 &lt;code&gt;go-fuzz&lt;/code&gt; 或 &lt;code&gt;fzgo&lt;/code&gt;（基于 &lt;code&gt;go-fuzz&lt;/code&gt;）来解决某些需求。然而，已有的每种解决方案都需要在典型的 Go 测试上做更多的事，而且还缺少关键的功能。相比于其他的 Go 测试（如基准测试和单元测试），模糊测试不应该比它们复杂，功能也不应该比它们少。已有的解决方案增加了额外的开销，比如自定义命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模糊测试工具&#34;&gt;模糊测试工具&lt;/h3&gt;
&lt;p&gt;在大家期望 Go 语言新增功能的列表中，模糊测试是其中很受欢迎的一项。虽然现在还是试验性的，但在将要到来的发布版本中会变得更强大。这给了我们足够的时间去尝试它以及探索它的使用场景。我们不应该把它视为一种开销，如果使用得当它会是一种发现错误非常高效的测试工具。使用 Go 的团队应该推动它的使用，开发者可以写简单的模糊测试，测试团队去慢慢扩展以此来使用它全部的能力。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/1/native-go-fuzz-testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/22/1/native-go-fuzz-testing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/gkamathe&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gaurav Kamathe&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】解决 CI/CD 中的仓库阻抗失配</title>
        <link>https://lxb.wiki/f5fbcabb/</link>
        <pubDate>Sat, 26 Mar 2022 14:32:25 +0000</pubDate>
        
        <guid>https://lxb.wiki/f5fbcabb/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;对齐部署镜像和描述符是很困难的，但是某些策略可以使整个过程更高效。
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220326161918.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在软件架构中，当两个组件之间有某些概念性或技术上的差异时会出现 &lt;!-- raw HTML omitted --&gt;阻抗失配&lt;!-- raw HTML omitted --&gt;impedance mismatch&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。这个术语其实是从电子工程中借用的，表示电路中输入和输出的电子阻抗必须要匹配。&lt;/p&gt;
&lt;p&gt;在软件开发中，存储在镜像仓库中的镜像与存储在源码控制管理系统（LCTT 译注：SCM，Source Code Management）中它的&lt;!-- raw HTML omitted --&gt;部署描述符&lt;!-- raw HTML omitted --&gt;deployment descriptor&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;之间存在阻抗失配。你如何确定存储在 SCM 中的部署描述符表示的是正确的镜像？两个仓库追踪数据的方式并不一致，因此将一个镜像（在镜像仓库中独立存储的不可修改的二进制）和它的部署描述符（Git 中以文本文件形式存储的一系列修改记录）相匹配并不那么直观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文假定读者已经熟悉以下概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;源码控制管理&lt;!-- raw HTML omitted --&gt;Source Control Management&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（SCM）系统和分支&lt;/li&gt;
&lt;li&gt;Docker 或符合 OCI 标准的镜像和容器&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;容器编排系统&lt;!-- raw HTML omitted --&gt;Container Orchestration Platforms&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（COP），如 Kubernetes&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;持续集成/持续交付&lt;!-- raw HTML omitted --&gt;Continuous Integration/Continuous Delivery&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（CI/CD）&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;软件开发生命周期&lt;!-- raw HTML omitted --&gt;Software development lifecycle&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（SDLC）环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;阻抗失配scm-与镜像仓库&#34;&gt;阻抗失配：SCM 与镜像仓库&lt;/h3&gt;
&lt;p&gt;为了更好地理解阻抗失配在什么场景下会成为问题，请考虑任意项目中的软件开发生命周期环境（SDLC），如开发、测试或发布环境。&lt;/p&gt;
&lt;p&gt;测试环境不会有阻抗失配。现在使用 CI/CD 的最佳实践中开发分支的最新提交都会对应开发环境中的最新部署。因此，一个典型的、成功的 CI/CD 开发流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向 SCM 的开发分支提交新的修改&lt;/li&gt;
&lt;li&gt;新提交触发一次镜像构建&lt;/li&gt;
&lt;li&gt;新生成的镜像被推送到镜像仓库，标记为开发中&lt;/li&gt;
&lt;li&gt;镜像被部署到容器编排系统（COP）中的开发环境，该镜像的部署描述符也更新为从 SCM 拉取的最新描述符。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;换句话说，开发环境中最新的镜像永远与最新的部署描述符匹配。回滚到前一个构建的版本也不是问题，因为 SCM 也会跟着回滚。&lt;/p&gt;
&lt;p&gt;最终，随着开发流程继续推进，需要进行更多正式的测试，因此某个镜像 —— 镜像对应着 SCM 中的某次提交 —— 被推到测试环境。如果是一次成功的构建，那么不会有大问题，因为从开发环境推过来的镜像应该会与开发分支的最新提交相对应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发环境的最新部署被允许入库，触发入库过程&lt;/li&gt;
&lt;li&gt;最新部署的镜像被标记为测试中&lt;/li&gt;
&lt;li&gt;镜像在测试环境中被拉取和部署，（该镜像）对应从 SCM 拉取的最新部署描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到目前为止,一切都没有问题，对吗？如果出现下面的场景，会有什么问题？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 A&lt;/strong&gt;：镜像被推到下游环境，如&lt;!-- raw HTML omitted --&gt;用户验收测试&lt;!-- raw HTML omitted --&gt;user acceptance testing &lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（UAT），或者是生产环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 B&lt;/strong&gt;：测试环境中发现了一个破坏性的 bug，镜像需要回滚到某个确定正常的版本。&lt;/p&gt;
&lt;p&gt;在任一场景中，开发过程并没有停止，即开发分支上游有了一次或多次新的提交，而这意味着最新的部署描述符已经发生了变化，最新的镜像与之前部署在测试环境中的镜像不一致。对部署描述符的修改可能会也可能不会对之前版本的镜像起作用，但是它们一定是不可信任的。如果它们有了变化，那么它们就一定与目前为止你测试过的想要部署的镜像的部署描述符不一致。&lt;/p&gt;
&lt;p&gt;问题的关键是：&lt;strong&gt;如果部署的镜像不是镜像库中的最新版本，你怎么确定与部署的镜像相对应的是 SCM 中的哪个部署描述符？&lt;/strong&gt; 一言以蔽之，无法确定。两个库直接有阻抗失配。如果要详细阐述下，那么是有方法可以解决的，但是你需要做很多工作，这部分内容就是文章接下来的主题了。请注意，下面的方案并不是解决问题的唯一办法，但是已经投入到生产环境并已经对很多项目起了作用，而且已经被构建并部署到生产环境中运行了超过一年。&lt;/p&gt;
&lt;h3 id=&#34;二进制与部署描述符&#34;&gt;二进制与部署描述符&lt;/h3&gt;
&lt;p&gt;源码通常被构建成一个 Docker 镜像或符合 OCI 标准的镜像，该镜像通常被部署到一个容器编排平台（COP）上，如 Kubernetes。部署到 COP 需要部署描述符来定义镜像被如何部署以及作为容器运行，如 &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kubernetes 部署&lt;/a&gt; 或 &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CronJobs&lt;/a&gt;。这是因为在镜像和它的部署描述符之间有本质差异，在这里可以看到阻抗失配。在这次讨论中，我们认为镜像是存储在镜像仓库中不可修改的二进制。对源码的任何修改都不会修改镜像，而是用另一个新的镜像去替换它。&lt;/p&gt;
&lt;p&gt;相比之下，部署描述符是文本文件，因而可以被认为是源码且可修改。如果遵循最佳实践，那么部署描述符是被存储在 SCM，所有修改都会提交，而这很容易回溯。&lt;/p&gt;
&lt;h3 id=&#34;解决阻抗失配&#34;&gt;解决阻抗失配&lt;/h3&gt;
&lt;p&gt;建议的解决方案的第一部分，就是提供一个能匹配镜像仓库中的镜像与对保存部署描述符的 SCM 做的代码提交的方法。最直接的解决方案是用源提交的哈希值标记镜像。这个方法可以区分不同版本的镜像、容易分辨，并且提供足够的信息来查找正确的部署描述符，以便镜像更好地部署到 COP。&lt;/p&gt;
&lt;p&gt;再回顾下上面的场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 A&lt;/strong&gt; &lt;em&gt;镜像被推到下游环境&lt;/em&gt;： 当镜像被从测试环境推到 UAT 环境时，我们可以从镜像的标签中知道应该从 SCM 的哪一次源码提交拉取部署描述符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 B&lt;/strong&gt; &lt;em&gt;当一个镜像需要在某一环节中回滚&lt;/em&gt;：无论我们选择回滚到那个镜像版本，我们都可以知道从 SCM 的哪一次源码提交拉取正确的部署描述符。&lt;/p&gt;
&lt;p&gt;在每一种情景中，无论在某个镜像被部署到测试环境后开发分支有多少次提交和构建，对于每一次升级的镜像，我们都可以找到它当初部署时对应的部署描述符。&lt;/p&gt;
&lt;p&gt;然而，这并不是阻抗失配的完整解决方案。再考虑两个场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 C&lt;/strong&gt; 在负载测试环境中，会尝试对不同的部署描述符进行多次部署，以此来验证某一次构建的表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 D&lt;/strong&gt; 一个镜像被推送到下游环境，在该环境中部署描述符有一个错误。&lt;/p&gt;
&lt;p&gt;在上面的所有场景中，我们都需要修改部署描述符，但是目前为止我们只有一个源码提交哈希。请记住，最佳实践要求我们所有对源码的修改都要先提交到 SCM。某次提交的哈希本身是无法修改的，因此我们需要一个比仅仅追踪原来的源码提交哈希更好地解决方案。&lt;/p&gt;
&lt;p&gt;解决方案是基于原来的源码提交哈希新建一个分支。我们把这个分支称为&lt;strong&gt;部署分支&lt;/strong&gt;。每当一个镜像被推到下游测试或发布环境时，你应该&lt;strong&gt;基于前一个 SDLC 环境的部署分支的最新提交&lt;/strong&gt;创建一个新的部署分支。&lt;/p&gt;
&lt;p&gt;这样同一个镜像可以重复多次部署到不同的 SDLC 环境，并在后面每个环境中可以感知前面发现的改动或对镜像做的修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在某个环境中做的修改是如何影响下一个环境的，是用可以共享数据的工具（如 Helm Charts）还是手动剪切、粘贴到其他目录，都不在本文讨论的范围内。&lt;/p&gt;
&lt;p&gt;因此，当一个镜像被从一个 SDLC 环境中推到下一环境时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个部署分支
&lt;ol&gt;
&lt;li&gt;如果镜像是从开发环境中推过来的，那么部署分支就基于构建这个镜像的源码提交哈希创建&lt;/li&gt;
&lt;li&gt;否则，&lt;em&gt;部署分支基于当前部署分支的最新提交创建&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;镜像被部署到下一个 SDLC 环境，使用的部署描述符是该环境中新创建的部署分支的部署描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220326162117.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;deployment branching tree&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图 1：部署分支树&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署分支&lt;/li&gt;
&lt;li&gt;下游环境的第一个部署分支，只有一次提交&lt;/li&gt;
&lt;li&gt;下游环境的第二个部署分支，只有一次提交&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了部署分支这个解决方案，再回顾下上面的场景 C 和场景 D：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 C&lt;/strong&gt; 修改已经部署到下游 SDLC 环境中的镜像的部署描述符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 D&lt;/strong&gt; 修复某个 SDLC 环境中部署描述符的错误&lt;/p&gt;
&lt;p&gt;两个场景中，工作流如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把对部署描述符做的修改提交到 SLDC 环境和镜像对应的部署分支&lt;/li&gt;
&lt;li&gt;通过部署分支最新提交对应的部署描述符把镜像重新部署到 SLDC 环境&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，部署分支彻底解决了（存储着代表一次独一无二的构建的单一的、不可修改的镜像的）镜像仓库与（存储着对应一个或多个 SDLC 环境的可修改的部署描述符的）SCM 仓库之间的阻抗失配。&lt;/p&gt;
&lt;h3 id=&#34;实践中的思考&#34;&gt;实践中的思考&lt;/h3&gt;
&lt;p&gt;这看起来像是行得通的解决方案，但同时它也为开发者和运维人员带来了新的实践中的问题，比如：&lt;/p&gt;
&lt;p&gt;A. 为了更好地管理部署分支，部署描述符作为资源应该保存在哪里，是否要与构建镜像的源码保存在同一个 SCM 仓库？&lt;/p&gt;
&lt;p&gt;到目前为止，我们都在避免谈论应该把部署描述符放在哪个仓库里。在还没有太多细节需要处理时，我们推荐把所有 SDLC 环境的部署描述符与镜像源码放在同一个 SCM 仓库。当部署分支创建后，镜像的源码可以作为方便找到部署的容器中运行的镜像的引用来使用。&lt;/p&gt;
&lt;p&gt;上面提到过，可以通过镜像的标签来关联镜像与原始的源码提交。在一个单独的仓库中查找某次提交的源码的引用，会给开发者带来更大的困难（即便借助工具），这就是没有必要把所有资源都分开存储的原因。&lt;/p&gt;
&lt;p&gt;B. 应该在部署分支上修改构建镜像的源码吗？&lt;/p&gt;
&lt;p&gt;简答：&lt;strong&gt;不应该&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;详细阐述：不应该，因为永远不要在部署分支上构建镜像，它们是在开发分支上构建的。修改部署分支上定义一个镜像的源码会破坏被部署的镜像的构建记录，而且这些修改并不会对镜像的功能生效。在对比两个部署分支的版本时这也会成为问题。这可能会导致两个版本的功能差异有错误的测试结果（这是使用部署分支的一个很小的额外好处）。&lt;/p&gt;
&lt;p&gt;C. 为什么使用镜像 &lt;!-- raw HTML omitted --&gt;标签&lt;!-- raw HTML omitted --&gt;tag&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;？&lt;!-- raw HTML omitted --&gt;标记&lt;!-- raw HTML omitted --&gt;label&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 不可以吗？&lt;/p&gt;
&lt;p&gt;通过 &lt;!-- raw HTML omitted --&gt;标签&lt;!-- raw HTML omitted --&gt;tag&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 可以在仓库中很容易地查找镜像，可读性也很好。在一组镜像中读取和查找 &lt;!-- raw HTML omitted --&gt;标记&lt;!-- raw HTML omitted --&gt;label&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 的值需要拉取所有镜像的&lt;!-- raw HTML omitted --&gt;清单文件&lt;!-- raw HTML omitted --&gt;manifest&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，而这会增加复杂度、降低性能。而且，考虑到历史记录的追踪和不同版本的查找，对不同版本的镜像添加 &lt;!-- raw HTML omitted --&gt;标签&lt;!-- raw HTML omitted --&gt;tag&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; 也很有必要，因此使用源码提交哈希是保证唯一性，以及保存能即时生效的有用信息的最简单的解决方案。&lt;/p&gt;
&lt;p&gt;D. 创建部署分支的最佳实践是怎样的？&lt;/p&gt;
&lt;p&gt;DevOps 最重要的三个原则：自动化、自动化、自动化。&lt;/p&gt;
&lt;p&gt;依赖资源来持续地强迫遵循最佳实践，充其量只是碰运气，因此在实现镜像的升级、回滚等 CI/CD 流水线时，把自动化部署分支写到脚本里。&lt;/p&gt;
&lt;p&gt;E. 对部署分支的命名规范有建议吗？&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;strong&gt;部署分支标识&lt;/strong&gt;&amp;gt;-&amp;lt;&lt;strong&gt;环境&lt;/strong&gt;&amp;gt;-&amp;lt;&lt;strong&gt;源码提交哈希&lt;/strong&gt;&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;部署分支标识&lt;/strong&gt;： 所有部署分支范围内唯一的字符串；如 “deployment” 或 “deploy”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境&lt;/strong&gt;： 部署分支适用的 SDLC 环境；如 “qa”（测试环境）、 “stg”（预生产环境）、 或 “prod”（生产环境）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源码提交哈希&lt;/strong&gt;： 源码提交哈希中包含原来构建被部署的镜像的源码，开发者可以通过它很容易地查找到创建镜像的原始提交，同时也能保证分支名唯一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如， &lt;code&gt;deployment-qa-asdf78s&lt;/code&gt; 表示推到 QA 环境的部署分支， &lt;code&gt;deployment-stg-asdf78s&lt;/code&gt; 表示推到 STG 环境的部署分支。&lt;/p&gt;
&lt;p&gt;F. 你怎么识别环境中运行的哪个镜像版本？&lt;/p&gt;
&lt;p&gt;我们的建议是把最新的部署分支提交哈希和源码提交哈希添加到 &lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;标记&lt;/a&gt; 中。开发者和运维人员可以通过这两个独一无二的标识符查找到部署的所有东西及其来源。在诸如执行回滚或前滚操作时，使用那些不同版本的部署的选择器也能清理资源碎片。&lt;/p&gt;
&lt;p&gt;G. 什么时候应该把部署分支的修改合并回开发分支？&lt;/p&gt;
&lt;p&gt;这完全取决于开发团队。&lt;/p&gt;
&lt;p&gt;如果你修改的目的是为了做负载测试，只是想验证什么情况会让程序崩溃，那么这些修改不应该被合并回开发分支。另一方面，如果你发现和修复了一个错误，或者对下游环境的部署做了调整，那么就应该把部署分支的修改合并回开发分支。&lt;/p&gt;
&lt;p&gt;H. 有现成的部署分支示例让我们试水吗？&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/elcicd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;el-CICD&lt;/a&gt; 已经在生产上使用这个策略持续一年半应用到超过一百个项目了，覆盖所有的 SDLC 环境，包括管理生产环境的部署。如果你可以访问 &lt;a class=&#34;link&#34; href=&#34;https://www.okd.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OKD&lt;/a&gt;、Red Hat OpenShift lab cluster 或 &lt;a class=&#34;link&#34; href=&#34;https://cloud.redhat.com/openshift/create/local&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat CodeReady Containers&lt;/a&gt;，你可以下载&lt;a class=&#34;link&#34; href=&#34;https://github.com/elcicd/el-CICD-RELEASES&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;el-CICD 的最新版本&lt;/a&gt;，参照 &lt;a class=&#34;link&#34; href=&#34;https://github.com/elcicd/el-CICD-docs/blob/master/tutorial.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;教程&lt;/a&gt; 来学习部署分支是何时以怎样的方式创建和使用的。&lt;/p&gt;
&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;
&lt;p&gt;通过实践上面的例子可以帮助你更好的理解开发过程中阻抗失配相关的问题。对齐镜像和部署描述符是成功管理部署的关键部分。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/21/8/impedance-mismatch-cicd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/21/8/impedance-mismatch-cicd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/hippyod&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Evan &amp;ldquo;Hippy&amp;rdquo; Slatis&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】使用子模块和子树来管理 Git 项目</title>
        <link>https://lxb.wiki/331c3227/</link>
        <pubDate>Wed, 23 Dec 2020 22:11:17 +0000</pubDate>
        
        <guid>https://lxb.wiki/331c3227/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;使用子模块和子树来帮助你管理多个存储库中共有的子项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222058.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果你参与了开源项目的开发，那么你很可能已经用了 Git 来管理你的源码。你可能遇到过有很多依赖和/或子项目的项目。你是如何管理它们的？&lt;/p&gt;
&lt;p&gt;对于一个开源组织，要实现社区&lt;strong&gt;和&lt;/strong&gt;产品的单一来源文档和依赖管理比较棘手。文档和项目往往会碎片化和变得冗余，这致使它们很难维护。&lt;/p&gt;
&lt;h3 id=&#34;必要性&#34;&gt;必要性&lt;/h3&gt;
&lt;p&gt;假设你想把单个项目作为一个存储库内的子项目，传统的方法是把该项目复制到父存储库中，但是，如果你想要在多个父项目中使用同一个子项目呢？如果把子项目复制到所有父项目中，当有更新时，你都要在每个父项目中做修改，这是不太可行的。这会导致父项目中的冗余和数据不一致，使更新和维护子项目变得很困难。&lt;/p&gt;
&lt;h3 id=&#34;git-子模块和子树&#34;&gt;Git 子模块和子树&lt;/h3&gt;
&lt;p&gt;如果你可以用一条命令把一个项目放进另一个项目中，会怎样呢？如果你随时可以把一个项目作为子项目添加到任意数目的项目中，并可以同步更新修改呢？Git 提供了这类问题的解决方案：Git 子模块submodule&lt;!-- raw HTML omitted --&gt;子模块&lt;!-- raw HTML omitted --&gt;submodule&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;和 Git 子树subtree&lt;!-- raw HTML omitted --&gt;子树&lt;!-- raw HTML omitted --&gt;subtree&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。创建这些工具的目的是以更加模块化的水平来支持共用代码的开发工作流，旨在 Git 存储库源码管理source-code management&lt;!-- raw HTML omitted --&gt;源码管理&lt;!-- raw HTML omitted --&gt;source-code management&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（SCM）与它下面的子树之间架起一座桥梁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222135.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Cherry tree growing on a mulberry tree&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;生长在桑树上的樱桃树&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面是本文要详细介绍的概念的一个真实应用场景。如果你已经很熟悉树形结构，这个模型看起来是下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222254.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Tree with subtrees&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;git-子模块是什么&#34;&gt;Git 子模块是什么？&lt;/h3&gt;
&lt;p&gt;Git 在它默认的包中提供了子模块，子模块可以把 Git 存储库嵌入到其他存储库中。确切地说，Git 子模块指向子树中的某次提交。下面是我 &lt;a class=&#34;link&#34; href=&#34;https://github.com/manaswinidas/Docs-test/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docs-test&lt;/a&gt; GitHub 存储库中的 Git 子模块的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222434.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Git submodules screenshot&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:folder@commitId&#34; &gt;文件夹@提交 Id&lt;/a&gt; 格式表明这个存储库是一个子模块，你可以直接点击文件夹进入该子树。名为 &lt;code&gt;.gitmodules&lt;/code&gt; 的配置文件包含所有子模块存储库的详细信息。我的存储库的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20210103222553.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Screenshot of .gitmodules file&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;你可以用下面的命令在你的存储库中使用 Git 子模块：&lt;/p&gt;
&lt;h4 id=&#34;克隆一个存储库并加载子模块&#34;&gt;克隆一个存储库并加载子模块&lt;/h4&gt;
&lt;p&gt;克隆一个含有子模块的存储库：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git clone --recursive &amp;lt;URL to Git repo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你之前已经克隆了存储库，现在想加载它的子模块：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule update --init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果有嵌套的子模块：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;下载子模块&#34;&gt;下载子模块&lt;/h4&gt;
&lt;p&gt;串行地连续下载多个子模块是很枯燥的工作，所以 &lt;code&gt;clone&lt;/code&gt; 和 &lt;code&gt;submodule update&lt;/code&gt; 会支持 &lt;code&gt;--jobs&lt;/code&gt; （或 &lt;code&gt;-j&lt;/code&gt;）参数：&lt;/p&gt;
&lt;p&gt;例如，想一次下载 8 个子模块，使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule update --init --recursive -j 8
$ git clone --recursive --jobs 8 &amp;lt;URL to Git repo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;拉取子模块&#34;&gt;拉取子模块&lt;/h4&gt;
&lt;p&gt;在运行或构建父项目之前，你需要确保依赖的子项目都是最新的。&lt;/p&gt;
&lt;p&gt;拉取子模块的所有修改：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule update --remote
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;使用子模块创建存储库&#34;&gt;使用子模块创建存储库：&lt;/h4&gt;
&lt;p&gt;向一个父存储库添加子树：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule add &amp;lt;URL to Git repo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初始化一个已存在的 Git 子模块：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你也可以通过为 &lt;code&gt;submodule update&lt;/code&gt; 命令添加 &lt;code&gt;--update&lt;/code&gt; 参数在子模块中创建分支和追踪提交：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule update --remote
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;更新子模块的提交&#34;&gt;更新子模块的提交&lt;/h4&gt;
&lt;p&gt;上面提到过，一个子模块就是一个指向子树中某次提交的链接。如果你想更新子模块的提交，不要担心。你不需要显式地指定最新的提交。你只需要使用通用的 &lt;code&gt;submodule update&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git submodule update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就像你平时创建父存储库和把父存储库推送到 GitHub 那样添加和提交就可以了。&lt;/p&gt;
&lt;h4 id=&#34;从一个父存储库中删除一个子模块&#34;&gt;从一个父存储库中删除一个子模块&lt;/h4&gt;
&lt;p&gt;仅仅手动删除一个子项目文件夹不会从父项目中移除这个子项目。想要删除名为 &lt;code&gt;childmodule&lt;/code&gt; 的子模块，使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git rm -f childmodule
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然 Git 子模块看起来很容易上手，但是对于初学者来说，有一定的使用门槛。&lt;/p&gt;
&lt;h3 id=&#34;git-子树是什么&#34;&gt;Git 子树是什么？&lt;/h3&gt;
&lt;p&gt;Git 子树 subtree&lt;!-- raw HTML omitted --&gt;子树&lt;!-- raw HTML omitted --&gt; subtree&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，是在 Git 1.7.11 引入的，让你可以把任何存储库的副本作为子目录嵌入另一个存储库中。它是 Git 项目可以注入和管理项目依赖的几种方法之一。它在常规的提交中保存了外部依赖信息。Git 子树提供了整洁的集成点，因此很容易复原它们。&lt;/p&gt;
&lt;p&gt;如果你参考 &lt;a class=&#34;link&#34; href=&#34;https://help.github.com/en/github/using-git/about-git-subtree-merges&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 提供的子树教程&lt;/a&gt;来使用子树，那么无论你什么时候添加子树，在本地都不会看到 &lt;code&gt;.gittrees&lt;/code&gt; 配置文件。这让我们很难分辨哪个是子树，因为它们看起来很像普通的文件夹，但是它们却是子树的副本。默认的 Git 包中不提供带 &lt;code&gt;.gittrees&lt;/code&gt; 配置文件的 Git 子树版本，因此如果你想要带 &lt;code&gt;.gittrees&lt;/code&gt; 配置文件的 git-subtree 命令，必须从 Git 源码存储库的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/git/git/tree/master/contrib/subtree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;/contrib/subtree 文件夹&lt;/a&gt; 下载 git-subtree。&lt;/p&gt;
&lt;p&gt;你可以像克隆其他常规的存储库那样克隆任何含有子树的存储库，但由于在父存储库中有整个子树的副本，因此克隆过程可能会持续很长时间。&lt;/p&gt;
&lt;p&gt;你可以用下面的命令在你的存储库中使用 Git 子树。&lt;/p&gt;
&lt;h4 id=&#34;向父存储库中添加一个子树&#34;&gt;向父存储库中添加一个子树&lt;/h4&gt;
&lt;p&gt;想要向父存储库中添加一个子树，首先你需要执行 &lt;code&gt;remote add&lt;/code&gt;，之后执行 &lt;code&gt;subtree add&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git remote add remote-name &amp;lt;URL to Git repo&amp;gt;
$ git subtree add --prefix=folder/ remote-name &amp;lt;URL to Git repo&amp;gt; subtree-branchname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的命令会把整个子项目的提交历史合并到父存储库。&lt;/p&gt;
&lt;h4 id=&#34;向子树推送修改以及从子树拉取修改&#34;&gt;向子树推送修改以及从子树拉取修改&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git subtree push-all
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ git subtree pull-all
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;你应该使用哪个&#34;&gt;你应该使用哪个？&lt;/h3&gt;
&lt;p&gt;任何工具都有优缺点。下面是一些可能会帮助你决定哪种最适合你的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 子模块的存储库占用空间更小，因为它们只是指向子项目的某次提交的链接，而 Git 子树保存了整个子项目及其提交历史。&lt;/li&gt;
&lt;li&gt;Git 子模块需要在服务器中可访问，但子树是去中心化的。&lt;/li&gt;
&lt;li&gt;Git 子模块大量用于基于组件的开发，而 Git 子树多用于基于系统的开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git 子树并不是 Git 子模块的直接可替代项。有明确的说明来指导我们该使用哪种。如果有一个归属于你的外部存储库，使用场景是向它回推代码，那么就使用 Git 子模块，因为推送代码更容易。如果你有第三方代码，且不会向它推送代码，那么使用 Git 子树，因为拉取代码更容易。&lt;/p&gt;
&lt;p&gt;自己尝试使用 Git 子树和子模块，然后在评论中留下你的使用感想。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/20/5/git-submodules-subtrees&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/20/5/git-submodules-subtrees&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/manaswinidas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Manaswini Das&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Go 1.14 中接口的菱形组合</title>
        <link>https://lxb.wiki/ace0b2ab/</link>
        <pubDate>Mon, 01 Jun 2020 21:00:20 +0000</pubDate>
        
        <guid>https://lxb.wiki/ace0b2ab/</guid>
        <description>&lt;p&gt;按照&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/6977-overlapping-interfaces.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;部分重叠的接口提议&lt;/a&gt;，Go 1.14 现在允许嵌入有部分方法重叠的接口。本文是一篇解释这次修改的简要说明。&lt;/p&gt;
&lt;p&gt;我们先来看 io 包中的三个关键接口：io.Reader、io.Writer 和 io.Closer：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Reader&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Writer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在结构体中嵌入类型时，如果在结构体中声明了被嵌入的类型，那么该类型的字段和方法允许被访问&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，对于接口来说这个处理也成立。因此下面两种方式：显式声明&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和使用嵌入来组成接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Reader&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;没有区别。&lt;/p&gt;
&lt;p&gt;你甚至可以混合使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WriteCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而，在 Go 1.14 之前，如果你用这种方式来声明接口，你可能会得到类似这样的结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadWriteCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadCloser&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;WriterCloser&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% Go build interfaces.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;command-line-arguments
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./interfaces.go:27:2: duplicate method Close
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;幸运的是，在 Go 1.14 中这不再是一个限制了，因此这个改动解决了在菱形嵌入时出现的问题。&lt;/p&gt;
&lt;p&gt;然而，在我向本地的用户组解释这个特性时也陷入了麻烦 — 只有 Go 编译器使用 1.14（或更高版本）语言规范时才支持这个特性。&lt;/p&gt;
&lt;p&gt;我理解的编译过程中 Go 语言规范所使用的版本的规则似乎是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你的源码是在 GOPATH 下（或者你用 GO111MODULE=off &lt;em&gt;关闭&lt;/em&gt;了 module），那么 Go 语言规范会使用你编译器的版本来编译。换句话说，如果安装了 Go 1.13，那么你的 Go 版本就是 1.13。如果你安装了 Go 1.14，那么你的版本就是 1.14。这里符合认知。&lt;/li&gt;
&lt;li&gt;如果你的源码保存在 GOPATH 外（或你用 GO111MODULE=on 强制开启了 module），那么 Go tool 会从 go.mod 文件中获取 Go 版本。&lt;/li&gt;
&lt;li&gt;如果 go.mod 中没有列出 Go 版本，那么语言规范会使用安装的 Go 的版本。这跟第 1 点是一致的。&lt;/li&gt;
&lt;li&gt;如果你用的是 Go module 模式，不管是源码在 GOPATH 外还是设置了 GO111MODULE=on，但是在当前目录或所有父目录中都没有 go.mod 文件，那么 Go 语言规范会默认用 Go 1.13 版本来编译你的代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我曾经遇到过第 4 点的情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dave Cheney&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;也就是说，嵌入提升了类型的字段和方法。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>【译】通过禁止比较让 Go 二进制文件变小</title>
        <link>https://lxb.wiki/27d7ea27/</link>
        <pubDate>Sat, 23 May 2020 12:24:34 +0000</pubDate>
        
        <guid>https://lxb.wiki/27d7ea27/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件就越大。这个符合直觉，毕竟如果你写的代码不去操作定义的类型，那么定义一堆类型就没有意义了。然而，链接器的部分工作就是检测没有被程序引用的函数（比如说它们是一个库的一部分，其中只有一个子集的功能被使用），然后把它们从最后的编译产出中删除。常言道，“类型越多，二进制文件越大”，对于多数 Go 程序还是正确的。&lt;/p&gt;
&lt;p&gt;本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/net/commit/e0ff5e5a1de5b859e2d48a2830d7933b3ab5b75f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;像这样&lt;/a&gt;的修改会对 Go 程序的大小有重大的影响。&lt;/p&gt;
&lt;h3 id=&#34;定义两个值相等&#34;&gt;定义两个值相等&lt;/h3&gt;
&lt;p&gt;Go 的语法定义了“赋值”和“相等”的概念。赋值是把一个值赋给一个标识符的行为。并不是所有声明的标识符都可以被赋值，如常量和函数就不可以。相等是通过检查标识符的内容是否相等来比较两个标识符的行为。&lt;/p&gt;
&lt;p&gt;作为强类型语言，“相同”的概念从根源上被植入标识符的类型中。两个标识符只有是相同类型的前提下，才有可能相同。除此之外，值的类型定义了如何比较该类型的两个值。&lt;/p&gt;
&lt;p&gt;例如，整型是用算数方法进行比较的。对于指针类型，是否相等是指它们指向的地址是否相同。映射和通道等引用类型，跟指针类似，如果它们指向相同的地址，那么就认为它们是相同的。&lt;/p&gt;
&lt;p&gt;上面都是按位比较相等的例子，即值占用的内存的位模式是相同的，那么这些值就相等。这就是所谓的 memcmp，即内存比较，相等是通过比较两个内存区域的内容来定义的。&lt;/p&gt;
&lt;p&gt;记住这个思路，我过会儿再来谈。&lt;/p&gt;
&lt;h3 id=&#34;结构体相等&#34;&gt;结构体相等&lt;/h3&gt;
&lt;p&gt;除了整型、浮点型和指针等标量类型，还有复合类型：结构体。所有的结构体以程序中的顺序被排列在内存中。因此下面这个声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type S struct {
    a, b, c, d int64
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会占用 32 字节的内存空间；&lt;code&gt;a&lt;/code&gt; 占用 8 个字节，&lt;code&gt;b&lt;/code&gt; 占用 8 个字节，以此类推。Go 的规则说如果结构体所有的字段都是可以比较的，那么结构体的值就是可以比较的。因此如果两个结构体所有的字段都相等，那么它们就相等。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a := S{1, 2, 3, 4}
b := S{1, 2, 3, 4}
fmt.Println(a == b) // 输出 true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器在底层使用 memcmp 来比较 &lt;code&gt;a&lt;/code&gt; 的 32 个字节和 &lt;code&gt;b&lt;/code&gt; 的 32 个字节。&lt;/p&gt;
&lt;h3 id=&#34;填充和对齐&#34;&gt;填充和对齐&lt;/h3&gt;
&lt;p&gt;然而，在下面的场景下过分简单化的按位比较的策略会返回错误的结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type S struct {
    a byte
    b uint64
    c int16
    d uint32
}

func main()
    a := S{1, 2, 3, 4}
    b := S{1, 2, 3, 4}
    fmt.Println(a == b) // 输出 true
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译代码后，这个比较表达式的结果还是 &lt;code&gt;true&lt;/code&gt;，但是编译器在底层并不能仅依赖比较 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的位模式，因为结构体有&lt;em&gt;填充&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;Go 要求结构体的所有字段都对齐。2 字节的值必须从偶数地址开始，4 字节的值必须从 4 的倍数地址开始，以此类推。编译器根据字段的类型和底层平台加入了填充来确保字段都&lt;em&gt;对齐&lt;/em&gt;。在填充之后，编译器实际上看到的是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type S struct {
    a byte
    _ [7]byte // 填充
    b uint64
    c int16
    _ [2]int16 // 填充
    d uint32
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;填充的存在保证了字段正确对齐，而填充确实占用了内存空间，但是填充字节的内容是未知的。你可能会认为在 Go 中 填充字节都是 0，但实际上并不是 — 填充字节的内容是未定义的。由于它们并不是被定义为某个确定的值，因此按位比较会因为分布在 &lt;code&gt;s&lt;/code&gt; 的 24 字节中的 9 个填充字节不一样而返回错误结果。&lt;/p&gt;
&lt;p&gt;Go 通过生成所谓的相等函数来解决这个问题。在这个例子中，&lt;code&gt;s&lt;/code&gt; 的相等函数只比较函数中的字段略过填充部分，这样就能正确比较类型 &lt;code&gt;s&lt;/code&gt; 的两个值。&lt;/p&gt;
&lt;h3 id=&#34;类型算法&#34;&gt;类型算法&lt;/h3&gt;
&lt;p&gt;呵，这是个很大的设置，说明了为什么，对于 Go 程序中定义的每种类型，编译器都会生成几个支持函数，编译器内部把它们称作类型的算法。如果类型是一个映射的键，那么除相等函数外，编译器还会生成一个哈希函数。为了维持稳定，哈希函数在计算结果时也会像相等函数一样考虑诸如填充等因素。&lt;/p&gt;
&lt;p&gt;凭直觉判断编译器什么时候生成这些函数实际上很难，有时并不明显，（因为）这超出了你的预期，而且链接器也很难消除没有被使用的函数，因为反射往往导致链接器在裁剪类型时变得更保守。&lt;/p&gt;
&lt;h3 id=&#34;通过禁止比较来减小二进制文件的大小&#34;&gt;通过禁止比较来减小二进制文件的大小&lt;/h3&gt;
&lt;p&gt;现在，我们来解释一下 Brad 的修改。向类型添加一个不可比较的字段，结构体也随之变成不可比较的，从而强制编译器不再生成相等函数和哈希函数，规避了链接器对那些类型的消除，在实际应用中减小了生成的二进制文件的大小。作为这项技术的一个例子，下面的程序：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
    type t struct {
        // _ [0][]byte // 取消注释以阻止比较
        a byte
        b uint16
        c int32
        d uint64
    }
    var a t
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用 Go 1.14.2（darwin/amd64）编译，大小从 2174088 降到了 2174056，节省了 32 字节。单独看节省的这 32 字节似乎微不足道，但是考虑到你的程序中每个类型及其传递闭包都会生成相等和哈希函数，还有它们的依赖，这些函数的大小随类型大小和复杂度的不同而不同，禁止它们会大大减小最终的二进制文件的大小，效果比之前使用 &lt;code&gt;-ldflags=&amp;quot;-s -w&amp;quot;&lt;/code&gt; 还要好。&lt;/p&gt;
&lt;p&gt;最后总结一下，如果你不想把类型定义为可比较的，可以在源码层级强制实现像这样的奇技淫巧，会使生成的二进制文件变小。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/author/davecheney&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dave Cheney&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Go：异步抢占</title>
        <link>https://lxb.wiki/5698ca18/</link>
        <pubDate>Tue, 05 May 2020 15:24:46 +0000</pubDate>
        
        <guid>https://lxb.wiki/5698ca18/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/00.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ℹ️ 本文基于 Go 1.14。&lt;/p&gt;
&lt;p&gt;抢占是调度器的重要部分，基于抢占调度器可以在各个协程中分配运行的时间。实际上，如果没有抢占机制，一个长时间占用 CPU 的协程会阻塞其他的协程被调度。1.14 版本引入了一项新的异步抢占的技术，赋予了调度器更大的能力和控制力。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我推荐你阅读我的文章&lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”Go：协程和抢占“&lt;/a&gt;来了解更多之前的特性和它的弊端。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;工作流&#34;&gt;工作流&lt;/h2&gt;
&lt;p&gt;我们以一个需要抢占的例子来开始。下面一段代码开启了几个协程，在几个循环中没有其他的函数调用，意味着调度器没有机会抢占它们：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然而，当把这个程序的追踪过程可视化后，我们清晰地看到了协程间的抢占和切换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们还可以看到表示协程的每个块儿的长度都相等。所有的协程运行时间相同（约 10 到 20 毫秒）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/03.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;异步抢占是基于一个时间条件触发的。当一个协程运行超过 10ms 时，Go 会尝试抢占它。&lt;/p&gt;
&lt;p&gt;抢占是由线程 &lt;code&gt;sysmon&lt;/code&gt; 初始化的，该线程专门用于监控包括长时间运行的协程在内的运行时。当某个协程被检测到运行超过 10ms 后，&lt;code&gt;sysmon&lt;/code&gt; 向当前的线程发出一个抢占信号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;之后，当信息被信号处理器接收到时，线程中断当前的操作来处理信号，因此不会再运行当前的协程，在我们的例子中是 &lt;code&gt;G7&lt;/code&gt;。取而代之的是，&lt;code&gt;gsignal&lt;/code&gt; 被调度为管理发送来的信号。当它发现它是一个抢占指令后，在程序处理信号后恢复时它准备好指令来中止当前的协程。下面是这第二个阶段的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/05.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你想了解更多关于 &lt;code&gt;gsignal&lt;/code&gt; 的信息，我推荐你读一下我的文章&lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-gsignal-master-of-signals-329f7ff39391&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”Go：gsignal，信号的掌控者“&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;我们在被选中的信号 &lt;code&gt;SIGURG&lt;/code&gt; 中第一次看到了实现的细节。这个选择在提案&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”提案：非合作式协程抢占“&lt;/a&gt;中有详细的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;它应该是调试者默认传递过来的一个信号。&lt;/li&gt;
&lt;li&gt;它不应该是 Go/C 混合二进制中 libc 内部使用的信号。&lt;/li&gt;
&lt;li&gt;它应该是一个可以伪造而没有其他后果的信号。&lt;/li&gt;
&lt;li&gt;我们需要在没有实时信号时与平台打交道。
然后，当信号被注入和接收时，Go 需要一种在程序恢复时能终止当前协程的方式。为了实现这个过程，Go 会把一条指令推进程序计数器，这样看起来运行中的程序调用了运行时的函数。该函数暂停了协程并把它交给了调度器，调度器之后还会运行其他的协程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;我们应该注意到 Go 不能做到在任何地方终止程序；当前的指令必须是一个安全点。例如，如果程序现在正在调用运行时，那么抢占协程并不安全，因为运行时很多函数不应该被抢占。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个新的抢占机制也让垃圾回收器受益，可以用更高效的方式终止所有的协程。诚然，STW 现在非常容易，Go 仅需要向所有运行的线程发出一个信号就可以了。下面是垃圾回收器运行时的一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/06.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后，所有的线程都接收到这个信号，在垃圾回收器重新开启全局之前会暂停执行。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你想了解更多关于 STW 的信息，我建议你阅读我的文章&lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”Go：Go 怎样实现 STW？“&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最后，这个特性被封装在一个参数中，你可以用这个参数关闭异步抢占。你可以用 &lt;code&gt;GODEBUG=asyncpreemptoff=1&lt;/code&gt; 来运行你的程序，如果你因为升级到了 Go 1.14 发现了不正常的现象就可以调试你的程序，或者观察你的程序有无异步抢占时的不同表现。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@blanchon.vincent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Vincent Blanchon&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Inlining Optimisations in Go</title>
        <link>https://lxb.wiki/6ce34c49/</link>
        <pubDate>Wed, 29 Apr 2020 21:05:10 +0000</pubDate>
        
        <guid>https://lxb.wiki/6ce34c49/</guid>
        <description>&lt;h1 id=&#34;go-中的内联优化&#34;&gt;Go 中的内联优化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文讨论 Go 编译器是如何实现内联的，以及这种优化方法如何影响你的 Go 代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*请注意：*本文重点讨论 &lt;em&gt;gc&lt;/em&gt;，这是来自 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;golang.org&lt;/a&gt; 的事实标准的 Go 编译器。讨论到的概念可以广泛适用于其它 Go 编译器，如 gccgo 和 llgo，但它们在实现方式和功效上可能有所差异。&lt;/p&gt;
&lt;h3 id=&#34;内联是什么&#34;&gt;内联是什么？&lt;/h3&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;内联&lt;!-- raw HTML omitted --&gt;inlining&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经成为编译过程中自动实现的基本优化过程的其中一步。&lt;/p&gt;
&lt;h3 id=&#34;为什么内联很重要&#34;&gt;为什么内联很重要？&lt;/h3&gt;
&lt;p&gt;有两个原因。第一个是它消除了函数调用本身的开销。第二个是它使得编译器能更高效地执行其他的优化策略。&lt;/p&gt;
&lt;h4 id=&#34;函数调用的开销&#34;&gt;函数调用的开销&lt;/h4&gt;
&lt;p&gt;在任何语言中，调用一个函数 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 都会有消耗。把参数编组进寄存器或放入栈中（取决于 ABI），在返回结果时的逆反过程都会有开销。引入一次函数调用会导致程序计数器从指令流的一点跳到另一点，这可能导致管道滞后。函数内部通常有&lt;!-- raw HTML omitted --&gt;前置处理&lt;!-- raw HTML omitted --&gt;preamble&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，需要为函数执行准备新的栈帧，还有与前置相似的&lt;!-- raw HTML omitted --&gt;后续处理&lt;!-- raw HTML omitted --&gt;epilogue&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，需要在返回给调用方之前释放栈帧空间。&lt;/p&gt;
&lt;p&gt;在 Go 中函数调用会消耗额外的资源来支持栈的动态增长。在进入函数时，goroutine 可用的栈空间与函数需要的空间大小进行比较。如果可用空间不同，前置处理就会跳到&lt;!-- raw HTML omitted --&gt;运行时&lt;!-- raw HTML omitted --&gt;runtime&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;的逻辑中，通过把数据复制到一块新的、更大的空间的来增长栈空间。当这个复制完成后，运行时就会跳回到原来的函数入口，再执行栈空间检查，现在通过了检查，函数调用继续执行。这种方式下，goroutine 开始时可以申请很小的栈空间，在有需要时再申请更大的空间。&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;这个检查消耗很小，只有几个指令，而且由于 goroutine 的栈是成几何级数增长的，因此这个检查很少失败。这样，现代处理器的分支预测单元可以通过假定检查肯定会成功来隐藏栈空间检查的消耗。当处理器预测错了栈空间检查，不得不放弃它在推测性执行所做的操作时，与为了增加 goroutine 的栈空间运行时所需的操作消耗的资源相比，管道滞后的代价更小。&lt;/p&gt;
&lt;p&gt;虽然现代处理器可以用预测性执行技术优化每次函数调用中的泛型和 Go 特定的元素的开销，但那些开销不能被完全消除，因此在每次函数调用执行必要的工作过程中都会有性能消耗。一次函数调用本身的开销是固定的，与更大的函数相比，调用小函数的代价更大，因为在每次调用过程中它们做的有用的工作更少。&lt;/p&gt;
&lt;p&gt;因此，消除这些开销的方法必须是要消除函数调用本身，Go 的编译器就是这么做的，在某些条件下通过用函数的内容来替换函数调用来实现。这个过程被称为&lt;em&gt;内联&lt;/em&gt;，因为它在函数调用处把函数体展开了。&lt;/p&gt;
&lt;h4 id=&#34;改进的优化机会&#34;&gt;改进的优化机会&lt;/h4&gt;
&lt;p&gt;Cliff Click 博士把内联描述为现代编译器做的优化措施，像常量传播（LCTT 译注：此处作者笔误，原文为 constant proportion，修正为 constant propagation）和死代码消除一样，都是编译器的基本优化方法。实际上，内联可以让编译器看得更深，使编译器可以观察调用的特定函数的上下文内容，可以看到能继续简化或彻底消除的逻辑。由于可以递归地执行内联，因此不仅可以在每个独立的函数上下文处进行这种优化决策，也可以在整个函数调用链中进行。&lt;/p&gt;
&lt;h3 id=&#34;实践中的内联&#34;&gt;实践中的内联&lt;/h3&gt;
&lt;p&gt;下面这个例子可以演示内联的影响：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;testing&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//go:noinline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行这个基准，会得到如下结果：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% go test -bench&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;. 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkMax-4   &lt;span style=&#34;color:#ae81ff&#34;&gt;530687617&lt;/span&gt;         2.24 ns/op
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我的 2015 MacBook Air 上 &lt;code&gt;max(-1, i)&lt;/code&gt; 的耗时约为 2.24 纳秒。现在去掉 &lt;code&gt;//go:noinline&lt;/code&gt; 编译指令，再看下结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% go test -bench&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;. 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkMax-4   &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000000&lt;/span&gt;         0.514 ns/op
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从 2.24 纳秒降到了 0.51 纳秒，或者从 &lt;code&gt;benchstat&lt;/code&gt; 的结果可以看出，有 78% 的提升。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% benchstat &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;old,new&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name   old time/op  new time/op  delta
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Max-4  2.21ns ± 1%  0.49ns ± 6%  -77.96%  &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0.000 n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;18+19&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个提升是从哪儿来的呢？&lt;/p&gt;
&lt;p&gt;首先，移除掉函数调用以及与之关联的前置处理 &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 是主要因素。把 &lt;code&gt;max&lt;/code&gt; 函数的函数体在调用处展开，减少了处理器执行的指令数量并且消除了一些分支。&lt;/p&gt;
&lt;p&gt;现在由于编译器优化了 &lt;code&gt;BenchmarkMax&lt;/code&gt;，因此它可以看到 &lt;code&gt;max&lt;/code&gt; 函数的内容，进而可以做更多的提升。当 &lt;code&gt;max&lt;/code&gt; 被内联后，&lt;code&gt;BenchmarkMax&lt;/code&gt; 呈现给编译器的样子，看起来是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再运行一次基准，我们看一下手动内联的版本和编译器内联的版本的表现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% benchstat &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;old,new&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name   old time/op  new time/op  delta
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Max-4  2.21ns ± 1%  0.48ns ± 3%  -78.14%  &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0.000 n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;18+18&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在编译器能看到在 &lt;code&gt;BenchmarkMax&lt;/code&gt; 里内联 &lt;code&gt;max&lt;/code&gt; 的结果，可以执行以前不能执行的优化措施。例如，编译器注意到 &lt;code&gt;i&lt;/code&gt; 初始值为 &lt;code&gt;0&lt;/code&gt;，仅做自增操作，因此所有与 &lt;code&gt;i&lt;/code&gt; 的比较都可以假定 &lt;code&gt;i&lt;/code&gt; 不是负值。这样条件表达式 &lt;code&gt;-1 &amp;gt; i&lt;/code&gt; 永远不是 &lt;code&gt;true&lt;/code&gt;。&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;证明了 &lt;code&gt;-1 &amp;gt; i&lt;/code&gt; 永远不为 true 后，编译器可以把代码简化为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并且因为分支里是个常量，编译器可以通过下面的方式移除不会走到的分支：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，通过内联和由内联解锁的优化过程，编译器把表达式 &lt;code&gt;r = max(-1, i))&lt;/code&gt; 简化为 &lt;code&gt;r = i&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;内联的限制&#34;&gt;内联的限制&lt;/h3&gt;
&lt;p&gt;本文中我论述的内联称作&lt;!-- raw HTML omitted --&gt;叶子内联&lt;!-- raw HTML omitted --&gt;leaf inlining&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：把函数调用栈中最底层的函数在调用它的函数处展开的行为。内联是个递归的过程，当把函数内联到调用它的函数 A 处后，编译器会把内联后的结果代码再内联到 A 的调用方，这样持续内联下去。例如，下面的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMaxMaxMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与之前的例子中的代码运行速度一样快，因为编译器可以对上面的代码重复地进行内联，也把代码简化到 &lt;code&gt;r = i&lt;/code&gt; 表达式。&lt;/p&gt;
&lt;p&gt;下一篇文章中，我会论述当 Go 编译器想要内联函数调用栈中间的某个函数时选用的另一种内联策略。最后我会论述编译器为了内联代码准备好要达到的极限，这个极限 Go 现在的能力还达不到。&lt;/p&gt;
&lt;h4 id=&#34;相关文章&#34;&gt;相关文章：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使 Go 变快的 5 件事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;为什么 Goroutine 的栈空间会无限增长？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中怎么写基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中隐藏的编译指令&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/author/davecheney&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dave Cheney&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
&lt;p&gt;[3]: tmp.gBQ2tEtMHc#easy-footnote-bottom-2-4053 &amp;ldquo;Up until Go 1.14 the stack check preamble was also used by the garbage collector to stop the world by setting all active goroutine’s stacks to zero, forcing them to trap into the runtime the next time they made a function call. This system was &lt;!-- raw HTML omitted --&gt;recently replaced&lt;!-- raw HTML omitted --&gt; with a mechanism which allowed the runtime to pause an goroutine without waiting for it to make a function call.&amp;rdquo;
[4]: tmp.gBQ2tEtMHc#easy-footnote-bottom-3-4053 &amp;ldquo;I’m using the &lt;!-- raw HTML omitted --&gt;//go:noinline&lt;!-- raw HTML omitted --&gt; pragma to prevent the compiler from inlining &lt;!-- raw HTML omitted --&gt;max&lt;!-- raw HTML omitted --&gt;. This is because I want to isolate the effects of inlining on &lt;!-- raw HTML omitted --&gt;max&lt;!-- raw HTML omitted --&gt; rather than disabling optimisations globally with &lt;!-- raw HTML omitted --&gt;-gcflags=&amp;rsquo;-l -N&amp;rsquo;&lt;!-- raw HTML omitted --&gt;. I go into detail about the &lt;!-- raw HTML omitted --&gt;//go:&lt;!-- raw HTML omitted --&gt; comments in &lt;!-- raw HTML omitted --&gt;this presentation&lt;!-- raw HTML omitted --&gt;.&amp;rdquo;
[5]: tmp.gBQ2tEtMHc#easy-footnote-bottom-4-4053 &amp;ldquo;You can check this for yourself by comparing the output of &lt;!-- raw HTML omitted --&gt;go test -bench=. -gcflags=-S&lt;!-- raw HTML omitted --&gt; with and without the &lt;!-- raw HTML omitted --&gt;//go:noinline&lt;!-- raw HTML omitted --&gt; annotation.&amp;rdquo;
[6]: tmp.gBQ2tEtMHc#easy-footnote-bottom-5-4053 &amp;ldquo;You can check this yourself with the &lt;!-- raw HTML omitted --&gt;-gcflags=-d=ssa/prove/debug=on&lt;!-- raw HTML omitted --&gt; flag.&amp;rdquo;
[7]: tmp.gBQ2tEtMHc#easy-footnote-1-4053
[8]: &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md&lt;/a&gt;
[9]: tmp.gBQ2tEtMHc#easy-footnote-2-4053
[10]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&lt;/a&gt;
[11]: tmp.gBQ2tEtMHc#easy-footnote-3-4053
[12]: tmp.gBQ2tEtMHc#easy-footnote-4-4053
[13]: tmp.gBQ2tEtMHc#easy-footnote-5-4053
[14]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&lt;/a&gt; &amp;ldquo;Five things that make Go fast&amp;rdquo;
[15]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&lt;/a&gt; &amp;ldquo;Why is a Goroutine’s stack infinite ?&amp;rdquo;
[16]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&lt;/a&gt; &amp;ldquo;How to write benchmarks in Go&amp;rdquo;
[17]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&lt;/a&gt; &amp;ldquo;Go’s hidden #pragmas&amp;rdquo;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;在 Go 1.14 以前，栈检查的前置处理也被垃圾回收器用于 STW，通过把所有活跃的 goroutine 栈空间设为 0，来强制它们切换为下一次函数调用时的运行时状态。这个机制[最近被替换][8]为一种新机制，新机制下运行时可以不用等 goroutine 进行函数调用就可以暂停 goroutine。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;我用 &lt;code&gt;//go:noinline&lt;/code&gt; 编译指令来阻止编译器内联 &lt;code&gt;max&lt;/code&gt;。这是因为我想把内联 &lt;code&gt;max&lt;/code&gt; 的影响与其他影响隔离开，而不是用 &lt;code&gt;-gcflags=&#39;-l -N&#39;&lt;/code&gt; 选项在全局范围内禁止优化。关于 &lt;code&gt;//go:&lt;/code&gt; 注释在[这篇文章][10]中详细论述。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;你可以自己通过比较 &lt;code&gt;go test -bench=. -gcflags=-S&lt;/code&gt; 有无 &lt;code&gt;//go:noinline&lt;/code&gt; 注释时的不同结果来验证一下。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;你可以用 &lt;code&gt;-gcflags=-d=ssa/prove/debug=on&lt;/code&gt; 选项来自己验证一下。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>【译】关于 CGo 的字符串函数的解释</title>
        <link>https://lxb.wiki/8c45788a/</link>
        <pubDate>Sun, 09 Feb 2020 20:55:26 +0000</pubDate>
        
        <guid>https://lxb.wiki/8c45788a/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/wiki/cgo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cgo&lt;/a&gt; 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。在 CGo 的文档中有简洁的解释，但我认为解释得太简洁了，因为文档只涉及了定义中的某些特定字符串，而忽略了两个很重要的注意事项。我曾经踩过这里的坑，现在我要详细解释一下。&lt;/p&gt;
&lt;p&gt;四个函数分别是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CString&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoString&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoStringN&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoBytes&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;C.CString()&lt;/code&gt; 等价于 C 的 &lt;code&gt;strdup()&lt;/code&gt;，像文档中提到的那样，把 Go 的字符串复制为可以传递给 C 函数的 C 的 &lt;code&gt;char *&lt;/code&gt;。很讨厌的一件事是，由于 Go 和 CGo 类型的定义方式，调用 &lt;code&gt;C.free&lt;/code&gt; 时需要做一个转换：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CString&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a string&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;free&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请留意，Go 字符串中可能嵌入了 &lt;code&gt;\0&lt;/code&gt; 字符，而 C 字符串不会。如果你的 Go 字符串中有 &lt;code&gt;\0&lt;/code&gt; 字符，当你调用 &lt;code&gt;C.CString()&lt;/code&gt; 时，C 代码会从 &lt;code&gt;\0&lt;/code&gt; 字符处截断你的字符串。这往往不会被注意到，但&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;有时文本并不保证不含 null 字符&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoString()&lt;/code&gt; 也等价于 &lt;code&gt;strdup()&lt;/code&gt;，但与 &lt;code&gt;C.CString()&lt;/code&gt; 相反，是把 C 字符串转换为 Go 字符串。你可以用它定义结构体的字段，或者是声明为 C 的 &lt;code&gt;char *&lt;/code&gt;（在 Go 中叫 &lt;code&gt;*C.cahr&lt;/code&gt;） 的其他变量，抑或其他的一些变量（我们后面会看到）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoStringN()&lt;/code&gt; 等价于 C 的 &lt;code&gt;memmove()&lt;/code&gt;，与 C 中普通的字符串函数不同。**它把整个 N 长度的 C buffer 复制为一个 Go 字符串，不单独处理 null 字符。**再详细点，它也通过复制来实现。如果你有一个定义为 &lt;code&gt;char feild[64]&lt;/code&gt; 的结构体的字段，然后调用了 &lt;code&gt;C.GoStringN(&amp;amp;field, 64)&lt;/code&gt;，那么你得到的 Go 字符串一定是 64 个字符，字符串的末尾有可能是一串 &lt;code&gt;\0&lt;/code&gt; 字符。&lt;/p&gt;
&lt;p&gt;(我认为这是 cgo 文档中的一个 bug。它宣称 GoStringN 的入参是一个 C 的字符串，但实际上很明显不是，因为 C 的字符串不能以 null 字符结束，而 GoStringN 不会在 null 字符处结束处理。)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoBytes()&lt;/code&gt; 是 &lt;code&gt;C.GoStringN()&lt;/code&gt; 的另一个版本，不返回 &lt;code&gt;string&lt;/code&gt; 而是返回 &lt;code&gt;[]byte&lt;/code&gt;。它没有宣称以 C 字符串作为入参，它仅仅是对整个 buffer 做了内存拷贝。&lt;/p&gt;
&lt;p&gt;如果你要拷贝的东西不是以 null 字符结尾的 C 字符串，而是固定长度的 memory buffer，那么 &lt;code&gt;C.GoString()&lt;/code&gt; 正好能满足需求；它避开了 C 中传统的问题&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;处理不是 C 字符串的 ’string‘&lt;/a&gt;。然而，如果你要处理定义为 &lt;code&gt;char field[N]&lt;/code&gt; 的结构体字段这种限定长度的 C 字符串时，这些函数&lt;em&gt;都不能&lt;/em&gt;满足需求。&lt;/p&gt;
&lt;p&gt;传统语义的结构体中固定长度的字符串变量，定义为 &lt;code&gt;char field[N]&lt;/code&gt; 的字段，以及“包含一个字符串”等描述，都表示当且仅当字符串有足够空间时以 null 字符结尾，换句话说，字符串最多有 N-1 个字符。如果字符串正好有 N 个字符，那么它不会以 null 字符结尾。这是 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/UnixAPIMistake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C 代码中诸多 bug 的根源&lt;/a&gt;，也不是一个好的 API，但我们却摆脱不了这个 API。每次我们遇到这样的字段，文档不会明确告诉你字段的内容并不一定是 null 字符结尾的，你需要自己假设你有这种 API。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoString()&lt;/code&gt; 或 &lt;code&gt;C.GoStringN()&lt;/code&gt; 都不能正确处理这些字段。使用 &lt;code&gt;GoStringN()&lt;/code&gt; 相对来说出错更少；它仅仅返回一个末尾有一串 &lt;code&gt;\0&lt;/code&gt; 字符长度为 N 的 Go 字符串（如果你仅仅是把这些字段打印出来，那么你可能不会留意到；我经常干这种事）。使用有诱惑力的 &lt;code&gt;GoString()&lt;/code&gt; 更是引狼入室，因为它内部会对入参做 &lt;code&gt;strlen()&lt;/code&gt;；如果字符末尾没有 null 字符，&lt;code&gt;strlen()&lt;/code&gt; 会访问越界的内存地址。如果你走运，你得到的 Go 字符串末尾会有大量的垃圾。如果你不走运，你的 Go 程序出现段错误，因为 &lt;code&gt;strlen()&lt;/code&gt; 访问了未映射的内存地址。&lt;/p&gt;
&lt;p&gt;（总的来说，如果字符串末尾出现了大量垃圾，通常意味着在某处有不含结束符的 C 字符串。）&lt;/p&gt;
&lt;p&gt;你需要的是与 C 的 &lt;code&gt;strndup()&lt;/code&gt; 等价的 Go 函数，以此来确保复制不超过 N 个字符且在 null 字符处终止。下面是我写的版本，不保证无错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strndup&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoStringN&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.int(&lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strings&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IndexByte&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于有 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 的字符串怎样占用内存&lt;/a&gt;的问题，这段代码做了些额外的工作来最小化额外的内存占用。你可能想用另一种方法，返回一个 &lt;code&gt;GoStringN()&lt;/code&gt; 字符串的切片。你也可以写复杂的代码，根据 i 和 len 的不同来决定选用哪种方法。&lt;/p&gt;
&lt;p&gt;更新：&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/12428#issuecomment-136581154&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ian Lance Taylor 给我展示了份更好的代码&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strndup&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoStringN&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.int(&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;strnlen&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size_t&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是的，这里有大量的转换。这篇文章就是你看到的 Go 和 Gco 类型的结合。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ChrisSiebenmann&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Go 字符串中的潜在问题</title>
        <link>https://lxb.wiki/10e5e8ba/</link>
        <pubDate>Fri, 17 Jan 2020 00:12:58 +0000</pubDate>
        
        <guid>https://lxb.wiki/10e5e8ba/</guid>
        <description>&lt;p&gt;在我之前的文章 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中我喜欢的东西&lt;/a&gt;中提到过，我喜欢的 &lt;a class=&#34;link&#34; href=&#34;https://golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go&lt;/a&gt; 的东西其中之一就是它的字符串（通常还有切片）。从一个 Python 开发者的角度看，它们之所以伟大，是因为创建它们时开销很少，因为它们通常不需要复制。在 Python 中，任何时候操作字符串都需要复制一部分或全部字符串，而 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/python/StringSpeedSurprises&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这很容易对性能造成影响&lt;/a&gt;。想要写高性能的 Python 代码需要谨慎考虑复制的问题。在 Go 中，几乎所有的字符串操作都是不复制的，仅仅是从原字符串取一个子集（例如去除字符串首尾的空白字符），因此你可以更自由地操作字符串。这个机制可以非常直接地解决你的问题，并且非常高效。&lt;/p&gt;
&lt;p&gt;（当然，不是所有的字符串操作都不复制。例如，把一个字符串转换成大写需要复制，尽管 Go 中的实现已经足够智能，在不需要改变原字符串时 — 例如由于它已经是一个全大写的字符串 — 可以规避掉复制。）&lt;/p&gt;
&lt;p&gt;但是这个优势也带来了潜在的坏处，那些没有开销的子字符串使原来的整个字符串一直存在于内存中。Go 中的字符串（和切片）操作之所以内存开销很少，是因为它们只是底层存储（字符串或切片底层的数组的真实数据）的一些部分的引用；创建一个字符串做的操作就是创建了一个新的引用。但是 Go（目前）不会对字符串数据或数组进行部分的垃圾回收，所以即使它一个很小的 bit 被其它元素引用，整个对象也会一直保持在内存中。换句话说，一个单字符的字符串（目前）足够让一个巨大的字符串不被 GC 回收。&lt;/p&gt;
&lt;p&gt;当然，不会有很多人遇到这个问题。为了遇到它，你需要处理一个非常庞大的原字符串，或造成大量的内存消耗（或者两者都做），在这个基础上，你必须创建那些不持久的字符串的持久的小子字符串（好吧，你是多么希望它是非持久的）。很多使用场景不会复现这个问题；要么你的原字符串不够大，要么你的子集获取了大部分原字符串（例如你把原字符串进行了分词处理），要么子字符串生命周期不够长。简而言之，如果你是一个普通的 Go 开发者，你可以忽略这个问题。处理长字符串并且长时间维持原字符串的很小部分的人才会关注这个问题。&lt;/p&gt;
&lt;p&gt;（我之所以关注到这个问题，是因为一次我花了大量精力用尽可能少的内存写 Python 程序，尽管它是从一个大的配置文件解析结果然后分块储存。这让我联想到了一些其他的事，如字符串的生命周期、限制字符串只复制一次，等等。然后我用 Go 语言写了一个解析器，这让我由重新考虑了一下这些问题，我意识到由于我的解析器截取出和维持的 bit 一直存在于内存中，从输入文件解析出的庞大字符串也会一直存在与内存中。）&lt;/p&gt;
&lt;p&gt;顺便说一下，我认为这是 Go 做了权衡之后的正确结果。大部分使用字符串的开发者不会遇到这个问题，而且截取子字符串开销很小对于开发者来说用处很大。这种低开销的截取操作也减轻了 GC 的负担；当代码使用大量的子字符串截取（像 Python 中那样）时，你只需要处理固定长度的字符串引用就可以了，而不是需要处理长度变化的字符串。&lt;/p&gt;
&lt;p&gt;当你的代码遇到这个问题时，当然有明显的解决方法：创建一个函数，通过把字符串转换成 &lt;code&gt;[]byte&lt;/code&gt; 来 ”最小化“ 字符串，然后返回。这种方法生成了一个最小化的字符串，内存开销是理论上最完美实现的只复制一次，而 Go 现在很容易就可以实现。&lt;/p&gt;
&lt;h2 id=&#34;附加问题stringstoupper-等怎样规避没有必要的复制&#34;&gt;附加问题：&lt;code&gt;strings.ToUpper()&lt;/code&gt; 等怎样规避没有必要的复制&lt;/h2&gt;
&lt;p&gt;所有的主动转换函数像 &lt;code&gt;ToUpper()&lt;/code&gt; 和 &lt;code&gt;ToTitle()&lt;/code&gt; 是用 &lt;code&gt;strings.Map()&lt;/code&gt; 和 &lt;a class=&#34;link&#34; href=&#34;http://golang.org/pkg/unicode/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;unicode 包&lt;/a&gt; 中的函数实现的。&lt;code&gt;Map()&lt;/code&gt; 足够智能，在映射的函数返回一个与已存在的 &lt;code&gt;rune&lt;/code&gt; 不同的结果之前不会创建新的字符串。因此，你代码中所有类似的直接使用 &lt;code&gt;Map()&lt;/code&gt; 的地方都不会有内存开销。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Chris Siebenmann&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lxbwolf&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/%e6%a0%a1%e5%af%b9%e8%80%85ID&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;校对者ID&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】微服务中的熔断器和重试</title>
        <link>https://lxb.wiki/c9399f4/</link>
        <pubDate>Thu, 12 Dec 2019 23:02:17 +0000</pubDate>
        
        <guid>https://lxb.wiki/c9399f4/</guid>
        <description>&lt;p&gt;今天我们来讨论微服务架构中的自我恢复能力。通常情况下，服务间会通过同步或异步的方式进行通信。我们假定把一个庞大的系统分解成一个个的小块能将各个服务解耦。管理服务内部的通信可能有点困难了。你可能听说过这两个著名的概念：熔断和重试。&lt;/p&gt;
&lt;h2 id=&#34;熔断器&#34;&gt;熔断器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204010211.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;想象一个简单的场景：用户发出的请求访问服务 A 随后访问另一个服务 B。我们可以称 B 是 A 的依赖服务或下游服务。到服务 B 的请求在到达各个实例前会先通过负载均衡器。&lt;/p&gt;
&lt;p&gt;后端服务发生系统错误的原因有很多，例如慢查询、network blip 和内存争用。在这种场景下，如果返回 A 的 response 是 timeout 和 server error，我们的用户会再试一次。在混乱的局面中我们怎样来保护下游服务呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204010301.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;熔断器可以让我们对失败率和资源有更好的控制。熔断器的设计思路是不等待 TCP 的连接 timeout 快速且优雅地处理 error。这种 fail fast 机制会保护下游的那一层。这种机制最重要的部分就是立刻向调用方返回 response。没有被 pending request 填充的线程池，没有 timeout，而且极有可能烦人的调用链中断者会更少。此外，下游服务也有了充足的时间来恢复服务能力。完全杜绝错误很难，但是减小失败的影响范围是有可能的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011033.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;通过 hystrix 熔断器，我们可以采用降级方案，对上游返回降级后的结果。例如，服务 B 可以访问一个备份服务或 cache，不再访问原来的服务 C。引入这种降级方案需要集成测试，因为我们在 happy path（译注：所谓 happy path，即测试方法的默认场景，没有异常和错误信息。具体可参见 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Happy_path&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wikipedia&lt;/a&gt;）可能不会遇到这种网络模式。&lt;/p&gt;
&lt;h2 id=&#34;状态&#34;&gt;状态&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011142.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;熔断器有三个主要的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Closed：让所有请求都通过的默认状态。在阈值下的请求不管成功还是失败，熔断器的状态都不会改变。可能出现的错误是 &lt;strong&gt;Max Concurrency&lt;/strong&gt;（最大并发数）和 &lt;strong&gt;Timeout&lt;/strong&gt;（超时）。&lt;/li&gt;
&lt;li&gt;Open：所有的请求都会返回 &lt;strong&gt;Circuit Open&lt;/strong&gt; 错误并被标记为失败。这是一种不等待处理结束的 timeout 时间的 fail-fast 机制。&lt;/li&gt;
&lt;li&gt;Half Open：周期性地向下游服务发出请求，检查它是否已恢复。如果下游服务已恢复，熔断器切换到 Closed 状态，否则熔断器保持 Open 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;熔断器原理&#34;&gt;熔断器原理&lt;/h2&gt;
&lt;p&gt;控制熔断的设置共有 5 个主要参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// CommandConfig is used to tune circuit settings at runtime
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CommandConfig&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Timeout&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;timeout&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;MaxConcurrentRequests&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;max_concurrent_requests&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;RequestVolumeThreshold&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;request_volume_threshold&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;SleepWindow&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;sleep_window&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;ErrorPercentThreshold&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;error_percent_threshold&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/aladine/18b38b37f838c1938131f67da0648e92/raw/8f97b8ef0b796ea5355b8f895b4009adfe472668/command.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;查看源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以通过根据两个服务的 SLA（‎ Service Level Agreement，&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/zh-hans/%e6%9c%8d%e5%8a%a1%e7%ba%a7%e5%88%ab%e5%8d%8f%e8%ae%ae&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;服务级别协议&lt;/a&gt;）来定出阈值。如果在测试时把依赖的其他服务也涉及到了，这些值会得到很好的调整。&lt;/p&gt;
&lt;p&gt;一个好的熔断器的名字应该能精确指出哪个服务连接出了问题。实际上，请求一个服务时可能会有很多个 API endpoint。每一个 endpoint 都应该有一个对应的熔断器。&lt;/p&gt;
&lt;h2 id=&#34;生产上的熔断器&#34;&gt;生产上的熔断器&lt;/h2&gt;
&lt;p&gt;熔断器通常被放在聚合点上。尽管熔断器提供了一种 fail-fast 机制，但我们仍然需要确保可选的降级方案可行。如果我们因为假定需要降级方案的场景出现的可能性很小就不去测试它，那（之前的努力）就是白费力气了。即使在最简单的演练中，我们也要确保阈值是有意义的。以我的个人经验，把参数配置在 log 中 print 出来对于 debug 很有帮助。&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;这段实例代码用的是 &lt;a class=&#34;link&#34; href=&#34;http://github.com/afex/hystrix-go/hystrix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hystrix-go&lt;/a&gt; 库，hystrix Netflix 库在 Golang 的实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;errors&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/afex/hystrix-go/hystrix&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;commandName&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;producer_api&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;hystrix&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ConfigureCommand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;commandName&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hystrix&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CommandConfig&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Timeout&lt;/span&gt;:                &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;MaxConcurrentRequests&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;ErrorPercentThreshold&lt;/span&gt;:  &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;RequestVolumeThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;SleepWindow&lt;/span&gt;:            &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;handle&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;listening on :8080&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ListenAndServe&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hystrix&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Go&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;commandName&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// talk to other services
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callChargeProducerAPI&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// err := callWithRetryV1()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;output&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// success
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;success %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// failure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;failed %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// logger is Handler wrapper function for logging
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandlerFunc&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandlerFunc&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;URL&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Path&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Method&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callChargeProducerAPI&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Getenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SERVER_ERROR&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Getenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SERVER_ERROR&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;503 error&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;demo 中分别测试了请求调用链 closed 和 open 两种情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/* Experiment 1: success path */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i in &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;seq 10&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; curl -x &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; localhost:8080 ;&lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/* Experiment 2: circuit open */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SERVER_ERROR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; Go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i in &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;seq 10&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; curl -x &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; localhost:8080 ;&lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/aladine/48d935c44820508e5bca2f061e3a7c1d/raw/930cdc10c41e8b9b37018f2be36bc421e6df481a/demo.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;查看源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;重试问题&#34;&gt;重试问题&lt;/h2&gt;
&lt;p&gt;在上面的熔断器模式中，如果服务 B 缩容，会发生什么？大量已经从 A 发出的请求会返回 5xx error。可能会触发熔断器切换到 open 的错误报警。因此我们需要重试以防间歇性的 network hiccup 发生。&lt;/p&gt;
&lt;p&gt;一段简单的重试代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callWithRetryV1&lt;/span&gt;() (&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// call producer API
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;callChargeProducerAPI&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// adding backoff
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// adding jitter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/aladine/6d65d1db78b020ef9866e3a8ad2516aa/raw/a4d3b65cc4ef920cdfc7e898c130b92371007785/retry.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;查看源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;重试模式&#34;&gt;重试模式&lt;/h2&gt;
&lt;p&gt;为了实现乐观锁，我们可以为不同的服务配置不同的重试次数。因为立即重试会对下游服务产生爆发性的请求，所以不能用立即重试。加一个 backoff 时间可以缓解下游服务的压力。一些其他的模式会用一个随机的 backoff 时间（或在等待时加 jitter）。&lt;/p&gt;
&lt;p&gt;一起来看下列算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exponential: bash * 2&lt;!-- raw HTML omitted --&gt;attemp&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Full Jitter: sleep = rand(0, base * 2&lt;!-- raw HTML omitted --&gt;attempt&lt;!-- raw HTML omitted --&gt;)&lt;/li&gt;
&lt;li&gt;Equal Jitter: temp = base * 2&lt;!-- raw HTML omitted --&gt;attemp&lt;!-- raw HTML omitted --&gt;; sleep = temp/2+rand(0, temp/2)&lt;/li&gt;
&lt;li&gt;De-corredlated Jitter: sleep = rand(base, sleep*3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【译注】关于这几个算法，可以参考&lt;a class=&#34;link&#34; href=&#34;https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文章&lt;/a&gt; 。&lt;strong&gt;Full Jitter&lt;/strong&gt;、 &lt;strong&gt;Equal Jitter&lt;/strong&gt;、 &lt;strong&gt;De-corredlated&lt;/strong&gt; 等都是原作者自己定义的名词。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204111132.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;客户端的数量与服务端的总负载和处理完成时间是有关联的。为了确定什么样的重试模式最适合你的系统，在客户端数量增加时很有必要运行基准测试。详细的实验过程可以在&lt;a class=&#34;link&#34; href=&#34;https://amazonaws-china.com/cn/blogs/architecture/exponential-backoff-and-jitter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文章&lt;/a&gt;中看到。我建议的算法是 de-corredlated Jitter 和 full jitter 选择其中一个。&lt;/p&gt;
&lt;h2 id=&#34;两者结合&#34;&gt;两者结合&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201204011245.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Example configuration of both tools&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;熔断器被广泛用在无状态线上事务系统中，尤其是在聚合点上。重试应该用于调度作业或不被 timeout 约束的 worker。经过深思熟虑后我们可以同时用熔断器和重试。在大型系统中，service mesh 是一种能更精确地编排不同配置的理想架构。&lt;/p&gt;
&lt;h2 id=&#34;参考文章&#34;&gt;参考文章&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/afex/hystrix-go/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/afex/hystrix-go/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/eapache/go-resiliency&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/eapache/go-resiliency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Netflix/Hystrix/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Netflix/Hystrix/wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.awsarchitectureblog.com/2015/03/backoff.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.awsarchitectureblog.com/2015/03/backoff.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dzone.com/articles/go-microservices-part-11-hystrix-and-resilience&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@trongdan_tran&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dan Tran&lt;/a&gt; 译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt; 校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/25295&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go语言中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】协程，操作系统线程和 CPU 管理</title>
        <link>https://lxb.wiki/4e717bb5/</link>
        <pubDate>Thu, 12 Dec 2019 23:01:35 +0000</pubDate>
        
        <guid>https://lxb.wiki/4e717bb5/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210657.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French.&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ℹ️ &lt;em&gt;本文运行环境为 Go 1.13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。&lt;/p&gt;
&lt;h2 id=&#34;m-p-g-编排&#34;&gt;M, P, G 编排&lt;/h2&gt;
&lt;p&gt;为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;The main concepts are:
G - goroutine.
M - worker thread, or machine.
P - processor, a resource that is required to execute Go code.
    M must have an associated P to execute Go code[...].
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;P&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt; 模型图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210733.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;P, M, G diagram&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每个协程（&lt;code&gt;G&lt;/code&gt;）运行在与一个逻辑 CPU（&lt;code&gt;P&lt;/code&gt;）相关联的 OS 线程（&lt;code&gt;M&lt;/code&gt;）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WaitGroup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;`hello`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;`world`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，Go 根据机器逻辑 CPU 的个数来创建不同的 &lt;code&gt;P&lt;/code&gt;，并且把它们保存在一个空闲 &lt;code&gt;P&lt;/code&gt; 的 list 里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210931.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;P initialization&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 &lt;code&gt;P&lt;/code&gt;。这个 &lt;code&gt;P&lt;/code&gt; 通过与之相关联的 OS 线程来创建一个 &lt;code&gt;M&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211012.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;OS thread creation&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然而，像 &lt;code&gt;P&lt;/code&gt; 那样，系统调用返回的甚至被 gc 强行停止的空闲的 &lt;code&gt;M&lt;/code&gt; — 比如没有协程在等待运行 — 也会被加到一个空闲 list：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211040.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;M and P idle list&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在程序启动阶段，Go 就已经创建了一些 OS 线程并与 &lt;code&gt;M&lt;/code&gt; 想关联了。在我们的例子中，打印 &lt;code&gt;hello&lt;/code&gt; 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211126.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;M and P pulled from the idle list&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 &lt;code&gt;P&lt;/code&gt; 多的 &lt;code&gt;M&lt;/code&gt;，在系统调用时怎么管理协程。&lt;/p&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;系统调用&lt;/h2&gt;
&lt;p&gt;Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 &lt;code&gt;P&lt;/code&gt; 和线程 &lt;code&gt;M&lt;/code&gt; 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;fd&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;number.txt&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;fd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;fd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   println(string(&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 42
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文件读取的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211158.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Syscall handoffs P&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P0&lt;/code&gt; 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试去捕获相同的 &lt;code&gt;P&lt;/code&gt;，在我们的例子中就是 &lt;code&gt;P0&lt;/code&gt;，然后 resume 执行过程&lt;/li&gt;
&lt;li&gt;尝试从空闲 list 中捕获一个 &lt;code&gt;P&lt;/code&gt;，然后 resume 执行过程&lt;/li&gt;
&lt;li&gt;把协程放到全局队列里，把与之相关联的 &lt;code&gt;M&lt;/code&gt; 放回空闲 list 去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`https://httpstat.us/200`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 &lt;code&gt;M&lt;/code&gt; 不会阻塞：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211227.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Network poller waiting for the resource&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211256.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。&lt;/p&gt;
&lt;h2 id=&#34;os-线程方面的限制&#34;&gt;OS 线程方面的限制&lt;/h2&gt;
&lt;p&gt;在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译注：&lt;strong&gt;GOMAXPROCS&lt;/strong&gt; 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 &lt;strong&gt;GOMAXPROCS&lt;/strong&gt; 没有影响。这个包的 &lt;em&gt;&lt;strong&gt;GOMAXPROCS&lt;/strong&gt;&lt;/em&gt; 函数查询和修改这个最大数限制。&lt;/p&gt;
&lt;p&gt;对这种情形举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WaitGroup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; ;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`https://httpstat.us/200?sleep=10000`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;利用追踪工具得到的线程数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211320.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@blanchon.vincent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Vincent Blanchon&lt;/a&gt; 译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt; 校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/25292&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go语言中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】How to split a string in C&#43;&#43;</title>
        <link>https://lxb.wiki/9747854a/</link>
        <pubDate>Sun, 04 Jun 2017 18:40:14 +0000</pubDate>
        
        <guid>https://lxb.wiki/9747854a/</guid>
        <description>&lt;p&gt;这个问题是说, 怎么得到组成一句话的各个单词, 或者得到CSV中的各个数据片段. 这在C++中是个很简单的问题, 却有很多种答案.&lt;/p&gt;
&lt;p&gt;有3种方案, 每种有利有弊. 使用时请自己选择最佳方案. 这篇文章的目的是说明 迭代器的接口是如何优胜于简单的容器的, 并且阐明 &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;design of the STL&lt;/a&gt; 是何等强大.&lt;/p&gt;
&lt;p&gt;方案1使用的标准组件(虽然方案1.2 做了微调). 方案2相对好点但使用了&lt;code&gt;boost&lt;/code&gt;. 而方案3 更好但使用了&lt;code&gt;ranges&lt;/code&gt;. 所以到底应该用哪个, 取决于你需要什么和你能使用什么.&lt;/p&gt;
&lt;h3 id=&#34;solution-1-iterating-on-a-stream&#34;&gt;Solution 1: Iterating on a stream&lt;/h3&gt;
&lt;h4 id=&#34;stepping-into-the-world-of-streams&#34;&gt;Stepping into the world of streams&lt;/h4&gt;
&lt;p&gt;&amp;ldquo;流&amp;rdquo; 是一个 能生成 与源或希望连接的目标 的联系 的对象. 流可以从源中获取信息(&lt;code&gt;std::istream&lt;/code&gt;), 或为目标提供信息(&lt;code&gt;std::ostream&lt;/code&gt;), 或者两者皆可(&lt;code&gt;std::iostream&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;源和目标可以是标准输入(&lt;code&gt;std::cin&lt;/code&gt;), 标准输出(&lt;code&gt;std::cout&lt;/code&gt;), 一个文件, 或者一个字符串, 前提是方式得当. 对流的主要操作包括: - 对于输入流: 使用操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 从里面读取信息 - 对于输出流: 使用操作符&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, 向它推入信息&lt;/p&gt;
&lt;p&gt;一个指向字符串的输入流, &lt;code&gt;std::istringstream&lt;/code&gt;, 有个有趣的特性: 它的操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 在源字符串中制造出去向下一个空格的字符串.&lt;/p&gt;
&lt;h4 id=&#34;istream_iterator&#34;&gt;istream_iterator&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;std::istream_iterator&lt;/code&gt; 是连接输入流的迭代器. 它代表了输入迭代器的普遍接口, 但它的操作符&lt;code&gt;++&lt;/code&gt; 更像是输入流.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream_iterator&lt;/code&gt; 以它从流里读取的类型为模板. 我们现在使用&lt;code&gt;istream_iterator&amp;lt;std::string&amp;gt;&lt;/code&gt;, 它从流里读取字符串, 分离时为我们提供一个字符串.&lt;/p&gt;
&lt;p&gt;当到达流的终点时, 流向它的迭代器发送信号, 然后迭代器被标记为结束.&lt;/p&gt;
&lt;h3 id=&#34;solution-11&#34;&gt;Solution 1.1&lt;/h3&gt;
&lt;p&gt;现在, 我们可以借迭代器的接口使用算法, 这真切地证明了&lt;code&gt;STL&lt;/code&gt; 设计的灵活性. 为了使用&lt;code&gt;STL&lt;/code&gt;, 我们需要一个&lt;code&gt;begin&lt;/code&gt; 和一个&lt;code&gt;end&lt;/code&gt; (请参考&lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/03/28/inserting-several-elements-into-an-stl-container/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Inserting several elements into an STL container efficiently&lt;/a&gt;). &lt;code&gt;begin&lt;/code&gt; 是一个 还没开始着手分割的字符串的&lt;code&gt;istreamstream&lt;/code&gt; 的迭代器: &lt;code&gt;std::istream_iterator&amp;lt;std::string&amp;gt;(iss)&lt;/code&gt; . 按照惯例, &lt;code&gt;end&lt;/code&gt; 的默认值也是个&lt;code&gt;istream_iterator&lt;/code&gt; : &lt;code&gt;std::istream_iterator&amp;lt;string&amp;gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let me split this into words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;std::string&amp;gt;(iss)), std::istream_iterator&amp;lt;std::string&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第一个参数的额外的括号是为了避免与一个函数调用的歧义&amp;ndash;请参考Scott Meyers的著作Effective STL 条目6 &amp;ldquo;most vexing parse&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优: - 仅使用标准组件 - 除字符串外, 对所有流都适用 劣: - 只能以空格为分隔符进行分割, 而且这在解析CSV时会是个至关重要的问题 - 在性能方面有待优化(但如果这不是影响你整个程序的瓶颈, 这也不是个大问题) - 很多人认为仅为了分割一个字符串, 写了太多代码&lt;/p&gt;
&lt;h3 id=&#34;solution12-pimp-my-operator&#34;&gt;Solution1.2: Pimp my operator&amp;raquo;&lt;/h3&gt;
&lt;p&gt;导致上面两条劣势的原因是同一个: &lt;code&gt;istream_iterator&lt;/code&gt; 从流里读取字符串时调用的操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. 这个操作符做了很多事: 在下一个空格处停止(这是我们的最初的需求, 但这个不能自定义), 格式化, 读取然后设置一些标志位, 构造对象, 等等. 而以上这些, 大部分我们是不需要的. 所以我们希望自己实现下面的函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream&amp;amp; is, std::string&amp;amp; output)
{
    // ...does lots of things...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上, 我们无法改变这些, 因为这是在标注库里的. 我们可以用另一个类型重载它, 但是这个类型需要是&lt;code&gt;string&lt;/code&gt; 的一种.&lt;/p&gt;
&lt;p&gt;所以现在的需求就是, 用另一种类型伪装成&lt;code&gt;string&lt;/code&gt;. 有两种方案: 继承&lt;code&gt;std::string&lt;/code&gt; 和 用显式转换封装&lt;code&gt;string&lt;/code&gt;. 这里我们选择继承.&lt;/p&gt;
&lt;p&gt;假如我们希望以逗号为分割符分割一个字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class WordDelimitedByCommas: pulic std::string
{};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我必须承认这是有争议的. 有人会说:&amp;quot;&lt;code&gt;std::string&lt;/code&gt; 没有虚析构函数, 所以你不应该继承它!&amp;quot; 这可能, 大概, 也许是有一点点点点武断. 这里我要说的是, 继承本身不会产生问题. 诚然, 当一个指向&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 的指针以&lt;code&gt;std::string&lt;/code&gt; 的形式被&lt;code&gt;delete&lt;/code&gt; 掉时, 会产生问题. 继续读, 你会发现, 我们不会这么做. 现在我们可以阻止写代码的人借&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 突发冷箭破坏程序吗? 我们不能. 但是这个险值得我们冒吗? 请继续读, 然后你自己判断.&lt;/p&gt;
&lt;p&gt;现在为了仅实现我们需要的功能, 我们可以重载操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : 获取下一个逗号之前的所有字符. 这个可以借用&lt;code&gt;getline&lt;/code&gt; 函数实现:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream* is, std::WordDelimitedByCommas&amp;amp;)
{
    std::getline(is, output, &#39;,&#39;);
    return is;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;code&gt;is&lt;/code&gt; 保证了可以连续调用操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以写初级代码了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let,me,split,this,into,words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;WordDelimitedByCommas&amp;gt;(iss)), std::istream_iterator&amp;lt;WordDelimitedByCommas&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过模板化&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 泛华所有的分隔符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;char delemiter&amp;gt;
class WordDelimitedBy: pulic std::string
{};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在以分号举例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let;me;split;this;into;words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;WordDelimitedBy&amp;lt;&#39;;&#39;&amp;gt;&amp;gt;(iss)), std::istream_iterator&amp;lt;WordDelimitedBy&amp;lt;&#39;;&#39;&amp;gt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优: - 编译时允许任何分隔符 - 不仅是字符串, 对任何流都可以操作 - 比方案1更快(快20%到30%) 劣: - 虽然可以很方便的复用, 但仍不是标准 - 仅仅为了分割一个字符串, 这个方案仍然使用了大量代码&lt;/p&gt;
&lt;h3 id=&#34;solution2-using-boostsplit&#34;&gt;Solution2: Using &lt;code&gt;boost::split&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这个方案比方案1高级, 除非你需要对所有的流都进行操作.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost/algorithm/string.hpp&amp;gt;

std::string text = &amp;quot;Let me split this into words&amp;quot;;
std::vector&amp;lt;std::string&amp;gt; result;
boost::split&amp;lt;results, text, [](char c){return &#39; &#39; == c;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传给&lt;code&gt;boost::split&lt;/code&gt; 的第三个参数是一个函数或函数对象, 确定一个字符是不是分隔符. 上面的例子是使用&lt;code&gt;lambda&lt;/code&gt; 表达式, 传入一个&lt;code&gt;char&lt;/code&gt;, 返回这个&lt;code&gt;char&lt;/code&gt; 是否是空格.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::split&lt;/code&gt; 的实现很简单: 在到达字符串的结束位置之前, 重复地调用&lt;code&gt;find_if&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;优: - 非常直观的接口 - 允许任何分隔符, 甚至是多个 - 高效: 比方案1.1 快 60% 劣: - 暂不是标准: 需要用到&lt;code&gt;boost&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;solution-3未来-usingranges&#34;&gt;Solution 3(未来): Using&lt;code&gt;ranges&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;虽然它们现在还没有像标准库甚至&lt;code&gt;boost&lt;/code&gt; 里的组件一样被广泛使用, &lt;code&gt;ranges&lt;/code&gt; 是&lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/01/12/ranges-stl-to-the-next-level/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;future of the STL&lt;/a&gt; . 在未来几年, 会大量面世.&lt;/p&gt;
&lt;p&gt;Eric Neiber 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ericniebler/range-v3/blob/master/test/view/split.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;range-v3&lt;/a&gt; 库 提供了非常友好的接口. 为了生成一个字符串的分割&lt;code&gt;view&lt;/code&gt;, 代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let me split this into words&amp;quot;;
auto splitText = text | view::split(&#39; &#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它有很多有趣的特性, 诸如 使用一个子字符串作为分隔符. &lt;code&gt;ranges&lt;/code&gt; 会被&lt;code&gt;C++20&lt;/code&gt; 引入, 所以我们应该能在几年之内就可以使用这个功能了.&lt;/p&gt;
&lt;h3 id=&#34;so-how-do-i-split-my-string&#34;&gt;So, how do I split my string?&lt;/h3&gt;
&lt;p&gt;如果你能使用&lt;code&gt;boost&lt;/code&gt;, 务必使用方案2. 或者你可以自己写算法, 像&lt;code&gt;boost&lt;/code&gt; 那样基于&lt;code&gt;find_if&lt;/code&gt; 分割字符串.&lt;/p&gt;
&lt;p&gt;如果你不想这么做, 你可以使用标准, 即方案1.1, 如果你需要自定义分隔符, 或者发现1.1是个瓶颈, 那么你可以选择方案1.2 .&lt;/p&gt;
&lt;p&gt;如果你可以使用&lt;code&gt;ranges&lt;/code&gt; , 那么就应该选择方案3.&lt;/p&gt;
&lt;p&gt;翻译原文: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】C&#43;&#43;11 sort using function objects</title>
        <link>https://lxb.wiki/e754bcbe/</link>
        <pubDate>Wed, 19 Apr 2017 21:58:53 +0000</pubDate>
        
        <guid>https://lxb.wiki/e754bcbe/</guid>
        <description>&lt;p&gt;如果你用C++编码， 需要对容器内的元素进行排序， 这个容器提供任意访问的迭代器， 比如&lt;code&gt;std::vector&lt;/code&gt;， 那么简单快捷的方法是使用里的&lt;code&gt;std::sort&lt;/code&gt; 函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Basic sorting&lt;/strong&gt; &lt;code&gt;std::sort&lt;/code&gt; 函数需要两个参数, 这两个参数分别指向你要排序的序列容器的开始(initial)和终点(final). 这个序列容易内除final指向的那个元素外 所有元素都会被排序. 下面是一个简单的排序例子:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;0 5 10 15 20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More complex sorting&lt;/strong&gt; 在某些时候, 根据数值升序排序已经足够解决问题了, 但是当我们需要按某个特定的参数进行排序, 或者降序排列时, 就需要一些其他的东西了. 对于这种需求, &lt;code&gt;std::sort&lt;/code&gt; 需要引入第三个参数: 比较函数. 这个比较函数有两个参数, 分别是序列容器的两个元素, 返回值可以隐式地转为bool. 如果第一个参数应该排在第二个参数前面, 则返回true.&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescOrderInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end(), DescOrderInt);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;DescOrderInt的实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescOrderInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;20 15 10 5 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++11 sort using function objects&lt;/strong&gt; 网上很多例子说, 为了排列元素, 可以使用&lt;code&gt;std::binary_function&lt;/code&gt; 定义比较函数, 但不幸的是, &lt;code&gt;std::binary_function&lt;/code&gt; 在C++11 中已经被标为 &amp;ldquo;将被弃用的&amp;rdquo;, 在C++17中会被完全移除, 所以写新的C++代码时, 最好不要用这个.&lt;/p&gt;
&lt;p&gt;我们可以使用C++11中引入的&lt;code&gt;std::function&lt;/code&gt; 来定义这个函数指针. 例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;function&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/function&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StrDescOrderInt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sorter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StrDescOrderInt();&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end(), sorter);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;20 15 10 5 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A real-life example: providing multiple sorting options&lt;/strong&gt; 我们假设有一队足球运动员, 我们想让用户按他们自己的意愿去排列这些运动员. 有一个图表的UI, 上面有几个按钮, 每个按钮对应不用的排序规则.&lt;/p&gt;
&lt;p&gt;Plaer 类的代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -- Player.h --
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&amp;lt;/string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Player(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; caps, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; goals);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;amp; GetName() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetCaps&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetGoals&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string mName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mCaps;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mGoals;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;现在我们新写一个类或结构体来列出所有的比较函数. 比较函数是一个结构体并实现操作符&lt;code&gt;()&lt;/code&gt;, 操作符&lt;code&gt;()&lt;/code&gt; 带有两个参数, 分别为两个指向Player的指针, 返回bool值.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PlayerSorting&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// name
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByNameAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByNameDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// caps
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByCapsAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByCapsDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// goals
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByGoalsAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByGoalsDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后, 在调用它的地方, 我们可以先把所有的&lt;code&gt;std::function&lt;/code&gt; 存在一个&lt;code&gt;std::vector&lt;/code&gt; 里, 使用的时候, 用索引访问vector的元素.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(player &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; player&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sorters;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByNameAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByCapsAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByGoalsAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByNameDes());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByCapsDes());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByGoalsDes());&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(player&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;例如, 根据得分降序排列:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;player &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; players;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;player&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ...init players...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(players.begin(), players.end(), sorters[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     CAPS  GOALS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Lionel Messi             &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;David Villa              &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Asamoah Gyan             &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Arjen Robben             &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mesut Oezil              &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Diego Forlan             &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Andres Iniesta           &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Wesley Sneijder          &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Xavi                     &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bastian Schweinsteiger   &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假如需要实现一种新的排序方式, 我们只需要在PlayerSorting类中添加一个新的仿函数即可.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】String&amp;#039;s interface</title>
        <link>https://lxb.wiki/4c3249cd/</link>
        <pubDate>Sun, 09 Apr 2017 22:00:41 +0000</pubDate>
        
        <guid>https://lxb.wiki/4c3249cd/</guid>
        <description>&lt;p&gt;考虑以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool fun(const string&amp;amp;amp; code)
{
assert(code.length() &amp;amp;gt;= 2);
if (code.substr(0, 2) == string(&amp;quot;XX&amp;quot;))
{
// ...
}
// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有没有发现什么问题? 不要纠结于assert(), 它只是为了保证 string &amp;ldquo;code&amp;rdquo; 长度大于2而已.&lt;/p&gt;
&lt;p&gt;很显然, 这段代码用来检查string是否以&amp;quot;XX&amp;quot;开头. 基于它长度大于2 的前提, 这段代码能正常运行. 我们的关心的问题是, 表达式能否达到正确的结果.&lt;/p&gt;
&lt;p&gt;绝大多数情况下, 我们之所以使用C++, 是希望能使我们的程序达到最优的性能. 基于这个目标, 上面的代码看起来就不是很正确了. 为了检查&amp;quot;code&amp;quot;是否以&amp;quot;XX&amp;quot;开头, 我们生成了两个临时的string, 每个string都可能潜在地申请堆上的内存. 有人可能会为此辩解: std::string应该能为一个 2字母的序列实现 短字符串最优化(SSO). 就算这个辩解是正确的, 这段代码也已经 耗费了 一些不能被优化掉的开销, 更何况, 并不是所有的都会实现SSO. 例如, 我使用的GCC 4.4.7 就不会为string实现SSO.&lt;/p&gt;
&lt;p&gt;类模板&lt;code&gt;std::basic_string&lt;/code&gt; 的接口很复杂. 它提供了大量的成员函数, 似乎不用它们显得不领情, 同时开发者也不会有自己一遍遍重新解析的冲动.&lt;/p&gt;
&lt;p&gt;因为开发者模糊地记得应用于NTBS(null-terminated byte strings)(可以被隐式地转为&lt;code&gt;const char*&lt;/code&gt; )的 操作符 &lt;code&gt;==&lt;/code&gt; 会使结果出错, 所以他通过 确保参与比较的两个值都是&lt;code&gt;std::string&lt;/code&gt; 类型来避开这个错误. 他可能在想, 在运行操作符&lt;code&gt;==&lt;/code&gt; 前文本&amp;quot;XX&amp;quot; 已经被显式地转成了&lt;code&gt;std::string&lt;/code&gt;, 那么这么做也没有坏处. &lt;strong&gt;但是&lt;/strong&gt;, 这是错误的, 因为对于操作符&lt;code&gt;==&lt;/code&gt;, 标准提供了两种版本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool operator==(const std::string&amp;amp;amp; lhs, const char* rhs);
bool operator==(const char* lhs, const std::string&amp;amp;amp; rhs);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然实际上他们是带有多个参数的函数模板, 远比这个复杂. &lt;code&gt;std::string&lt;/code&gt; 可以直接跟NTBS比较, 没有必要生成临时的&lt;code&gt;std::string&lt;/code&gt;. 我们开头的例子, 可以通过去除显式生成的临时副本 进行优化: &lt;code&gt;if (code.substr(0, 2) == &amp;quot;XX&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更进一步, 不可否认, 在有些地方使用操作符&lt;code&gt;==&lt;/code&gt; 看起来很高雅, 但是仅仅为了检查一个&lt;code&gt;string&lt;/code&gt; 本身的一部分而去新申请一部分资源(生成一个新的&lt;code&gt;string&lt;/code&gt;) 这种做法是错误的. 开发者的初衷, 并不是要是程序看起来高雅. 实际上, 如果我们深入研究&lt;code&gt;std::basic_string&lt;/code&gt; 的官方文档, 就会发现, &lt;code&gt;std::basic_string&lt;/code&gt;提供了一种比较它的子字符串和NTBS的方法: &lt;code&gt;if(code.compare(0, 2, &amp;quot;XX&amp;quot;) == 0)&lt;/code&gt; 这个比较是三方比较, 结果等于0表示相等. 它可以达到目的, 并且不需要生成任何临时的&lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;尽管这个&lt;code&gt;compare()&lt;/code&gt; 使性能达到了很大的优化, 但我并不满足于此. 虽然它做了正确的事情, 但如果我们是第一次遇到他, 很难抓住他的精髓. 如果你可以使用boost库, 我的建议性的解决方案是使用&lt;code&gt;Boost String Algorithms Library&lt;/code&gt; 中的算法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost algorithm=&amp;quot;&amp;quot; string=&amp;quot;&amp;quot; predicate.hpp=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/boost&amp;gt;

bool func(const string&amp;amp;amp; code)
{
if (boost::algorithm::starts_with(code, &amp;quot;XX&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码很好地体现了我想说的意思, 没有任何多余的开销.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;https://akrzemi1.wordpress.com/2015/04/15/strings-interface/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://akrzemi1.wordpress.com/2015/04/15/strings-interface/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Custom comparison, equality and equivalence with the STL</title>
        <link>https://lxb.wiki/55f488ad/</link>
        <pubDate>Wed, 29 Mar 2017 19:01:51 +0000</pubDate>
        
        <guid>https://lxb.wiki/55f488ad/</guid>
        <description>&lt;p&gt;从一段代码引用开始:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;amp;lt; std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt; &amp;amp;gt; v1 = ... // v1 is filled with data
std::vector&amp;amp;lt; std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt; &amp;amp;gt; v2 = ... // v2 is filled with data
std::vector&amp;amp;lt; std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt; &amp;amp;gt; results;&amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;

std::sort(v1.begin(), v1.end());
std::sort(v2.begin(), v2.end());

std::set_difference(v1.begin(), v1.end(),
v2.begin(), v2.end(),
std::back_inserter(result),
compareFirst);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在两个排好序的vector v1 和 v2上调用&lt;code&gt;std::set_difference&lt;/code&gt;. &lt;code&gt;std::set_difference&lt;/code&gt; 把结果写入 &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;std::back_inserter&lt;/code&gt; 确保输出的结果从&lt;code&gt;result&lt;/code&gt; 的后面添入. 自定义的&lt;code&gt;compareFirst&lt;/code&gt; 作为比较函数提供给&lt;code&gt;std::set_difference&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认地, &lt;code&gt;std::set_difference&lt;/code&gt; 通过 &lt;code&gt;std::pair&lt;/code&gt; 默认的比较函数来比较里面的元素(比较pair的first和second), 我们自定义了&lt;code&gt;compareFirst&lt;/code&gt;, 希望只比较pair的first. &lt;code&gt;compareFirst&lt;/code&gt;不是STL的函数, 需要我们自己实现.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::set_difference&lt;/code&gt; 使用的前提是input已经排好序, 倘若我们自定义比较函数C, 而通过C我们能把元素排好序, 那么我们使用这个C代替sort的默认排序也是可以的.&lt;/p&gt;
&lt;p&gt;在此例中, 我们使用&lt;code&gt;std::set_difference&lt;/code&gt; 只对pair的first进行排序, 尽管它们已经通过&amp;quot;first + second&amp;quot;的方式排序完了.&lt;/p&gt;
&lt;p&gt;下面来实现&lt;code&gt;compareFirst&lt;/code&gt;. 初版:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool compareFirst(const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp;amp; p1, const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp;amp; p2)
{
return p1.first == p2.first; // not final code, bug lurking here!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上, 上面的代码不会得到我们预期的结果. 为什么? 毕竟&lt;code&gt;std::set_difference&lt;/code&gt; 会检查元素跟另一个容器的元素是否相等(equal), 不是吗?&amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;&lt;/p&gt;
&lt;p&gt;为了理解上面的内容, 我们把STL大概地分为两类: 操作排序元素的 和操作乱序元素的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Comparing elements&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++中描述&amp;quot;a is the same as b&amp;quot; 有两种方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- the natural way: a == b. This is called equality. Equality is based on operator==.
- the other way: a is not smaller than b and b is not smaller than a, so !(a&amp;lt;b) &amp;amp;&amp;amp;=&amp;quot;&amp;quot; !(b&amp;lt;a).=&amp;quot;&amp;quot; this=&amp;quot;&amp;quot; is=&amp;quot;&amp;quot; called=&amp;quot;&amp;quot; equivalence.=&amp;quot;&amp;quot; equivalence=&amp;quot;&amp;quot; based=&amp;quot;&amp;quot; on=&amp;quot;&amp;quot; operator&amp;lt;.=&amp;quot;&amp;quot; ```=&amp;quot;&amp;quot; 这两个问题涉及到另一个名词:=&amp;quot;&amp;quot; `equivalence`=&amp;quot;&amp;quot; &amp;lt;u=&amp;quot;&amp;quot;&amp;gt;How is it different from equality?&amp;lt;/b)&amp;gt;

对于基本类型如int, 甚至实践中大多数类型, `equivalence` 和`quality` 是相通的. 但是正如*Scott Meyers* 在&amp;amp;lt;&amp;amp;lt; Effective STL&amp;amp;gt;&amp;amp;gt;  一书条目19中指出的, 对于有一些类型, 即使&amp;quot;并非罕见&amp;quot;, `equivalence` 和 `equality` 是不同的, 如 大小写不敏感的string类型.

&amp;lt;u&amp;gt;Why such a far-fetched way to express a simple thing?&amp;lt;/u&amp;gt;

当我们使用算法对容器内元素进行排序时, 很容易理解必须有独一无二的排序方法(如有多种排序方法, 会很笨重, 并可能产生不一致的结果). 所以对于一个特定的容器, 排序时, &amp;quot;==&amp;quot; 和&amp;quot;&amp;amp;lt;&amp;quot; 只能选一个. 

对于STL中排序的部分, 我们别无选择: 排序时必须使用&amp;quot;&amp;amp;lt;&amp;quot;;
而乱序部分, 则没有这个约束, 我们可以使用&amp;quot;==&amp;quot;.

**Implementing the comparator**

STL的乱序部分使用&amp;quot;==&amp;quot;, 而排序部分使用&amp;quot;&amp;amp;lt;&amp;quot;. 我们自定义的比较函数也必须遵循这种逻辑. 

现在我们可以理解怎么自定义实现`std::set_difference` 的比较函数`compareFirst` 了.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;bool compareFirst(const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp; p1, const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp; p2) { return p1.first &amp;lt; p2.first; // correct, STL-compatible code. } ```&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/&lt;/a&gt; &amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】How to (std::)find something efficiently with the STL</title>
        <link>https://lxb.wiki/56dc57bb/</link>
        <pubDate>Thu, 16 Mar 2017 22:07:59 +0000</pubDate>
        
        <guid>https://lxb.wiki/56dc57bb/</guid>
        <description>&lt;p&gt;本文分3部分: 1. 怎么使用STL进行高效的查找: 借用传统STL算法对元素进行范围搜索 2. 搜索STL容器: 当你有直接读取STL容器里元素的权限时, 怎么进行高效准确的搜索(与简单的范围搜索相比较) 3. STL搜索算法的秘密: 向公众展示不为人知的算法, 这些算法在已经学习过的人眼里确实是很有用的&lt;/p&gt;
&lt;p&gt;STL根据查看方式的不同, 一共分为两种: 排序的和不排序的. * 排序集合的遍历, 通常需要对数时长, 而乱序集合的遍历, 需要线性时长 * 排序容器中比较元素大小的函数根据equivalence(comparing with &amp;lt;), 而乱序容器中的函数根据equality(comparing with ==).&lt;/p&gt;
&lt;p&gt;本文将展示对于在一个范围内搜索一个给定的值, C++怎么样去阐述下面3个问题: * 它存在否 * 它在哪 * 它应该在什么位置(排序容器)&lt;/p&gt;
&lt;h3 id=&#34;is-it-there&#34;&gt;Is it there?&lt;/h3&gt;
&lt;h4 id=&#34;乱序容器的元素&#34;&gt;乱序容器的元素&lt;/h4&gt;
&lt;p&gt;这个问题可以用std::find来表达(需要和与范围的终点值的比较相结合):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v = ... // v filled with values
if (std::find(v.begin(), v.end(), 42) != v.end())
{
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Is it there&amp;quot;这个问题也可以用std::count来表达:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v = ... // v filled with values
if (std::count(v.begin(), v.end(), 42))
{
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::count()的返回值会被隐式地转换成if条件里的bool值: 如果该范围里有至少一个值为42, 则返回true.&lt;/p&gt;
&lt;p&gt;与std::find相比, std::count的优劣: 优势:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::count避免了与范围的end值相比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;弊端:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::count遍历整个集合, 而std::find在第一个与要查找的值相等的位置停下&lt;/li&gt;
&lt;li&gt;可以证明, 对于&amp;quot;想要查找某个值&amp;quot;这件事, std::find 表达得更明确 基于以上, std::find用得更多.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; 若要确认某个值存在而非是与要搜索的值相等, 请使用&lt;code&gt;std::count_if, std::find_if, std::find_if_not&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;排序容器的元素&#34;&gt;排序容器的元素&lt;/h4&gt;
&lt;p&gt;使用的算法是&lt;code&gt;std::binary_search&lt;/code&gt;, 此函数返回一个bool值, 此bool值表示在集合中是否存在与搜索的值相等的元素.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::set&amp;lt;int&amp;gt; numbers = // sorted elements
bool is42InThere = std::binary_search(numbers.begin(), numbers.end(), 42);
```&amp;lt;/int&amp;gt;

### Where is it?
(当确定了要搜索的值存在后,) 我们想更进一步, 得到指向那个元素的迭代器.

#### 乱序容器的元素

使用std::find. 返回指向第一个与搜索的值相等的元素的迭代器, 如果找不到, 则返回集合的终点.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;std::vector numbers = &amp;hellip; auto searchResult = std::find(numbers.begin(), numbers.end(), 42);&lt;/p&gt;
&lt;p&gt;if (searchResult != numbers.end()) { &amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 排序容器的元素

对于排序集合, STL并没有像std::find一样直接的算法. std::find并不是为排序容器设计的, 因为它依据的是&amp;quot;==&amp;quot;而不是&amp;quot;&amp;amp;lt;&amp;quot;, 消耗的时间为线性时长而不是对数时长.
对于一个给定的容器, 如果容器内元素的&amp;quot;equality&amp;quot;和&amp;quot;equivalence&amp;quot;是相同的, 且你能接受消耗的线性时长, 那么std::find会为你返回正确的结果, 你也能从它简单直接的接口中获益. **但是,** 不能忘记, std::find并不是为排序容器设计的.

这里推荐使用`std::equal_range`. (并非`std::lower_bound`)
函数原型: 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;template&amp;lt; class ForwardIt, class T &amp;gt; std::pair&amp;lt;forwardit,forwardit&amp;gt; equal_range( ForwardIt first, ForwardIt last, const T&amp;amp; value );&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`std::equal_range` 返回与搜索值相等的元素的范围, 这个范围用一对集合内的迭代器表示. 这两个迭代器分别指向 与搜索值相等的范围里第一个元素和最后一个元素的下一个位置.&amp;lt;/forwardit,forwardit&amp;gt;

然而, 它的接口有些笨重:
例A:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&lt;/p&gt;
&lt;p&gt;// equal_range, attempt 1: natively clumsy std::pair&amp;lt;std::vector::iterator, std::vector::iterator&amp;gt; range1 = equal_range(v.begin(), v.end(), 3); std::for_each(range1.first, range1.second, doSomething);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用一个`typedef` 或者`using`让它更简洁:
例B:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&amp;lt;/std::vector&lt;/p&gt;
&lt;p&gt;using IteratorPair = std::pair&amp;lt;std::vector::iterator, std::vector::iterator&amp;gt;;&amp;lt;/std::vector&lt;/p&gt;
&lt;p&gt;// equal_range, attempt 2: with the classical typedef IteratorPair range2 = equal_range(v.begin(), v.end(), 3); std::for_each(range2.first, range2.second, doSomething);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例B确实简洁了很多, 但是仍有一个根本问题: 没有考虑 抽象等级.
尽管返回的是一个范围, 但这对迭代器强迫我们在操作返回的范围时必须按照&amp;quot;第一&amp;quot;&amp;quot;第二&amp;quot;这种方式来写代码. 范围就应该用&amp;quot;首&amp;quot;&amp;quot;尾&amp;quot;这种方式来表达. 这不仅给我们在其他地方使用这个返回值时造成很大的麻烦, 而且使代码很别扭.

为了解决这个问题, 我么可以把`std::equal_range` 返回的迭代器对封装进一个有&amp;quot;范围&amp;quot;这种语义的`object`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;template&lt;/p&gt;
&lt;p&gt;class Range&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;public:&lt;/p&gt;
&lt;p&gt;Range(std::pair range)&lt;/p&gt;
&lt;p&gt;m_begin(range.first), m_end(range.second) {} typename Container::iterator begin() { return m_begin; } typename Container::iterator end() { return m_end; }&lt;/p&gt;
&lt;p&gt;private: typename Container::iterator m_begin; typename Container::iterator m_end; };&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意: 尽管`std::equal_range` 返回的结果是一个&amp;quot;范围&amp;quot;, 但是`std::begin` 和 `std::end` 不能用在这个结果上. 而上面的封装解决了这个问题.
可以像下面这样使用:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&lt;/p&gt;
&lt;p&gt;// equal_range, attempt 3: natural al last Range&lt;a class=&#34;link&#34; href=&#34;std::vector%5c&#34; &gt;std::vector\&lt;/a&gt; range3 = equal_range(v.begin(), v.end(), 3); std::for_each(range3.begin(), range3.end(), doSomething);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不管你使用上面的哪种方式, `std::equal_range` 都会返回一个范围, 要确定它是否为空, 可以通过检查那两个迭代器(是否相等)或者使用`std::distance` 检查它的大小. &amp;lt;/std::vector&amp;lt;int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;bool noElementFound = range3.begin() == range3.end(); size_t numberOfElementFound = std::distance(range3.begin(), range3.end()) ```&lt;/p&gt;
&lt;h3 id=&#34;where-should-it-be&#34;&gt;Where should it be?&lt;/h3&gt;
&lt;p&gt;这个问题仅仅针对排序的范围, 因为对于乱序的范围, 某个元素可能会存在任何位置.&lt;/p&gt;
&lt;p&gt;对于排序的范围, 这个问题可以简化为: 如果它存在, 那么它在哪儿? 如果它不存在, 那么它应该在哪儿?&lt;/p&gt;
&lt;p&gt;这个问题可以用算法&lt;code&gt;std::lower_bound&lt;/code&gt; 和&lt;code&gt;std::upper_bound&lt;/code&gt; 来解释.&lt;/p&gt;
&lt;p&gt;当你理解了&lt;code&gt;std::equal_range&lt;/code&gt; 后, 上面这句话就很容易理解了: &lt;code&gt;std::lower_bound&lt;/code&gt; 和&lt;code&gt;std::upper_bound&lt;/code&gt; 都会返回 &lt;code&gt;std::equal_range&lt;/code&gt; 返回的那个迭代器对的第一个和第二个迭代器.&lt;/p&gt;
&lt;p&gt;要插入某个值x, 使用&lt;code&gt;std::lower_bound&lt;/code&gt; 得到指向 在范围里与x相等的元素之前的位置的迭代器, 使用&lt;code&gt;std::upper_bound&lt;/code&gt; 得到指向 在范围里与x相等的元素之后的位置的迭代器.&lt;/p&gt;
&lt;p&gt;注意: 如果仅仅是搜索某个元素, 永远不要使用&lt;code&gt;std::lower_bound&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;std::find&lt;/code&gt; 相反, 你不能根据 判断&lt;code&gt;std::lower_bound&lt;/code&gt; 返回的迭代器是否与终点的迭代器相等 来判断要搜索的值是否存在于这个集合. 事实上, 如果这个值在集合里不存在, 则&lt;code&gt;std::lower_bound&lt;/code&gt; 返回它应该在的位置, 而不是终点的迭代器. 所以, 你不仅需要确认返回的迭代器不是终点的迭代器, 还要确认它指向的元素跟要搜索的值是相等的.&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;Question to express in C++&lt;/p&gt;
&lt;p&gt;NOT SORTED&lt;/p&gt;
&lt;p&gt;SORTED&lt;/p&gt;
&lt;p&gt;Is it there?&lt;/p&gt;
&lt;p&gt;std::find != end&lt;/p&gt;
&lt;p&gt;std::binary_search&lt;/p&gt;
&lt;p&gt;Where is it?&lt;/p&gt;
&lt;p&gt;std::find&lt;/p&gt;
&lt;p&gt;std::equal_range&lt;/p&gt;
&lt;p&gt;Where should it be?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;std::lower_bound / std::upper_bound&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;amp;utm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm&lt;/a&gt;_medium=toutiao.io&amp;amp;utm_source=toutiao.io&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Effective STL 9</title>
        <link>https://lxb.wiki/978f4b48/</link>
        <pubDate>Thu, 09 Mar 2017 21:09:09 +0000</pubDate>
        
        <guid>https://lxb.wiki/978f4b48/</guid>
        <description>&lt;p&gt;条款9：在删除选项中仔细选择 假定你有一个标准STL容器，c，容纳int， &lt;code&gt;Container&amp;lt;int&amp;gt; c;&lt;/code&gt; 而你想把c中所有值为&lt;code&gt;1963&lt;/code&gt;的对象都去掉。令人吃惊的是，完成这项任务的方法因不同的容 器类型而不同：没有一种方法是通用的。&lt;/p&gt;
&lt;p&gt;如果你有一个连续内存容器（vector、deque或string——参见条款1），最好的方法是erase-remove惯用法（参见条款32）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.erase(remove(c.begin(), c.end(), &lt;span style=&#34;color:#ae81ff&#34;&gt;1963&lt;/span&gt;),       &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是vector、string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;c.end());                               &lt;span style=&#34;color:#75715e&#34;&gt;// 或deque时，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// erase-remove惯用法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 是去除特定值的元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这方法也适合于list，但是，正如条款44解释的，list的成员函数remove更高效：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.remove(&lt;span style=&#34;color:#ae81ff&#34;&gt;1963&lt;/span&gt;);     &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是list时，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// remove成员函数是去除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 特定值的元素的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当c是标准关联容器（即，set、multiset、map或multimap）时，使用任何叫做remove的东 西都是完全错误的。这样的容器没有叫做remove的成员函数，而且使用remove算法可能覆 盖容器值（参见条款32），潜在地破坏容器。（关于这样的破坏的细节，参考条款22，那 个条款也解释了为什么试图在map和multimap上使用remove肯定不能编译，而试图在set和 multiset上使用可能不能编译。）&lt;/p&gt;
&lt;p&gt;不，对于关联容器，解决问题的适当方法是调用erase：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.erase(&lt;span style=&#34;color:#ae81ff&#34;&gt;1963&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是标准关联容器时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// erase成员函数是去除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 特定值的元素的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这不仅是正确的，而且很高效，只花费对数时间。（序列容器的基于删除的技术需要线性 时间。）并且，关联容器的erase成员函数有基于等价而不是相等的优势，条款19解释了这 一区别的重要性。&lt;/p&gt;
&lt;p&gt;让我们现在稍微修改一下这个问题。不是从c中除去每个有特定值的物体，让我们消除下面 判断式（参见条款39）返回真的每个对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;badValue&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x);   &lt;span style=&#34;color:#75715e&#34;&gt;// 返回x是否是“bad”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对于序列容器（&lt;/span&gt;vector&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;string&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;deque&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;和&lt;/span&gt;list&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;），我们要做的只是把每个&lt;/span&gt;remove()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;替换为&lt;/span&gt;remove_if()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，然后就完成了：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.erase(remove_if(c.begin(), c.end(), badValue),    &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是vector、string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;c.end());           &lt;span style=&#34;color:#75715e&#34;&gt;// 或deque时这是去掉
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// badValue返回真
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的对象的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;c.remove_if(badValue);              &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是list时这是去掉
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// badValue返回真
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的对象的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于标准关联容器，它不是很直截了当。有两种方法处理该问题，一个更容易编码，另一 个更高效。“更容易但效率较低”的解决方案用&lt;code&gt;remove_copy_if()&lt;/code&gt;把我们需要的值拷贝到一 个新容器中，然后把原容器的内容和新的交换：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;              &lt;span style=&#34;color:#75715e&#34;&gt;// c现在是一种
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;...                                 &lt;span style=&#34;color:#75715e&#34;&gt;// 标准关联容器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; goodValues;         &lt;span style=&#34;color:#75715e&#34;&gt;// 用于容纳不删除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的值的临时容器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;remove_copy_if(c.begin(), c.end(),          &lt;span style=&#34;color:#75715e&#34;&gt;// 从c拷贝不删除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;inserter(goodValues,        &lt;span style=&#34;color:#75715e&#34;&gt;// 的值到
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;goodValues.end()),          &lt;span style=&#34;color:#75715e&#34;&gt;// goodValues
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;badValue);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.swap(goodValues);             &lt;span style=&#34;color:#75715e&#34;&gt;// 交换c和goodValues
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的内容
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种方法的缺点是它拷贝了所有不删除的元素，而这样的拷贝开销可能大于我们期望的底线。&lt;/p&gt;
&lt;p&gt;我们可以通过直接从原容器删除元素来避开拷贝的开销。不过，因为关联容器没有提供类似&lt;code&gt;remove_if()&lt;/code&gt;的成员函数，所以我们必须写一个循环来迭代c中的元素，和原来一样删除元素.&lt;/p&gt;
&lt;p&gt;看起来，这个任务很简单，而且实际上，代码也很简单。不幸的是，那些正确工作的代码 很少是跃出脑海的代码。例如，这是很多程序员首先想到的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();   &lt;span style=&#34;color:#75715e&#34;&gt;// 清晰，直截了当
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; c.end();                                &lt;span style=&#34;color:#75715e&#34;&gt;// 而漏洞百出的用于
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {                                      &lt;span style=&#34;color:#75715e&#34;&gt;// 删除c中badValue返回真
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)) c.erase(i);                   &lt;span style=&#34;color:#75715e&#34;&gt;// 的每个元素的代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}                                                   &lt;span style=&#34;color:#75715e&#34;&gt;// 不要这么做！&amp;lt;/int&amp;gt;&amp;lt;/int&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;唉，这有未定义的行为。当容器的一个元素被删时，指向那个元素的所有迭代器都失效了 。当c.erase(i)返回时，i已经失效。那对于这个循环是个坏消息，因为在erase()返回后， i通过for循环的++i部分自增。&lt;/p&gt;
&lt;p&gt;为了避免这个问题，我们必须保证在调用erase之前就得到了c中下一元素的迭代器。最容 易的方法是当我们调用时在i上使用后置递增：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();   &lt;span style=&#34;color:#75715e&#34;&gt;// for循环的第三部分
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; c.end();                                   &lt;span style=&#34;color:#75715e&#34;&gt;// 是空的；i现在在下面
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*nothing*/&lt;/span&gt; ){                                 &lt;span style=&#34;color:#75715e&#34;&gt;// 自增
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)) c.erase(i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;);     &lt;span style=&#34;color:#75715e&#34;&gt;// 对于坏的值，把当前的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i;                           &lt;span style=&#34;color:#75715e&#34;&gt;// i传给erase，然后
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}                                       &lt;span style=&#34;color:#75715e&#34;&gt;// 作为副作用增加i；
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 对于好的值，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 只增加i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种调用erase()的解决方法可以工作，因为表达式i++的值是i的旧值，但作为副作用，i增 加了。因此，我们把i的旧值（没增加的）传给erase，但在erase开始执行前i已经自增了 。那正好是我们想要的。正如我所说的，代码很简单，只不过不是大多数程序员在第一次 尝试时想到的。&lt;/p&gt;
&lt;p&gt;现在让我们进一步修改该问题。不仅删除badValue返回真的每个元素，而且每当一个元素 被删掉时，我们也想把一条消息写到日志文件中。&lt;/p&gt;
&lt;p&gt;对于关联容器，这说多容易就有多容易，因为只需要对我们刚才开发的循环做一个微不足 道的修改就行了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ofstream logFile;                   &lt;span style=&#34;color:#75715e&#34;&gt;// 要写入的日志文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();   &lt;span style=&#34;color:#75715e&#34;&gt;// 循环条件和前面一样
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;c.end();){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logFile &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Erasing &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 写日志文件 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        c.erase(i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;);           &lt;span style=&#34;color:#75715e&#34;&gt;// 删除元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在是vector、string和deque给我们带来麻烦。我们不能再使用&lt;code&gt;erase-remove&lt;/code&gt;惯用法，因为没有办法让erase()或remove()写日志文件。而且，我们不能使用刚刚为关联容器开发的循环, 因为它为vector、string和deque产生未定义的行为！要记得对于那样的容器，调用erase不仅使所有指向被删元素的迭代器失效，也使被删元素之后的所有迭代器失效。在我们的情况里，那包括所有i之后的迭代器。我们写i++，++i或你能想起的其它任何东西都没有用，因为没有能导致迭代器有效的。&lt;/p&gt;
&lt;p&gt;我们必须对vector、string和deque采用不同的战略。特别是，我们必须利用erase()的返回值。那个返回值正是我们需要的：一旦删除完成，它就是指向紧接在被删元素之后的元素的有效迭代器。换句话说，我们这么写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (SeqContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; c.end();){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logFile &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Erasing &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.erase(i);         &lt;span style=&#34;color:#75715e&#34;&gt;// 通过把erase的返回值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }                   &lt;span style=&#34;color:#75715e&#34;&gt;// 赋给i来保持i有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这可以很好地工作，但只用于标准序列容器。由于论证一个可能的问题（条款5做了），标准关联容器的erase()的返回类型是void[1]。对于那些容器，你必须使用“后置递增你要传给erase()的迭代器”技术。（顺便说说，在为序列容器编码和为关联容器编码之间的这种差别是为什么写容器无关代码一般缺乏考虑的一个例子——参见条款2。)&lt;/p&gt;
&lt;p&gt;为了避免你奇怪list的适当方法是什么，事实表明对于迭代和删除，你可以像vector/str ing/deque一样或像关联容器一样对待list；两种方法都可以为list工作。&lt;/p&gt;
&lt;p&gt;如果我们观察在本条款中提到的所有东西，我们得出下列结论：&lt;/p&gt;
&lt;p&gt;去除一个容器中有特定值的所有对象： 如果容器是vector、string或deque，使用erase-remove惯用法。&lt;/p&gt;
&lt;p&gt;如果容器是list，使用list::remove。&lt;/p&gt;
&lt;p&gt;如果容器是标准关联容器，使用它的erase成员函数。&lt;/p&gt;
&lt;p&gt;去除一个容器中满足一个特定判定式的所有对象： 如果容器是vector、string或deque，使用&lt;code&gt;erase-remove_if&lt;/code&gt;惯用法。&lt;/p&gt;
&lt;p&gt;如果容器是list，使用list::remove_if。&lt;/p&gt;
&lt;p&gt;如果容器是标准关联容器，使用&lt;code&gt;remove_copy_if&lt;/code&gt;和&lt;code&gt;swap&lt;/code&gt;，或写一个循环来遍历容器元素， 当你把迭代器传给erase时记得后置递增它。&lt;/p&gt;
&lt;p&gt;在循环内做某些事情（除了删除对象之外）： 如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。 如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。&lt;/p&gt;
&lt;p&gt;如你所见，与仅仅调用erase相比，有效地删除容器元素有更多的东西。解决问题的最好方法取决于你是怎样鉴别出哪个对象是要被去掉的，储存它们的容器的类型，和当你删除它们的时候你还想要做什么（如果有的话）。只要你小心而且注意了本条款的建议，你将毫不费力。如果你不小心，你将冒着产生不必要低效的代码或未定义行为的危险。&lt;/p&gt;
&lt;h2 id=&#34;------------------------------------------------------------------------------&#34;&gt;------------------------------------------------------------------------------&lt;/h2&gt;
&lt;p&gt;[1] 这仅对带有迭代器实参的erase()形式是正确的。关联容器也提供一个带有一个值的实参 的erase()形式，而那种形式返回被删掉的元素个数。但这里，我们只关心通过迭代器删除东 西。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_3%2FC%2Fnetres%2Feffstl%2Ffile10.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
