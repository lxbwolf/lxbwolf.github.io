<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>pb on Xiaobin&#39;s Blog</title>
        <link>https://lxb.wiki/tags/pb/</link>
        <description>Recent content in pb on Xiaobin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 21 Mar 2018 17:47:31 +0000</lastBuildDate><atom:link href="https://lxb.wiki/tags/pb/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>protocol buffer</title>
        <link>https://lxb.wiki/66065582/</link>
        <pubDate>Wed, 21 Mar 2018 17:47:31 +0000</pubDate>
        
        <guid>https://lxb.wiki/66065582/</guid>
        <description>&lt;h5 id=&#34;developer-guide&#34;&gt;Developer Guide&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;.proto&lt;/code&gt; 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you&amp;rsquo;ve defined your messages, you run the protocol buffer compiler for your application&amp;rsquo;s language on your .proto file to generate data access classes. These provide simple accessors for each field (like name() and set_name()) as well as methods to serialize/parse the whole structure to/from raw bytes&lt;/p&gt;
&lt;p&gt;You can add new fields to your message formats without breaking backwards-compatibility; old binaries simply ignore the new field when parsing. So if you have a communications protocol that uses protocol buffers as its data format, you can extend your protocol without having to worry about breaking existing code.&lt;/p&gt;
&lt;h5 id=&#34;language-guide&#34;&gt;Language Guide&lt;/h5&gt;
&lt;h6 id=&#34;defining-a-message-type&#34;&gt;Defining A Message Type&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;; // First non-empty; first non-comment line

message SearchRequest {
  string query = 1; // unique numbered tag
  int32 page_number = 2;
  int32 result_per_page = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;specifying-field-types&#34;&gt;Specifying Field Types&lt;/h6&gt;
&lt;h6 id=&#34;assigning-tags&#34;&gt;Assigning Tags&lt;/h6&gt;
&lt;p&gt;1-15 one byte 16-2047 two bytes you should reserve the tags 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.&lt;/p&gt;
&lt;p&gt;range: 1 to 536,870,911 You also cannot use the numbers 19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber)&lt;/p&gt;
&lt;h6 id=&#34;specifying-field-rules&#34;&gt;Specifying Field Rules&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;singular zero or one of this field&lt;/li&gt;
&lt;li&gt;repeated any number of times&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;adding-more-message-types&#34;&gt;Adding More Message Types&lt;/h6&gt;
&lt;h6 id=&#34;reserved-fields&#34;&gt;Reserved Fields&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;message Foo {
  reserved 2, 15, 9 to 11;
  reserved &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that you can&amp;rsquo;t mix field names and tag numbers in the same reserved statement.&lt;/p&gt;
&lt;h6 id=&#34;whats-generated-from-your-proto&#34;&gt;What&amp;rsquo;s Generated From Your .proto?&lt;/h6&gt;
&lt;h6 id=&#34;default-values&#34;&gt;Default Values&lt;/h6&gt;
&lt;p&gt;sigular: - string - byte - bool - numeric type - enum - message field&lt;/p&gt;
&lt;p&gt;repeated: - repeated filed&lt;/p&gt;
&lt;h6 id=&#34;enumerations&#34;&gt;Enumerations&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  Corpus corpus = 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can define aliases by assigning the same value to different enum constants&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum EnumAllowingAlias {
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1;
}

enum EnumNotAllowingAlias {
  UNKNOWN = 0;
  STARTED = 1;
  // RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;reserved-values&#34;&gt;Reserved Values&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;enum Foo {
  reserved 2, 15, 9 to 11, 40 to max;
  reserved &amp;quot;FOO&amp;quot;, &amp;quot;BAR&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that you can&amp;rsquo;t mix field names and numeric values in the same reserved statement.&lt;/p&gt;
&lt;h6 id=&#34;using-other-message-types&#34;&gt;Using Other Message Types&lt;/h6&gt;
&lt;p&gt;Define a message in the same &lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message SearchResponse {
  repeated Result results = 1;
}

message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;importing-definitions&#34;&gt;Importing Definitions&lt;/h6&gt;
&lt;p&gt;By default you can only use definitions from directly imported .proto files. &lt;code&gt;import &amp;quot;myproject/other_protos.proto&amp;quot;;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// new.proto
// All definitions are moved here
======================================================
// old.proto
// This is the proto that all clients are importing.
import public &amp;quot;new.proto&amp;quot;;
import &amp;quot;other.proto&amp;quot;;
======================================================
// client.proto
import &amp;quot;old.proto&amp;quot;;
// You use definitions from old.proto and new.proto, but not other.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The protocol compiler searches for imported files in a set of directories specified on the protocol compiler command line using the -I/&amp;ndash;proto_path flag. If no flag was given, it looks in the directory in which the compiler was invoked. In general you should set the &amp;ndash;proto_path flag to the root of your project and use fully qualified names for all imports.&lt;/p&gt;
&lt;h6 id=&#34;using-proto2-message-types&#34;&gt;Using proto2 Message Types&lt;/h6&gt;
&lt;p&gt;It&amp;rsquo;s possible to import proto2 message types and use them in your proto3 messages, and vice versa. However, proto2 enums cannot be used directly in proto3 syntax (it&amp;rsquo;s okay if an imported proto2 message uses them).&lt;/p&gt;
&lt;h6 id=&#34;nested-types&#34;&gt;Nested Types&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result results = 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to reuse this message type outside its parent message type, you refer to it as &lt;code&gt;Parent.Type&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message SomeOtherMessage {
  SearchResponse.Result result = 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can nest messages as deeply as you like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message Outer {                  // Level 0
  message MiddleAA {  // Level 1
    message Inner {   // Level 2
      int64 ival = 1;
      bool  booly = 2;
    }
  }
  message MiddleBB {  // Level 1
    message Inner {   // Level 2
      int32 ival = 1;
      bool  booly = 2;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;updating-a-message-type&#34;&gt;Updating A Message Type&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;Don&amp;rsquo;t change the numeric tags for any existing fields&lt;/li&gt;
&lt;li&gt;If you add new fields, any messages serialized by code using your &amp;ldquo;old&amp;rdquo; message format can still be parsed by your new generated code&lt;/li&gt;
&lt;li&gt;Fields can be removed, as long as the tag number is not used again in your updated message type
&lt;ul&gt;
&lt;li&gt;You may want to rename the field instead, perhaps adding the prefix &amp;ldquo;OBSOLETE_&amp;rdquo;, or make the tag reserved, so that future users of your .proto can&amp;rsquo;t accidentally reuse the number.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compatibility
&lt;ul&gt;
&lt;li&gt;int32, uint32, int64, uint64, and bool are all compatible&lt;/li&gt;
&lt;li&gt;sint32 and sint64 are compatible with each other but are not compatible with the other integer types&lt;/li&gt;
&lt;li&gt;string and bytes are compatible as long as the bytes are valid UTF-8&lt;/li&gt;
&lt;li&gt;Embedded messages are compatible with bytes if the bytes contain an encoded version of the message&lt;/li&gt;
&lt;li&gt;fixed32 is compatible with sfixed32, and fixed64 with sfixed64&lt;/li&gt;
&lt;li&gt;enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don&amp;rsquo;t fit)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Moving any fields into an existing oneof is not safe&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;any&#34;&gt;Any&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;google/protobuf/any.proto&amp;quot;;

message ErrorStatus {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;oneof&#34;&gt;Oneof&lt;/h6&gt;
&lt;p&gt;You can add fields of any type, but cannot use &lt;code&gt;repeated&lt;/code&gt; fields&lt;/p&gt;
&lt;p&gt;Features: - Setting a oneof field will automatically clear all other members of the oneof - If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message - If you&amp;rsquo;re using C++, make sure your code doesn&amp;rsquo;t cause memory crashes - Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case&lt;/p&gt;
&lt;h6 id=&#34;maps&#34;&gt;Maps&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;map&amp;lt;key_type, value_type&amp;gt; map_field = N&lt;/code&gt; The &lt;code&gt;key_type&lt;/code&gt; can be any integral or string type. The &lt;code&gt;value_type&lt;/code&gt; can be any type except another map.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map fields cannot be &lt;code&gt;repeated&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Wire format ordering and map iteration ordering of map values is undefined&lt;/li&gt;
&lt;li&gt;When generating text format for a &lt;code&gt;.proto&lt;/code&gt;, maps are sorted by key&lt;/li&gt;
&lt;li&gt;When parsing from the wire or when merging, if there are duplicate map keys the last key seen is used. When parsing a map from text format, parsing may fail if there are duplicate keys&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;backwords compatibility:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message MapFieldEntry {
  key_type key = 1;
  value_type value = 2;
}

repeated MapFieldEntry map_field = N;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;packages&#34;&gt;Packages&lt;/h6&gt;
&lt;h6 id=&#34;json-mapping&#34;&gt;JSON Mapping&lt;/h6&gt;
</description>
        </item>
        
    </channel>
</rss>
