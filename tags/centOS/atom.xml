<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>centOS on Xiaobin&#39;s Blog</title>
        <link>http://lxb.wiki/tags/centOS/</link>
        <description>Recent content in centOS on Xiaobin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 10 Oct 2019 00:36:59 +0000</lastBuildDate><atom:link href="http://lxb.wiki/tags/centOS/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>CentOS释放被占用端口</title>
        <link>http://lxb.wiki/2d1cc7f9/</link>
        <pubDate>Thu, 10 Oct 2019 00:36:59 +0000</pubDate>
        
        <guid>http://lxb.wiki/2d1cc7f9/</guid>
        <description>&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt;
在前面的某些操作中, 启动某进程时, 监听8080 和 443 端口, 后进程关闭, 这两个端口却一直处于占用状态, 导致后面再起进程想监听这两个端口时, 启动报错&lt;/p&gt;
&lt;p&gt;1.输入netstat -tln,查看系统当前所有被占用端口,主要是为了查看你的端口是否真正的被占用着,搭建可以看到我的9001,和9002端口都已经被占用了,所以我需要释放这两个端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003213.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;listen-port&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;2.根据端口查询进程,输入lsof -i :9001,切记不要忘了添加冒号,如下图,就可以看到当前被占用的端口的进程
的进程编号&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003347.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;kill 掉PID&lt;/li&gt;
&lt;li&gt;再&lt;code&gt;netstat -tln&lt;/code&gt; 确认下, 然后就可以起进程了&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>CentOS7升级gcc 和gdb</title>
        <link>http://lxb.wiki/ec9feff6/</link>
        <pubDate>Wed, 28 Mar 2018 11:37:20 +0000</pubDate>
        
        <guid>http://lxb.wiki/ec9feff6/</guid>
        <description>&lt;p&gt;升级后版本: gcc-5.4.0 gdb-7.11.1&lt;/p&gt;
&lt;h4 id=&#34;安装开发必备环境&#34;&gt;安装开发必备环境&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;yum groupinstall &amp;quot;Development Tools&amp;quot;
yum install glibc-static libstdc++-static
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;编译安装gcc-540&#34;&gt;编译安装gcc-5.4.0&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gcc下载地址&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -xvf gcc-5.4.0.tar.bz2
cd gcc-5.4.0
./contrib/download_prerequisits
mkdir build
cd build
../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib
make（建议不要使用make -j来编译，虽然可以缩短编译时间，但极大可能会编译失败）
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中执行&lt;code&gt;./contrib/download_prerequisits&lt;/code&gt;将自动下载以下几个文件，这个几个文件在gcc编译时需要： - mpfr-2.4.2.tar.bz2 - gmp-4.3.2.tar.bz2 - mpc-0.8.1.tar.gz - isl-0.15.tar.bz2&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make install&lt;/code&gt; 时, 自动安装到&lt;code&gt;/usr/local/gcc-5.40&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;解决运行程序时-gcc-报错glibcxx_3421-not-found&#34;&gt;解决运行程序时, gcc 报错&amp;rsquo;GLIBCXX_3.4.21&amp;rsquo; not found&lt;/h4&gt;
&lt;p&gt;这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决，运行以下命令检查动态库： &lt;code&gt;strings /lib64/libstdc++.so.6 | grep GLIBC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以下是输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GLIBCXX_3.4
GLIBCXX_3.4.1
GLIBCXX_3.4.2
GLIBCXX_3.4.3
GLIBCXX_3.4.4
GLIBCXX_3.4.5
GLIBCXX_3.4.6
GLIBCXX_3.4.7
GLIBCXX_3.4.8
GLIBCXX_3.4.9
GLIBCXX_3.4.10
GLIBCXX_3.4.11
GLIBCXX_3.4.12
GLIBCXX_3.4.13
GLIBCXX_3.4.14
GLIBCXX_3.4.15
GLIBCXX_3.4.16
GLIBCXX_3.4.17
GLIBCXX_3.4.18
GLIBCXX_3.4.19
GLIBC_2.3
GLIBC_2.2.5
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3.2
GLIBCXX_DEBUG_MESSAGE_LENGTH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从输出结果可以看到并没有“GLIBCXX_3.4.21“,所以可以断定我们的程序运行时动态加载的是老的动态库，解决这个问题需要将当前链接文件的链接指向改成最新的动态库地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp /usr/local/lib64/libstdc++.so.6.0.21 /lib64
cd /lib64
rm -rf libstdc++.so.6
ln -s libstdc++.so.6.0.21 libstdc++.so.6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以执行以下命令来查看&amp;rsquo;GLIBCXX_3.4.21&amp;rsquo;已经可以找到了: &lt;code&gt;strings /lib64/libstdc++.so.6 | grep GLIBC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决了这个问题终于可以执行程序了，然后又测试了-g选项来编译程序，编译好程序调试程序时并不能够设置断点以及print变量的值，gdb调试中出现：Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.e17_2.6.x86_4 libgcc-4.8.5-4.e17.x86_64的问题，通过上网查阅资料，是因为gcc版本和gdb版本并不匹配，或者说gdb版本过低&lt;/p&gt;
&lt;h4 id=&#34;编译安装gdb-7111&#34;&gt;编译安装gdb-7.11.1&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://ftp.gnu.org/gnu/gdb/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gdb下载地址&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -xvf gdb-7.11.1.tar.gz
cd gdb-7.11.1
./configure
make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行make install时gdb安装出现了错误：&lt;code&gt;WARNING: &#39;makeinfo&#39; is missing on your sysem&lt;/code&gt;，则需安装相关依赖程序: &lt;code&gt;yum install texinfo libncurses5-dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果调试程序时出现下面信息时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warning: File &amp;quot;/usr/local/lib64/libstdc++.so.6.0.21-gdb.py&amp;quot; auto-loading has been declined by your `auto-load safe-path&#39; set to &amp;quot;$debugdir:$datadir/auto-load&amp;quot;.
To enable execution of this file add
    add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.py
line to your configuration file &amp;quot;/root/.gdbinit&amp;quot;.
To completely disable this security protection add
    set auto-load safe-path /
line to your configuration file &amp;quot;/root/.gdbinit&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方法: 将以下信息放入&lt;code&gt;~/.gdbinit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.py
set auto-load safe-path /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若想通过gdb来调试STL容器，则还需要做一些配置，可以通过&lt;code&gt;GDB Python pretty printers&lt;/code&gt;来解决这个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;svn checkout svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python stlPrettyPrinter
mv stlPrettyPrinter /usr/local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将下面的配置信息放入&lt;code&gt;~/.gdbinit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python
import sys
sys.path.insert(0, &#39;/usr/local/stlPrettyPrinter&#39;)
from libstdcxx.v6.printers import register_libstdcxx_printers
register_libstdcxx_printers (None)
end
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
