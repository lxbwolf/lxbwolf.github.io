<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>c&#43;&#43; on Xiaobin&#39;s Notes</title>
        <link>https://lxb.wiki/tags/c&#43;&#43;/</link>
        <description>Recent content in c&#43;&#43; on Xiaobin&#39;s Notes</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 21 Aug 2020 07:13:27 +0000</lastBuildDate><atom:link href="https://lxb.wiki/tags/c++/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; Lambda 表达式</title>
        <link>https://lxb.wiki/e4d97659/</link>
        <pubDate>Fri, 21 Aug 2020 07:13:27 +0000</pubDate>
        
        <guid>https://lxb.wiki/e4d97659/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。&lt;/p&gt;
&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;p&gt;Lambda 表达式的基本语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;捕获列表&lt;/span&gt;](&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;参数列表&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;mutable&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;可选&lt;/span&gt;) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;异常属性&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;返回类型&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 函数体
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的语法规则除了 &lt;code&gt;[捕获列表]&lt;/code&gt; 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。&lt;/p&gt;
&lt;p&gt;所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：&lt;/p&gt;
&lt;h4 id=&#34;1-值捕获&#34;&gt;1. 值捕获&lt;/h4&gt;
&lt;p&gt;与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，&lt;strong&gt;被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lambda_value_capture&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; copy_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [value] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copy_value();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stored_value = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这时, stored_value == 1, 而 value == 100.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 copy_value 在创建时就保存了一份 value 的拷贝
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-引用捕获&#34;&gt;2. 引用捕获&lt;/h4&gt;
&lt;p&gt;与引用传参类似，引用捕获保存的是引用，值会发生变化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lambda_reference_capture&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; copy_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copy_value();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stored_value = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这时, stored_value == 100, value == 100.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 copy_value 保存的是引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-隐式捕获&#34;&gt;3. 隐式捕获&lt;/h4&gt;
&lt;p&gt;手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;=&lt;/code&gt; 向编译器声明采用引用捕获或者值捕获.&lt;/p&gt;
&lt;p&gt;总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[] 空捕获列表&lt;/li&gt;
&lt;li&gt;[name1, name2, …] 捕获一系列变量&lt;/li&gt;
&lt;li&gt;[&amp;amp;] 引用捕获, 让编译器自行推导捕获列表&lt;/li&gt;
&lt;li&gt;[=] 值捕获, 让编译器执行推导引用列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-表达式捕获&#34;&gt;4. 表达式捕获&lt;/h4&gt;
&lt;p&gt;上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。&lt;/p&gt;
&lt;p&gt;C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 &lt;code&gt;auto&lt;/code&gt; 本质上是相同的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;utility&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; important &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;make_unique&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; add &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [v1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, v2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(important)](&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;v1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; add(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的代码中，&lt;code&gt;important&lt;/code&gt; 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值， 在表达式中初始化。&lt;/p&gt;
&lt;h3 id=&#34;泛型-lambda&#34;&gt;泛型 Lambda&lt;/h3&gt;
&lt;p&gt;上一节中我们提到了 &lt;code&gt;auto&lt;/code&gt; 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。 这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。&lt;/p&gt;
&lt;p&gt;幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始， Lambda 函数的形式参数可以使用 &lt;code&gt;auto&lt;/code&gt; 关键字来产生意义上的泛型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; add &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [](&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; y) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>大小端</title>
        <link>https://lxb.wiki/7ee0edaa/</link>
        <pubDate>Fri, 24 May 2019 18:37:53 +0000</pubDate>
        
        <guid>https://lxb.wiki/7ee0edaa/</guid>
        <description>&lt;p&gt;计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构而已），比如C/C++中，short类型一般是2个字节，int类型一般4个字节等。因此这里就存在着一个如何安排多个字节数据中各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。&lt;/p&gt;
&lt;h4 id=&#34;1-解释&#34;&gt;1. 解释&lt;/h4&gt;
&lt;p&gt;假如有一个4字节的数据为 0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址 0x4000 8000中，则有：&lt;/p&gt;
&lt;p&gt;内存地址&lt;/p&gt;
&lt;p&gt;0x4000 8000（低地址）&lt;/p&gt;
&lt;p&gt;0x4000 8001&lt;/p&gt;
&lt;p&gt;0x4000 8002&lt;/p&gt;
&lt;p&gt;0x4000 8003（高地址）&lt;/p&gt;
&lt;p&gt;大端模式&lt;/p&gt;
&lt;p&gt;0x12（高字节）&lt;/p&gt;
&lt;p&gt;0x34&lt;/p&gt;
&lt;p&gt;0x56&lt;/p&gt;
&lt;p&gt;0x78（低字节）&lt;/p&gt;
&lt;p&gt;小端模式&lt;/p&gt;
&lt;p&gt;0x78（低字节）&lt;/p&gt;
&lt;p&gt;0x56&lt;/p&gt;
&lt;p&gt;0x34&lt;/p&gt;
&lt;p&gt;0x12（高字节）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中&lt;/li&gt;
&lt;li&gt;小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么截然相反的大小端存储模式能够并存至今？在标准化备受推崇的今天，为什么大小端谁都没有被另外一个所同化？我想这除了历史的惯性使然，还与它们各自的优缺点有关。 大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小 小端模式优点：1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）； 2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持（见1.3节），因此在多字节存储顺序上始终没有一个统一的标准&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel的80×86系列芯片使用小端存储模式&lt;/li&gt;
&lt;li&gt;ARM芯片默认采用小端，但可以切换为大端&lt;/li&gt;
&lt;li&gt;MIPS芯片采用大端，但可以在大小端之间切换&lt;/li&gt;
&lt;li&gt;在网络上传输的数据普遍采用的都是大端&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-判断&#34;&gt;2. 判断&lt;/h4&gt;
&lt;p&gt;方法一：通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @Ret: 大端，返回true; 小端，返回false
bool IsBigEndian_1()
{
    int nNum = 0x12345678;
    char cLowAddressValue = *(char*)&amp;amp;nNum;

    // 低地址处是高字节，则为大端
    if ( cLowAddressValue == 0x12 )    return true;

    return false; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二：利用联合体union的存放顺序是所有成员都从低地址开始存放这一特性进行检测&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @Ret: 大端，返回true; 小端，返回false
bool isBigEndian_2()
{
    union uendian
    {
       int nNum;
       char cLowAddressValue;
    };

    uendian u;
    u.nNum = 0x12345678;

    if ( u.cLowAddressValue == 0x12 )     return true;

    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-转换&#34;&gt;3. 转换&lt;/h4&gt;
&lt;p&gt;大小端转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 实现16bit的数据之间的大小端转换
#define BLSWITCH16(A)   (  ( ( (uint16)(A) &amp;amp; 0xff00 ) &amp;gt;&amp;gt; 8  )    | \  
                           ( ( (uint16)(A) &amp;amp; 0x00ff ) &amp;lt;&amp;lt; 8  )     )  

// 实现32bit的数据之间的大小端转换
#define BLSWITCH32(A)   (  ( ( (uint32)(A) &amp;amp; 0xff000000) &amp;gt;&amp;gt; 24) |\
         (((uint32)(A) &amp;amp; 0x00ff0000) &amp;gt;&amp;gt; 8) | \
         (((unit32)(A) &amp;amp; 0x0000ff00) &amp;lt;&amp;lt; 8) | \
         (((uint32)(A) &amp;amp; 0x000000ff) &amp;lt;&amp;lt; 32)  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】How to split a string in C&#43;&#43;</title>
        <link>https://lxb.wiki/9747854a/</link>
        <pubDate>Sun, 04 Jun 2017 18:40:14 +0000</pubDate>
        
        <guid>https://lxb.wiki/9747854a/</guid>
        <description>&lt;p&gt;这个问题是说, 怎么得到组成一句话的各个单词, 或者得到CSV中的各个数据片段. 这在C++中是个很简单的问题, 却有很多种答案.&lt;/p&gt;
&lt;p&gt;有3种方案, 每种有利有弊. 使用时请自己选择最佳方案. 这篇文章的目的是说明 迭代器的接口是如何优胜于简单的容器的, 并且阐明 &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;design of the STL&lt;/a&gt; 是何等强大.&lt;/p&gt;
&lt;p&gt;方案1使用的标准组件(虽然方案1.2 做了微调). 方案2相对好点但使用了&lt;code&gt;boost&lt;/code&gt;. 而方案3 更好但使用了&lt;code&gt;ranges&lt;/code&gt;. 所以到底应该用哪个, 取决于你需要什么和你能使用什么.&lt;/p&gt;
&lt;h3 id=&#34;solution-1-iterating-on-a-stream&#34;&gt;Solution 1: Iterating on a stream&lt;/h3&gt;
&lt;h4 id=&#34;stepping-into-the-world-of-streams&#34;&gt;Stepping into the world of streams&lt;/h4&gt;
&lt;p&gt;&amp;ldquo;流&amp;rdquo; 是一个 能生成 与源或希望连接的目标 的联系 的对象. 流可以从源中获取信息(&lt;code&gt;std::istream&lt;/code&gt;), 或为目标提供信息(&lt;code&gt;std::ostream&lt;/code&gt;), 或者两者皆可(&lt;code&gt;std::iostream&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;源和目标可以是标准输入(&lt;code&gt;std::cin&lt;/code&gt;), 标准输出(&lt;code&gt;std::cout&lt;/code&gt;), 一个文件, 或者一个字符串, 前提是方式得当. 对流的主要操作包括: - 对于输入流: 使用操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 从里面读取信息 - 对于输出流: 使用操作符&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, 向它推入信息&lt;/p&gt;
&lt;p&gt;一个指向字符串的输入流, &lt;code&gt;std::istringstream&lt;/code&gt;, 有个有趣的特性: 它的操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 在源字符串中制造出去向下一个空格的字符串.&lt;/p&gt;
&lt;h4 id=&#34;istream_iterator&#34;&gt;istream_iterator&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;std::istream_iterator&lt;/code&gt; 是连接输入流的迭代器. 它代表了输入迭代器的普遍接口, 但它的操作符&lt;code&gt;++&lt;/code&gt; 更像是输入流.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream_iterator&lt;/code&gt; 以它从流里读取的类型为模板. 我们现在使用&lt;code&gt;istream_iterator&amp;lt;std::string&amp;gt;&lt;/code&gt;, 它从流里读取字符串, 分离时为我们提供一个字符串.&lt;/p&gt;
&lt;p&gt;当到达流的终点时, 流向它的迭代器发送信号, 然后迭代器被标记为结束.&lt;/p&gt;
&lt;h3 id=&#34;solution-11&#34;&gt;Solution 1.1&lt;/h3&gt;
&lt;p&gt;现在, 我们可以借迭代器的接口使用算法, 这真切地证明了&lt;code&gt;STL&lt;/code&gt; 设计的灵活性. 为了使用&lt;code&gt;STL&lt;/code&gt;, 我们需要一个&lt;code&gt;begin&lt;/code&gt; 和一个&lt;code&gt;end&lt;/code&gt; (请参考&lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/03/28/inserting-several-elements-into-an-stl-container/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Inserting several elements into an STL container efficiently&lt;/a&gt;). &lt;code&gt;begin&lt;/code&gt; 是一个 还没开始着手分割的字符串的&lt;code&gt;istreamstream&lt;/code&gt; 的迭代器: &lt;code&gt;std::istream_iterator&amp;lt;std::string&amp;gt;(iss)&lt;/code&gt; . 按照惯例, &lt;code&gt;end&lt;/code&gt; 的默认值也是个&lt;code&gt;istream_iterator&lt;/code&gt; : &lt;code&gt;std::istream_iterator&amp;lt;string&amp;gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let me split this into words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;std::string&amp;gt;(iss)), std::istream_iterator&amp;lt;std::string&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第一个参数的额外的括号是为了避免与一个函数调用的歧义&amp;ndash;请参考Scott Meyers的著作Effective STL 条目6 &amp;ldquo;most vexing parse&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优: - 仅使用标准组件 - 除字符串外, 对所有流都适用 劣: - 只能以空格为分隔符进行分割, 而且这在解析CSV时会是个至关重要的问题 - 在性能方面有待优化(但如果这不是影响你整个程序的瓶颈, 这也不是个大问题) - 很多人认为仅为了分割一个字符串, 写了太多代码&lt;/p&gt;
&lt;h3 id=&#34;solution12-pimp-my-operator&#34;&gt;Solution1.2: Pimp my operator&amp;raquo;&lt;/h3&gt;
&lt;p&gt;导致上面两条劣势的原因是同一个: &lt;code&gt;istream_iterator&lt;/code&gt; 从流里读取字符串时调用的操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. 这个操作符做了很多事: 在下一个空格处停止(这是我们的最初的需求, 但这个不能自定义), 格式化, 读取然后设置一些标志位, 构造对象, 等等. 而以上这些, 大部分我们是不需要的. 所以我们希望自己实现下面的函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream&amp;amp; is, std::string&amp;amp; output)
{
    // ...does lots of things...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上, 我们无法改变这些, 因为这是在标注库里的. 我们可以用另一个类型重载它, 但是这个类型需要是&lt;code&gt;string&lt;/code&gt; 的一种.&lt;/p&gt;
&lt;p&gt;所以现在的需求就是, 用另一种类型伪装成&lt;code&gt;string&lt;/code&gt;. 有两种方案: 继承&lt;code&gt;std::string&lt;/code&gt; 和 用显式转换封装&lt;code&gt;string&lt;/code&gt;. 这里我们选择继承.&lt;/p&gt;
&lt;p&gt;假如我们希望以逗号为分割符分割一个字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class WordDelimitedByCommas: pulic std::string
{};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我必须承认这是有争议的. 有人会说:&amp;quot;&lt;code&gt;std::string&lt;/code&gt; 没有虚析构函数, 所以你不应该继承它!&amp;quot; 这可能, 大概, 也许是有一点点点点武断. 这里我要说的是, 继承本身不会产生问题. 诚然, 当一个指向&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 的指针以&lt;code&gt;std::string&lt;/code&gt; 的形式被&lt;code&gt;delete&lt;/code&gt; 掉时, 会产生问题. 继续读, 你会发现, 我们不会这么做. 现在我们可以阻止写代码的人借&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 突发冷箭破坏程序吗? 我们不能. 但是这个险值得我们冒吗? 请继续读, 然后你自己判断.&lt;/p&gt;
&lt;p&gt;现在为了仅实现我们需要的功能, 我们可以重载操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : 获取下一个逗号之前的所有字符. 这个可以借用&lt;code&gt;getline&lt;/code&gt; 函数实现:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream* is, std::WordDelimitedByCommas&amp;amp;)
{
    std::getline(is, output, &#39;,&#39;);
    return is;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;code&gt;is&lt;/code&gt; 保证了可以连续调用操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以写初级代码了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let,me,split,this,into,words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;WordDelimitedByCommas&amp;gt;(iss)), std::istream_iterator&amp;lt;WordDelimitedByCommas&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过模板化&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 泛华所有的分隔符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;char delemiter&amp;gt;
class WordDelimitedBy: pulic std::string
{};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在以分号举例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let;me;split;this;into;words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;WordDelimitedBy&amp;lt;&#39;;&#39;&amp;gt;&amp;gt;(iss)), std::istream_iterator&amp;lt;WordDelimitedBy&amp;lt;&#39;;&#39;&amp;gt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优: - 编译时允许任何分隔符 - 不仅是字符串, 对任何流都可以操作 - 比方案1更快(快20%到30%) 劣: - 虽然可以很方便的复用, 但仍不是标准 - 仅仅为了分割一个字符串, 这个方案仍然使用了大量代码&lt;/p&gt;
&lt;h3 id=&#34;solution2-using-boostsplit&#34;&gt;Solution2: Using &lt;code&gt;boost::split&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这个方案比方案1高级, 除非你需要对所有的流都进行操作.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost/algorithm/string.hpp&amp;gt;

std::string text = &amp;quot;Let me split this into words&amp;quot;;
std::vector&amp;lt;std::string&amp;gt; result;
boost::split&amp;lt;results, text, [](char c){return &#39; &#39; == c;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传给&lt;code&gt;boost::split&lt;/code&gt; 的第三个参数是一个函数或函数对象, 确定一个字符是不是分隔符. 上面的例子是使用&lt;code&gt;lambda&lt;/code&gt; 表达式, 传入一个&lt;code&gt;char&lt;/code&gt;, 返回这个&lt;code&gt;char&lt;/code&gt; 是否是空格.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::split&lt;/code&gt; 的实现很简单: 在到达字符串的结束位置之前, 重复地调用&lt;code&gt;find_if&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;优: - 非常直观的接口 - 允许任何分隔符, 甚至是多个 - 高效: 比方案1.1 快 60% 劣: - 暂不是标准: 需要用到&lt;code&gt;boost&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;solution-3未来-usingranges&#34;&gt;Solution 3(未来): Using&lt;code&gt;ranges&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;虽然它们现在还没有像标准库甚至&lt;code&gt;boost&lt;/code&gt; 里的组件一样被广泛使用, &lt;code&gt;ranges&lt;/code&gt; 是&lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/01/12/ranges-stl-to-the-next-level/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;future of the STL&lt;/a&gt; . 在未来几年, 会大量面世.&lt;/p&gt;
&lt;p&gt;Eric Neiber 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ericniebler/range-v3/blob/master/test/view/split.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;range-v3&lt;/a&gt; 库 提供了非常友好的接口. 为了生成一个字符串的分割&lt;code&gt;view&lt;/code&gt;, 代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let me split this into words&amp;quot;;
auto splitText = text | view::split(&#39; &#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它有很多有趣的特性, 诸如 使用一个子字符串作为分隔符. &lt;code&gt;ranges&lt;/code&gt; 会被&lt;code&gt;C++20&lt;/code&gt; 引入, 所以我们应该能在几年之内就可以使用这个功能了.&lt;/p&gt;
&lt;h3 id=&#34;so-how-do-i-split-my-string&#34;&gt;So, how do I split my string?&lt;/h3&gt;
&lt;p&gt;如果你能使用&lt;code&gt;boost&lt;/code&gt;, 务必使用方案2. 或者你可以自己写算法, 像&lt;code&gt;boost&lt;/code&gt; 那样基于&lt;code&gt;find_if&lt;/code&gt; 分割字符串.&lt;/p&gt;
&lt;p&gt;如果你不想这么做, 你可以使用标准, 即方案1.1, 如果你需要自定义分隔符, 或者发现1.1是个瓶颈, 那么你可以选择方案1.2 .&lt;/p&gt;
&lt;p&gt;如果你可以使用&lt;code&gt;ranges&lt;/code&gt; , 那么就应该选择方案3.&lt;/p&gt;
&lt;p&gt;翻译原文: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】C&#43;&#43;11 sort using function objects</title>
        <link>https://lxb.wiki/e754bcbe/</link>
        <pubDate>Wed, 19 Apr 2017 21:58:53 +0000</pubDate>
        
        <guid>https://lxb.wiki/e754bcbe/</guid>
        <description>&lt;p&gt;如果你用C++编码， 需要对容器内的元素进行排序， 这个容器提供任意访问的迭代器， 比如&lt;code&gt;std::vector&lt;/code&gt;， 那么简单快捷的方法是使用里的&lt;code&gt;std::sort&lt;/code&gt; 函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Basic sorting&lt;/strong&gt; &lt;code&gt;std::sort&lt;/code&gt; 函数需要两个参数, 这两个参数分别指向你要排序的序列容器的开始(initial)和终点(final). 这个序列容易内除final指向的那个元素外 所有元素都会被排序. 下面是一个简单的排序例子:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;0 5 10 15 20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More complex sorting&lt;/strong&gt; 在某些时候, 根据数值升序排序已经足够解决问题了, 但是当我们需要按某个特定的参数进行排序, 或者降序排列时, 就需要一些其他的东西了. 对于这种需求, &lt;code&gt;std::sort&lt;/code&gt; 需要引入第三个参数: 比较函数. 这个比较函数有两个参数, 分别是序列容器的两个元素, 返回值可以隐式地转为bool. 如果第一个参数应该排在第二个参数前面, 则返回true.&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescOrderInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end(), DescOrderInt);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;DescOrderInt的实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescOrderInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;20 15 10 5 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++11 sort using function objects&lt;/strong&gt; 网上很多例子说, 为了排列元素, 可以使用&lt;code&gt;std::binary_function&lt;/code&gt; 定义比较函数, 但不幸的是, &lt;code&gt;std::binary_function&lt;/code&gt; 在C++11 中已经被标为 &amp;ldquo;将被弃用的&amp;rdquo;, 在C++17中会被完全移除, 所以写新的C++代码时, 最好不要用这个.&lt;/p&gt;
&lt;p&gt;我们可以使用C++11中引入的&lt;code&gt;std::function&lt;/code&gt; 来定义这个函数指针. 例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;function&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/function&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StrDescOrderInt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sorter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StrDescOrderInt();&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end(), sorter);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;20 15 10 5 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A real-life example: providing multiple sorting options&lt;/strong&gt; 我们假设有一队足球运动员, 我们想让用户按他们自己的意愿去排列这些运动员. 有一个图表的UI, 上面有几个按钮, 每个按钮对应不用的排序规则.&lt;/p&gt;
&lt;p&gt;Plaer 类的代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -- Player.h --
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&amp;lt;/string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Player(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; caps, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; goals);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;amp; GetName() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetCaps&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetGoals&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string mName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mCaps;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mGoals;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;现在我们新写一个类或结构体来列出所有的比较函数. 比较函数是一个结构体并实现操作符&lt;code&gt;()&lt;/code&gt;, 操作符&lt;code&gt;()&lt;/code&gt; 带有两个参数, 分别为两个指向Player的指针, 返回bool值.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PlayerSorting&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// name
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByNameAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByNameDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// caps
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByCapsAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByCapsDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// goals
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByGoalsAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByGoalsDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后, 在调用它的地方, 我们可以先把所有的&lt;code&gt;std::function&lt;/code&gt; 存在一个&lt;code&gt;std::vector&lt;/code&gt; 里, 使用的时候, 用索引访问vector的元素.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(player &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; player&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sorters;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByNameAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByCapsAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByGoalsAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByNameDes());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByCapsDes());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByGoalsDes());&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(player&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;例如, 根据得分降序排列:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;player &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; players;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;player&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ...init players...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(players.begin(), players.end(), sorters[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     CAPS  GOALS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Lionel Messi             &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;David Villa              &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Asamoah Gyan             &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Arjen Robben             &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mesut Oezil              &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Diego Forlan             &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Andres Iniesta           &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Wesley Sneijder          &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Xavi                     &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bastian Schweinsteiger   &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假如需要实现一种新的排序方式, 我们只需要在PlayerSorting类中添加一个新的仿函数即可.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】String&amp;#039;s interface</title>
        <link>https://lxb.wiki/4c3249cd/</link>
        <pubDate>Sun, 09 Apr 2017 22:00:41 +0000</pubDate>
        
        <guid>https://lxb.wiki/4c3249cd/</guid>
        <description>&lt;p&gt;考虑以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool fun(const string&amp;amp;amp; code)
{
assert(code.length() &amp;amp;gt;= 2);
if (code.substr(0, 2) == string(&amp;quot;XX&amp;quot;))
{
// ...
}
// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有没有发现什么问题? 不要纠结于assert(), 它只是为了保证 string &amp;ldquo;code&amp;rdquo; 长度大于2而已.&lt;/p&gt;
&lt;p&gt;很显然, 这段代码用来检查string是否以&amp;quot;XX&amp;quot;开头. 基于它长度大于2 的前提, 这段代码能正常运行. 我们的关心的问题是, 表达式能否达到正确的结果.&lt;/p&gt;
&lt;p&gt;绝大多数情况下, 我们之所以使用C++, 是希望能使我们的程序达到最优的性能. 基于这个目标, 上面的代码看起来就不是很正确了. 为了检查&amp;quot;code&amp;quot;是否以&amp;quot;XX&amp;quot;开头, 我们生成了两个临时的string, 每个string都可能潜在地申请堆上的内存. 有人可能会为此辩解: std::string应该能为一个 2字母的序列实现 短字符串最优化(SSO). 就算这个辩解是正确的, 这段代码也已经 耗费了 一些不能被优化掉的开销, 更何况, 并不是所有的都会实现SSO. 例如, 我使用的GCC 4.4.7 就不会为string实现SSO.&lt;/p&gt;
&lt;p&gt;类模板&lt;code&gt;std::basic_string&lt;/code&gt; 的接口很复杂. 它提供了大量的成员函数, 似乎不用它们显得不领情, 同时开发者也不会有自己一遍遍重新解析的冲动.&lt;/p&gt;
&lt;p&gt;因为开发者模糊地记得应用于NTBS(null-terminated byte strings)(可以被隐式地转为&lt;code&gt;const char*&lt;/code&gt; )的 操作符 &lt;code&gt;==&lt;/code&gt; 会使结果出错, 所以他通过 确保参与比较的两个值都是&lt;code&gt;std::string&lt;/code&gt; 类型来避开这个错误. 他可能在想, 在运行操作符&lt;code&gt;==&lt;/code&gt; 前文本&amp;quot;XX&amp;quot; 已经被显式地转成了&lt;code&gt;std::string&lt;/code&gt;, 那么这么做也没有坏处. &lt;strong&gt;但是&lt;/strong&gt;, 这是错误的, 因为对于操作符&lt;code&gt;==&lt;/code&gt;, 标准提供了两种版本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool operator==(const std::string&amp;amp;amp; lhs, const char* rhs);
bool operator==(const char* lhs, const std::string&amp;amp;amp; rhs);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然实际上他们是带有多个参数的函数模板, 远比这个复杂. &lt;code&gt;std::string&lt;/code&gt; 可以直接跟NTBS比较, 没有必要生成临时的&lt;code&gt;std::string&lt;/code&gt;. 我们开头的例子, 可以通过去除显式生成的临时副本 进行优化: &lt;code&gt;if (code.substr(0, 2) == &amp;quot;XX&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更进一步, 不可否认, 在有些地方使用操作符&lt;code&gt;==&lt;/code&gt; 看起来很高雅, 但是仅仅为了检查一个&lt;code&gt;string&lt;/code&gt; 本身的一部分而去新申请一部分资源(生成一个新的&lt;code&gt;string&lt;/code&gt;) 这种做法是错误的. 开发者的初衷, 并不是要是程序看起来高雅. 实际上, 如果我们深入研究&lt;code&gt;std::basic_string&lt;/code&gt; 的官方文档, 就会发现, &lt;code&gt;std::basic_string&lt;/code&gt;提供了一种比较它的子字符串和NTBS的方法: &lt;code&gt;if(code.compare(0, 2, &amp;quot;XX&amp;quot;) == 0)&lt;/code&gt; 这个比较是三方比较, 结果等于0表示相等. 它可以达到目的, 并且不需要生成任何临时的&lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;尽管这个&lt;code&gt;compare()&lt;/code&gt; 使性能达到了很大的优化, 但我并不满足于此. 虽然它做了正确的事情, 但如果我们是第一次遇到他, 很难抓住他的精髓. 如果你可以使用boost库, 我的建议性的解决方案是使用&lt;code&gt;Boost String Algorithms Library&lt;/code&gt; 中的算法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost algorithm=&amp;quot;&amp;quot; string=&amp;quot;&amp;quot; predicate.hpp=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/boost&amp;gt;

bool func(const string&amp;amp;amp; code)
{
if (boost::algorithm::starts_with(code, &amp;quot;XX&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码很好地体现了我想说的意思, 没有任何多余的开销.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;https://akrzemi1.wordpress.com/2015/04/15/strings-interface/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://akrzemi1.wordpress.com/2015/04/15/strings-interface/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C/C&#43;&#43;返回内部静态成员的陷阱</title>
        <link>https://lxb.wiki/d66df6b4/</link>
        <pubDate>Sun, 02 Apr 2017 23:43:17 +0000</pubDate>
        
        <guid>https://lxb.wiki/d66df6b4/</guid>
        <description>&lt;p&gt;在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多开发人员。如果你的内存是在函数内栈上分配的，那么这个内存会随着函数的返回而被弹栈释放，所以，你一定要返回一块函数外部还有效的内存。&lt;/p&gt;
&lt;p&gt;这是一个让无数人困扰的问题。如果你一不小心，你就很有可能在这个上面犯错误。当然目前有很多解决方法，如果你熟悉一些标准库的话，你可以看到许多各式各样的解决方法。大体来说有下面几种：&lt;/p&gt;
&lt;p&gt;1）在函数内部通过malloc或new在堆上分配内存，然后把这块内存返回（因为在堆上分配的内存是全局可见的）。这样带来的问题就是潜在的内存问题。因为，如果返回出去的内存不释放，那么就是memory Leak。或者是被多次释放，从而造成程序的crash。这两个问题都相当的严重，所以这种设计方法并不推荐。（在一些Windows API中，当你调用了一些API后，你必需也要调用他的某些API来释放这块内存）&lt;/p&gt;
&lt;p&gt;2）让用户传入一块他自己的内存地址，而在函数中把要返回的内存放到这块内存中。这是一个目前普遍使用的方式。很多Windows API函数或是标准C函数都需要你传入一个buffer和这个buffer的长度。这种方式对我们来说应该是屡见不鲜了。这种方式的好处就是由函数外部的程序来维护这块内存，比较简显直观。但问题就是在使用上稍许有些麻烦。不过这种方式把犯错误的机率减到了最低。&lt;/p&gt;
&lt;p&gt;3）第三种方式显得比较另类，他利用了static的特性，static的栈内存一旦分配，那这块内存不会随着函数的返回而释放，而且，它是全局可见的（只要你有这块内存的地址）。所以，有一些函数使用了static的这个特性，即不用使用堆上的内存，也不需要用户传入一个buffer和其长度。从而，使用得自己的函数长得很漂亮，也很容易使用。&lt;/p&gt;
&lt;p&gt;这里，我想对第三个方法进行一些讨论。使用static内存这个方法看似不错，但是它有让你想象不到的陷阱。让我们来用一个实际发生的案例来举一个例子吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有过socket编程经验的人一定知道一个函数叫：inet_ntoa，这个函数主要的功能是把一个数字型的IP地址转成字符串，这个函数的定义是这样的（注意它的返回值）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char *inet_ntoa(struct in_addr in);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显然，这个函数不会分配堆上的内存，而他又没有让你传一下字符串的buffer进入，那么他一定使用“返回static char[]”这种方法。在我们继续我们的讨论之前，让我们先了解一下IP地址相关的知识，下面是inet_ntoa这个函数需要传入的参数：（也许你会很奇怪，只有一个member的struct还要放在struct中干什么？这应该是为了程序日后的扩展性的考虑）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;in_addr&lt;/span&gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; s_addr;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于IPV4来说，一个IP地址由四个8位的bit组成，其放在&lt;code&gt;s_addr&lt;/code&gt;中，高位在后，这是为了方便网络传输。如果你得到的一个&lt;code&gt;s_addr&lt;/code&gt;的整型值是：3776385196。那么，打开你的Windows计算器吧，看看它的二进制是什么？让我们从右到左，8位为一组（如下所示）。&lt;/p&gt;
&lt;p&gt;11100001   00010111    00010000    10101100&lt;/p&gt;
&lt;p&gt;再把每一组转成十进制，于是我们就得到：225   23   16   172， 于是IP地址就是 172.16.23.225。&lt;/p&gt;
&lt;p&gt;好了，言归正传。我们有这样一个程序，想记录网络包的源地址和目地地址，于是，我们有如下的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;in_addr&lt;/span&gt; src, des;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;........  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;........  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fprintf(fp, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;源IP地址&amp;lt;%s&amp;gt;/t目的IP地址&amp;lt;%s&amp;gt;/n&amp;#34;&lt;/span&gt;, inet_ntoa(src),   inet_ntoa(des));  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会发生什么样的结果呢？你会发现记录到文件中的源IP地址和目的IP地址完全一样。这是什么问题呢？于是你开始调试你的程序，你发现src.s_addr和des.s_addr根本不一样（如下所示）。可为什么输出到文件的源和目的都是一样的？难道说是inet_ntoa的bug？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;src.s_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3776385196&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;//对应于172.16.23.225  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;des.s_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1678184620&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;//对应于172.16.7.100  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原因就是&lt;code&gt;inet_ntoa()&lt;/code&gt;“自作聪明”地把内部的static char[]返回了，而我们的程序正是踩中了这个陷阱。让我们来分析一下fprintf代码。在我们fprintf时，编译器先计算&lt;code&gt;inet_ntoa(des)&lt;/code&gt;，于是其返回一个字符串的地址，然后程序再去求&lt;code&gt;inet_ntoa(src)&lt;/code&gt;表达式，又得到一个字符串的地址。这两个字符串的地址都是&lt;code&gt;inet_ntoa()&lt;/code&gt;中那个&lt;code&gt;static char[]&lt;/code&gt;，显然是同一个地址，而第二次求src的IP时，这个值的des的IP地址内容必将被src的IP覆盖。所以，这两个表达式的字符串内存都是一样的了，此时，程序会调用fprintf把这两个字符串（其实是一个）输出到文件。所以，得到相同的结果也就不奇怪。&lt;/p&gt;
&lt;p&gt;仔细看一下inet_ntoa的man，我们可以看到这句话：&lt;code&gt;The string is returned in a statically allocated buffer,  which  subsequent calls will overwrite. &lt;/code&gt;证实了我们的分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们大家都扪心自问一下，我们在写程序的过程当中是否使用了这种方法？这是一个比较危险，容易出错的方法。这种陷阱让人防不胜防。想想，如果你有这样的程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( strcmp( inet_ntoa(ip1), inet_ntoa(ip2) )&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; ) {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;. &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;.  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;本想判断一下两个IP地址是否一样，却不料掉入了那个陷阱——让这个条件表达式永真。&lt;/p&gt;
&lt;p&gt;这个事情告诉我们下面几个道理：&lt;/p&gt;
&lt;p&gt;1）慎用这种方式的设计。返回函数内部的static内存有很大的陷阱。&lt;/p&gt;
&lt;p&gt;2）如果一定要使用这种方式的话。你就必须严肃地告诉所有使用这个函数的人，千万不要在一个表达式中多次使用这个函数。而且，还要告诉他们，不copy函数返回的内存的内容，而只是保存返回的内存地址或是引用是没用的。不然的话，后果概不负责。&lt;/p&gt;
&lt;p&gt;3）C/C++是很危险的世界，如果你不清楚他的话。还是回火星去吧。&lt;/p&gt;
&lt;p&gt;附：看过Efftive C++的朋友一定知道其中有一个条款（item 23）：不要试图返回对象的引用。这个条款中也对是否返回函数内部的static变量进行了讨论。结果也是持否定态度的。&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://www.tuicool.com/articles/JNZZfiZ&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.tuicool.com/articles/JNZZfiZ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>编译器工作过程</title>
        <link>https://lxb.wiki/49fab9fa/</link>
        <pubDate>Thu, 09 Feb 2017 22:13:33 +0000</pubDate>
        
        <guid>https://lxb.wiki/49fab9fa/</guid>
        <description>&lt;p&gt;代码要运行，必须先转成二进制的机器码。这是编译器的任务。&lt;/p&gt;
&lt;p&gt;比如，下面这段源码（假定文件名叫做test.c）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
fputs(&amp;quot;Hello, world!\n&amp;quot;, stdout);
return 0;
}
```&amp;lt;/stdio.h&amp;gt;

要先用编译器处理一下，才能运行。

```bash
$ gcc test.c
$ ./a.out
Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于复杂的项目，编译过程还必须分成三步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./configure
$ make
$ make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。&lt;/p&gt;
&lt;p&gt;本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了Alex Smith的文章《Building C Projects》。需要声明的是，本文主要针对gcc编译器，也就是针对C和C++，不一定适用于其他语言的编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170105233325494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;这里写图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;第一步-配置configure&#34;&gt;第一步 配置（configure）&lt;/h4&gt;
&lt;p&gt;编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。&lt;/p&gt;
&lt;p&gt;这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。&lt;/p&gt;
&lt;p&gt;configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ ./configure --prefix=/www --with-mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。&lt;/p&gt;
&lt;h4 id=&#34;第二步-确定标准库和头文件的位置&#34;&gt;第二步 确定标准库和头文件的位置&lt;/h4&gt;
&lt;p&gt;源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。&lt;/p&gt;
&lt;p&gt;编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。&lt;/p&gt;
&lt;h4 id=&#34;第三步-确定依赖关系&#34;&gt;第三步 确定依赖关系&lt;/h4&gt;
&lt;p&gt;对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。&lt;/p&gt;
&lt;p&gt;（1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。&lt;/p&gt;
&lt;p&gt;编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。&lt;/p&gt;
&lt;p&gt;在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。&lt;/p&gt;
&lt;h4 id=&#34;第四步-头文件的预编译precompilation&#34;&gt;第四步 头文件的预编译（precompilation）&lt;/h4&gt;
&lt;p&gt;不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。&lt;/p&gt;
&lt;p&gt;不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。&lt;/p&gt;
&lt;h4 id=&#34;第五步-预处理preprocessing&#34;&gt;第五步 预处理（Preprocessing）&lt;/h4&gt;
&lt;p&gt;预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern int fputs(const char *, FILE *);
extern FILE *stdout;
int main(void)
{
fputs(&amp;quot;Hello, world!\n&amp;quot;, stdout);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。&lt;/p&gt;
&lt;p&gt;这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。&lt;/p&gt;
&lt;h4 id=&#34;第六步-编译compilation&#34;&gt;第六步 编译（Compilation）&lt;/h4&gt;
&lt;p&gt;预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。&lt;/p&gt;
&lt;p&gt;下面是本文开头的那段源码转成的汇编码。&lt;/p&gt;
&lt;p&gt;```` .file &amp;ldquo;test.c&amp;rdquo; .section .rodata .LC0: .string &amp;ldquo;Hello, world!\n&amp;rdquo; .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movq stdout(%rip), %rax movq %rax, %rcx movl $14, %edx movl $1, %esi movl $.LC0, %edi call fwrite movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident &amp;ldquo;GCC: (Debian 4.9.1-19) 4.9.1&amp;rdquo; .section .note.GNU-stack,&amp;quot;&amp;quot;,@progbits ```&lt;/p&gt;
&lt;p&gt;这种转码后的文件称为对象文件（object file）。&lt;/p&gt;
&lt;h4 id=&#34;第七步-连接linking&#34;&gt;第七步 连接（Linking）&lt;/h4&gt;
&lt;p&gt;对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。&lt;/p&gt;
&lt;p&gt;编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;第八步-安装installation&#34;&gt;第八步 安装（Installation）&lt;/h4&gt;
&lt;p&gt;上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。&lt;/p&gt;
&lt;p&gt;表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。&lt;/p&gt;
&lt;h4 id=&#34;第九步-操作系统连接&#34;&gt;第九步 操作系统连接&lt;/h4&gt;
&lt;p&gt;可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。&lt;/p&gt;
&lt;p&gt;这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在&lt;code&gt;/usr/share/applications&lt;/code&gt;目录下的&lt;code&gt;.desktop&lt;/code&gt;文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。&lt;/p&gt;
&lt;p&gt;这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。&lt;/p&gt;
&lt;h4 id=&#34;第十步-生成安装包&#34;&gt;第十步 生成安装包&lt;/h4&gt;
&lt;p&gt;写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。&lt;/p&gt;
&lt;p&gt;所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。&lt;/p&gt;
&lt;h4 id=&#34;第十一步-动态连接dynamic-linking&#34;&gt;第十一步 动态连接（Dynamic linking）&lt;/h4&gt;
&lt;p&gt;正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。&lt;/p&gt;
&lt;p&gt;前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。&lt;/p&gt;
&lt;p&gt;现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>c&#43;&#43;代码优化建议</title>
        <link>https://lxb.wiki/8e72ff9a/</link>
        <pubDate>Sat, 17 Dec 2016 22:02:36 +0000</pubDate>
        
        <guid>https://lxb.wiki/8e72ff9a/</guid>
        <description>&lt;ol&gt;
&lt;li&gt;记住阿姆达尔定律： Ahmdal&amp;rsquo;s rule $$Speedup =\dfrac{ time_{old}}{time_{new}} = \dfrac{1}{(1-func_{cost})+func_{cost}/func_{speedup}}$$&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;func_cost是函数func运行时间百分比，func_speedup是你优化函数的运行的系数。&lt;/li&gt;
&lt;li&gt;所以，如果你优化了函数TriangleIntersect执行40%的运行时间，使它运行快了近两倍，而你的程序会运行快25%。&lt;/li&gt;
&lt;li&gt;这意味着不经常使用的代码不需要做较多优化考虑（或者完全不优化）。&lt;/li&gt;
&lt;li&gt;这里有句俗语：让经常执行的路径运行更加高效，而运行稀少的路径正确运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码先保证正确，然后再考虑优化 这并不意味着用8周时间写一个全功能的射线追踪算法，然后用8周时间去优化它。 分多步来做性能优化。 先写正确的代码，当你意识到这个函数可能会被经常调用，进行明显的优化。 然后再寻找算法的瓶颈，并解决（通过优化或者改进算法）。通常，改进算法能显著地改进瓶颈——也许是采用一个你还没有预想到的方法。所有频繁调用的函数，都需要优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我所了解的那些写出非常高效代码的人说，他们优化代码的时间，是写代码时间的两倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转和分支执行代价高，如果可能，尽量少用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数调用需要两次跳转，外加栈内存操作。 优先使用迭代而不是递归。 使用内联函数处理短小的函数来消除函数调用开销。 将循环内的函数调用移动到循环外(例如，将for(i=0;i&amp;lt;100;i++) DoSomething();改为DoSomething() { for(i=0;i&amp;lt;100;i++) { … }})。 if…else if…else if…else if…很长的分支链执行到最后的分支需要很多的跳转。如果可能，将其转换为一个switch声明语句，编译器有时候会将其转换为一个表查询单次跳转。如果switch声明不可行，将最常见的场景放在if分支链的最前面。 5. 仔细思考函数下标的顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;两阶或更高阶的数组在内存中还是以一维的方式在存储在内存中，这意味着（对于C/C++数组）array[i][j] 和 array[i][j+1]是相邻的，但是array[i][j] 和array[i+1][j]可能相距很远。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以适当的方式访问存储实际内存中的数据，可以显著地提升你代码的执行效率（有时候可以提升一个数量级甚至更多）。 现代处理器从主内存中加载数据到处理器cache，会加载比单个值更多的数据。该操作会获取请求数据和相邻数据（一个cache行大小）的整块数据。这意味着，一旦array[i][j]已经在处理器cache中，array[i][j+1]很大可能也已经在cache中了，而array[i+1][j]可能还在内存中。 6. 使用指令层的并行机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;尽管许多程序还是依赖单线程的执行，现代处理器在单核中也提供了不少的并行性。例如：单个CPU可以同时执行4个浮点数乘，等待4个内存请求并执行一个分支预判。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了最大化利用这种并行性，代码块（在跳转之间的）需要足够的独立指令来允许处理器被充分利用。 考虑展开循环来改进这一点。 这也是使用内联函数的一个好理由。 7. 避免或减少使用本地变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;本地变量通常都存储在栈上。不过如果数量比较少，它们可以存储在CPU寄存器中。在这种情况下，函数不但得到了更快访问存储在寄存器中的数据的好处，也避免了初始化一个栈帧的开销。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要将大量数据转换为全局变量。 8. 减少函数参数的个数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;和减少使用本地变量的理由一样——它们也是存放在栈上。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9. 通过引用传递结构体而不是传值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我在射线追踪中还找不到一个场景需要将结构体使用传值方式（包括一些简单结构如：Vector，Point和Color）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10. 如果你的函数不需要返回值，不要定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽量避免数据转换。&lt;/p&gt;
&lt;p&gt;整数和浮点数指令通常操作不同的寄存器，所以转换需要进行一次拷贝操作。 短整型（char和short）仍然使用一整个寄存器，并且它们需要被填充为32/64位，然后在存储回内存时需要再次转换为小字节（不过，这个开销一定比一个更大的数据类型的内存开销要多一点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义C++对象时需要注意。&lt;/p&gt;
&lt;p&gt;使用类初始化而不是使用赋值（Color c(black); 比Color c; c = black;更快）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使类构造函数尽可能轻量。 尤其是常用的简单类型（比如，color，vector，point等等），这些类经常被复制。 这些默认构造函数通常都是在隐式执行的，这或许不是你所期望的。 使用类初始化列表(Use Color::Color() : r(0), g(0), b(0) {}，而不是初始化函数Color::Color() { r= g = b = 0; } .)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果可以的话，使用位移操作&amp;raquo;和&amp;laquo;来代替整数乘除法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心使用表查找函数&lt;/p&gt;
&lt;p&gt;许多人都鼓励将复杂的函数（比如：三角函数）转化为使用预编译的查找表。对于射线追踪功能来说，这通常导致了不必要的内存查找，这很昂贵（并不断增长），并且这和计算一个三角函数并从内存中获取值一样快（尤其你考虑到三角查找打乱了cpu的cache存取）。 在其他情况下，查找表会很有用。对于GPU编程通常优先使用表查找而不是复杂函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对大多数类，优先使用+= 、 -= 、 *= 和 /=，而不是使用+ 、 – 、 * 、 和?/&lt;/p&gt;
&lt;p&gt;这些简单操作需要创建一个匿名临时中间变量。 例如：Vector v = Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1);?创建了五个匿名临时Vector: Vector(1,0,0), Vector(0,1,0), Vector(0,0,1), Vector(1,0,0) + Vector(0,1,0), 和 Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1). 对上述代码进行简单转换：Vector v(1,0,0); v+= Vector(0,1,0); v+= Vector(0,0,1);仅仅创建了两个临时Vector: Vector(0,1,0) 和 Vector(0,0,1)。这节约了6次函数调用（3次构造函数和3次析构函数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于基本数据类型，优先使用+?、?-?、?&lt;em&gt;?、?和?/，而不是+=?、?-=?、?&lt;/em&gt;= 和 /=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推迟定义本地变量&lt;/p&gt;
&lt;p&gt;定义一个对象变量通常需要调用一次函数（构造函数）。 如果一个变量只在某些情况下需要（例如在一个if声明语句内），仅在其需要的时候定义，这样，构造函数仅在其被使用的时候调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于对象，使用前缀操作符（++obj），而不是后缀操作符（obj++）&lt;/p&gt;
&lt;p&gt;这在你的射线追踪算法中可能不是一个问题 使用后缀操作符需要执行一次对象拷贝（这也导致了额外的构造和析构函数调用），而前缀的构造函数不需要一个临时的拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心使用模板&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;对不同的是实例实现进行不同的优化。 标准模板库已经经过良好的优化，不过我建议你在实现一个交互式射线追踪算法时避免使用它。 使用自己的实现，你知道它如何使用算法，所以你知道如何最有效的实现它。 最重要的是，我的经历告诉我：调试STL库非常低效。通常这也不是一个问题，除非你使用debug版本做性能分析。你会发现STL的构造函数，迭代器和其他一些操作，占用了你15%的运行时间，这会导致你分析性能输出更加费劲。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;避免在计算时进行动态内存分配&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;动态内存对于存储场景和运行期间其他数据都很有用。 但是，在许多（大多数）的系统动态内存分配需要获取控制访问分配器的锁。对于多线程应用程序，现实中使用动态内存由于额外的处理器导致了性能下降，因为需要等待分配器锁和释放内存。 即便对于单线程应用，在堆上分配内存也比在栈上分配内存开销大得多。操作系统还需要执行一些操作来计算并找到适合尺寸的内存块。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;找到你系统内存cache的信息并利用它们&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;如果一个是数据结构正好适合一个cache行，处理整个类从内存中只需要做一次获取操作。 确保所有的数据结构都是cache行大小对齐（如果你的数据结构和一个cache行大小都是128字节，仍有可能因为你的结构体中的一个字节在一个cache行中，而其他127字节在另外一个cahce行中）。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;避免不需要的数据初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;如果你需要初始化一大段的内存，考虑使用memset。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;尽早结束循环和尽早返回函数调用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;考虑一个射线和三角形交叉，通常的情况是射线会越过三角，所以这里可以优化。 如果你决定将射线和三角面板交叉。如果射线和面板交叉t值是负数，你可以立即返回。这允许你跳过射线三角交叉一大半的质心坐标计算。这是一个大的节约，一旦你知道这个交叉不存在，你就应该立即返回交叉计算函数。 同样的，一些循环也应该尽早结束。例如，当设置阴影射线，对于近处的交叉通常都是不必须的，一旦有类似的的交叉，交叉计算就应该尽早返回。（这里的交叉含义不太明白，可能是专业词汇，译者注）
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;在稿纸上简化你的方程式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;许多方程式中，通常都可以或者在某些条件中取消计算。 编译器不能发现这些简化，但是你可以。取消一个内部循环的一些昂贵操作可以抵消你在其他地方的好几天的优化工作。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;整数、定点数、32位浮点数和64位双精度数字的数学运算差异，没有你想象的那么大&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;在现代CPU，浮点数运算和整数运算差不多拥有同样的效率。在计算密集型应用（比如射线追踪），这意味这可以忽略整数和浮点数计算的开销差异。这也就是说，你不必要对算数进行整数处理优化。 双精度浮点数运算也不比单精度浮点数运算更慢，尤其是在64位机器上。我在同一台机器测试射线追踪算法全部使用double比全部使用floats运行有时候更快，反过来测试也看到了一样的现象（这里的原文是：I have seen ray tracers run faster using all doubles than all floats on the same machine. I have also seen the reverse）。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;不断改进你的数学计算，以消除昂贵的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sqrt()经常可以被优化掉，尤其是在比较两个值的平方根是否一致时。 如果你重复地需要处理 除x 操作，考虑计算1/x的值，乘以它。这在向量规范化（3次除法）运算中赢得了大的改进，不过我最近发现也有点难以确定的。不过，这仍然有所改进，如果你要进行三次或更多除法运算。 如果你在执行一个循环，那些在循环中执行不发生变化的部分，确保提取到循环外部。 考虑看看你的计算值是否可以在循环中修改得到（而不每次都重新开始循环计算）。
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>x == x</title>
        <link>https://lxb.wiki/72da8a18/</link>
        <pubDate>Sat, 19 Nov 2016 20:40:58 +0000</pubDate>
        
        <guid>https://lxb.wiki/72da8a18/</guid>
        <description>&lt;p&gt;C的表达式 x == x，何时为假呢？即下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (x == x)
{
printf(&amp;quot;Equal\n&amp;quot;);
}
else
{
printf(&amp;quot;Not equal\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;什么时候输出为&amp;quot;Not equal&amp;quot;呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;&amp;lt;/string.h&amp;gt;&amp;lt;/stdio.h&amp;gt;&amp;lt;/stdlib.h&amp;gt;

int main(void)
{
float x = 0xffffffff;

if (x == x)
{
printf(&amp;quot;Equal\n&amp;quot;);
}
else
{
printf(&amp;quot;Not equal\n&amp;quot;);
}

if (x &amp;amp;gt;= 0)
{
printf(&amp;quot;x(%f) &amp;amp;gt;= 0\n&amp;quot;, x);
}
else if (x &amp;amp;lt; 0) 
    {
        printf(&amp;quot;x(%f) &amp;amp;lt; 0\n&amp;quot;, x);
    }

    int a = 0xffffffff;
    memcpy(&amp;amp;amp;x, &amp;amp;amp;a, sizeof(x));
    if (x == x) 
    {
        printf(&amp;quot;Equal\n&amp;quot;);
    }
    else 
    {
        printf(&amp;quot;Not equal\n&amp;quot;);
    }

    if (x &amp;amp;gt;= 0)
{
printf(&amp;quot;x(%f) &amp;amp;gt;= 0\n&amp;quot;, x);
}
else if (x &amp;amp;lt; 0) 
    {
        printf(&amp;quot;x(%f) &amp;amp;lt; 0\n&amp;quot;, x);
    }
    else 
    {
        printf(&amp;quot;Surprise x(%f)!!!\n&amp;quot;, x);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译&lt;code&gt;gcc -g -Wall test.c&lt;/code&gt;，看执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./a.out
Equal
x(4294967296.000000) &amp;amp;gt;= 0
Not equal
Surprise x(-nan)!!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后两行输出是不是有点surprise啊。&lt;/p&gt;
&lt;p&gt;下面先简单解释一下： 1. 当&lt;code&gt;float x = 0xffffffff&lt;/code&gt;：这时将整数赋给一个浮点数，由于float和int的size都是4，而浮点数的存储格式与整数不同，其需要将某些位作为小数位，所以float的范围要小于int的范围。因此这里涉及到了整数转换浮点的规定。因为这个转换其实很少用到，我也就不查了。但是总之，这个转换是合法的。但是最终的值很可能不是你想要的结果——尤其是当浮点的范围小于整数的范围时。 2. 即使整数转换成浮点，数值再不是期望值，但它也一定是一个合法的浮点数值。所以第一个&lt;code&gt;x == x&lt;/code&gt;，一定为true，且x不是大于0，就是小于0。这时x存的并不是0xffffffff。 3. 当使用memcpy将0xff填充到x的地址时，这时x存的保证为0xffffffff。但是这个不是一个合法的float的值。因此奇怪的现象发生了，x并不等于x。原因则是与cpu的浮点指令相关. 4. 作为一个非法的float值，当它与其它任何数值比较时，都会返回false。这也就造成了，后面惊奇的结果，x既不大于等于0，也不小于0。&lt;/p&gt;
&lt;p&gt;总结一下：一般来说，浮点类型很少被使用，也不应该在程序中鼓励使用。不仅其效率比整数低，且由于浮点类型特殊的存储格式，很容易造成一些意想不到的错误。如果真的无法避免时，一定要小心小心再小心。特别要注意今天的主题，这种非法的浮点值，会导致任何比较判断都失败。而判断这种浮点值的方法也很简单，如果&lt;code&gt;x != x&lt;/code&gt;，那么该浮点即为非法浮点值。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;在重载operator=为带模板的函数的时候的陷阱</title>
        <link>https://lxb.wiki/a25c4e07/</link>
        <pubDate>Sat, 29 Oct 2016 20:20:32 +0000</pubDate>
        
        <guid>https://lxb.wiki/a25c4e07/</guid>
        <description>&lt;p&gt;原文地址 &lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000004467381&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://segmentfault.com/a/1190000004467381&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近被一个语法问题缠了半天，终于找到了原因。不仔细思考一下写的时候真的很容易忽略。先看代码：&lt;/p&gt;
&lt;p&gt;template class A { public: const T t = 0;&lt;/p&gt;
&lt;p&gt;template A&amp;amp; operator=(const A&amp;amp; a) { return *this; } };&lt;/p&gt;
&lt;p&gt;int main() { A a, b;&lt;/p&gt;
&lt;p&gt;b = a; // error } 这会带来一个编译错误，然而横睇掂睇都看不出问题。于是我就试了一下这样的代码：A c; b = c;居然通过了编译。F**k，这个模板居然胳膊肘往外拐。&lt;/p&gt;
&lt;p&gt;其实我在写这个代码的时候忽略了一点，就是default assignment operator，它是你在定义类的时候编译器默认给你加上去的，行为是对所有成员变量赋值。它的声明是A&amp;amp; operator=(const A&amp;amp; a);，跟我们自己定义的放在一起：&lt;/p&gt;
&lt;p&gt;template A&amp;amp; operator=(const A&amp;amp; a) { return *this; }&lt;/p&gt;
&lt;p&gt;A&amp;amp; operator=(const A&amp;amp; a) /&lt;em&gt;= delete&lt;/em&gt;/; 恰好构成了模板特化，这就糟了。一旦构成了特化，OtherT可以匹配的类型就会除去int，用A赋值时只能调用系统给我们定义的那个。然而它也不起作用，因为成员里面有常量（这样它就会被标记为= delete，留意delete并不会令OtherT可以匹配到int，反而令它匹配不到）。&lt;/p&gt;
&lt;p&gt;知道了原因之后，解决就很方便了，只要重新定义这个默认赋值运算符就好：&lt;/p&gt;
&lt;p&gt;A&amp;amp; operator=(const A&amp;amp; a) { /&lt;em&gt;&amp;hellip;&lt;/em&gt;/ }&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
