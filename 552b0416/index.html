<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Lucene 的索引文件格式'>

<meta name="keywords" content="lucene , 索引文件格式"><title>Lucene 三: Lucene 的索引文件格式</title>

<link rel='canonical' href='https://lxb.wiki/552b0416/'>

<link rel="stylesheet" href="/scss/style.min.e5fa5972b3e81b9d9b61e2598991a71c444ca50e38b034d78f5651a82802e894.css"><meta property='og:title' content='Lucene 三: Lucene 的索引文件格式'>
<meta property='og:description' content='Lucene 的索引文件格式'>
<meta property='og:url' content='https://lxb.wiki/552b0416/'>
<meta property='og:site_name' content='Xiaobin&#39;s Notes'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='lucene' /><meta property='article:published_time' content='2023-09-03T22:05:28&#43;08:00'/><meta property='article:modified_time' content='2023-09-03T22:05:28&#43;08:00'/>
<meta name="twitter:title" content="Lucene 三: Lucene 的索引文件格式">
<meta name="twitter:description" content="Lucene 的索引文件格式">
<link rel="shortcut icon" href="/favicon.png" />




<script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ2PWLT6JY"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-JZ2PWLT6JY');
</script>
<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e710560ffa44cae2b3a6259e0171fb5f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
<script>
    (function () {
        var el = document.createElement("script");
        el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?f146251743600ee0672cdcc8455ce18def91cdb255ad969a2ef5c715d5ed5baecaf7cd753709c168f20e6a2e9019123fd11e31a222d3a2fe01ad05c6b8f519b2";
        el.id = "ttzz";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(el, s);
    })(window)
</script>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu692828361b78eaa42fdbdbbf5a7177a9_44446_300x0_resize_q75_box.jpeg" width="300"
                            height="298" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Xiaobin&#39;s Notes</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header>


    <ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                <span>首页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/categories/' >
                
                
                
                <span>分类</span>
            </a>
        </li>
        
        
        <li >
            <a href='/tags/' >
                
                
                
                <span>标签</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                <span>友链</span>
            </a>
        </li>
        

        <div class="menu-bottom-section"><ol class="social-menu">
                    
                        <li>
                            <a 
                                href='mailto://me@lxb.wiki'
                                target="_blank"
                                title="Email"
                                rel="me"
                            >
                                
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
                                
                            </a>
                        </li>
                    
                        <li>
                            <a 
                                href='https://github.com/lxbwolf'
                                target="_blank"
                                title="GitHub"
                                rel="me"
                            >
                                
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                                
                            </a>
                        </li>
                    
                        <li>
                            <a 
                                href='https://lxb.wiki/atom.xml'
                                target="_blank"
                                title="Rss"
                                rel="me"
                            >
                                
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="5" cy="19" r="1" />
  <path d="M4 4a16 16 0 0 1 16 16" />
  <path d="M4 11a9 9 0 0 1 9 9" />
</svg>



                                
                            </a>
                        </li>
                    
                </ol>
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
<section class="widget archives">
    
    <h2 class="widget-title section-title">目录</h2>

    <div class="widget--toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#一基本概念"><strong>一、基本概念</strong></a></li>
    <li><a href="#二基本类型"><strong>二、基本类型</strong></a></li>
    <li><a href="#三基本规则"><strong>三、基本规则</strong></a>
      <ul>
        <li><a href="#1-前缀后缀规则prefixsuffix"><strong>1. 前缀后缀规则(Prefix+Suffix)</strong></a></li>
        <li><a href="#2-差值规则delta"><strong>2. 差值规则(Delta)</strong></a></li>
        <li><a href="#3-或然跟随规则a-b"><strong>3. 或然跟随规则(A, B?)</strong></a></li>
        <li><a href="#4-跳跃表规则skip-list"><strong>4. 跳跃表规则(Skip list)</strong></a></li>
      </ul>
    </li>
    <li><a href="#四具体格式"><strong>四、具体格式</strong></a>
      <ul>
        <li><a href="#41-正向信息"><strong>4.1. 正向信息</strong></a></li>
        <li><a href="#42-反向信息"><strong>4.2. 反向信息</strong></a></li>
        <li><a href="#43-其他信息"><strong>4.3. 其他信息</strong></a></li>
      </ul>
    </li>
    <li><a href="#五总体结构"><strong>五、总体结构</strong></a></li>
  </ul>
</nav>
    </div>
</section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
        <a href="/categories/Lang/" >
            Lang
        </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/552b0416/">Lucene 三: Lucene 的索引文件格式</a>
        </h2>

        
        <h3 class="article-subtitle">
            Lucene 的索引文件格式
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
            <time class="article-time--published">Sep 03, 2023</time>
        </div>
        

        
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



            <time class="article-time--reading">
                阅读时长: 40 分钟
            </time>
        </div>
        
        <small>
    <section class="article-tags">
        
            <a href="/tags/lucene/">lucene</a>
        
    </section>
</small>
    </footer>
    

    
</div>
</header>

    <section class="article-content">
    
    
    <p>Lucene的索引里面存了些什么，如何存放的，也即Lucene的索引文件格式，是读懂Lucene源代码的一把钥匙。</p>
<p>当我们真正进入到Lucene源代码之中的时候，我们会发现:</p>
<ul>
<li>Lucene的索引过程，就是按照全文检索的基本过程，将倒排表写成此文件格式的过程。</li>
<li>Lucene的搜索过程，就是按照此文件格式将索引进去的信息读出来，然后计算每篇文档打分(score)的过程。</li>
</ul>
<p>参考官网 <a class="link" href="http://lucene.apache.org/java/2_9_0/fileformats.html"  target="_blank" rel="noopener"
    >Apache Lucene - Index File Formats</a>。</p>
<h2 id="一基本概念"><strong>一、基本概念</strong></h2>
<p>下图就是Lucene生成的索引的一个实例：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262111476.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>Lucene的索引结构是有层次结构的，主要分以下几个层次：</p>
<ul>
<li>索引(Index)：
<ul>
<li>在Lucene中一个索引是放在一个文件夹中的。</li>
<li>如上图，同一文件夹中的所有的文件构成一个Lucene索引。</li>
</ul>
</li>
<li>段(Segment)：
<ul>
<li>一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。</li>
<li>如上图，具有相同前缀文件的属同一个段，图中共两个段 &ldquo;_0&rdquo; 和 &ldquo;_1&rdquo;。</li>
<li>segments.gen和segments_5是段的元数据文件，也即它们保存了段的属性信息。</li>
</ul>
</li>
<li>文档(Document)：
<ul>
<li>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。</li>
<li>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。</li>
</ul>
</li>
<li>域(Field)：
<ul>
<li>一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。</li>
<li>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。</li>
</ul>
</li>
<li>词(Term)：
<ul>
<li>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</li>
</ul>
</li>
</ul>
<p>Lucene的索引结构中，即保存了正向信息，也保存了反向信息。</p>
<p>所谓正向信息：</p>
<ul>
<li>按层次保存了从索引，一直到词的包含关系：索引(Index) –&gt; 段(segment) –&gt; 文档(Document) –&gt; 域(Field) –&gt; 词(Term)</li>
<li>也即此索引包含了那些段，每个段包含了那些文档，每个文档包含了那些域，每个域包含了那些词。</li>
<li>既然是层次结构，则每个层次都保存了本层次的信息以及下一层次的元信息，也即属性信息，比如一本介绍中国地理的书，应该首先介绍中国地理的概况，以及中国包含多少个省，每个省介绍本省的基本概况及包含多少个市，每个市介绍本市的基本概况及包含多少个县，每个县具体介绍每个县的具体情况。</li>
<li>如上图，包含正向信息的文件有：
<ul>
<li>segments_N保存了此索引包含多少个段，每个段包含多少篇文档。</li>
<li>XXX.fnm保存了此段包含了多少个域，每个域的名称及索引方式。</li>
<li>XXX.fdx，XXX.fdt保存了此段包含的所有文档，每篇文档包含了多少域，每个域保存了那些信息。</li>
<li>XXX.tvx，XXX.tvd，XXX.tvf保存了此段包含多少文档，每篇文档包含了多少域，每个域包含了多少词，每个词的字符串，位置等信息。</li>
</ul>
</li>
</ul>
<p>所谓反向信息：</p>
<ul>
<li>保存了词典到倒排表的映射：词(Term) –&gt; 文档(Document)</li>
<li>如上图，包含反向信息的文件有：
<ul>
<li>XXX.tis，XXX.tii保存了词典(Term Dictionary)，也即此段包含的所有的词按字典顺序的排序。</li>
<li>XXX.frq保存了倒排表，也即包含每个词的文档ID列表。</li>
<li>XXX.prx保存了倒排表中每个词在包含此词的文档中的位置。</li>
</ul>
</li>
</ul>
<p>在了解Lucene索引的详细结构之前，先看看Lucene索引中的基本数据类型。</p>
<h2 id="二基本类型"><strong>二、基本类型</strong></h2>
<p>Lucene索引文件中，用以下基本类型来保存信息：</p>
<ul>
<li>Byte：是最基本的类型，长8位(bit)。</li>
<li>UInt32：由4个Byte组成。</li>
<li>UInt64：由8个Byte组成。</li>
<li>VInt：
<ul>
<li>变长的整数类型，它可能包含多个Byte，对于每个Byte的8位，其中后7位表示数值，最高1位表示是否还有另一个Byte，0表示没有，1表示有。</li>
<li>越前面的Byte表示数值的低位，越后面的Byte表示数值的高位。</li>
<li>例如130化为二进制为 1000, 0010，总共需要8位，一个Byte表示不了，因而需要两个Byte来表示，第一个Byte表示后7位，并且在最高位置1来表示后面还有一个Byte，所以为(1) 0000010，第二个Byte表示第8位，并且最高位置0来表示后面没有其他的Byte了，所以为(0) 0000001。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262118850.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>Chars：是UTF-8编码的一系列Byte。</li>
<li>String：一个字符串首先是一个VInt来表示此字符串包含的字符的个数，接着便是UTF-8编码的字符序列Chars。</li>
</ul>
<h2 id="三基本规则"><strong>三、基本规则</strong></h2>
<p>Lucene为了使的信息的存储占用的空间更小，访问速度更快，采取了一些特殊的技巧，然而在看Lucene文件格式的时候，这些技巧却容易使我们感到困惑，所以有必要把这些特殊的技巧规则提取出来介绍一下。</p>
<h3 id="1-前缀后缀规则prefixsuffix"><strong>1. 前缀后缀规则(Prefix+Suffix)</strong></h3>
<p>Lucene在反向索引中，要保存词典(Term Dictionary)的信息，所有的词(Term)在词典中是按照字典顺序进行排列的，然而词典中包含了文档中的几乎所有的词，并且有的词还是非常的长的，这样索引文件会非常的大，所谓前缀后缀规则，即当某个词和前一个词有共同的前缀的时候，后面的词仅仅保存前缀在词中的偏移(offset)，以及除前缀以外的字符串(称为后缀)。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262121854.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>比如要存储如下词:term，termagancy，termagant，terminal，</p>
<p>如果按照正常方式来存储，需要的空间如下：</p>
<p>[VInt = 4] [t][e][r][m]，</p>
<p>[VInt = 10][t][e][r][m][a][g][a][n][c][y]，</p>
<p>[VInt = 9][t][e][r][m][a][g][a][n][t]，</p>
<p>[VInt = 8][t][e][r][m][i][n][a][l]</p>
<p>共需要35个Byte.</p>
<p>如果应用前缀后缀规则，需要的空间如下：</p>
<p>[VInt = 4] [t][e][r][m]，</p>
<p>[VInt = 4 (offset)][VInt = 6][a][g][a][n][c][y]，</p>
<p>[VInt = 8 (offset)][VInt = 1][t]，</p>
<p>[VInt = 4 (offset)][VInt = 4][i][n][a][l]</p>
<p>共需要22个Byte。</p>
<p>大大缩小了存储空间，尤其是在按字典顺序排序的情况下，前缀的重合率大大提高。</p>
<h3 id="2-差值规则delta"><strong>2. 差值规则(Delta)</strong></h3>
<p>在Lucene的反向索引中，需要保存很多整型数字的信息，比如文档ID号，比如词(Term)在文档中的位置等等。</p>
<p>由上面介绍，我们知道，整型数字是以VInt的格式存储的。随着数值的增大，每个数字占用的Byte的个数也逐渐的增多。所谓差值规则(Delta)就是先后保存两个整数的时候，后面的整数仅仅保存和前面整数的差即可。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262129662.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>比如要存储如下整数：16386，16387，16388，16389</p>
<p>如果按照正常方式来存储，需要的空间如下：</p>
<p>[(1) 000, 0010][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(1) 000, 0011][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(1) 000, 0100][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(1) 000, 0101][(1) 000, 0000][(0) 000, 0001]</p>
<p>供需12个Byte。</p>
<p>如果应用差值规则来存储，需要的空间如下：</p>
<p>[(1) 000, 0010][(1) 000, 0000][(0) 000, 0001]，</p>
<p>[(0) 000, 0001]，</p>
<p>[(0) 000, 0001]，</p>
<p>[(0) 000, 0001]</p>
<p>共需6个Byte。</p>
<p>大大缩小了存储空间，而且无论是文档ID，还是词在文档中的位置，都是按从小到大的顺序，逐渐增大的。</p>
<h3 id="3-或然跟随规则a-b"><strong>3. 或然跟随规则(A, B?)</strong></h3>
<p>Lucene的索引结构中存在这样的情况，某个值A后面可能存在某个值B，也可能不存在，需要一个标志来表示后面是否跟随着B。</p>
<p>一般的情况下，在A后面放置一个Byte，为0则后面不存在B，为1则后面存在B，或者0则后面存在B，1则后面不存在B。</p>
<p>但这样要浪费一个Byte的空间，其实一个Bit就可以了。</p>
<p>在Lucene中，采取以下的方式：A的值左移一位，空出最后一位，作为标志位，来表示后面是否跟随B，所以在这种情况下，A/2是真正的A原来的值。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262134351.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>如果去读Apache Lucene - Index File Formats这篇文章，会发现很多符合这种规则的：</p>
<ul>
<li>.frq文件中的DocDelta[, Freq?]，DocSkip,PayloadLength?</li>
<li>.prx文件中的PositionDelta,Payload? (但不完全是，如下表分析)</li>
</ul>
<p>当然还有一些带?的但不属于此规则的：</p>
<ul>
<li>.frq文件中的SkipChildLevelPointer?，是多层跳跃表中，指向下一层表的指针，当然如果是最后一层，此值就不存在，也不需要标志。</li>
<li>.tvf文件中的Positions?, Offsets?。
<ul>
<li>在此类情况下，带?的值是否存在，并不取决于前面的值的最后一位。</li>
<li>而是取决于Lucene的某项配置，当然这些配置也是保存在Lucene索引文件中的。</li>
<li>如Position和Offset是否存储，取决于.fnm文件中对于每个域的配置(TermVector.WITH_POSITIONS和TermVector.WITH_OFFSETS)</li>
</ul>
</li>
</ul>
<p>为什么会存在以上两种情况，其实是可以理解的：</p>
<ul>
<li>对于符合或然跟随规则的，是因为对于每一个A，B是否存在都不相同，当这种情况大量存在的时候，从一个Byte到一个Bit如此8倍的空间节约还是很值得的。</li>
<li>对于不符合或然跟随规则的，是因为某个值的是否存在的配置对于整个域(Field)甚至整个索引都是有效的，而非每次的情况都不相同，因而可以统一存放一个标志。</li>
</ul>
<blockquote>
<p>文章中对如下格式的描述令人困惑：</p>
</blockquote>
<blockquote>
<p>Positions &ndash;&gt; &lt;PositionDelta,Payload?&gt; <!-- raw HTML omitted -->Freq<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>Payload &ndash;&gt; &lt;PayloadLength?,PayloadData&gt;</p>
</blockquote>
<blockquote>
<p>PositionDelta和Payload是否适用或然跟随规则呢？如何标识PayloadLength是否存在呢？</p>
</blockquote>
<blockquote>
<p>其实PositionDelta和Payload并不符合或然跟随规则，Payload是否存在，是由.fnm文件中对于每个域的配置中有关Payload的配置决定的(FieldOption.STORES_PAYLOADS) 。</p>
</blockquote>
<blockquote>
<p>当Payload不存在时，PayloadDelta本身不遵从或然跟随原则。</p>
</blockquote>
<blockquote>
<p>当Payload存在时，格式应该变成如下：Positions &ndash;&gt; &lt;PositionDelta,PayloadLength?,PayloadData&gt; <!-- raw HTML omitted -->Freq<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>从而PositionDelta和PayloadLength一起适用或然跟随规则。</p>
</blockquote>
<h3 id="4-跳跃表规则skip-list"><strong>4. 跳跃表规则(Skip list)</strong></h3>
<p>为了提高查找的性能，Lucene在很多地方采取的跳跃表的数据结构。</p>
<p>跳跃表(Skip List)是如图的一种数据结构，有以下几个基本特征：</p>
<ul>
<li>元素是按顺序排列的，在Lucene中，或是按字典顺序排列，或是按从小到大顺序排列。</li>
<li>跳跃是有间隔的(Interval)，也即每次跳跃的元素数，间隔是事先配置好的，如图跳跃表的间隔为3。</li>
<li>跳跃表是由层次的(level)，每一层的每隔指定间隔的元素构成上一层，如图跳跃表共有2层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402262141098.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>需要注意一点的是，在很多数据结构或算法书中都会有跳跃表的描述，原理都是大致相同的，但是定义稍有差别：</p>
<ul>
<li>对间隔(Interval)的定义： 如图中，有的认为间隔为2，即两个上层元素之间的元素数，不包括两个上层元素；有的认为是3，即两个上层元素之间的差，包括后面上层元素，不包括前面的上层元素；有的认为是4，即除两个上层元素之间的元素外，既包括前面，也包括后面的上层元素。Lucene是采取的第二种定义。</li>
<li>对层次(Level)的定义：如图中，有的认为应该包括原链表层，并从1开始计数，则总层次为3，为1，2，3层；有的认为应该包括原链表层，并从0计数，为0，1，2层；有的认为不应该包括原链表层，且从1开始计数，则为1，2层；有的认为不应该包括链表层，且从0开始计数，则为0，1层。Lucene采取的是最后一种定义。</li>
</ul>
<p>跳跃表比顺序查找，大大提高了查找速度，如查找元素72，原来要访问2，3，7，12，23，37，39，44，50，72总共10个元素，应用跳跃表后，只要首先访问第1层的50，发现72大于50，而第1层无下一个节点，然后访问第2层的94，发现94大于72，然后访问原链表的72，找到元素，共需要访问3个元素即可。</p>
<p>然而Lucene在具体实现上，与理论又有所不同，在具体的格式中，会详细说明。</p>
<h2 id="四具体格式"><strong>四、具体格式</strong></h2>
<p>上面曾经交代过，Lucene保存了从Index到Segment到Document到Field一直到Term的正向信息，也包括了从Term到Document映射的反向信息，还有其他一些Lucene特有的信息。下面对这三种信息一一介绍。</p>
<h3 id="41-正向信息"><strong>4.1. 正向信息</strong></h3>
<p><code>Index –&gt; Segments (segments.gen, segments_N) –&gt; Field(fnm, fdx, fdt) –&gt; Term (tvx, tvd, tvf)</code></p>
<p>上面的层次结构不是十分的准确，因为segments.gen和segments_N保存的是段(segment)的元数据信息(metadata)，其实是每个Index一个的，而段的真正的数据信息，是保存在域(Field)和词(Term)中的。</p>
<h4 id="411-段的元数据信息segments_n"><strong>4.1.1. 段的元数据信息(segments_N)</strong></h4>
<p>一个索引(Index)可以同时存在多个segments_N(至于如何存在多个segments_N，在描述完详细信息之后会举例说明)，然而当我们要打开一个索引的时候，我们必须要选择一个来打开，那如何选择哪个segments_N呢？</p>
<p>Lucene采取以下过程：</p>
<ul>
<li>
<p>其一，在所有的segments_N中选择N最大的一个。基本逻辑参照SegmentInfos.getCurrentSegmentGeneration(File[] files)，其基本思路就是在所有以segments开头，并且不是segments.gen的文件中，选择N最大的一个作为genA。</p>
</li>
<li>
<p>其二，打开segments.gen，其中保存了当前的N值。其格式如下，读出版本号(Version)，然后再读出两个N，如果两者相等，则作为genB。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272228421.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>IndexInput genInput <span style="color:#f92672">=</span> directory<span style="color:#f92672">.</span><span style="color:#a6e22e">openInput</span><span style="color:#f92672">(</span>IndexFileNames<span style="color:#f92672">.</span><span style="color:#a6e22e">SEGMENTS_GEN</span><span style="color:#f92672">);</span><span style="color:#75715e">//&#34;segments.gen&#34;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> version <span style="color:#f92672">=</span> genInput<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span><span style="color:#75715e">//读出版本号  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>version <span style="color:#f92672">==</span> FORMAT_LOCKLESS<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//如果版本号正确  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> gen0 <span style="color:#f92672">=</span> genInput<span style="color:#f92672">.</span><span style="color:#a6e22e">readLong</span><span style="color:#f92672">();</span><span style="color:#75715e">//读出第一个N  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> gen1 <span style="color:#f92672">=</span> genInput<span style="color:#f92672">.</span><span style="color:#a6e22e">readLong</span><span style="color:#f92672">();</span><span style="color:#75715e">//读出第二个N  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>gen0 <span style="color:#f92672">==</span> gen1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//如果两者相等则为genB  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        genB <span style="color:#f92672">=</span> gen0<span style="color:#f92672">;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
<li>
<p>其三，在上述得到的genA和genB中选择最大的那个作为当前的N，方才打开segments_N文件。其基本逻辑如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>genA <span style="color:#f92672">&gt;</span> genB<span style="color:#f92672">)</span>  
</span></span><span style="display:flex;"><span>    gen <span style="color:#f92672">=</span> genA<span style="color:#f92672">;</span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>  
</span></span><span style="display:flex;"><span>    gen <span style="color:#f92672">=</span> genB<span style="color:#f92672">;</span>
</span></span></code></pre></div></li>
</ul>
<p>如下图是segments_N的具体格式：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272230529.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>Format：
<ul>
<li>索引文件格式的版本号。</li>
<li>由于Lucene是在不断开发过程中的，因而不同版本的Lucene，其索引文件格式也不尽相同，于是规定一个版本号。</li>
<li>Lucene 2.1此值-3，Lucene 2.9时，此值为-9。</li>
<li>当用某个版本号的IndexReader读取另一个版本号生成的索引的时候，会因为此值不同而报错。</li>
</ul>
</li>
<li>Version：
<ul>
<li>索引的版本号，记录了IndexWriter将修改提交到索引文件中的次数。</li>
<li>其初始值大多数情况下从索引文件里面读出，仅仅在索引开始创建的时候，被赋予当前的时间，已取得一个唯一值。</li>
<li>其值改变在 <code>IndexWriter.commit-&gt;IndexWriter.startCommit-&gt;SegmentInfos.prepareCommit-&gt;SegmentInfos.write-&gt;writeLong(++version)</code></li>
<li>其初始值之所最初取一个时间，是因为我们并不关心IndexWriter将修改提交到索引的具体次数，而更关心到底哪个是最新的。IndexReader中常比较自己的version和索引文件中的version是否相同来判断此IndexReader被打开后，还有没有被IndexWriter更新。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//在DirectoryReader中有一下函数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isCurrent</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CorruptIndexException<span style="color:#f92672">,</span> IOException <span style="color:#f92672">{</span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> SegmentInfos<span style="color:#f92672">.</span><span style="color:#a6e22e">readCurrentVersion</span><span style="color:#f92672">(</span>directory<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> segmentInfos<span style="color:#f92672">.</span><span style="color:#a6e22e">getVersion</span><span style="color:#f92672">();</span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>NameCount
<ul>
<li>是下一个新段(Segment)的段名。</li>
<li>所有属于同一个段的索引文件都以段名作为文件名，一般为_0.xxx, _0.yyy,  _1.xxx, _1.yyy ……</li>
<li>新生成的段的段名一般为原有最大段名加一。</li>
<li>如同的索引，NameCount读出来是2，说明新的段为_2.xxx, _2.yyy</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202402272232711.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>SegCount
<ul>
<li>段(Segment)的个数。</li>
<li>如上图，此值为2。</li>
</ul>
</li>
<li>SegCount个段的元数据信息：
<ul>
<li>SegName
<ul>
<li>段名，所有属于同一个段的文件都有以段名作为文件名。</li>
<li>如上图，第一个段的段名为&quot;_0&quot;，第二个段的段名为&quot;_1&quot;</li>
</ul>
</li>
<li>SegSize
<ul>
<li>此段中包含的文档数</li>
<li>然而此文档数是包括已经删除，又没有optimize的文档的，因为在optimize之前，Lucene的段中包含了所有被索引过的文档，而被删除的文档是保存在.del文件中的，在搜索的过程中，是先从段中读到了被删除的文档，然后再用.del中的标志，将这篇文档过滤掉。</li>
<li>如下的代码形成了上图的索引，可以看出索引了两篇文档形成了_0段，然后又删除了其中一篇，形成了_0_1.del，又索引了两篇文档形成_1段，然后又删除了其中一篇，形成_1_1.del。因而在两个段中，此值都是2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>IndexWriter writer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IndexWriter<span style="color:#f92672">(</span>FSDirectory<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>INDEX<span style="color:#960050;background-color:#1e0010">\</span>_DIR<span style="color:#f92672">),</span> <span style="color:#66d9ef">new</span> StandardAnalyzer<span style="color:#f92672">(</span>Version<span style="color:#f92672">.</span><span style="color:#a6e22e">LUCENE</span><span style="color:#960050;background-color:#1e0010">\</span>_CURRENT<span style="color:#f92672">),</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">,</span> IndexWriter<span style="color:#f92672">.</span><span style="color:#a6e22e">MaxFieldLength</span><span style="color:#f92672">.</span><span style="color:#a6e22e">LIMITED</span><span style="color:#f92672">);</span>  
</span></span><span style="display:flex;"><span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">setUseCompoundFile</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>  
</span></span><span style="display:flex;"><span>indexDocs<span style="color:#f92672">(</span>writer<span style="color:#f92672">,</span> docDir<span style="color:#f92672">);</span><span style="color:#75715e">//docDir中只有两篇文档
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//文档一为：Students should be allowed to go out with their friends, but not allowed to drink beer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//文档二为：My friend Jerry went to school to see his students but found them drunk which is not allowed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">commit</span><span style="color:#f92672">();</span><span style="color:#75715e">//提交两篇文档，形成\_0段。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteDocuments</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Term<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;contents&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;school&#34;</span><span style="color:#f92672">));</span><span style="color:#75715e">//删除文档二  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">commit</span><span style="color:#f92672">();</span><span style="color:#75715e">//提交删除，形成\_0\_1.del  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>indexDocs<span style="color:#f92672">(</span>writer<span style="color:#f92672">,</span> docDir<span style="color:#f92672">);</span><span style="color:#75715e">//再次索引两篇文档，Lucene不能判别文档与文档的不同，因而算两篇新的文档。  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">commit</span><span style="color:#f92672">();</span><span style="color:#75715e">//提交两篇文档，形成\_1段  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteDocuments</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Term<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;contents&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;school&#34;</span><span style="color:#f92672">));</span><span style="color:#75715e">//删除第二次添加的文档二  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>writer<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span><span style="color:#75715e">//提交删除，形成\_1\_1.del
</span></span></span></code></pre></div><ul>
<li>
<ul>
<li>DelGen
<ul>
<li>.del文件的版本号</li>
<li>Lucene中，在optimize之前，删除的文档是保存在.del文件中的。</li>
<li>在Lucene 2.9中，文档删除有以下几种方式：
<ul>
<li>IndexReader.deleteDocument(int docID)是用IndexReader按文档号删除。</li>
<li>IndexReader.deleteDocuments(Term term)是用IndexReader删除包含此词(Term)的文档。</li>
<li>IndexWriter.deleteDocuments(Term term)是用IndexWriter删除包含此词(Term)的文档。</li>
<li>IndexWriter.deleteDocuments(Term[] terms)是用IndexWriter删除包含这些词(Term)的文档。</li>
<li>IndexWriter.deleteDocuments(Query query)是用IndexWriter删除能满足此查询(Query)的文档。</li>
<li>IndexWriter.deleteDocuments(Query[] queries)是用IndexWriter删除能满足这些查询(Query)的文档。</li>
<li>原来的版本中Lucene的删除一直是由IndexReader来完成的，在Lucene 2.9中虽可以用IndexWriter来删除，但是其实真正的实现是在IndexWriter中，保存了readerpool，当IndexWriter向索引文件提交删除的时候，仍然是从readerpool中得到相应的IndexReader，并用IndexReader来进行删除的。下面的代码可以说明：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> IndexWriter<span style="color:#f92672">.</span><span style="color:#a6e22e">applyDeletes</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">-&gt;</span> DocumentsWriter<span style="color:#f92672">.</span><span style="color:#a6e22e">applyDeletes</span><span style="color:#f92672">(</span>SegmentInfos<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">-&gt;</span> reader<span style="color:#f92672">.</span><span style="color:#a6e22e">deleteDocument</span><span style="color:#f92672">(</span>doc<span style="color:#f92672">);</span>
</span></span></code></pre></div><ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>DelGen是每当IndexWriter向索引文件中提交删除操作的时候，加1，并生成新的.del文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<ul>
<li>
<p>DocStoreOffset</p>
</li>
<li>
<p>DocStoreSegment</p>
</li>
<li>
<p>DocStoreIsCompoundFile</p>
<ul>
<li>对于域(Stored Field)和词向量(Term Vector)的存储可以有不同的方式，即可以每个段(Segment)单独存储自己的域和词向量信息，也可以多个段共享域和词向量，把它们存储到一个段中去。</li>
<li>如果DocStoreOffset为-1，则此段单独存储自己的域和词向量，从存储文件上来看，如果此段段名为XXX，则此段有自己的XXX.fdt，XXX.fdx，XXX.tvf，XXX.tvd，XXX.tvx文件。DocStoreSegment和DocStoreIsCompoundFile在此处不被保存。</li>
<li>如果DocStoreOffset不为-1，则DocStoreSegment保存了共享的段的名字，比如为YYY，DocStoreOffset则为此段的域及词向量信息在共享段中的偏移量。则此段没有自己的XXX.fdt，XXX.fdx，XXX.tvf，XXX.tvd，XXX.tvx文件，而是将信息存放在共享段的YYY.fdt，YYY.fdx，YYY.tvf，YYY.tvd，YYY.tvx文件中。</li>
<li>DocumentsWriter中有两个成员变量：String segment是当前索引信息存放的段，String docStoreSegment是域和词向量信息存储的段。两者可以相同也可以不同，决定了域和词向量信息是存储在本段中，还是和其他的段共享。</li>
<li>IndexWriter.flush(boolean triggerMerge, boolean flushDocStores, boolean flushDeletes)中第二个参数flushDocStores会影响到是否单独或是共享存储。其实最终影响的是DocumentsWriter.closeDocStore()。每当flushDocStores为false时，closeDocStore不被调用，说明下次添加到索引文件中的域和词向量信息是同此次共享一个段的。直到flushDocStores为true的时候，closeDocStore被调用，从而下次添加到索引文件中的域和词向量信息将被保存在一个新的段中，不同此次共享一个段(在这里需要指出的是Lucene的一个很奇怪的实现，虽然下次域和词向量信息是被保存到新的段中，然而段名却是这次被确定了的，在initSegmentName中当docStoreSegment == null时，被置为当前的segment，而非下一个新的segment，docStoreSegment = segment，于是会出现如下面的例子的现象)。</li>
<li>好在共享域和词向量存储并不是经常被使用到，实现也或有缺陷，暂且解释到此。</li>
</ul>
<p>IndexWriter writer = new IndexWriter(FSDirectory.open(INDEX_DIR), new StandardAnalyzer(Version.LUCENE_CURRENT), true, IndexWriter.MaxFieldLength.LIMITED);<br>
writer.setUseCompoundFile(false);</p>
<p>indexDocs(writer, docDir);<br>
writer.flush();</p>
</li>
</ul>
</li>
</ul>
<p>//flush生成segment &ldquo;_0&rdquo;，并且flush函数中，flushDocStores设为false，也即下个段将同本段共享域和词向量信息，这时DocumentsWriter中的docStoreSegment= &ldquo;_0&rdquo;。</p>
<pre><code>  indexDocs(writer, docDir);  
  writer.commit();
</code></pre>
<p>//commit生成segment &ldquo;_1&rdquo;，由于上次flushDocStores设为false，于是段&quot;_1&quot;的域以及词向量信息是保存在&quot;_0&quot;中的，在这个时刻，段&quot;_1&quot;并不生成自己的&quot;_1.fdx&quot;和&quot;_1.fdt&quot;。然而在commit函数中，flushDocStores设为true，也即下个段将单独使用新的段来存储域和词向量信息。然而这时，DocumentsWriter中的docStoreSegment= &ldquo;_1&rdquo;，也即当段&quot;_2&quot;存储其域和词向量信息的时候，是存在&quot;_1.fdx&quot;和&quot;_1.fdt&quot;中的，而段&quot;_1&quot;的域和词向量信息却是存在&quot;_0.fdt&quot;和&quot;_0.fdx&quot;中的，这一点非常令人困惑。 如图writer.commit的时候，_1.fdt和_1.fdx并没有形成。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022114233.png"
	
	
	
	loading="lazy"
	
	
></p>
<pre><code>  indexDocs(writer, docDir);  
  writer.flush();
</code></pre>
<p>//段&quot;_2&quot;形成，由于上次flushDocStores设为true，其域和词向量信息是新创建一个段保存的，却是保存在_1.fdt和_1.fdx中的，这时候才产生了此二文件。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022115773.png"
	
	
	
	loading="lazy"
	
	
></p>
<pre><code>  indexDocs(writer, docDir);  
  writer.flush();
</code></pre>
<p>//段&quot;_3&quot;形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_1.fdt和_1.fdx中的</p>
<pre><code>  indexDocs(writer, docDir);  
  writer.commit();
</code></pre>
<p>//段&quot;_4&quot;形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_1.fdt和_1.fdx中的。然而函数commit中flushDocStores设为true，也意味着下一个段将新创建一个段保存域和词向量信息，此时DocumentsWriter中docStoreSegment= &ldquo;_4&rdquo;，也表明了虽然段&quot;_4&quot;的域和词向量信息保存在了段&quot;_1&quot;中，将来的域和词向量信息却要保存在段&quot;_4&quot;中。此时&quot;_4.fdx&quot;和&quot;_4.fdt&quot;尚未产生。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022115627.png"
	
	
	
	loading="lazy"
	
	
></p>
<pre><code>  indexDocs(writer, docDir);  
  writer.flush();
</code></pre>
<p>//段&quot;_5&quot;形成，由于上次flushDocStores设为true，其域和词向量信息是新创建一个段保存的，却是保存在_4.fdt和_4.fdx中的，这时候才产生了此二文件。</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022116165.png"
	
	
	
	loading="lazy"
	
	
></p>
<pre><code>  indexDocs(writer, docDir);  
  writer.commit();  
  writer.close();
</code></pre>
<p>//段&quot;_6&quot;形成，由于上次flushDocStores设为false，其域和词向量信息是共享一个段保存的，也是是保存在_4.fdt和_4.fdx中的</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022116777.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>
<ul>
<li>HasSingleNormFile
<ul>
<li>在搜索的过程中，标准化因子(Normalization Factor)会影响文档最后的评分。</li>
<li>不同的文档重要性不同，不同的域重要性也不同。因而每个文档的每个域都可以有自己的标准化因子。</li>
<li>如果HasSingleNormFile为1，则所有的标准化因子都是存在.nrm文件中的。</li>
<li>如果HasSingleNormFile不是1，则每个域都有自己的标准化因子文件.fN</li>
</ul>
</li>
<li>NumField
<ul>
<li>域的数量</li>
</ul>
</li>
<li>NormGen
<ul>
<li>如果每个域有自己的标准化因子文件，则此数组描述了每个标准化因子文件的版本号，也即.fN的N。</li>
</ul>
</li>
<li>IsCompoundFile
<ul>
<li>是否保存为复合文件，也即把同一个段中的文件按照一定格式，保存在一个文件当中，这样可以减少每次打开文件的个数。</li>
<li>是否为复合文件，由接口IndexWriter.setUseCompoundFile(boolean)设定。</li>
<li>非符合文件同符合文件的对比如下图：</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>DeletionCount
<ul>
<li>记录了此段中删除的文档的数目。</li>
</ul>
</li>
<li>HasProx
<ul>
<li>如果至少有一个段omitTf为false，也即词频(term freqency)需要被保存，则HasProx为1，否则为0。</li>
</ul>
</li>
<li>Diagnostics
<ul>
<li>调试信息。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>User map data</p>
<ul>
<li>保存了用户从字符串到字符串的映射Map</li>
</ul>
</li>
<li>
<p>CheckSum</p>
<ul>
<li>此文件segment_N的校验和。</li>
</ul>
</li>
</ul>
<p>读取此文件格式参考SegmentInfos.read(Directory directory, String segmentFileName):</p>
<ul>
<li>
<p>int format = input.readInt();</p>
</li>
<li>
<p>version = input.readLong(); // read version</p>
</li>
<li>
<p>counter = input.readInt(); // read counter</p>
</li>
<li>
<p>for (int i = input.readInt(); i &gt; 0; i&ndash;) // read segmentInfos</p>
<ul>
<li>add(new SegmentInfo(directory, format, input));
<ul>
<li>name = input.readString();</li>
<li>docCount = input.readInt();</li>
<li>delGen = input.readLong();</li>
<li>docStoreOffset = input.readInt();</li>
<li>docStoreSegment = input.readString();</li>
<li>docStoreIsCompoundFile = (1 == input.readByte());</li>
<li>hasSingleNormFile = (1 == input.readByte());</li>
<li>int numNormGen = input.readInt();</li>
<li>normGen = new long[numNormGen];</li>
<li>for(int j=0;j</li>
<li>normGen[j] = input.readLong();</li>
</ul>
</li>
<li>isCompoundFile = input.readByte();</li>
<li>delCount = input.readInt();</li>
<li>hasProx = input.readByte() == 1;</li>
<li>diagnostics = input.readStringStringMap();</li>
</ul>
</li>
<li>
<p>userData = input.readStringStringMap();</p>
</li>
<li>
<p>final long checksumNow = input.getChecksum();</p>
</li>
<li>
<p>final long checksumThen = input.readLong();</p>
</li>
</ul>
<h4 id="412-域field的元数据信息fnm"><strong>4.1.2. 域(Field)的元数据信息(.fnm)</strong></h4>
<p>一个段(Segment)包含多个域，每个域都有一些元数据信息，保存在.fnm文件中，.fnm文件的格式如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022117877.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>FNMVersion
<ul>
<li>是fnm文件的版本号，对于Lucene 2.9为-2</li>
</ul>
</li>
<li>FieldsCount
<ul>
<li>域的数目</li>
</ul>
</li>
<li>一个数组的域(Fields)
<ul>
<li>FieldName：域名，如&quot;title&quot;，&ldquo;modified&rdquo;，&ldquo;content&quot;等。</li>
<li>FieldBits:一系列标志位，表明对此域的索引方式
<ul>
<li>最低位：1表示此域被索引，0则不被索引。所谓被索引，也即放到倒排表中去。
<ul>
<li>仅仅被索引的域才能够被搜到。</li>
<li>Field.Index.NO则表示不被索引。</li>
<li>Field.Index.ANALYZED则表示不但被索引，而且被分词，比如索引&quot;hello world&quot;后，无论是搜&quot;hello&rdquo;，还是搜&quot;world&quot;都能够被搜到。</li>
<li>Field.Index.NOT_ANALYZED表示虽然被索引，但是不分词，比如索引&quot;hello world&quot;后，仅当搜&quot;hello world&quot;时，能够搜到，搜&quot;hello&quot;和搜&quot;world&quot;都搜不到。</li>
<li>一个域出了能够被索引，还能够被存储，仅仅被存储的域是搜索不到的，但是能通过文档号查到，多用于不想被搜索到，但是在通过其它域能够搜索到的情况下，能够随着文档号返回给用户的域。</li>
<li>Field.Store.Yes则表示存储此域，Field.Store.NO则表示不存储此域。</li>
</ul>
</li>
<li>倒数第二位：1表示保存词向量，0为不保存词向量。
<ul>
<li>Field.TermVector.YES表示保存词向量。</li>
<li>Field.TermVector.NO表示不保存词向量。</li>
</ul>
</li>
<li>倒数第三位：1表示在词向量中保存位置信息。
<ul>
<li>Field.TermVector.WITH_POSITIONS</li>
</ul>
</li>
<li>倒数第四位：1表示在词向量中保存偏移量信息。
<ul>
<li>Field.TermVector.WITH_OFFSETS</li>
</ul>
</li>
<li>倒数第五位：1表示不保存标准化因子
<ul>
<li>Field.Index.ANALYZED_NO_NORMS</li>
<li>Field.Index.NOT_ANALYZED_NO_NORMS</li>
</ul>
</li>
<li>倒数第六位：是否保存payload</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>要了解域的元数据信息，还要了解以下几点：</p>
<ul>
<li>位置(Position)和偏移量(Offset)的区别
<ul>
<li>位置是基于词Term的，偏移量是基于字母或汉字的。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022117067.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>索引域(Indexed)和存储域(Stored)的区别
<ul>
<li>一个域为什么会被存储(store)而不被索引(Index)呢？在一个文档中的所有信息中，有这样一部分信息，可能不想被索引从而可以搜索到，但是当这个文档由于其他的信息被搜索到时，可以同其他信息一同返回。</li>
<li>举个例子，读研究生时，您好不容易写了一篇论文交给您的导师，您的导师却要他所第一作者而您做第二作者，然而您导师不想别人在论文系统中搜索您的名字时找到这篇论文，于是在论文系统中，把第二作者这个Field的Indexed设为false，这样别人搜索您的名字，永远不知道您写过这篇论文，只有在别人搜索您导师的名字从而找到您的文章时，在一个角落表述着第二作者是您。</li>
</ul>
</li>
<li>payload的使用
<ul>
<li>我们知道，索引是以倒排表形式存储的，对于每一个词，都保存了包含这个词的一个链表，当然为了加快查询速度，此链表多用跳跃表进行存储。</li>
<li>Payload信息就是存储在倒排表中的，同文档号一起存放，多用于存储与每篇文档相关的一些信息。当然这部分信息也可以存储域里(stored Field)，两者从功能上基本是一样的，然而当要存储的信息很多的时候，存放在倒排表里，利用跳跃表，有利于大大提高搜索速度。</li>
<li>Payload的存储方式如下图：</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022122309.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>
<ul>
<li>Payload主要有以下几种用法：
<ul>
<li>存储每个文档都有的信息：比如有的时候，我们想给每个文档赋一个我们自己的文档号，而不是用Lucene自己的文档号。于是我们可以声明一个特殊的域(Field)&quot;_ID&quot;和特殊的词(Term)&quot;_ID&quot;，使得每篇文档都包含词&quot;_ID&quot;，于是在词&quot;_ID&quot;的倒排表里面对于每篇文档又有一项，每一项都有一个payload，于是我们可以在payload里面保存我们自己的文档号。每当我们得到一个Lucene的文档号的时候，就能从跳跃表中查找到我们自己的文档号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>//声明一个特殊的域和特殊的词</p>
<p>public static final String ID_PAYLOAD_FIELD = &ldquo;_ID&rdquo;;</p>
<p>public static final String ID_PAYLOAD_TERM = &ldquo;_ID&rdquo;;</p>
<p>public static final Term ID_TERM = new Term(ID_PAYLOAD_TERM, ID_PAYLOAD_FIELD);</p>
<p>//声明一个特殊的TokenStream，它只生成一个词(Term)，就是那个特殊的词，在特殊的域里面。</p>
<p>static class SinglePayloadTokenStream extends TokenStream {<br>
private Token token;<br>
private boolean returnToken = false;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SinglePayloadTokenStream<span style="color:#f92672">(</span>String idPayloadTerm<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> term <span style="color:#f92672">=</span> idPayloadTerm<span style="color:#f92672">.</span><span style="color:#a6e22e">toCharArray</span><span style="color:#f92672">();</span>  
</span></span><span style="display:flex;"><span>    token <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Token<span style="color:#f92672">(</span>term<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> term<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> term<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setPayloadValue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  
</span></span><span style="display:flex;"><span>    token<span style="color:#f92672">.</span><span style="color:#a6e22e">setPayload</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Payload<span style="color:#f92672">(</span>value<span style="color:#f92672">));</span>  
</span></span><span style="display:flex;"><span>    returnToken <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Token <span style="color:#a6e22e">next</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>returnToken<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>  
</span></span><span style="display:flex;"><span>        returnToken <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> token<span style="color:#f92672">;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>  
</span></span></code></pre></div><p>}</p>
<p>//对于每一篇文档，都让它包含这个特殊的词，在特殊的域里面</p>
<p>SinglePayloadTokenStream singlePayloadTokenStream = new SinglePayloadTokenStream(ID_PAYLOAD_TERM);<br>
singlePayloadTokenStream.setPayloadValue(long2bytes(id));<br>
doc.add(new Field(ID_PAYLOAD_FIELD, singlePayloadTokenStream));</p>
<p>//每当得到一个Lucene的文档号时，通过以下的方式得到payload里面的文档号</p>
<p>long id = 0;<br>
TermPositions tp = reader.termPositions(ID_PAYLOAD_TERM);<br>
boolean ret = tp.skipTo(docID);<br>
tp.nextPosition();<br>
int payloadlength = tp.getPayloadLength();<br>
byte[] payloadBuffer = new byte[payloadlength];<br>
tp.getPayload(payloadBuffer, 0);<br>
id = bytes2long(payloadBuffer);<br>
tp.close();</p>
<ul>
<li>
<ul>
<li>
<ul>
<li>影响词的评分
<ul>
<li>在Similarity抽象类中有函数public float scorePayload(byte [] payload, int offset, int length)  可以根据payload的值影响评分。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>读取域元数据信息的代码如下：</li>
</ul>
<p>FieldInfos.read(IndexInput, String)</p>
<ul>
<li>int firstInt = input.readVInt();</li>
<li>size = input.readVInt();</li>
<li>for (int i = 0; i &lt; size; i++)
<ul>
<li>String name = input.readString();</li>
<li>byte bits = input.readByte();</li>
<li>boolean isIndexed = (bits &amp; IS_INDEXED) != 0;</li>
<li>boolean storeTermVector = (bits &amp; STORE_TERMVECTOR) != 0;</li>
<li>boolean storePositionsWithTermVector = (bits &amp; STORE_POSITIONS_WITH_TERMVECTOR) != 0;</li>
<li>boolean storeOffsetWithTermVector = (bits &amp; STORE_OFFSET_WITH_TERMVECTOR) != 0;</li>
<li>boolean omitNorms = (bits &amp; OMIT_NORMS) != 0;</li>
<li>boolean storePayloads = (bits &amp; STORE_PAYLOADS) != 0;</li>
<li>boolean omitTermFreqAndPositions = (bits &amp; OMIT_TERM_FREQ_AND_POSITIONS) != 0;</li>
</ul>
</li>
</ul>
<h4 id="413-域field的数据信息fdtfdx"><strong>4.1.3. 域(Field)的数据信息(.fdt，.fdx)</strong></h4>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022125684.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>域数据文件(fdt):
<ul>
<li>真正保存存储域(stored field)信息的是fdt文件</li>
<li>在一个段(segment)中总共有segment size篇文档，所以fdt文件中共有segment size个项，每一项保存一篇文档的域的信息</li>
<li>对于每一篇文档，一开始是一个fieldcount，也即此文档包含的域的数目，接下来是fieldcount个项，每一项保存一个域的信息。</li>
<li>对于每一个域，fieldnum是域号，接着是一个8位的byte，最低一位表示此域是否分词(tokenized)，倒数第二位表示此域是保存字符串数据还是二进制数据，倒数第三位表示此域是否被压缩，再接下来就是存储域的值，比如new Field(&ldquo;title&rdquo;, &ldquo;lucene in action&rdquo;, Field.Store.Yes, …)，则此处存放的就是&quot;lucene in action&quot;这个字符串。</li>
</ul>
</li>
<li>域索引文件(fdx)
<ul>
<li>由域数据文件格式我们知道，每篇文档包含的域的个数，每个存储域的值都是不一样的，因而域数据文件中segment size篇文档，每篇文档占用的大小也是不一样的，那么如何在fdt中辨别每一篇文档的起始地址和终止地址呢，如何能够更快的找到第n篇文档的存储域的信息呢？就是要借助域索引文件。</li>
<li>域索引文件也总共有segment size个项，每篇文档都有一个项，每一项都是一个long，大小固定，每一项都是对应的文档在fdt文件中的起始地址的偏移量，这样如果我们想找到第n篇文档的存储域的信息，只要在fdx中找到第n项，然后按照取出的long作为偏移量，就可以在fdt文件中找到对应的存储域的信息。</li>
</ul>
</li>
<li>读取域数据信息的代码如下：</li>
</ul>
<p>Document FieldsReader.doc(int n, FieldSelector fieldSelector)</p>
<ul>
<li>long position = indexStream.readLong();//indexStream points to &ldquo;.fdx&rdquo;</li>
<li>fieldsStream.seek(position);//fieldsStream points to &ldquo;fdt&rdquo;</li>
<li>int numFields = fieldsStream.readVInt();</li>
<li>for (int i = 0; i &lt; numFields; i++)
<ul>
<li>int fieldNumber = fieldsStream.readVInt();</li>
<li>byte bits = fieldsStream.readByte();</li>
<li>boolean compressed = (bits &amp; FieldsWriter.FIELD_IS_COMPRESSED) != 0;</li>
<li>boolean tokenize = (bits &amp; FieldsWriter.FIELD_IS_TOKENIZED) != 0;</li>
<li>boolean binary = (bits &amp; FieldsWriter.FIELD_IS_BINARY) != 0;</li>
<li>if (binary)
<ul>
<li>int toRead = fieldsStream.readVInt();</li>
<li>final byte[] b = new byte[toRead];</li>
<li>fieldsStream.readBytes(b, 0, b.length);</li>
<li>if (compressed)
<ul>
<li>int toRead = fieldsStream.readVInt();</li>
<li>final byte[] b = new byte[toRead];</li>
<li>fieldsStream.readBytes(b, 0, b.length);</li>
<li>uncompress(b),</li>
</ul>
</li>
</ul>
</li>
<li>else
<ul>
<li>fieldsStream.readString()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="413-词向量term-vector的数据信息tvxtvdtvf"><strong>4.1.3. 词向量(Term Vector)的数据信息(.tvx，.tvd，.tvf)</strong></h4>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022135786.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>词向量信息是从索引(index)到文档(document)到域(field)到词(term)的正向信息，有了词向量信息，我们就可以得到一篇文档包含那些词的信息。</p>
<ul>
<li>词向量索引文件(tvx)
<ul>
<li>一个段(segment)包含N篇文档，此文件就有N项，每一项代表一篇文档。</li>
<li>每一项包含两部分信息：第一部分是词向量文档文件(tvd)中此文档的偏移量，第二部分是词向量域文件(tvf)中此文档的第一个域的偏移量。</li>
</ul>
</li>
<li>词向量文档文件(tvd)
<ul>
<li>一个段(segment)包含N篇文档，此文件就有N项，每一项包含了此文档的所有的域的信息。</li>
<li>每一项首先是此文档包含的域的个数NumFields，然后是一个NumFields大小的数组，数组的每一项是域号。然后是一个(NumFields - 1)大小的数组，由前面我们知道，每篇文档的第一个域在tvf中的偏移量在tvx文件中保存，而其他(NumFields - 1)个域在tvf中的偏移量就是第一个域的偏移量加上这(NumFields - 1)个数组的每一项的值。</li>
</ul>
</li>
<li>词向量域文件(tvf)
<ul>
<li>此文件包含了此段中的所有的域，并不对文档做区分，到底第几个域到第几个域是属于那篇文档，是由tvx中的第一个域的偏移量以及tvd中的(NumFields - 1)个域的偏移量来决定的。</li>
<li>对于每一个域，首先是此域包含的词的个数NumTerms，然后是一个8位的byte，最后一位是指定是否保存位置信息，倒数第二位是指定是否保存偏移量信息。然后是NumTerms个项的数组，每一项代表一个词(Term)，对于每一个词，由词的文本TermText，词频TermFreq(也即此词在此文档中出现的次数)，词的位置信息，词的偏移量信息。</li>
</ul>
</li>
<li>读取词向量数据信息的代码如下：</li>
</ul>
<p>TermVectorsReader.get(int docNum, String field, TermVectorMapper)</p>
<ul>
<li>int fieldNumber = fieldInfos.fieldNumber(field);//通过field名字得到field号</li>
<li>seekTvx(docNum);//在tvx文件中按docNum文档号找到相应文档的项</li>
<li>long tvdPosition = tvx.readLong();//找到tvd文件中相应文档的偏移量</li>
<li>tvd.seek(tvdPosition);//在tvd文件中按偏移量找到相应文档的项</li>
<li>int fieldCount = tvd.readVInt();//此文档包含的域的个数。</li>
<li>for (int i = 0; i &lt; fieldCount; i++) //按域号查找域
<ul>
<li>number = tvd.readVInt();</li>
<li>if (number == fieldNumber)
<ul>
<li>found = i;</li>
</ul>
</li>
</ul>
</li>
<li>position = tvx.readLong();//在tvx中读出此文档的第一个域在tvf中的偏移量</li>
<li>for (int i = 1; i &lt;= found; i++)
<ul>
<li>position += tvd.readVLong();//加上所要找的域在tvf中的偏移量</li>
</ul>
</li>
<li>tvf.seek(position);</li>
<li>int numTerms = tvf.readVInt();</li>
<li>byte bits = tvf.readByte();</li>
<li>storePositions = (bits &amp; STORE_POSITIONS_WITH_TERMVECTOR) != 0;</li>
<li>storeOffsets = (bits &amp; STORE_OFFSET_WITH_TERMVECTOR) != 0;</li>
<li>for (int i = 0; i &lt; numTerms; i++)
<ul>
<li>start = tvf.readVInt();</li>
<li>deltaLength = tvf.readVInt();</li>
<li>totalLength = start + deltaLength;</li>
<li>tvf.readBytes(byteBuffer, start, deltaLength);</li>
<li>term = new String(byteBuffer, 0, totalLength, &ldquo;UTF-8&rdquo;);</li>
<li>if (storePositions)
<ul>
<li>positions = new int[freq];</li>
<li>int prevPosition = 0;</li>
<li>for (int j = 0; j &lt; freq; j++)
<ul>
<li>positions[j] = prevPosition + tvf.readVInt();</li>
<li>prevPosition = positions[j];</li>
</ul>
</li>
</ul>
</li>
<li>if (storeOffsets)
<ul>
<li>offsets = new TermVectorOffsetInfo[freq];</li>
<li>int prevOffset = 0;</li>
<li>for (int j = 0; j &lt; freq; j++)</li>
<li>int startOffset = prevOffset + tvf.readVInt();</li>
<li>int endOffset = startOffset + tvf.readVInt();</li>
<li>offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);</li>
<li>prevOffset = endOffset;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="42-反向信息"><strong>4.2. 反向信息</strong></h3>
<p>反向信息是索引文件的核心，也即反向索引。</p>
<p>反向索引包括两部分，左面是词典(Term Dictionary)，右面是倒排表(Posting List)。</p>
<p>在Lucene中，这两部分是分文件存储的，词典是存储在tii，tis中的，倒排表又包括两部分，一部分是文档号及词频，保存在frq中，一部分是词的位置信息，保存在prx中。</p>
<ul>
<li>Term Dictionary (tii, tis)
<ul>
<li>–&gt; Frequencies (.frq)</li>
<li>–&gt; Positions (.prx)</li>
</ul>
</li>
</ul>
<h4 id="421-词典tis及词典索引tii信息"><strong>4.2.1. 词典(tis)及词典索引(tii)信息</strong></h4>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022136378.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>在词典中，所有的词是按照字典顺序排序的。</p>
<ul>
<li>词典文件(tis)
<ul>
<li>TermCount：词典中包含的总的词数</li>
<li>IndexInterval：为了加快对词的查找速度，也应用类似跳跃表的结构，假设IndexInterval为4，则在词典索引(tii)文件中保存第4个，第8个，第12个词，这样可以加快在词典文件中查找词的速度。</li>
<li>SkipInterval：倒排表无论是文档号及词频，还是位置信息，都是以跳跃表的结构存在的，SkipInterval是跳跃的步数。</li>
<li>MaxSkipLevels：跳跃表是多层的，这个值指的是跳跃表的最大层数。</li>
<li>TermCount个项的数组，每一项代表一个词，对于每一个词，以前缀后缀规则存放词的文本信息(PrefixLength + Suffix)，词属于的域的域号(FieldNum)，有多少篇文档包含此词(DocFreq)，此词的倒排表在frq，prx中的偏移量(FreqDelta, ProxDelta)，此词的倒排表的跳跃表在frq中的偏移量(SkipDelta)，这里之所以用Delta，是应用差值规则。</li>
</ul>
</li>
<li>词典索引文件(tii)
<ul>
<li>词典索引文件是为了加快对词典文件中词的查找速度，保存每隔IndexInterval个词。</li>
<li>词典索引文件是会被全部加载到内存中去的。</li>
<li>IndexTermCount = TermCount / IndexInterval：词典索引文件中包含的词数。</li>
<li>IndexInterval同词典文件中的IndexInterval。</li>
<li>SkipInterval同词典文件中的SkipInterval。</li>
<li>MaxSkipLevels同词典文件中的MaxSkipLevels。</li>
<li>IndexTermCount个项的数组，每一项代表一个词，每一项包括两部分，第一部分是词本身(TermInfo)，第二部分是在词典文件中的偏移量(IndexDelta)。假设IndexInterval为4，此数组中保存第4个，第8个，第12个词。。。</li>
</ul>
</li>
<li>读取词典及词典索引文件的代码如下：</li>
</ul>
<p>origEnum = new SegmentTermEnum(directory.openInput(segment + &ldquo;.&rdquo; + IndexFileNames.TERMS_EXTENSION,readBufferSize), fieldInfos, false);//用于读取tis文件</p>
<ul>
<li>int firstInt = input.readInt();</li>
<li>size = input.readLong();</li>
<li>indexInterval = input.readInt();</li>
<li>skipInterval = input.readInt();</li>
<li>maxSkipLevels = input.readInt();</li>
</ul>
<p>SegmentTermEnum indexEnum = new SegmentTermEnum(directory.openInput(segment + &ldquo;.&rdquo; + IndexFileNames.TERMS_INDEX_EXTENSION, readBufferSize), fieldInfos, true);//用于读取tii文件</p>
<ul>
<li>indexTerms = new Term[indexSize];</li>
<li>indexInfos = new TermInfo[indexSize];</li>
<li>indexPointers = new long[indexSize];</li>
<li>for (int i = 0; indexEnum.next(); i++)
<ul>
<li>indexTerms[i] = indexEnum.term();</li>
<li>indexInfos[i] = indexEnum.termInfo();</li>
<li>indexPointers[i] = indexEnum.indexPointer;</li>
</ul>
</li>
</ul>
<h4 id="422-文档号及词频frq信息"><strong>4.2.2. 文档号及词频(frq)信息</strong></h4>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022137895.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>文档号及词频文件里面保存的是倒排表，是以跳跃表形式存在的。</p>
<ul>
<li>此文件包含TermCount个项，每一个词都有一项，因为每一个词都有自己的倒排表。</li>
<li>对于每一个词的倒排表都包括两部分，一部分是倒排表本身，也即一个数组的文档号及词频，另一部分是跳跃表，为了更快的访问和定位倒排表中文档号及词频的位置。</li>
<li>对于文档号和词频的存储应用的是差值规则和或然跟随规则，Lucene的文档本身有以下几句话，比较难以理解，在此解释一下：</li>
</ul>
<p>For example, the TermFreqs for a term which occurs once in document seven and three times in document eleven, with omitTf false, would be the following sequence of VInts:</p>
<p>15, 8, 3</p>
<p>If omitTf were true it would be this sequence of VInts instead:</p>
<p>7,4</p>
<p>首先我们看omitTf=false的情况，也即我们在索引中会存储一个文档中term出现的次数。</p>
<p>例子中说了，表示在文档7中出现1次，并且又在文档11中出现3次的文档用以下序列表示：15，8，3.</p>
<p>那这三个数字是怎么计算出来的呢？</p>
<p>首先，根据定义TermFreq &ndash;&gt; DocDelta[, Freq?]，一个TermFreq结构是由一个DocDelta后面或许跟着Freq组成，也即上面我们说的A+B？结构。</p>
<p>DocDelta自然是想存储包含此Term的文档的ID号了，Freq是在此文档中出现的次数。</p>
<p>所以根据例子，应该存储的完整信息为[DocID = 7, Freq = 1] [DocID = 11,  Freq = 3](见全文检索的基本原理章节)。</p>
<p>然而为了节省空间，Lucene对编号此类的数据都是用差值来表示的，也即上面说的规则2，Delta规则，于是文档ID就不能按完整信息存了，就应该存放如下：</p>
<p>[DocIDDelta = 7, Freq = 1][DocIDDelta = 4 (11-7), Freq = 3]</p>
<p>然而Lucene对于A+B?这种或然跟随的结果，有其特殊的存储方式，见规则3，即A+B?规则，如果DocDelta后面跟随的Freq为1，则用DocDelta最后一位置1表示。</p>
<p>如果DocDelta后面跟随的Freq大于1，则DocDelta得最后一位置0，然后后面跟随真正的值，从而对于第一个Term，由于Freq为1，于是放在DocDelta的最后一位表示，DocIDDelta = 7的二进制是000 0111，必须要左移一位，且最后一位置一，000 1111 = 15，对于第二个Term，由于Freq大于一，于是放在DocDelta的最后一位置零，DocIDDelta = 4的二进制是0000 0100，必须要左移一位，且最后一位置零，0000 1000 = 8，然后后面跟随真正的Freq = 3。</p>
<p>于是得到序列：[DocDleta = 15][DocDelta = 8, Freq = 3]，也即序列，15，8，3。</p>
<p>如果omitTf=true，也即我们不在索引中存储一个文档中Term出现的次数，则只存DocID就可以了，因而不存在A+B?规则的应用。</p>
<p>[DocID = 7][DocID = 11]，然后应用规则2，Delta规则，于是得到序列[DocDelta = 7][DocDelta = 4 (11 - 7)]，也即序列，7，4.</p>
<ul>
<li>对于跳跃表的存储有以下几点需要解释一下：
<ul>
<li>跳跃表可根据倒排表本身的长度(DocFreq)和跳跃的幅度(SkipInterval)而分不同的层次，层次数为NumSkipLevels = Min(MaxSkipLevels, floor(log(DocFreq/log(SkipInterval)))).</li>
<li>第Level层的节点数为DocFreq/(SkipInterval^(Level + 1))，level从零计数。</li>
<li>除了最低层之外，其他层都有SkipLevelLength来表示此层的二进制长度(而非节点的个数)，方便读取某一层的跳跃表到缓存里面。</li>
<li>高层在前，低层在后，当读完所有的高层后，剩下的就是最低一层，因而最后一层不需要SkipLevelLength。这也是为什么Lucene文档中的格式描述为 <!-- raw HTML omitted -->NumSkipLevels-1<!-- raw HTML omitted -->, SkipLevel，也即低NumSKipLevels-1层有SkipLevelLength，最后一层只有SkipLevel，没有SkipLevelLength。</li>
<li>除最低层以外，其他层都有SkipChildLevelPointer来指向下一层相应的节点。</li>
<li>每一个跳跃节点包含以下信息：文档号，payload的长度，文档号对应的倒排表中的节点在frq中的偏移量，文档号对应的倒排表中的节点在prx中的偏移量。</li>
<li>虽然Lucene的文档中有以下的描述，然而实验的结果却不是完全准确的：</li>
</ul>
</li>
</ul>
<p>Example: SkipInterval = 4, MaxSkipLevels = 2, DocFreq = 35. Then skip level 0 has 8 SkipData entries, containing the 3<!-- raw HTML omitted -->rd<!-- raw HTML omitted -->, 7<!-- raw HTML omitted -->th<!-- raw HTML omitted -->, 11<!-- raw HTML omitted -->th<!-- raw HTML omitted -->, 15<!-- raw HTML omitted -->th<!-- raw HTML omitted -->, 19<!-- raw HTML omitted -->th<!-- raw HTML omitted -->, 23<!-- raw HTML omitted -->rd<!-- raw HTML omitted -->, 27<!-- raw HTML omitted -->th<!-- raw HTML omitted -->, and 31<!-- raw HTML omitted -->st<!-- raw HTML omitted --> document numbers in TermFreqs. Skip level 1 has 2 SkipData entries, containing the 15<!-- raw HTML omitted -->th<!-- raw HTML omitted --> and 31<!-- raw HTML omitted -->st<!-- raw HTML omitted --> document numbers in TermFreqs.</p>
<p>按照描述，当SkipInterval为4，且有35篇文档的时候，Skip level = 0应该包括第3，第7，第11，第15，第19，第23，第27，第31篇文档，Skip level = 1应该包括第15，第31篇文档。</p>
<p>然而真正的实现中，跳跃表节点的时候，却向前偏移了，偏移的原因在于下面的代码：</p>
<ul>
<li>FormatPostingsDocsWriter.addDoc(int docID, int termDocFreq)
<ul>
<li>final int delta = docID - lastDocID;</li>
<li>if ((++df % skipInterval) == 0)
<ul>
<li>skipListWriter.setSkipData(lastDocID, storePayloads, posWriter.lastPayloadLength);</li>
<li>skipListWriter.bufferSkip(df);</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从代码中，我们可以看出，当SkipInterval为4的时候，当docID = 0时，++df为1，1%4不为0，不是跳跃节点，当docID = 3时，++df=4，4%4为0，为跳跃节点，然而skipData里面保存的却是lastDocID为2。</p>
<p>所以真正的倒排表和跳跃表中保存一下的信息：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022137901.png"
	
	
	
	loading="lazy"
	
	
></p>
<h4 id="423-词位置prx信息"><strong>4.2.3. 词位置(prx)信息</strong></h4>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022138998.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>词位置信息也是倒排表，也是以跳跃表形式存在的。</p>
<ul>
<li>此文件包含TermCount个项，每一个词都有一项，因为每一个词都有自己的词位置倒排表。</li>
<li>对于每一个词的都有一个DocFreq大小的数组，每项代表一篇文档，记录此文档中此词出现的位置。这个文档数组也是和frq文件中的跳跃表有关系的，从上面我们知道，在frq的跳跃表节点中有ProxSkip，当SkipInterval为3的时候，frq的跳跃表节点指向prx文件中的此数组中的第1，第4，第7，第10，第13，第16篇文档。</li>
<li>对于每一篇文档，可能包含一个词多次，因而有一个Freq大小的数组，每一项代表此词在此文档中出现一次，则有一个位置信息。</li>
<li>每一个位置信息包含：PositionDelta(采用差值规则)，还可以保存payload，应用或然跟随规则。</li>
</ul>
<h3 id="43-其他信息"><strong>4.3. 其他信息</strong></h3>
<h4 id="431-标准化因子文件nrm"><strong>4.3.1. 标准化因子文件(nrm)</strong></h4>
<p>为什么会有标准化因子呢？从第一章中的描述，我们知道，在搜索过程中，搜索出的文档要按与查询语句的相关性排序，相关性大的打分(score)高，从而排在前面。相关性打分(score)使用向量空间模型(Vector Space Model)，在计算相关性之前，要计算Term Weight，也即某Term相对于某Document的重要性。在计算Term Weight时，主要有两个影响因素，一个是此Term在此文档中出现的次数，一个是此Term的普通程度。显然此Term在此文档中出现的次数越多，此Term在此文档中越重要。</p>
<p>这种Term Weight的计算方法是最普通的，然而存在以下几个问题：</p>
<ul>
<li>不同的文档重要性不同。有的文档重要些，有的文档相对不重要，比如对于做软件的，在索引书籍的时候，我想让计算机方面的书更容易搜到，而文学方面的书籍搜索时排名靠后。</li>
<li>不同的域重要性不同。有的域重要一些，如关键字，如标题，有的域不重要一些，如附件等。同样一个词(Term)，出现在关键字中应该比出现在附件中打分要高。</li>
<li>根据词(Term)在文档中出现的绝对次数来决定此词对文档的重要性，有不合理的地方。比如长的文档词在文档中出现的次数相对较多，这样短的文档比较吃亏。比如一个词在一本砖头书中出现了10次，在另外一篇不足100字的文章中出现了9次，就说明砖头书应该排在前面码？不应该，显然此词在不足100字的文章中能出现9次，可见其对此文章的重要性。</li>
</ul>
<p>由于以上原因，Lucene在计算Term Weight时，都会乘上一个标准化因子(Normalization Factor)，来减少上面三个问题的影响。</p>
<p>标准化因子(Normalization Factor)是会影响随后打分(score)的计算的，Lucene的打分计算一部分发生在索引过程中，一般是与查询语句无关的参数如标准化因子，大部分发生在搜索过程中，会在搜索过程的代码分析中详述。</p>
<p>标准化因子(Normalization Factor)在索引过程总的计算如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139227.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>它包括三个参数：</p>
<ul>
<li>Document boost：此值越大，说明此文档越重要。</li>
<li>Field boost：此域越大，说明此域越重要。</li>
<li>lengthNorm(field) = (1.0 / Math.sqrt(numTerms))：一个域中包含的Term总数越多，也即文档越长，此值越小，文档越短，此值越大。</li>
</ul>
<p>从上面的公式，我们知道，一个词(Term)出现在不同的文档或不同的域中，标准化因子不同。比如有两个文档，每个文档有两个域，如果不考虑文档长度，就有四种排列组合，在重要文档的重要域中，在重要文档的非重要域中，在非重要文档的重要域中，在非重要文档的非重要域中，四种组合，每种有不同的标准化因子。</p>
<p>于是在Lucene中，标准化因子共保存了(文档数目乘以域数目)个，格式如下：</p>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139297.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>标准化因子文件(Normalization Factor File: nrm)：
<ul>
<li>NormsHeader：字符串“NRM”外加Version，依Lucene的版本的不同而不同。</li>
<li>接着是一个数组，大小为NumFields，每个Field一项，每一项为一个Norms。</li>
<li>Norms也是一个数组，大小为SegSize，即此段中文档的数量，每一项为一个Byte，表示一个浮点数，其中0~2为尾数，3~8为指数。</li>
</ul>
</li>
</ul>
<h4 id="432-删除文档文件del"><strong>4.3.2. 删除文档文件(del)</strong></h4>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139282.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>被删除文档文件(Deleted Document File: .del)
<ul>
<li>Format：在此文件中，Bits和DGaps只能保存其中之一，-1表示保存DGaps，非负值表示保存Bits。</li>
<li>ByteCount：此段中有多少文档，就有多少个bit被保存，但是以byte形式计数，也即Bits的大小应该是byte的倍数。</li>
<li>BitCount：Bits中有多少位被至1，表示此文档已经被删除。</li>
<li>Bits：一个数组的byte，大小为ByteCount，应用时被认为是byte*8个bit。</li>
<li>DGaps：如果删除的文档数量很小，则Bits大部分位为0，很浪费空间。DGaps采用以下的方式来保存稀疏数组：比如第十，十二，三十二个文档被删除，于是第十，十二，三十二位设为1，DGaps也是以byte为单位的，仅保存不为0的byte，如第1个byte，第4个byte，第1个byte十进制为20，第4个byte十进制为1。于是保存成DGaps，第1个byte，位置1用不定长正整数保存，值为20用二进制保存，第2个byte，位置4用不定长正整数保存，用差值为3，值为1用二进制保存，二进制数据不用差值表示。</li>
</ul>
</li>
</ul>
<h2 id="五总体结构"><strong>五、总体结构</strong></h2>
<p><img src="https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202403022139069.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li>图示为Lucene索引文件的整体结构：
<ul>
<li>属于整个索引(Index)的segment.gen，segment_N，其保存的是段(segment)的元数据信息，然后分多个segment保存数据信息，同一个segment有相同的前缀文件名。</li>
<li>对于每一个段，包含域信息，词信息，以及其他信息(标准化因子，删除文档)</li>
<li>域信息也包括域的元数据信息，在fnm中，域的数据信息，在fdx，fdt中。</li>
<li>词信息是反向信息，包括词典(tis, tii)，文档号及词频倒排表(frq)，词位置倒排表(prx)。</li>
</ul>
</li>
</ul>
<p>大家可以通过看源代码，相应的Reader和Writer来了解文件结构，将更为透彻。</p>
<p>参考资料</p>
<ul>
<li><a class="link" href="https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html"  target="_blank" rel="noopener"
    >https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html</a></li>
<li><a class="link" href="https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html"  target="_blank" rel="noopener"
    >https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html</a></li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/1c70c347/">
        
        

        <div class="article-details">
            <h2 class="article-title">Lucene 二: Lucene 的总体架构</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/5e159a30/">
        
        

        <div class="article-details">
            <h2 class="article-title">Lucene 一: 全文检索的基本原理</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/f8737bfa/">
        
        

        <div class="article-details">
            <h2 class="article-title">【译】Lucene 查询语法</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/6ddc4d41/">
        
        

        <div class="article-details">
            <h2 class="article-title">Lucene 概述</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="lxbwolf/lxbwolf.github.io"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 Xiaobin&#39;s Notes
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
