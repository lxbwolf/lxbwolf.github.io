<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Lang on Xiaobin&#39;s Notes</title>
        <link>https://lxb.wiki/categories/Lang/</link>
        <description>Recent content in Lang on Xiaobin&#39;s Notes</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 24 Feb 2023 22:31:55 +0800</lastBuildDate><atom:link href="https://lxb.wiki/categories/Lang/atom.xml" rel="self" type="application/rss+xml" /><item>
        <title>编译原理一</title>
        <link>https://lxb.wiki/a66c6839/</link>
        <pubDate>Fri, 24 Feb 2023 22:31:55 +0800</pubDate>
        
        <guid>https://lxb.wiki/a66c6839/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;什么是编译原理&#34;&gt;什么是编译原理&lt;/h2&gt;
&lt;p&gt;编译原理是介绍如何将高级程序设计语言转换成计算机硬件能识别的机器语言，以便计算机进行处理&lt;/p&gt;
&lt;h2 id=&#34;编译与计算机程序设计语言的关系&#34;&gt;编译与计算机程序设计语言的关系&lt;/h2&gt;
&lt;p&gt;日常开发过程中我们使用的语言一般都是高级语法比如 JAVA、Python、PHP、JavaScript等等，但是计算机只能识别0、1这样的机器码。那么这些高级语言是如何翻译成机器能识别的0、1等呢？这就用的了&lt;strong&gt;编译&lt;/strong&gt;，首先我们通过下面这幅图看下编译与计算机程序语言的关系，有助于我们直观的了解编译的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242238073.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;注意：每种机器都对应一种汇编语言&lt;/p&gt;
&lt;h3 id=&#34;程序设计语言的转换方式&#34;&gt;程序设计语言的转换方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;翻译&lt;/strong&gt;：指把某种语言的源程序，&lt;strong&gt;在不改变语义的条件下&lt;/strong&gt;，转换成另一种语言程序即目标语言程序&lt;/p&gt;
&lt;p&gt;真正的实现有两种方式，编译及解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编译&lt;/strong&gt;：专指由高级语言转换为低级语言，&lt;strong&gt;整个程序翻译&lt;/strong&gt;。常用的例如： c、c++，delphi,Fortran、Pascal、Ada&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解释&lt;/strong&gt;：接受某种高级语言的一个语句输入，进行解释并控制计算机执行，马上得到这个句子的执行结果，然后再接受下一个语句。类似口译，&lt;strong&gt;一句一句进行解释&lt;/strong&gt;。常用的例如：python 解释以源程序作为输入，&lt;strong&gt;不产生目标程序&lt;/strong&gt;，一边解释一边执行。&lt;strong&gt;优点&lt;/strong&gt;：直观易懂，结构简单，易于实现人机对话。&lt;strong&gt;缺点&lt;/strong&gt;：效率低(不产生目标程序，每次都需要重新执行，速度慢)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译的转换过程&#34;&gt;编译的转换过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编译-&amp;gt;运行&lt;/li&gt;
&lt;li&gt;编译-&amp;gt;汇编-&amp;gt;运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242240217.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;编译器在语言处理系统中的位置&#34;&gt;编译器在语言处理系统中的位置&lt;/h2&gt;
&lt;p&gt;了解了编译与程序设计语言的关系，那么我们接下来再来看下编译器在语言处理系统中所处位置，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242243681.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;编译系统的结构&#34;&gt;编译系统的结构&lt;/h2&gt;
&lt;p&gt;那么机器是如何把高级语言翻译为汇编语言程序或机器语言程序的呢？&lt;/p&gt;
&lt;p&gt;我们先来看下人工进行英文翻译的例子，这里引用的哈工大编译原理中的图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242245950.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;图中的&lt;strong&gt;中间表示很重要主要起到了一个桥梁的作用&lt;/strong&gt;，比如图中的中间表示可以使用各种语言表示。&lt;/p&gt;
&lt;p&gt;根据上图可以看出要进行语义分析首先需要划分句子成分，那么我们是如何划分句子成分的呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先通过&lt;strong&gt;词法分析分析出句子中各个单词的词性或者词类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接下来通过&lt;strong&gt;语法分析识别出句子中的各类短语从而获得句子的结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后进行&lt;strong&gt;语义分析根据句子结构分析出句子中各个短语在句子中充当什么成分&lt;/strong&gt;，从而确定各个名词性成分同各个核心谓语动词间的关系语意关系&lt;/li&gt;
&lt;li&gt;最后给出中间表示形式  &lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242246694.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;  &lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242250835.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; 实际上编译器在工作的时候也是经过了以上几个步骤，我们成为&lt;strong&gt;阶段(计算机的逻辑组织方式，在实现过程中多个阶段可能会被组合在一起实现)&lt;/strong&gt;，可以分为两大部分：&lt;strong&gt;分析源语言、生成目标代码&lt;/strong&gt;,在编译器中他们分别对应编译器的前端和后端两个部分。编译器的结构如下图   &lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242248147.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; 了解了编译器的结构，让我们从编译器的前端开始讲起，看看词法分析、语法分析、语义分析等各个阶段都做了什么。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;词法分析扫描&#34;&gt;词法分析(扫描)&lt;/h3&gt;
&lt;p&gt;编译的第一个阶段，从左到右逐行扫描源程序的字符，识别出各个&lt;strong&gt;单词&lt;/strong&gt;(是高级语言中有是在意义的最小语法单元，由字符构成)，&lt;strong&gt;确定单词的类型&lt;/strong&gt;。将识别的单词转换成统一的机内表示即&lt;strong&gt;词法单元 简称Token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;token:&amp;lt;种别码，属性值&amp;gt;token: &amp;lt;种别码，属性值&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;单词类型&lt;/th&gt;
&lt;th&gt;种别&lt;/th&gt;
&lt;th&gt;种别码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;关键字&lt;/td&gt;
&lt;td&gt;program、if、else、then&amp;hellip;&lt;/td&gt;
&lt;td&gt;一词一码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;标识符&lt;/td&gt;
&lt;td&gt;变量名、数组名、记录名、过程名&amp;hellip;&lt;/td&gt;
&lt;td&gt;多词一码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;常量&lt;/td&gt;
&lt;td&gt;整型、浮点型、字符型、布尔型&amp;hellip;&lt;/td&gt;
&lt;td&gt;一型一码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;运算符&lt;/td&gt;
&lt;td&gt;算术（+ - * / ++ &amp;ndash;）&lt;!-- raw HTML omitted --&gt;关系（&amp;gt; &amp;lt; == != &amp;gt;= &amp;lt;=） &lt;!-- raw HTML omitted --&gt;逻辑（&amp;amp; | ~）&lt;/td&gt;
&lt;td&gt;一词一码&lt;!-- raw HTML omitted --&gt;或&lt;!-- raw HTML omitted --&gt;一型一码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;界限符&lt;/td&gt;
&lt;td&gt;; ( ) = { }&lt;/td&gt;
&lt;td&gt;一词一码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;名字解释&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一词一码&lt;/strong&gt;：例如，关键字是唯一的且事先可以确定，为每个关键字分配一个种别码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多词一码&lt;/strong&gt;：例如，所有的标示符统一作为一类单词分配同一个种别码，为了区分不同的标示符，用token的第二个分量“属性值”存放不同标示符具体的字面值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一型一码&lt;/strong&gt;：不同类型的常量他们的构成方式是不同的，例如，我们为每种类型的常量分配一个种别码，为了区分同一类型下的不同常量，也用token的第二个分量“属性值”存放每个常量具体的值 下面图中是一个词法分析后得到的token序列的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242300575.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;描述词法规则的有效工具是&lt;strong&gt;正规式&lt;/strong&gt;和&lt;strong&gt;有限自动机&lt;/strong&gt;。&lt;strong&gt;正规式&lt;/strong&gt;:用来确定单词是否和程序语言规范。&lt;strong&gt;有限自动机&lt;/strong&gt;：通过有限自动机进行单词和正规式比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语法分析parsing&#34;&gt;语法分析(parsing)&lt;/h3&gt;
&lt;h4 id=&#34;语法分析的定义&#34;&gt;语法分析的定义&lt;/h4&gt;
&lt;p&gt;语法分析器从词法分析器输出的&lt;strong&gt;token序列中识别出各类短语，并构造语法分析树&lt;/strong&gt;(parse tree),语法分析树描述了&lt;strong&gt;句子的语法结构&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;语法分析的规则&#34;&gt;语法分析的规则&lt;/h4&gt;
&lt;p&gt;即&lt;strong&gt;语法规则&lt;/strong&gt;又称&lt;strong&gt;文法&lt;/strong&gt;，规定了单词如何构成短语、句子、过程和程序。&lt;/p&gt;
&lt;p&gt;语法规则的标示如下，含义是A定义为B或者C&lt;/p&gt;
&lt;p&gt;BNF:A::=B∣CBNF:A::=B|C&lt;/p&gt;
&lt;p&gt;&amp;lt;句子&amp;gt;::=&amp;lt;主&amp;gt;&amp;lt;谓&amp;gt;&amp;lt;宾&amp;gt;&amp;lt;句子&amp;gt;::=&amp;lt;主&amp;gt;&amp;lt;谓&amp;gt;&amp;lt;宾&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;主&amp;gt;::=&amp;lt;定&amp;gt;&amp;lt;名&amp;gt;&amp;lt;主&amp;gt;::=&amp;lt;定&amp;gt;&amp;lt;名&amp;gt;&lt;/p&gt;
&lt;p&gt;来看下赋值语句的语法规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A::=V=E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E::=T|E+T&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T::=F|T*F&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F::=V|(E)|C&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V::=标示符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C::=常数&lt;/strong&gt; &lt;strong&gt;即由标示符或者常数的表达式进行加减乘除运算&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;语法分析的方法&#34;&gt;语法分析的方法&lt;/h4&gt;
&lt;p&gt;推导(derive)和归约(reduce)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推导&lt;/strong&gt;：最左推导、最右推导&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;归约&lt;/strong&gt;：最右归约、最左归约,推导的逆过程就是归约&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最右推导、最左归约：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242302837.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;最左推导、最右归约：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242303370.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;语法树&#34;&gt;语法树&lt;/h4&gt;
&lt;p&gt;计算机通过&lt;strong&gt;语法树&lt;/strong&gt;来进行分析，即语法分析过程也可以用一颗倒着的树来标示，这颗树叫&lt;strong&gt;语法树&lt;/strong&gt;。正确的语法树叶子节点数必须是表达式的符号，例如&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242303395.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;赋值语句的分析树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242304331.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;变量声明语句的分析树：&lt;/p&gt;
&lt;p&gt;首先看下变量声明语句的文法(&lt;strong&gt;文法是由一系列规则构成的&lt;/strong&gt;)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;D&amp;gt; -&amp;gt; &amp;lt;T&amp;gt; &amp;lt;IDS&amp;gt;;
&amp;lt;T&amp;gt; -&amp;gt; int | real | char | bool
&amp;lt;IDS&amp;gt; -&amp;gt; id | &amp;lt;IDS&amp;gt;, id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242305150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;语义分析&#34;&gt;语义分析&lt;/h3&gt;
&lt;p&gt;语义的任务主要有两个&lt;/p&gt;
&lt;h4 id=&#34;一-收集标识符的属性信息&#34;&gt;一. 收集标识符的属性信息&lt;/h4&gt;
&lt;h4 id=&#34;二-语义检查&#34;&gt;二. 语义检查&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;变量或过程&lt;strong&gt;未经声明就使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;变量或过程名&lt;strong&gt;重复声明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;运算分量&lt;strong&gt;类型不匹配&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作符与操作数之间的类型不匹配&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组下标&lt;/strong&gt;不是整数&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;非数组变量&lt;/strong&gt;使用数组访问操作符&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;非过程名&lt;/strong&gt;使用过程调用操作符&lt;/li&gt;
&lt;li&gt;过程调用的**参数类型或数目不匹配 **&lt;/li&gt;
&lt;li&gt;函数&lt;strong&gt;返回类型&lt;/strong&gt;有误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中间代码生成&#34;&gt;中间代码生成&lt;/h3&gt;
&lt;p&gt;通常和语义分析一起实现。对语法分析识别出的各类语法范畴，分析他的含义，进行初步翻译，产生介于源代码和目标代码质检的一种代码&lt;/p&gt;
&lt;h4 id=&#34;常用的中间代码表示形式&#34;&gt;常用的中间代码表示形式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;三地址码&lt;/strong&gt; (Three-address Code)：三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法结构树/语法树&lt;/strong&gt; (Syntax Trees)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逆波兰式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;三地址指令的表示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;四元式&lt;/strong&gt; (Quadruples)，(op, y, z, x)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;三元式&lt;/strong&gt; (Triples)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;间接三元式&lt;/strong&gt;(Indirect triples)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242305150.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;下面图中展示了一个中间代码生成的例子 &lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242308231.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码优化&#34;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;对前面生成的中间代码进行加工变换，以便在最后极端产生更为高效的目标代码 ，&lt;strong&gt;需要遵循等价变换的原则&lt;/strong&gt;，优化的方面包括：公共子表达式的提取、合并已知量、删除无用语句、循环优化。&lt;/p&gt;
&lt;h3 id=&#34;目标代码生成&#34;&gt;目标代码生成&lt;/h3&gt;
&lt;p&gt;把经过优化的中间代码转化成特定机器上的低级语言&lt;/p&gt;
&lt;p&gt;目标代码的形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;绝对指令代码：可立即执行的目标代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;汇编指令代码：汇编语言程序，需要经过汇编陈旭汇编后才能运行&lt;/li&gt;
&lt;li&gt;可重定位指令代码：先将各目标模块连接起来，确定变量、常数在主存中的位置，装入主存后才能成为可以运行的绝对指令代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;h4 id=&#34;出错处理&#34;&gt;出错处理&lt;/h4&gt;
&lt;p&gt;如果源程序有错误，编译程序应设法发现错误并报告给用户。由专门的出错处理程序来完成。 错误类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法错误：在词法分析和语法分析阶段检测出来&lt;/li&gt;
&lt;li&gt;语义错误：一般在语义分析阶段检测&lt;/li&gt;
&lt;li&gt;逻辑错误：不可检测，比如死循环，一般不处理因为没办法在编译阶段检测出来&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;遍&#34;&gt;遍&lt;/h4&gt;
&lt;p&gt;指对源程序或源程序的中间结果从头到尾扫描一次，并做有关的加工处理，生成新的中间结果或目标代码。&lt;strong&gt;遍与阶段的含义毫无关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多遍扫描： &lt;strong&gt;优点&lt;/strong&gt;：节省内存空间，提高目标代码的质量，使编译的逻辑结构清晰。&lt;strong&gt;缺点&lt;/strong&gt;：编译时间长。在内存许可的情况下还是遍数尽可能少较好 &lt;img src=&#34;https://raw.githubusercontent.com/lxbwolf/blog_source_image/main/202310242309680.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;编译程序生成&#34;&gt;编译程序生成&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;直接用机器语言编写编译程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用汇编语言编写编译程序&lt;/strong&gt;，编译程序核心部分常用汇编语言编写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用高级语言编写编译程序&lt;/strong&gt;，这也是普遍采用的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自编译&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译工具&lt;/strong&gt; LEX（语法分析）与YACC(用于自动生成LALR分析表)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移植&lt;/strong&gt;(同种语言的编译程序在不同类型的机器之 间移植) 在某机器上为某种语言构造编译程序要掌握以下三方面:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;源语言&lt;/li&gt;
&lt;li&gt;目标语言&lt;/li&gt;
&lt;li&gt;编译方法&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Go 1.18 的工作区模式</title>
        <link>https://lxb.wiki/a51740e5/</link>
        <pubDate>Sat, 10 Dec 2022 22:04:58 +0800</pubDate>
        
        <guid>https://lxb.wiki/a51740e5/</guid>
        <description>&lt;p&gt;当一个项目越来越复杂的时候，一定会拆分为多个模块，以便进行代码复用和更好的多人协作开发。&lt;/p&gt;
&lt;p&gt;假设我们已经有了两个模块 &lt;code&gt;xxx.org/util&lt;/code&gt; 和 &lt;code&gt;xxx.org/product&lt;/code&gt; ，模块&lt;code&gt;xxx.org/product&lt;/code&gt;依赖 &lt;code&gt;xxx.org/util&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;现在有一个需求，需要同时修改这两个模块，以便让&lt;code&gt;xxx.org/util&lt;/code&gt;新增的方法给模块&lt;code&gt;xxx.org/product&lt;/code&gt;使用。&lt;/p&gt;
&lt;p&gt;但是当同事A在模块&lt;code&gt;xxx.org/util&lt;/code&gt;中增加新的方法后，要么推送到VCS中，让负责模块&lt;code&gt;xxx.org/product&lt;/code&gt;的同事B使用，这是发布的场景。&lt;/p&gt;
&lt;p&gt;如果模块&lt;code&gt;xxx.org/util&lt;/code&gt;没有发布呢？那么就只能通过go.mod中的replace指令进行替换，把对模块&lt;code&gt;xxx.org/util&lt;/code&gt;的引用，换成本地的未发布的版本，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;replace&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;org&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Users&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;demo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相信我们都遇到过以上两种情形，这两种情形都有相应的弊端，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把没有调试、没有测试的代码发布了，会影响其他正常构建&lt;/li&gt;
&lt;li&gt;replace的时候，忘记改回来，提交到VCS中了，影响了其他人使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决以上问题，Go 团队提出了工作区的概念，并且在Go 1.18 中发布。&lt;/p&gt;
&lt;p&gt;Go 工作区，是你的工作区，它和多人协作、VCS等无关。说白了它就是个本地目录，通过go.work文件来管理多个go.mod模块。&lt;/p&gt;
&lt;p&gt;要创建一个Go 工作区非常简单，通过如下命令即可:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mkdir&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;workspace&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;workspace&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;work&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Users&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;demo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Users&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;demo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;product&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在以上示例中，workspace是我创建的一个工作区,可以在你的电脑的任何地方,名字也可以自取。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;go work init&lt;/code&gt; 后是两个go.mod的绝对路径，用空格分开，当然你也可以用相对路径。&lt;/p&gt;
&lt;p&gt;运行以上代码后,就会在workspace目录下生成一个go.work文件，它的内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.18&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;use&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Users&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;demo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;product&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Users&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;demo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;use&lt;/code&gt;是&lt;code&gt;go.work&lt;/code&gt;文件的一个指令，用于管理包含的go.mod模块。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;use&lt;/code&gt;指令，go.work还有&lt;code&gt;replace&lt;/code&gt;指令，它和go.mod的replace很像，它用于把Go 工作区间管理的go.mod全部替换为指定的路径，并且它的优先级要比go.mod的replace要高。&lt;/p&gt;
&lt;p&gt;现在，我们用到的这两个模块都在同一个工作区了，那么就不需要再修改模块xxx/product的go.mod replace 指令完成本地的依赖了。&lt;/p&gt;
&lt;p&gt;这时候，在工作区 workspce目录下，运行如下命令，即可进行验证。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;➜&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;workspace&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;org&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;product&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;你好&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为都在一个工作区，go可以帮你找到模块xxx.org/product所依赖的xxx.org/util模块。&lt;/p&gt;
&lt;p&gt;如果你只是切换到product目录下运行以上命令，只会提示你：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;➜&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;product&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;required&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;provides&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;org&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xxx&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;org&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不止我上面这种依赖上游模块的例子可以使用Go工作区，如果你一个代码库中有多个模块也是可以用的，只需要把他们都加入到Go 工作区即可。&lt;/p&gt;
&lt;p&gt;go work命令有一个use可以把本地目录的模块加入工作区，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;work&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;use&lt;/span&gt; [&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;your&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;module&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方括号中的路径，可以换成你自己电脑上的本地模块路径。&lt;/p&gt;
&lt;p&gt;当然你也可以直接修改go.work文件，效果是一样的,这里不再举例，你可以自己试试。&lt;/p&gt;
&lt;p&gt;go.work本质上是一种本地化的解决办法，因为go.mod都是放在VCS中的，和项目息息相关，所以我们很少去修改它来达到一些Hack的操作。&lt;/p&gt;
&lt;p&gt;现在有了go.work就好办多了，因为它就是一个本地的东西，不在VCS中，想怎么改就怎么改，又不&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言中用exec执行命令的五种姿势</title>
        <link>https://lxb.wiki/a9bb05dc/</link>
        <pubDate>Sun, 04 Dec 2022 21:16:01 +0800</pubDate>
        
        <guid>https://lxb.wiki/a9bb05dc/</guid>
        <description>&lt;p&gt;在 Golang 中用于执行命令的库是 &lt;code&gt;os/exec&lt;/code&gt;，exec.Command 函数返回一个 &lt;code&gt;Cmd&lt;/code&gt; 对象，根据不同的需求，可以将命令的执行分为三种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只执行命令，不获取结果&lt;/li&gt;
&lt;li&gt;执行命令，并获取结果（不区分 stdout 和 stderr）&lt;/li&gt;
&lt;li&gt;执行命令，并获取结果（区分 stdout 和 stderr）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第一种只执行命令不获取结果httpswwwcnblogscomwongbingmingp13984538htmlidx_0&#34;&gt;第一种：只执行命令，不获取结果&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wongbingming/p/13984538.html#idx_0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;直接调用 Cmd 对象的 Run 函数，返回的只有成功和失败，获取不到任何输出的结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmd.Run() failed with %s\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;第二种执行命令并获取结果httpswwwcnblogscomwongbingmingp13984538htmlidx_1&#34;&gt;第二种：执行命令，并获取结果&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wongbingming/p/13984538.html#idx_1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有时候我们执行一个命令就是想要获取输出结果，此时你可以调用 Cmd 的 CombinedOutput 函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CombinedOutput&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;combined out:\n%s\n&amp;#34;&lt;/span&gt;, string(&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmd.Run() failed with %s\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;combined out:\n%s\n&amp;#34;&lt;/span&gt;, string(&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CombinedOutput 函数，只返回 out，并不区分 stdout 和 stderr。如果你想区分他们，可以直接看第三种方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go run demo.go 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;combined out:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total &lt;span style=&#34;color:#ae81ff&#34;&gt;11540876&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r--  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; root       root         &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; Oct &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2018&lt;/span&gt; yum.log
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;drwx------  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; root       root           &lt;span style=&#34;color:#ae81ff&#34;&gt;94&lt;/span&gt; Nov  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; 05:56 audit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r--  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root       root    &lt;span style=&#34;color:#ae81ff&#34;&gt;185249234&lt;/span&gt; Nov &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; message
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r--  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; root       root        &lt;span style=&#34;color:#ae81ff&#34;&gt;16374&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt; 10:13 boot.log
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过在那之前，我却发现一个小问题：有时候，shell 命令能执行，并不代表代码 exec 也能执行。&lt;/p&gt;
&lt;p&gt;比如我只想查看 &lt;code&gt;/var/log/&lt;/code&gt; 目录下的 log 后缀名的文件呢？shell命令如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -l /var/log/*.log
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total &lt;span style=&#34;color:#ae81ff&#34;&gt;11540&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r--  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; root       root         &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; Oct &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2018&lt;/span&gt; /var/log/yum.log
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r--  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; root       root        &lt;span style=&#34;color:#ae81ff&#34;&gt;16374&lt;/span&gt; Aug &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt; 10:13 /var/log/boot.log
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;按照这个写法将它放入到 &lt;code&gt;exec.Command&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/*.log&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CombinedOutput&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;combined out:\n%s\n&amp;#34;&lt;/span&gt;, string(&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmd.Run() failed with %s\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;combined out:\n%s\n&amp;#34;&lt;/span&gt;, string(&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;什么情况？居然不行，报错了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go run demo.go 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;combined out:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls: cannot access /var/log/*.log: No such file or directory
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2020/11/11 19:46:00 cmd.Run&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; failed with exit status &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exit status &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么会报错呢？&lt;/p&gt;
&lt;p&gt;其实很简单，原来 &lt;code&gt;ls -l /var/log/*.log&lt;/code&gt; 并不等价于下面这段代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exec.Command&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/*.log&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码对应的 Shell 命令应该是下面这样，如果你这样子写，ls 就会把参数里的内容当成具体的文件名，而忽略通配符 &lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -l &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/*.log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls: cannot access /var/log/*.log: No such file or directory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;第三种执行命令并区分stdout-和-stderrhttpswwwcnblogscomwongbingmingp13984538htmlidx_2&#34;&gt;第三种：执行命令，并区分stdout 和 stderr&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wongbingming/p/13984538.html#idx_2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面的写法，无法实现区分标准输出和标准错误，只要换成下面种写法，就可以实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bytes&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/*.log&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stdout&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;stderr&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stdout&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stdout&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 标准输出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stderr&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stderr&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 标准错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;outStr&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;errStr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; string(&lt;span style=&#34;color:#a6e22e&#34;&gt;stdout&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Bytes&lt;/span&gt;()), string(&lt;span style=&#34;color:#a6e22e&#34;&gt;stderr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Bytes&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;out:\n%s\nerr:\n%s\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;outStr&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;errStr&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmd.Run() failed with %s\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出如下，可以看到前面的报错内容被归入到标准错误里&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go run demo.go 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;out:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;err:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls: cannot access /var/log/*.log: No such file or directory
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2020/11/11 19:59:31 cmd.Run&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; failed with exit status &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exit status &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;第四种多条命令组合请使用管道httpswwwcnblogscomwongbingmingp13984538htmlidx_3&#34;&gt;第四种：多条命令组合，请使用管道&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wongbingming/p/13984538.html#idx_3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将上一条命令的执行输出结果，做为下一条命令的参数。在 Shell 中可以使用管道符 &lt;code&gt;|&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;比如下面这条命令，统计了 message 日志中 ERROR 日志的数量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ grep ERROR /var/log/messages | wc -l
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;类似的，在 Golang 中也有类似的实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CopyCopypackage&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;grep&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ERROR&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/log/messages&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wc&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stdin&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;c1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StdoutPipe&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stdout&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stdout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;c2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Start&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;c1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;c2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go run demo.go 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;第五种设置命令级别的环境变量httpswwwcnblogscomwongbingmingp13984538htmlidx_4&#34;&gt;第五种：设置命令级别的环境变量&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wongbingming/p/13984538.html#idx_4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使用 os 库的 Setenv 函数来设置的环境变量，是作用于整个进程的生命周期的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Setenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NAME&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;myname&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;echo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ExpandEnv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$NAME&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CombinedOutput&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmd.Run() failed with %s\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只要在这个进程里，&lt;code&gt;NAME&lt;/code&gt; 这个变量的值都会是 &lt;code&gt;myname&lt;/code&gt;，无论你执行多少次命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go run demo.go 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;myname
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果想把环境变量的作用范围再缩小到命令级别，也是有办法的。&lt;/p&gt;
&lt;p&gt;为了方便验证，我新建个 sh 脚本，内容如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat /home/myname/demo.sh
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo $NAME
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ bash /home/myname/demo.sh   &lt;span style=&#34;color:#75715e&#34;&gt;# 由于全局环境变量中没有 NAME，所以无输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，demo.go 里的代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os/exec&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ChangeYourCmdEnvironment&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Cmd&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;env&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Environ&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdEnv&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;env&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdEnv&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdEnv&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdEnv&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdEnv&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;NAME=myname&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Env&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;cmdEnv&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bash&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/home/myname/demo.sh&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;ChangeYourCmdEnvironment&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 添加环境变量到 cmd1 命令: NAME=myname
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CombinedOutput&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;output: %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;out1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exec&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bash&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/home/myname/demo.sh&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out2&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CombinedOutput&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;output: %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;out2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行后，可以看到第二次执行的命令，是没有输出 NAME 的变量值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go run demo.go 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;output: myname
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;output: 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Go 调用 GoogleSheets API 写入数据</title>
        <link>https://lxb.wiki/ee1035bf/</link>
        <pubDate>Wed, 02 Nov 2022 21:11:17 +0800</pubDate>
        
        <guid>https://lxb.wiki/ee1035bf/</guid>
        <description>&lt;h2 id=&#34;前置依赖&#34;&gt;前置依赖&lt;/h2&gt;
&lt;h3 id=&#34;1-创建-google-cloud-项目&#34;&gt;1 创建 Google Cloud 项目&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://console.cloud.google.com/projectcreate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://console.cloud.google.com/projectcreate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在项目页面上，确保启用了 Google Sheets API。你可以在“API 和服务”&amp;gt;“库”中搜索并启用该 API。&lt;/p&gt;
&lt;h3 id=&#34;2-创建服务账号密钥&#34;&gt;2 创建服务账号密钥：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 Google Cloud Console 的项目页面上，导航到“API 和服务”&amp;gt;“凭据”。&lt;/li&gt;
&lt;li&gt;点击“创建凭据”按钮，选择“服务账号密钥”。&lt;/li&gt;
&lt;li&gt;在“服务账号”部分，选择“新建服务账号”，并为其指定一个名称。&lt;/li&gt;
&lt;li&gt;在“角色”部分，选择“项目”&amp;gt;“编辑者”角色。&lt;/li&gt;
&lt;li&gt;选择“JSON”作为密钥类型，并点击“创建”按钮。这将下载一个 JSON 文件，其中包含你的服务账号密钥。&lt;/li&gt;
&lt;li&gt;Google Sheet 分享给服务账号，邀请其成为“编辑者”，被邀请人填入服务账号的邮箱&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;go-代码&#34;&gt;Go 代码&lt;/h2&gt;
&lt;p&gt;安装 Go 的 Google Sheets API 客户端库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go get -u google.golang.org/api/sheets/v4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;golang.org/x/oauth2/google&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;google.golang.org/api/sheets/v4&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 加载密钥文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ioutil&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadFile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;credential&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;无法读取密钥文件：%v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 从密钥文件创建一个配置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;google&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;JWTConfigFromJSON&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SpreadsheetsScope&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;无法创建配置：%v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 使用配置创建一个客户端
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Client&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Background&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 创建 Sheets 服务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;sheetsService&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;无法创建 Sheets 服务：%v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 指定要写入的 Spreadsheet ID 和 Sheet 名称
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;spreadsheetID&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MY_GG_SHEET_ID&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// sheetName := &amp;#34;test&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;sheetName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Now&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Format&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;010215&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 创建一个 SheetProperties 对象，指定新 Sheet 的名称
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;sheetProperties&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SheetProperties&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Title&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;sheetName&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 创建一个 AddSheetRequest 对象，将 SheetProperties 放入其中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;addSheetRequest&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;AddSheetRequest&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Properties&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;sheetProperties&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 创建一个 BatchUpdateSpreadsheetRequest 对象，将 AddSheetRequest 放入其中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;batchUpdateRequest&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BatchUpdateSpreadsheetRequest&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Requests&lt;/span&gt;: []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#a6e22e&#34;&gt;AddSheet&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;addSheetRequest&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 执行批量更新操作，创建新的 Sheet
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;batUpdResp&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sheetsService&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Spreadsheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BatchUpdate&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;spreadsheetID&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;batchUpdateRequest&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Do&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unable to create new sheet: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		panic(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;执行批量更新操作，创建新的 Sheet失败&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 打印新 Sheet 的 ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;newSheetID&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;batUpdResp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Replies&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;AddSheet&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Properties&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SheetId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Created new sheet with ID: %d\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;newSheetID&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 构建要写入的数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;values&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; [][]&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value 1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value 2&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value 3&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value 4&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value 5&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value 6&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 构建写入请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;writeRequest&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ValueRange&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;Values&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;values&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//// 执行写入请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//_, err = sheetsService.Spreadsheets.Values.Update(spreadsheetID, sheetName, writeRequest).ValueInputOption(&amp;#34;RAW&amp;#34;).Do()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//if err != nil {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//	log.Fatalf(&amp;#34;无法写入数据：%v&amp;#34;, err)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//fmt.Println(&amp;#34;数据已成功写入 Google Sheets！&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 执行追加操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;appendResp&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sheetsService&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Spreadsheets&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Values&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Append&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;spreadsheetID&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;sheetName&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;writeRequest&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;ValueInputOption&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;USER_ENTERED&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Do&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unable to append data: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 打印追加操作的结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Appended %d rows\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;appendResp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Updates&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;UpdatedRows&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developers.google.com/docs/api/reference/rest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developers.google.com/docs/api/reference/rest&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/googleworkspace/go-samples/tree/main/sheets/quickstart&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/googleworkspace/go-samples/tree/main/sheets/quickstart&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go命令行库cobra</title>
        <link>https://lxb.wiki/e80bf483/</link>
        <pubDate>Sat, 16 Jul 2022 22:23:51 +0800</pubDate>
        
        <guid>https://lxb.wiki/e80bf483/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;Cobra 是一个 Golang 包，它提供了简单的接口来创建命令行程序。同时，Cobra 也是一个应用程序，用来生成应用框架，从而开发以 Cobra 为基础的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202305062144121.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;主要功能&#34;&gt;主要功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;简易的子命令行模式，如 app server， app fetch 等等&lt;/li&gt;
&lt;li&gt;完全兼容 posix 命令行模式&lt;/li&gt;
&lt;li&gt;嵌套子命令 subcommand&lt;/li&gt;
&lt;li&gt;支持全局，局部，串联 flags&lt;/li&gt;
&lt;li&gt;使用 cobra 很容易的生成应用程序和命令，使用 cobra create appname 和 cobra add cmdname&lt;/li&gt;
&lt;li&gt;如果命令输入错误，将提供智能建议，如 app srver，将提示 srver 没有，是不是 app server&lt;/li&gt;
&lt;li&gt;自动生成 commands 和 flags 的帮助信息&lt;/li&gt;
&lt;li&gt;自动生成详细的 help 信息，如 app help&lt;/li&gt;
&lt;li&gt;自动识别帮助 flag -h，&amp;ndash;help&lt;/li&gt;
&lt;li&gt;自动生成应用程序在 bash 下命令自动完成功能&lt;/li&gt;
&lt;li&gt;自动生成应用程序的 man 手册&lt;/li&gt;
&lt;li&gt;命令行别名&lt;/li&gt;
&lt;li&gt;自定义 help 和 usage 信息&lt;/li&gt;
&lt;li&gt;可选的与 viper apps 的紧密集成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cobra-中的主要概念&#34;&gt;cobra 中的主要概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commands 行为&lt;/li&gt;
&lt;li&gt;args 命令行参数(或称为位置参数)&lt;/li&gt;
&lt;li&gt;flags 对行为的改变(即命令行选项)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行命令行程序时的一般格式为： &lt;code&gt;APPNAME COMMAND ARG --FLAG&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建-cobra-应用&#34;&gt;创建 cobra 应用&lt;/h2&gt;
&lt;p&gt;获取最新版本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go get -u github.com/spf13/cobra@latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装 cobra-cli&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;install&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;github&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;com&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;spf13&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cli&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;latest&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd /pathto/mysrc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ go mod init
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cobra-cli init
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行后，该目录下生成的结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;▾ demo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ▾ cmd/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        root.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main.go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;使用-cobra-程序生成命令代码&#34;&gt;使用 cobra 程序生成命令代码&lt;/h2&gt;
&lt;p&gt;除了生成应用程序框架，还可以生成子命令的代码文件。添加自命令 mysub1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd /pathto/mysrc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cobra-cli add mysub1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;为命令添加具体的功能&#34;&gt;为命令添加具体的功能&lt;/h2&gt;
&lt;p&gt;打开文件 &lt;code&gt;cmd/root.go&lt;/code&gt; ，找到变量 rootCmd 的初始化过程并为之设置 Run 方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cobra demo program&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建一个 version Command 用来输出当前的软件版本。先在 cmd 目录下添加 version.go 文件，编辑文件的内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/spf13/cobra&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;AddCommand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;versionCmd&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;versionCmd&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Use&lt;/span&gt;:   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Short&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Print the version number of cobrademo&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Long&lt;/span&gt;:  &lt;span style=&#34;color:#e6db74&#34;&gt;`All software has versions. This is cobrademo&amp;#39;s`&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cobrademo version is v1.0&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;为-command-添加选项flags&#34;&gt;为 Command 添加选项(flags)&lt;/h2&gt;
&lt;p&gt;选项(flags)用来控制 Command 的具体行为。根据选项的作用范围，可以把选项分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;persistent&lt;/li&gt;
&lt;li&gt;local&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 persistent 类型的选项，既可以设置给该 Command，又可以设置给该 Command 的子 Command。对于一些全局性的选项，比较适合设置为 persistent 类型，比如控制输出的 verbose 选项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Verbose&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PersistentFlags&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;BoolVarP&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Verbose&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;verbose&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;verbose output&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;local 类型的选项只能设置给指定的 Command，比如下面定义的 source 选项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Source&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Flags&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;StringVarP&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Source&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;source&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Source directory to read from&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该选项不能指定给 rootCmd 之外的其它 Command。
默认情况下的选项都是可选的，但一些用例要求用户必须设置某些选项，这种情况 cobra 也是支持的，通过 Command 的 MarkFlagRequired 方法标记该选项即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Flags&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;StringVarP&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user name (required)&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;MarkFlagRequired&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;命令行参数arguments&#34;&gt;命令行参数(arguments)&lt;/h2&gt;
&lt;p&gt;命令行参数(arguments)与命令行选项的区别(flags/options)。以常见的 ls 命令来说，其命令行的格式为：
&lt;code&gt;ls [OPTION]... [FILE]…&lt;/code&gt;
其中的 OPTION 对应本文中介绍的 flags，以 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 开头；而 FILE 则被称为参数(arguments)或位置参数。一般的规则是参数在所有选项的后面，上面的 … 表示可以指定多个选项和多个参数。&lt;/p&gt;
&lt;p&gt;cobra 默认提供了一些验证方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NoArgs - 如果存在任何位置参数，该命令将报错&lt;/li&gt;
&lt;li&gt;ArbitraryArgs - 该命令会接受任何位置参数&lt;/li&gt;
&lt;li&gt;OnlyValidArgs - 如果有任何位置参数不在命令的 ValidArgs 字段中，该命令将报错&lt;/li&gt;
&lt;li&gt;MinimumNArgs(int) - 至少要有 N 个位置参数，否则报错&lt;/li&gt;
&lt;li&gt;MaximumNArgs(int) - 如果位置参数超过 N 个将报错&lt;/li&gt;
&lt;li&gt;ExactArgs(int) - 必须有 N 个位置参数，否则报错&lt;/li&gt;
&lt;li&gt;ExactValidArgs(int) 必须有 N 个位置参数，且都在命令的 ValidArgs 字段中，否则报错&lt;/li&gt;
&lt;li&gt;RangeArgs(min, max) - 如果位置参数的个数不在区间 min 和 max 之中，报错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;帮助信息help-command&#34;&gt;帮助信息(help command)&lt;/h2&gt;
&lt;p&gt;cobra 会自动添加 &lt;code&gt;--help(-h)&lt;/code&gt; 选项，同时还自动添加了 help 子命，默认效果和使用 &amp;ndash;help 选项相同。如果为 help 命令传递其它命令作为参数，则会显示对应命令的帮助信息。也可以自定义 help 的处理&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetHelpCommand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetHelpFunc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetHelpTemplate&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;提示信息usage-message&#34;&gt;提示信息(usage message)&lt;/h2&gt;
&lt;p&gt;提示信息和帮助信息很相似，只不过它是在你输入了非法的参数、选项或命令时才出现的。也可以自定义提示信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetUsageFunc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetUsageTemplate&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;在-commnad-执行前后执行额外的操作&#34;&gt;在 Commnad 执行前后执行额外的操作&lt;/h2&gt;
&lt;p&gt;Command 执行的操作是通过 Command.Run 方法实现的，为了支持我们在 Run 方法执行的前后执行一些其它的操作，Command 还提供了额外的几个方法，它们的执行顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PersistentPreRun&lt;/li&gt;
&lt;li&gt;PreRun&lt;/li&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;li&gt;PostRun&lt;/li&gt;
&lt;li&gt;PersistentPostRun&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Use&lt;/span&gt;:   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cobrademo&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Short&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sparkdev&amp;#39;s cobra demo&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Long&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;the demo show how to use cobra package&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PersistentPreRun&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Inside rootCmd PersistentPreRun with args: %v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PreRun&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Inside rootCmd PreRun with args: %v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cobra demo program, with args: %v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PostRun&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Inside rootCmd PostRun with args: %v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PersistentPostRun&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cobra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Inside rootCmd PersistentPostRun with args: %v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;代码解析&#34;&gt;代码解析&lt;/h2&gt;
&lt;h3 id=&#34;command-结构体&#34;&gt;Command 结构体&lt;/h3&gt;
&lt;p&gt;Command 结构体是 cobra 抽象出来的核心概念，它的实例表示一个命令或者是一个命令的子命令。下面的代码仅展示 Command 结构体中一些比较重要的字段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用户通过指定 Run 函数来完成命令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// PreRun 和 PostRun 则允许用户在 Run 运行的前后时机执行自定义代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PersistentPreRun&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PreRun&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PostRun&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PersistentPostRun&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// commands 字段包含了该命令的所有子命令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;commands&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// parent 字段记录了该命令的父命令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 该命令的 help 子命令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;helpCommand&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;执行命令的逻辑&#34;&gt;执行命令的逻辑&lt;/h3&gt;
&lt;p&gt;cobra 包启动程序执行的代码一般为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Execute&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Execute() 函数会调用我们定义的 rootCmd(Command 的一个实例)的 Execute() 方法。
在 Command 的 Execute() 方法中又调用了 Command 的 ExecuteC() 方法，我们可以通过下面的调用堆栈看到执行命令逻辑的调用过程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Execute&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&amp;gt;                  &lt;span style=&#34;color:#75715e&#34;&gt;// main.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rootCmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Execute&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&amp;gt;              &lt;span style=&#34;color:#75715e&#34;&gt;// root.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ExecuteC&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&amp;gt;                   &lt;span style=&#34;color:#75715e&#34;&gt;// command.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&amp;gt;             &lt;span style=&#34;color:#75715e&#34;&gt;// command.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;()                           &lt;span style=&#34;color:#75715e&#34;&gt;// command.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;c.Run() 方法即用户为命令(Command) 设置的执行逻辑。&lt;/p&gt;
&lt;h3 id=&#34;解析命令行子命令&#34;&gt;解析命令行子命令&lt;/h3&gt;
&lt;p&gt;ExecuteC() 方法中，在执行 execute() 方法前，需要先通过 Find() 方法解析命令行上的子命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Find&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;比如我们执行下面的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./myApp mycmd1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解析出的 cmd 就是 imamycmd1ge 子命令，接下来就是执行 mycmd1 子命令的执行逻辑。&lt;/p&gt;
&lt;p&gt;Find() 方法的逻辑如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./myApp help mycmd1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 myApp 对应代码中的 rootCmd，Find() 方法中定义了一个名称为 innerfind 的函数，innerfind 从参数中解析出下一个名称，这里是 help，然后从 rootCmd 开始查找解析出的名称 help 是不是当前命令的子命令，如果 help 是 rootCmd 的子命令，继续查找。接下来查找名称 mycmd1，发现 mycmd1 不是 help 的子命令，innerfind 函数就返回 help 命令。execute() 方法中就执行这个找到的 help 子命令。&lt;/p&gt;
&lt;h3 id=&#34;为根命令添加-help-子命令&#34;&gt;为根命令添加 help 子命令&lt;/h3&gt;
&lt;p&gt;在执行 ExecuteC() 方法时，cobra 会为根命令添加一个 help 子命令，这个子命令主要用来提供子命令的帮助信息。因为任何一个程序都需要提供输出帮助信息的方式，所以 cobra 就为它实现了一套默认的逻辑。help 子命令是通过 InitDefaultHelpCmd() 方法添加的，其实现代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// InitDefaultHelpCmd adds default help command to c.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// It is called automatically by executing the c or by calling help and usage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// If c already has help command or c has no subcommands, it will do nothing.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;InitDefaultHelpCmd&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HasSubCommands&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;helpCommand&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;helpCommand&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;Use&lt;/span&gt;:   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help [command]&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;Short&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Help about any command&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;Long&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;`Help provides help for any command in the application.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Simply type `&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;` help [path to command] for full details.`&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Root&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Find&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown help topic %#q\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Root&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Usage&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;InitDefaultHelpFlag&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// make possible &amp;#39;help&amp;#39; flag to be shown
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Help&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RemoveCommand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;helpCommand&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;AddCommand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;helpCommand&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;如果没有找到用户指定的子命令&lt;/strong&gt;,就输出错误信息，并调用根命令的 Usage() 方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown help topic %#q\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Root&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Usage&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cobra 默认提供的 usage 模板如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`Usage:&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Runnable&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.UseLine&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasAvailableSubCommands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.CommandPath&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; [command]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;gt&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Aliases&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Aliases:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.NameAndAliases&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasExample&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Examples:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.Example&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasAvailableSubCommands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Available Commands:&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Commands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.IsAvailableCommand&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;eq&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Name&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rpad&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Name&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.NamePadding&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.Short&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasAvailableLocalFlags&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Flags:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.LocalFlags.FlagUsages&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trimTrailingWhitespaces&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasAvailableInheritedFlags&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Global Flags:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.InheritedFlags.FlagUsages&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trimTrailingWhitespaces&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasHelpSubCommands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Additional help topics:&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Commands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.IsAdditionalHelpTopicCommand&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rpad&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.CommandPath&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.CommandPathPadding&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.Short&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasAvailableSubCommands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Use &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.CommandPath&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; [command] --help&amp;#34; for more information about a command.&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;如果找到用户指定的子命令&lt;/strong&gt;，就为子命令添加默认的 help flag，并执行其 Help() 方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;InitDefaultHelpFlag&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// make possible &amp;#39;help&amp;#39; flag to be shown
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Help&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 cobra 实现了一个命令行程序 myApp，它有一个子命令 image，image 也有一个子命令 times。执行下面的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./myApp help mycmd1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 help 命令的 Run 方法中，c 为 help 命令， args 为 mycmd1。结果就是通过 help 查看 mycmd1 命令的帮助文档。如果 mycmd1 后面还有其他的子命令，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./myApp help mycmd1 mysub1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;则 c.Root().Find(args) 逻辑会找出子命令 mysub1(此时 args 为 mycmd1 mysub1)，最终由 help 查看 mysub1 命令的帮助文档。
注意：help 信息中包含 usage 信息。&lt;/p&gt;
&lt;h3 id=&#34;为命令添加-help-flag&#34;&gt;为命令添加 help flag&lt;/h3&gt;
&lt;p&gt;除了在 InitDefaultHelpCmd() 方法中会调用 InitDefaultHelpFlag() 方法，在 execute() 方法中执行命令逻辑前也会调用 InitDefaultHelpFlag() 方法为命令添加默认的 help flag，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;InitDefaultHelpFlag&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是 InitDefaultHelpFlag() 方法的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// InitDefaultHelpFlag adds default help flag to c.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// It is called automatically by executing the c or by calling help and usage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// If c already has help flag, it will do nothing.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;InitDefaultHelpFlag&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mergePersistentFlags&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Flags&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Lookup&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;usage&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help for &amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;usage&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;this command&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;usage&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Flags&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;BoolP&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;h&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;usage&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这让我们不必为命令添加 help flag 就可以直接使用&lt;/p&gt;
&lt;h3 id=&#34;输出-help-信息&#34;&gt;输出 help 信息&lt;/h3&gt;
&lt;p&gt;不管是 help 命令还是 help falg，最后都是通过 HelpFunc() 方法来获得输出 help 信息的逻辑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// HelpFunc returns either the function set by SetHelpFunc for this command
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// or a parent, or it returns a function with default help behavior.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;HelpFunc&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;helpFunc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;helpFunc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HasParent&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Parent&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;HelpFunc&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mergePersistentFlags&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tmpl&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;OutOrStdout&lt;/span&gt;(), &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HelpTemplate&lt;/span&gt;(), &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们没有指定自定义的逻辑，就找父命令的，再没有就用 cobra 的默认逻辑。cobra 默认设置的帮助模板如下(包含 usage)：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Short&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trimTrailingWhitespaces&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.Runnable&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;.HasSubCommands&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.UsageString&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}{{&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;}}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cobra.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cobra. Dev&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/spf13/cobra&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【译】Go中的模糊测试</title>
        <link>https://lxb.wiki/dfd7f257/</link>
        <pubDate>Tue, 19 Apr 2022 21:30:29 +0000</pubDate>
        
        <guid>https://lxb.wiki/dfd7f257/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 团队接受了新增对模糊测试的支持的提议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go&lt;/a&gt; 的应用越来越广泛。现在它是云原生软件、容器软件、命令行工具和数据库等等的首选语言。Go 很早之前就已经有了内建的 &lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;对测试的支持&lt;/a&gt;。这使得写测试代码和运行都相当简单。&lt;/p&gt;
&lt;h3 id=&#34;什么是模糊测试&#34;&gt;什么是模糊测试？&lt;/h3&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;模糊测试&lt;!-- raw HTML omitted --&gt;fuzz testing&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;（fuzzing）是指向你的软件输入非预期的数据。理想情况下，这种测试会让你的应用程序崩溃或有非预期的表现。抛开最终的结果，从程序对非预期的输入数据的处理结果中你可以得到很多信息，这样你就可以增加一些合适的错误处理。&lt;/p&gt;
&lt;p&gt;任何一个软件都有对不同来源的输入或数据的接收说明，软件会对这些数据进行处理并返回适当的结果。软件开发后，测试工程师团队对其进行测试，找出软件中的错误，给出测试报告，并（由开发者）修复。通常测试的目的是验证软件的行为是否符合预期。测试又可以细分为不同的类型，如功能测试、集成测试、性能测试等等。每种测试方法关注软件功能的某一个方面，以便发现错误或者提升可靠性或性能。&lt;/p&gt;
&lt;p&gt;模糊测试在这一测试过程上更进一步，尝试向软件程序输入一些“无效”或“随机”的数据。这种输入是故意的，期望得到的结果就是程序崩溃或输出异常，这样就可以暴露程序中的错误以便由开发者来修复它们。与其他测试类似，很少需要手动进行模糊测试，业界有大量的模糊测试工具可以将这个过程自动化。&lt;/p&gt;
&lt;h3 id=&#34;go-中的软件测试&#34;&gt;Go 中的软件测试&lt;/h3&gt;
&lt;p&gt;举个例子，假如你想测试 &lt;code&gt;add.go&lt;/code&gt; 中的 &lt;code&gt;Add()&lt;/code&gt; 函数，你可以在 &lt;code&gt;add_test.go&lt;/code&gt; 中导入 &lt;code&gt;testing&lt;/code&gt; 包并把测试体写在以 &lt;code&gt;TestXXX()&lt;/code&gt;  开头的函数内。&lt;/p&gt;
&lt;p&gt;考虑如下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Add(num1, num2 int) int {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;add_test.go&lt;/code&gt; 文件中，你可能有如下测试代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import &amp;#34;testing&amp;#34;

func TestAdd(t *testing.T) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行测试：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go test
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;新增对模糊测试的支持&#34;&gt;新增对模糊测试的支持&lt;/h3&gt;
&lt;p&gt;Go 团队已经接受了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/44551&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;新增对模糊测试的支持的提议&lt;/a&gt;，以进一步推动这项工作。这涉及到新增一个 &lt;code&gt;testing.F&lt;/code&gt; 类型，在 &lt;code&gt;_test.go&lt;/code&gt; 文件中新增 &lt;code&gt;FuzzXXX()&lt;/code&gt; 函数，在 Go 工具中会新增一个 &lt;code&gt;-fuzz&lt;/code&gt; 选项来执行这些测试。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;add_test.go&lt;/code&gt; 文件中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func FuzzAdd(f *testing.F) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行以下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go test -fuzz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在本文编写时，这个 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/fuzz-beta&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;功能还是试验性的&lt;/a&gt;，但是应该会在 1.18 发布版本中包含。（LCTT 译注：&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/go1.18&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 1.18&lt;/a&gt; 刚刚发布，已经包含了对模糊测试的支持）目前很多功能如 &lt;code&gt;-keepfuzzing&lt;/code&gt;、&lt;code&gt;-race&lt;/code&gt; 等也还没有支持。Go 团队最近发布了一篇 &lt;a class=&#34;link&#34; href=&#34;https://go.dev/doc/tutorial/fuzz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;模糊测试教程&lt;/a&gt;，值得读一下。&lt;/p&gt;
&lt;h3 id=&#34;安装-gotip-来获取最新的功能&#34;&gt;安装 gotip 来获取最新的功能&lt;/h3&gt;
&lt;p&gt;如果你极度渴望在正式发布之前尝试这些功能，你可以使用 &lt;code&gt;gotip&lt;/code&gt; 来测试即将正式发布的 Go 功能并反馈给他们。你可以使用下面的命令来安装 &lt;code&gt;gotip&lt;/code&gt;。安装之后，你可以用 &lt;code&gt;gotip&lt;/code&gt; 程序代替以前的 &lt;code&gt;go&lt;/code&gt; 程序来编译和运行程序。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go install golang.org/dl/gotip@latest
$ gotip download

$ gotip version
go version devel go1.18-f009910 Thu Jan 6 16:22:21 2022 +0000 linux/amd64
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;社区对于模糊测试的观点&#34;&gt;社区对于模糊测试的观点&lt;/h3&gt;
&lt;p&gt;软件社区中经常会讨论模糊测试，不同的人对模糊测试有不同的看法。有些人认为这是一种有用的技术，可以找到错误，尤其是在安全方面。然而考虑到模糊测试所需要的资源（CPU、内存），有人就认为这是一种浪费，而他们更愿意用其他的测试方法。即使在 Go 团队内部，意见也不统一。我们可以看到 Go 的联合创始人 Rob Pike 对模糊测试的使用和在 Go 中的实现是持轻微的怀疑态度的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;&lt;em&gt;虽然模糊测试有助于发现某类错误，但是它会占用大量的 CPU 和存储资源，并且效益成本比率也不明确。我担心为了写模糊测试浪费精力，或者 git 仓库中充斥大量无用的测试数据&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;~&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/44551#issuecomment-784584785&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rob Pike&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，Go 安全团队的另一个成员，Filo Sottile，似乎对 Go 新增支持模糊测试很乐观，举了很多例子来支持，也希望模糊测试能成为开发过程中的一部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;我想说模糊测试可以发现极端情况下的错误。这是我们作为安全团队对其感兴趣的原因：在极端情况下发现的错误可以避免在生产环境中成为弱点。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们希望模糊测试能成为开发的一部分 —— 不只是构建或安全方面 —— 而是整个开发过程：它能提升相关代码的质量&amp;hellip;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;~&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/44551#issuecomment-784655571&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Filo Sottile&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;现实中的模糊测试&#34;&gt;现实中的模糊测试&lt;/h3&gt;
&lt;p&gt;对我而言，模糊测试在发现错误以及让系统变得更安全和更有弹性方面似乎非常有效。举个例子，Linux 内核也会使用名为 &lt;a class=&#34;link&#34; href=&#34;https://github.com/google/syzkaller&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;syzkaller&lt;/a&gt; 的工具进行模糊测试，这个工具已经发现了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/google/syzkaller/blob/master/docs/linux/found_bugs.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;大量&lt;/a&gt; 错误。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/google/AFL&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AFL&lt;/a&gt; 也是比较流行的模糊测试工具，用来测试 C/C++ 写的程序。&lt;/p&gt;
&lt;p&gt;之前也有对 Go 程序进行模糊测试的观点，其中之一就是 Filo 在 GitHub 评论中提到的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/dvyukov/go-fuzz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go-fuzz&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;go-fuzz 的记录提供了相当惊人的证据，证明模糊处理能很好地找到人类没有发现的错误。根据我的经验，我们只需要消耗一点点 CPU 的时间就可以得到极端情况下非常高效的测试结果。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么在-go-中新增对模糊测试的原生支持&#34;&gt;为什么在 Go 中新增对模糊测试的原生支持&lt;/h3&gt;
&lt;p&gt;如果我们的需求是对 Go 程序进行模糊测试，之前的工具像 &lt;code&gt;go-fuzz&lt;/code&gt; 就可以完成，那么为什么要在这种语言中增加原生支持呢？&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/proposal/&amp;#43;/master/design/draft-fuzzing.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 模糊测试设计草案&lt;/a&gt; 中说明了这样做的一些根本原因。设计的思路是让开发过程更简单，因为前面说的工具增加了开发者的工作量，还有功能缺失。如果你没有接触过模糊测试，那么我建议你读一下设计草案文档。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开发者可以使用诸如 &lt;code&gt;go-fuzz&lt;/code&gt; 或 &lt;code&gt;fzgo&lt;/code&gt;（基于 &lt;code&gt;go-fuzz&lt;/code&gt;）来解决某些需求。然而，已有的每种解决方案都需要在典型的 Go 测试上做更多的事，而且还缺少关键的功能。相比于其他的 Go 测试（如基准测试和单元测试），模糊测试不应该比它们复杂，功能也不应该比它们少。已有的解决方案增加了额外的开销，比如自定义命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模糊测试工具&#34;&gt;模糊测试工具&lt;/h3&gt;
&lt;p&gt;在大家期望 Go 语言新增功能的列表中，模糊测试是其中很受欢迎的一项。虽然现在还是试验性的，但在将要到来的发布版本中会变得更强大。这给了我们足够的时间去尝试它以及探索它的使用场景。我们不应该把它视为一种开销，如果使用得当它会是一种发现错误非常高效的测试工具。使用 Go 的团队应该推动它的使用，开发者可以写简单的模糊测试，测试团队去慢慢扩展以此来使用它全部的能力。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/22/1/native-go-fuzz-testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/22/1/native-go-fuzz-testing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/gkamathe&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gaurav Kamathe&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go 语言内存分配</title>
        <link>https://lxb.wiki/57be14fe/</link>
        <pubDate>Sat, 20 Nov 2021 22:39:07 +0000</pubDate>
        
        <guid>https://lxb.wiki/57be14fe/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。&lt;/p&gt;
&lt;p&gt;Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的 TCMalloc算法，全称 Thread-CachingMalloc。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。&lt;/p&gt;
&lt;h2 id=&#34;基础概念&#34;&gt;基础概念&lt;/h2&gt;
&lt;p&gt;Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。&lt;/p&gt;
&lt;p&gt;申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204105.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arena区域&lt;/code&gt;就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成&lt;code&gt;8KB&lt;/code&gt;大小的页，一些页组合起来称为&lt;code&gt;mspan&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bitmap区域&lt;/code&gt;标识&lt;code&gt;arena&lt;/code&gt;区域哪些地址保存了对象，并且用&lt;code&gt;4bit&lt;/code&gt;标志位表示对象是否包含指针、&lt;code&gt;GC&lt;/code&gt;标记信息。&lt;code&gt;bitmap&lt;/code&gt;中一个&lt;code&gt;byte&lt;/code&gt;大小的内存对应&lt;code&gt;arena&lt;/code&gt;区域中4个指针大小（指针大小为 8B ）的内存，所以&lt;code&gt;bitmap&lt;/code&gt;区域的大小是&lt;code&gt;512GB/(4*8B)=16GB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204132.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spans区域&lt;/code&gt;存放&lt;code&gt;mspan&lt;/code&gt;（也就是一些&lt;code&gt;arena&lt;/code&gt;分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以&lt;code&gt;spans&lt;/code&gt;区域的大小就是&lt;code&gt;512GB/8KB*8B=512MB&lt;/code&gt;。除以8KB是计算&lt;code&gt;arena&lt;/code&gt;区域的页数，而最后乘以8是计算&lt;code&gt;spans&lt;/code&gt;区域所有指针的大小。创建&lt;code&gt;mspan&lt;/code&gt;的时候，按页填充对应的&lt;code&gt;spans&lt;/code&gt;区域，在回收&lt;code&gt;object&lt;/code&gt;时，根据地址很容易就能找到它所属的&lt;code&gt;mspan&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;内存管理单元&#34;&gt;内存管理单元&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mspan&lt;/code&gt;：Go中内存管理的基本单元，是由一片连续的&lt;code&gt;8KB&lt;/code&gt;的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：&lt;code&gt;mspan&lt;/code&gt;是一个包含起始地址、&lt;code&gt;mspan&lt;/code&gt;规格、页的数量等内容的双端链表。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;mspan&lt;/code&gt;按照它自身的属性&lt;code&gt;Size Class&lt;/code&gt;的大小分割成若干个&lt;code&gt;object&lt;/code&gt;，每个&lt;code&gt;object&lt;/code&gt;可存储一个对象。并且会使用一个位图来标记其尚未使用的&lt;code&gt;object&lt;/code&gt;。属性&lt;code&gt;Size Class&lt;/code&gt;决定&lt;code&gt;object&lt;/code&gt;大小，而&lt;code&gt;mspan&lt;/code&gt;只会分配给和&lt;code&gt;object&lt;/code&gt;尺寸大小接近的对象，当然，对象的大小要小于&lt;code&gt;object&lt;/code&gt;大小。还有一个概念：&lt;code&gt;Span Class&lt;/code&gt;，它和&lt;code&gt;Size Class&lt;/code&gt;的含义差不多，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Size_Class &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Span_Class &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是因为其实每个 &lt;code&gt;Size Class&lt;/code&gt;有两个&lt;code&gt;mspan&lt;/code&gt;，也就是有两个&lt;code&gt;Span Class&lt;/code&gt;。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。&lt;/p&gt;
&lt;p&gt;如下图，&lt;code&gt;mspan&lt;/code&gt;由一组连续的页组成，按照一定大小划分成&lt;code&gt;object&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204238.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Go1.9.2里&lt;code&gt;mspan&lt;/code&gt;的&lt;code&gt;Size Class&lt;/code&gt;共有67种，每种&lt;code&gt;mspan&lt;/code&gt;分割的object大小是8*2n的倍数，这个是写死在代码里的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// path: /usr/local/go/src/runtime/sizeclasses.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_NumSizeClasses&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;67&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class_to_size&lt;/span&gt; = [&lt;span style=&#34;color:#a6e22e&#34;&gt;_NumSizeClasses&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;96&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;112&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;144&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;160&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;176&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;192&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;208&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;224&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;240&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;288&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;320&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;352&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;384&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;416&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;448&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;480&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;512&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;576&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;640&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;704&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;768&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;896&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1152&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1280&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1408&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1536&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1792&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2304&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2688&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3072&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3200&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3456&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4864&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5376&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6144&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6528&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6784&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6912&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8192&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9472&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9728&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10240&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10880&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;12288&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;13568&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;14336&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;16384&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;18432&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19072&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20480&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21760&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;24576&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;27264&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;28672&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32768&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据&lt;code&gt;mspan&lt;/code&gt;的&lt;code&gt;Size Class&lt;/code&gt;可以得到它划分的&lt;code&gt;object&lt;/code&gt;大小。 比如&lt;code&gt;Size Class&lt;/code&gt;等于3，&lt;code&gt;object&lt;/code&gt;大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个&lt;code&gt;object&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型&lt;code&gt;Size Class&lt;/code&gt;为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过&lt;code&gt;mspan&lt;/code&gt;来分配。&lt;/p&gt;
&lt;p&gt;对于mspan来说，它的&lt;code&gt;Size Class&lt;/code&gt;会决定它所能分到的页数，这也是写死在代码里的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// path: /usr/local/go/src/runtime/sizeclasses.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_NumSizeClasses&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;67&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class_to_allocnpages&lt;/span&gt; = [&lt;span style=&#34;color:#a6e22e&#34;&gt;_NumSizeClasses&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;比如当我们要申请一个&lt;code&gt;object&lt;/code&gt;大小为&lt;code&gt;32B&lt;/code&gt;的&lt;code&gt;mspan&lt;/code&gt;的时候，在class_to_size里对应的索引是3，而索引3在&lt;code&gt;class_to_allocnpages&lt;/code&gt;数组里对应的页数就是1。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mspan&lt;/code&gt;结构体定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// path: /usr/local/go/src/runtime/mheap.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mspan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//链表前向指针，用于将span链接起来
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mspan&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//链表前向指针，用于将span链接起来
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mspan&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 起始地址，也即所管理页的地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;startAddr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 管理的页数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;npages&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 块个数，表示有多少个块可供分配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;nelems&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//分配位图，每一位代表一个块是否已分配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;allocBits&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;gcBits&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 已分配块的个数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;allocCount&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// class表中的class ID，和Size Classs相关
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;spanclass&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;spanClass&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// class表中的对象大小，也即块大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;elemsize&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们将&lt;code&gt;mspan&lt;/code&gt;放到更大的视角来看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204350.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图可以看到有两个&lt;code&gt;S&lt;/code&gt;指向了同一个&lt;code&gt;mspan&lt;/code&gt;，因为这两个&lt;code&gt;S&lt;/code&gt;指向的&lt;code&gt;P&lt;/code&gt;是同属一个&lt;code&gt;mspan&lt;/code&gt;的。所以，通过&lt;code&gt;arena&lt;/code&gt;上的地址可以快速找到指向它的&lt;code&gt;S&lt;/code&gt;，通过&lt;code&gt;S&lt;/code&gt;就能找到&lt;code&gt;mspan&lt;/code&gt;，回忆一下前面我们说的&lt;code&gt;mspan&lt;/code&gt;区域的每个指针对应一页。&lt;/p&gt;
&lt;p&gt;假设最左边第一个&lt;code&gt;mspan&lt;/code&gt;的&lt;code&gt;Size Class&lt;/code&gt;等于10，根据前面的&lt;code&gt;class_to_size&lt;/code&gt;数组，得出这个&lt;code&gt;msapn&lt;/code&gt;分割的&lt;code&gt;object&lt;/code&gt;大小是144B，算出可分配的对象个数是&lt;code&gt;8KB/144B=56.89&lt;/code&gt;个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有&lt;code&gt;Size Class&lt;/code&gt;的&lt;code&gt;mspan&lt;/code&gt;浪费的内存的大小；再根据&lt;code&gt;class_to_allocnpages&lt;/code&gt;数组，得到这个&lt;code&gt;mspan&lt;/code&gt;只由1个&lt;code&gt;page&lt;/code&gt;组成；假设这个&lt;code&gt;mspan&lt;/code&gt;是分配给无指针对象的，那么&lt;code&gt;spanClass&lt;/code&gt;等于20。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;startAddr&lt;/code&gt;直接指向&lt;code&gt;arena&lt;/code&gt;区域的某个位置，表示这个&lt;code&gt;mspan&lt;/code&gt;的起始地址，&lt;code&gt;allocBits&lt;/code&gt;指向一个位图，每位代表一个块是否被分配了对象；&lt;code&gt;allocCount&lt;/code&gt;则表示总共已分配的对象个数。&lt;/p&gt;
&lt;p&gt;这样，左起第一个&lt;code&gt;mspan&lt;/code&gt;的各个字段参数就如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204458.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存管理组件&#34;&gt;内存管理组件&lt;/h2&gt;
&lt;p&gt;内存分配由内存分配器完成。分配器由3种组件构成：&lt;code&gt;mcache&lt;/code&gt;, &lt;code&gt;mcentral&lt;/code&gt;, &lt;code&gt;mheap&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;mcache&#34;&gt;mcache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mcache&lt;/code&gt;：每个工作线程都会绑定一个mcache，本地缓存可用的&lt;code&gt;mspan&lt;/code&gt;资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mcache&lt;/code&gt;的结构体定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//path: /usr/local/go/src/runtime/mcache.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mcache&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;alloc&lt;/span&gt; [&lt;span style=&#34;color:#a6e22e&#34;&gt;numSpanClasses&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mspan&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;numSpanClasses&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;_NumSizeClasses&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;mcache&lt;/code&gt;用&lt;code&gt;Span Classes&lt;/code&gt;作为索引管理多个用于分配的&lt;code&gt;mspan&lt;/code&gt;，它包含所有规格的&lt;code&gt;mspan&lt;/code&gt;。它是&lt;code&gt;_NumSizeClasses&lt;/code&gt;的2倍，也就是&lt;code&gt;67*2=134&lt;/code&gt;，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的&lt;code&gt;mspan&lt;/code&gt;中分配的对象不包含指针，另一半则包含指针。&lt;/p&gt;
&lt;p&gt;对于无指针对象的&lt;code&gt;mspan&lt;/code&gt;在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204550.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mcache&lt;/code&gt;在初始化的时候是没有任何&lt;code&gt;mspan&lt;/code&gt;资源的，在使用过程中会动态地从&lt;code&gt;mcentral&lt;/code&gt;申请，之后会缓存下来。当对象小于等于32KB大小时，使用&lt;code&gt;mcache&lt;/code&gt;的相应规格的&lt;code&gt;mspan&lt;/code&gt;进行分配。&lt;/p&gt;
&lt;h2 id=&#34;mcentral&#34;&gt;mcentral&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mcentral&lt;/code&gt;：为所有&lt;code&gt;mcache&lt;/code&gt;提供切分好的&lt;code&gt;mspan&lt;/code&gt;资源。每个&lt;code&gt;central&lt;/code&gt;保存一种特定大小的全局&lt;code&gt;mspan&lt;/code&gt;列表，包括已分配出去的和未分配出去的。 每个&lt;code&gt;mcentral&lt;/code&gt;对应一种&lt;code&gt;mspan&lt;/code&gt;，而&lt;code&gt;mspan&lt;/code&gt;的种类导致它分割的&lt;code&gt;object&lt;/code&gt;大小不同。当工作线程的&lt;code&gt;mcache&lt;/code&gt;中没有合适（也就是特定大小的）的&lt;code&gt;mspan&lt;/code&gt;时就会从&lt;code&gt;mcentral&lt;/code&gt;获取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mcentral&lt;/code&gt;被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//path: /usr/local/go/src/runtime/mcentral.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mcentral&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 互斥锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 规格
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sizeclass&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 尚有空闲object的mspan链表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;nonempty&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mSpanList&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;empty&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mSpanList&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 已累计分配的对象个数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;nmalloc&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204644.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;empty&lt;/code&gt;表示这条链表里的&lt;code&gt;mspan&lt;/code&gt;都被分配了&lt;code&gt;object&lt;/code&gt;，或者是已经被&lt;code&gt;cache&lt;/code&gt;取走了的&lt;code&gt;mspan&lt;/code&gt;，这个&lt;code&gt;mspan&lt;/code&gt;就被那个工作线程独占了。而&lt;code&gt;nonempty&lt;/code&gt;则表示有空闲对象的&lt;code&gt;mspan&lt;/code&gt;列表。每个&lt;code&gt;central&lt;/code&gt;结构体都在&lt;code&gt;mheap&lt;/code&gt;中维护。&lt;/p&gt;
&lt;p&gt;简单说下&lt;code&gt;mcache&lt;/code&gt;从&lt;code&gt;mcentral&lt;/code&gt;获取和归还&lt;code&gt;mspan&lt;/code&gt;的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取 加锁；从&lt;code&gt;nonempty&lt;/code&gt;链表找到一个可用的&lt;code&gt;mspan&lt;/code&gt;；并将其从&lt;code&gt;nonempty&lt;/code&gt;链表删除；将取出的&lt;code&gt;mspan&lt;/code&gt;加入到&lt;code&gt;empty&lt;/code&gt;链表；将&lt;code&gt;mspan&lt;/code&gt;返回给工作线程；解锁。&lt;/li&gt;
&lt;li&gt;归还 加锁；将&lt;code&gt;mspan&lt;/code&gt;从&lt;code&gt;empty&lt;/code&gt;链表删除；将&lt;code&gt;mspan&lt;/code&gt;加入到&lt;code&gt;nonempty&lt;/code&gt;链表；解锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mheap&#34;&gt;mheap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mheap&lt;/code&gt;：代表Go程序持有的所有堆空间，Go程序使用一个&lt;code&gt;mheap&lt;/code&gt;的全局对象&lt;code&gt;_mheap&lt;/code&gt;来管理堆内存。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;mcentral&lt;/code&gt;没有空闲的&lt;code&gt;mspan&lt;/code&gt;时，会向&lt;code&gt;mheap&lt;/code&gt;申请。而&lt;code&gt;mheap&lt;/code&gt;没有资源时，会向操作系统申请新内存。&lt;code&gt;mheap&lt;/code&gt;主要用于大对象的内存分配，以及管理未切割的&lt;code&gt;mspan&lt;/code&gt;，用于给&lt;code&gt;mcentral&lt;/code&gt;切割成小对象。&lt;/p&gt;
&lt;p&gt;同时我们也看到，&lt;code&gt;mheap&lt;/code&gt;中含有所有规格的&lt;code&gt;mcentral&lt;/code&gt;，所以，当一个&lt;code&gt;mcache&lt;/code&gt;从&lt;code&gt;mcentral&lt;/code&gt;申请&lt;code&gt;mspan&lt;/code&gt;时，只需要在独立的&lt;code&gt;mcentral&lt;/code&gt;中使用锁，并不会影响申请其他规格的&lt;code&gt;mspan&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mheap&lt;/code&gt;结构体定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//path: /usr/local/go/src/runtime/mheap.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mheap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// spans: 指向mspans区域，用于映射mspan和page的关系
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;spans&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mspan&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 指向bitmap首地址，bitmap是从高地址向低地址增长的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;bitmap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 指示arena区首地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;arena_start&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 指示arena区已使用地址位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;arena_used&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 指示arena区末地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;arena_end&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;central&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;67&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;mcentral&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mcentral&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;pad&lt;/span&gt; [&lt;span style=&#34;color:#a6e22e&#34;&gt;sys&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CacheLineSize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sizeof&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;mcentral&lt;/span&gt;{})&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sys&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CacheLineSize&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312204738.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。&lt;/p&gt;
&lt;h2 id=&#34;分配流程&#34;&gt;分配流程&lt;/h2&gt;
&lt;p&gt;变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是&amp;quot;zero garbage&amp;quot;，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。&lt;/p&gt;
&lt;p&gt;Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。&lt;/p&gt;
&lt;p&gt;大体上的分配流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32KB 的对象，直接从mheap上分配；&lt;/li&gt;
&lt;li&gt;&amp;lt;=16B 的对象使用mcache的tiny分配器分配；&lt;/li&gt;
&lt;li&gt;(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；&lt;/li&gt;
&lt;li&gt;如果mcache没有相应规格大小的mspan，则向mcentral申请&lt;/li&gt;
&lt;li&gt;如果mcentral没有相应规格大小的mspan，则向mheap申请&lt;/li&gt;
&lt;li&gt;如果mheap中也没有合适大小的mspan，则向操作系统申请&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。&lt;/li&gt;
&lt;li&gt;Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。&lt;/li&gt;
&lt;li&gt;mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。&lt;/li&gt;
&lt;li&gt;极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Go channel 原理</title>
        <link>https://lxb.wiki/7b2461e3/</link>
        <pubDate>Wed, 10 Nov 2021 21:56:56 +0000</pubDate>
        
        <guid>https://lxb.wiki/7b2461e3/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;section1-channel-使用&#34;&gt;Section1 channel 使用&lt;/h1&gt;
&lt;h2 id=&#34;11-make-channel&#34;&gt;1.1 make channel&lt;/h2&gt;
&lt;p&gt;一种是带缓冲的channel一种是不带缓冲的channel。创建方式分别如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// buffered
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Task&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// unbuffered
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;buffered channel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们创建一个带buffer的channel，底层的数据模型如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170000.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当我们向channel里面写入数据时候，会直接把数据存入circular queue(send)。当Queue存满了之后就会是如下的状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170039.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当dequeue一个元素时候，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170108.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上图可知，recvx自增加一，表示出队了一个元素，其实也就是循环数组实现FIFO语义。&lt;/p&gt;
&lt;p&gt;那么还有一个问题，当我们新建channel的时候，底层创建的hchan数据结构是在哪里分配内存的呢？其实Section2里面源码分析时候已经做了分析，hchan是在heap里面分配的。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170236.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当我们使用make去创建一个channel的时候，实际上返回的是一个指向channel的pointer，所以我们能够在不同的function之间直接传递channel对象，而不用通过指向channel的指针。&lt;/p&gt;
&lt;h2 id=&#34;12-sends-and-receives&#34;&gt;1.2 sends and receives&lt;/h2&gt;
&lt;p&gt;不同goroutine在channel上面进行读写时，涉及到的过程比较复杂，比如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170342.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图中G1会往channel里面写入数据，G2会从channel里面读取数据。&lt;/p&gt;
&lt;p&gt;G1作用于底层hchan的流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170423.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先获取全局锁；&lt;/li&gt;
&lt;li&gt;然后enqueue元素(通过移动拷贝的方式)；&lt;/li&gt;
&lt;li&gt;释放锁；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;G2读取时候作用于底层数据结构流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170525.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先获取全局锁；&lt;/li&gt;
&lt;li&gt;然后dequeue元素(通过移动拷贝的方式)；&lt;/li&gt;
&lt;li&gt;释放锁；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的读写思路其实很简单，除了hchan数据结构外，不要通过共享内存去通信；而是通过通信(复制)实现共享内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写入满channel的场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图所示：channel写入3个task之后队列已经满了，这时候G1再写入第四个task的时候会发生什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312170644.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;G1这时候会暂停直到出现一个receiver。&lt;/p&gt;
&lt;p&gt;这个地方需要介绍一下Golang的scheduler的。我们知道goroutine是用户空间的线程，创建和管理协程都是通过Go的runtime，而不是通过OS的thread。&lt;/p&gt;
&lt;p&gt;但是Go的runtime调度执行goroutine却是基于OS thread的。如下图：
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173326.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当向已经满的channel里面写入数据时候，会发生什么呢？如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173420.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图流程大概如下：&lt;/p&gt;
&lt;p&gt;当前goroutine（G1）会调用gopark函数，将当前协程置为waiting状态；
将M和G1绑定关系断开；
scheduler会调度另外一个就绪态的goroutine与M建立绑定关系，然后M 会运行另外一个G。
所以整个过程中，OS thread会一直处于运行状态，不会因为协程G1的阻塞而阻塞。最后当前的G1的引用会存入channel的sender队列(队列元素是持有G1的sudog)。&lt;/p&gt;
&lt;p&gt;那么blocked的G1怎么恢复呢？&lt;strong&gt;当有一个receiver接收channel数据的时候，会恢复 G1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上hchan数据结构也存储了channel的sender和receiver的等待队列。数据原型如下：
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173537.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;等待队列里面是sudog的单链表，sudog持有一个G代表goroutine对象引用，elem代表channel里面保存的元素。当G1执行&lt;code&gt;ch&amp;lt;-task4&lt;/code&gt;的时候，G1会创建一个sudog然后保存进入sendq队列，实际上hchan结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这个时候，如果G2进行一个读取channel操作，读取前和读取后的变化图如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173709.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;整个过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;G2调用 t:=&amp;lt;-ch 获取一个元素；&lt;/li&gt;
&lt;li&gt;从channel的buffer里面取出一个元素task1；&lt;/li&gt;
&lt;li&gt;从sender等待队列里面pop一个sudog；&lt;/li&gt;
&lt;li&gt;将task4复制buffer中task1的位置，然后更新buffer的sendx和recvx索引值；&lt;/li&gt;
&lt;li&gt;这时候需要将G1置为Runable状态，表示G1可以恢复运行；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个时候将G1恢复到可运行状态需要scheduler的参与。G2会调用goready(G1)来唤醒G1。流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173855.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先G2会调用goready(G1)，唤起scheduler的调度；&lt;/li&gt;
&lt;li&gt;将G1设置成Runable状态；&lt;/li&gt;
&lt;li&gt;G1会加入到局部调度器P的local queue队列，等待运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;读取空channel的场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当channel的buffer里面为空时，这时候如果G2首先发起了读取操作。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312173959.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;会创建一个sudog，将代表G2的sudog存入recvq等待队列。然后G2会调用gopark函数进入等待状态，让出OS thread，然后G2进入阻塞态。&lt;/p&gt;
&lt;p&gt;这个时候，如果有一个G1执行写入操作，最直观的流程就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将recvq中的task存入buffer；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;goready(G2) 唤醒G2；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;我们有更加智能的方法：direct send; 其实也就是G1直接把数据写入到G2中的elem中，这样就不用走G2中的elem复制到buffer中，再从buffer复制给G1。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312174123.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;具体过程就是G1直接把数据写入到G2的栈中。这样 G2 不需要去获取channel的全局锁和操作缓冲。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;section2-channel源码&#34;&gt;Section2 channel源码&lt;/h1&gt;
&lt;h2 id=&#34;21-channel数据存储结构&#34;&gt;2.1 channel数据存储结构&lt;/h2&gt;
&lt;p&gt;在源码&lt;code&gt;runtime/chan.go&lt;/code&gt; 里面定义了channel的数据模型，channel可以理解成一个缓冲队列，这个缓冲队列用来存储元素，并且提供FIFO的语义。源码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//channel队列里面总的数据量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;qcount&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;// total data in the queue
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 循环队列的容量，如果是非缓冲的channel就是0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;dataqsiz&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;// size of the circular queue
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 缓冲队列，数组类型。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// points to an array of dataqsiz elements
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 元素占用字节的size
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;elemsize&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 当前队列关闭标志位，非零表示关闭
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;closed&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 队列里面元素类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;elemtype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// element type
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 队列send索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;sendx&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// send index
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 队列索引
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;recvx&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// receive index
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 等待channel的G队列。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;recvq&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;waitq&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// list of recv waiters
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 向channel发送数据的G队列。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;sendq&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;waitq&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// list of send waiters
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// lock protects all fields in hchan, as well as several
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// fields in sudogs blocked on this channel.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Do not change another G&amp;#39;s status while holding this lock
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// (in particular, do not ready a G), as this can deadlock
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// with stack shrinking.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 全局锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;channel的数据结构相对比较简单，主要是两个结构：
1）一个数组实现的环形队列，数组有两个下标索引分别表示读写的索引，用于保存channel缓冲区数据。
2）channel的send和recv队列，队列里面都是持有goroutine的sudog元素，队列都是双链表实现的。
3）channel的全局锁。&lt;/p&gt;
&lt;h2 id=&#34;22-环形队列&#34;&gt;2.2 环形队列&lt;/h2&gt;
&lt;p&gt;chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。&lt;/p&gt;
&lt;p&gt;下图展示了一个可缓存6个元素的channel示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312174357.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dataqsiz指示了队列长度为6，即可缓存6个元素；&lt;/li&gt;
&lt;li&gt;buf指向队列的内存，队列中还剩余两个元素；&lt;/li&gt;
&lt;li&gt;qcount表示队列中还有两个元素；&lt;/li&gt;
&lt;li&gt;sendx指示后续写入的数据存储的位置，取值[0, 6)；&lt;/li&gt;
&lt;li&gt;recvx指示从该位置读取数据, 取值[0, 6)；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23-等待队列&#34;&gt;2.3 等待队列&lt;/h2&gt;
&lt;p&gt;从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。
向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。&lt;/p&gt;
&lt;p&gt;被阻塞的goroutine将会挂在channel的等待队列中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；&lt;/li&gt;
&lt;li&gt;因写阻塞的goroutine会被从channel读数据的goroutine唤醒；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312174513.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。&lt;/p&gt;
&lt;h2 id=&#34;24-类型信息&#34;&gt;2.4 类型信息&lt;/h2&gt;
&lt;p&gt;一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;elemtype代表类型，用于数据传递过程中的赋值；&lt;/li&gt;
&lt;li&gt;elemsize代表类型大小，用于在buf中定位元素位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;25-锁&#34;&gt;2.5 锁&lt;/h2&gt;
&lt;p&gt;一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。&lt;/p&gt;
&lt;h1 id=&#34;section3-channel读写&#34;&gt;Section3 channel读写&lt;/h1&gt;
&lt;h2 id=&#34;31-创建channel&#34;&gt;3.1 创建channel&lt;/h2&gt;
&lt;p&gt;我们新建一个channel的时候一般使用 &lt;code&gt;make(chan, n)&lt;/code&gt; 语句，这个语句的执行编译器会重写然后执行 chan.go里面的 makechan函数。函数源码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makechan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;chantype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// compiler checks this but be safe.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;throw&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;makechan: invalid channel element type&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hchanSize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maxAlign&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;align&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxAlign&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;throw&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;makechan: bad alignment&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxSliceCap&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxAlloc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchanSize&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		panic(&lt;span style=&#34;color:#a6e22e&#34;&gt;plainError&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;makechan: size out of range&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// buf points into the same allocation, elemtype is persistent.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// SudoG&amp;#39;s are referenced from their owning thread so they can&amp;#39;t be collected.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Queue or element size is zero.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;mallocgc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;hchanSize&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Race detector uses this location for synchronization.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;kind&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;kindNoPointers&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Elements do not contain pointers.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Allocate hchan and buf in one call.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;mallocgc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;hchanSize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;hchanSize&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Elements contain pointers.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = new(&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;mallocgc&lt;/span&gt;(uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;elemsize&lt;/span&gt; = uint16(&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;elemtype&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dataqsiz&lt;/span&gt; = uint(&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;debugChan&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;makechan: chan=&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;; elemsize=&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;; elemalg=&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;alg&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;; dataqsiz=&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数接收两个参数，一个是channel里面保存的元素的数据类型，一个是缓冲的容量(如果为0表示是非缓冲buffer)，创建流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据传递的缓冲大小size是否为零，分别创建不带buffer的channel或则带size大小的缓冲channel：
&lt;ul&gt;
&lt;li&gt;对于不带缓冲channel，申请一个hchan数据结构的内存大小；&lt;/li&gt;
&lt;li&gt;对于带缓冲channel，new一个hchan对象，并初始化buffer内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新 chan中循环队列的关键属性：elemsize、elemtype、dataqsiz。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。&lt;/p&gt;
&lt;p&gt;创建channel的伪代码如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makechan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;chantype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = new(&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;malloc&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;元素类型大小&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;elemsize&lt;/span&gt; = &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;元素类型大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;elemtype&lt;/span&gt; = &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;元素类型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dataqsiz&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;32-协程向channel写入数据goroutine-sender-data&#34;&gt;3.2 协程向channel写入数据(goroutine sender data)&lt;/h2&gt;
&lt;p&gt;所有执行 c &amp;lt; ep 将ep发送到channel的代码，最后都会调用到chan.go里面的 chansend函数。&lt;/p&gt;
&lt;p&gt;函数的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chansend&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ep&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;block&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;callerpc&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数有三个参数，第一个代表channel的数据结构，第二个是要指向写入的数据的指针，第三个block代表写入操作是否阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175238.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;向一个channel中写数据简单过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；&lt;/li&gt;
&lt;li&gt;如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；&lt;/li&gt;
&lt;li&gt;如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175356.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-协程从channel接收数据goroutine-receive-data&#34;&gt;3.3 协程从channel接收数据(goroutine receive data)&lt;/h2&gt;
&lt;p&gt;所有执行 &lt;code&gt;ep &amp;lt; c&lt;/code&gt; 使用ep接收channel数据的代码，最后都会调用到chan.go里面的 &lt;code&gt;chanrecv函数&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;函数的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chanrecv&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hchan&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ep&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;block&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;selected&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;received&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从源码注释就可以知道，该函数从channel里面接收数据，然后将接收到的数据写入到ep指针指向的对象里面。&lt;/p&gt;
&lt;p&gt;还有一个参数block，表示当channel无法返回数据时是否阻塞等待。当block=false并且channel里面没有数据时候，函数直接返回(false,false)。
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175531.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从一个channel读数据简单过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；&lt;/li&gt;
&lt;li&gt;如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；&lt;/li&gt;
&lt;li&gt;如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；&lt;/li&gt;
&lt;li&gt;将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220312175628.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-关闭channel&#34;&gt;3.4 关闭channel&lt;/h2&gt;
&lt;p&gt;当我们执行channel的close操作的时候会关闭channel。&lt;/p&gt;
&lt;p&gt;关闭的主要流程如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取全局锁；&lt;/li&gt;
&lt;li&gt;设置channel数据结构chan的关闭标志位；&lt;/li&gt;
&lt;li&gt;获取当前channel上面的读goroutine并链接成链表；&lt;/li&gt;
&lt;li&gt;获取当前channel上面的写goroutine然后拼接到前面的读链表后面；&lt;/li&gt;
&lt;li&gt;释放全局锁；&lt;/li&gt;
&lt;li&gt;唤醒所有的读写goroutine。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。&lt;/p&gt;
&lt;p&gt;除此之外，panic出现的常见场景还有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关闭值为nil的channel&lt;/li&gt;
&lt;li&gt;关闭已经被关闭的channel&lt;/li&gt;
&lt;li&gt;向已经关闭的channel写数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;section4-常见用法&#34;&gt;Section4 常见用法&lt;/h1&gt;
&lt;h2 id=&#34;41-单向channel&#34;&gt;4.1 单向channel&lt;/h2&gt;
&lt;p&gt;单向channel指只能用于发送或接收数据，实际上并没有单向channel。&lt;/p&gt;
&lt;p&gt;我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;func readChan(chanName &amp;lt;-chan int)： 通过形参限定函数内部只能从channel中读取数据&lt;/li&gt;
&lt;li&gt;func writeChan(chanName chan&amp;lt;- int)： 通过形参限定函数内部只能向channel中写入数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个简单的示例程序如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;writeChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mychan&lt;/span&gt; = make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;writeChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;mychan&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;readChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;mychan&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来写。&lt;/p&gt;
&lt;h2 id=&#34;42-select&#34;&gt;4.2 select&lt;/h2&gt;
&lt;p&gt;使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。&lt;/p&gt;
&lt;p&gt;一个简单的示例程序如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addNumberToChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Second&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chan1&lt;/span&gt; = make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chan2&lt;/span&gt; = make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addNumberToChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;chan1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addNumberToChan&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;chan2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chan1&lt;/span&gt; :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Get element from chan1: %d\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chan2&lt;/span&gt; :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Get element from chan2: %d\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;No element in chan1 and chan2.\n&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Second&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。&lt;/p&gt;
&lt;p&gt;程序输出如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;D:&lt;span style=&#34;color:#ae81ff&#34;&gt;\S&lt;/span&gt;ourceCode&lt;span style=&#34;color:#ae81ff&#34;&gt;\G&lt;/span&gt;oExpert&lt;span style=&#34;color:#ae81ff&#34;&gt;\s&lt;/span&gt;rc&amp;gt;go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get element from chan1: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get element from chan2: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;No element in chan1 and chan2.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get element from chan2: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get element from chan1: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;No element in chan1 and chan2.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get element from chan2: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Get element from chan1: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;No element in chan1 and chan2.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的，关于select的实现原理会有专门章节分析。&lt;/p&gt;
&lt;p&gt;通过这个示例想说的是：&lt;strong&gt;select的case语句读channel不会阻塞&lt;/strong&gt;，尽管channel中没有数据。这是由于case语句编译后调用读channel时会&lt;strong&gt;明确传入不阻塞的参数&lt;/strong&gt;，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。&lt;/p&gt;
&lt;h2 id=&#34;43-range&#34;&gt;4.3 range&lt;/h2&gt;
&lt;p&gt;通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chanRange&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chanName&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Get element from chan: %d\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go 八股</title>
        <link>https://lxb.wiki/30fc3293/</link>
        <pubDate>Sun, 10 Oct 2021 21:18:51 +0000</pubDate>
        
        <guid>https://lxb.wiki/30fc3293/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;1-相比较于其他语言-go-有什么优势或者特点&#34;&gt;&lt;strong&gt;1. 相比较于其他语言, Go 有什么优势或者特点？&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Go 允许跨平台编译，编译出来的是二进制的可执行文件，直接部署在对应系统上即可运行。&lt;/li&gt;
&lt;li&gt;Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型， 即所谓的&lt;code&gt;通过通信来共享内存&lt;/code&gt;；Go 在 runtime 运行时里实现了属于自己的调度机制：GMP，降低了内核态和用户态的切换成本。&lt;/li&gt;
&lt;li&gt;Go 的代码风格是强制性的统一，如果没有按照规定来，会编译不通过。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-golang-里的-gmp-模型&#34;&gt;&lt;strong&gt;2. Golang 里的 GMP 模型？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;GMP 模型是 golang 自己的一个调度模型，它抽象出了下面三个结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;G：&lt;/code&gt; 也就是协程 goroutine，由 Go runtime 管理。我们可以认为它是用户级别的线程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P：&lt;/code&gt; processor 处理器。每当有 goroutine 要创建时，会被添加到 P 上的 goroutine 本地队列上，如果 P 的本地队列已满，则会维护到全局队列里。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M：&lt;/code&gt; 系统线程。在 M 上有调度函数，它是真正的调度执行者，M 需要跟 P 绑定，并且会让 P 按下面的原则挑出个 goroutine 来执行：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先从 P 的本地队列获取 goroutine 来执行；如果本地队列没有，从全局队列获取，如果全局队列也没有，会从其他的 P 上偷取 goroutine。&lt;/p&gt;
&lt;h2 id=&#34;3-goroutine-的协程有什么特点和线程相比&#34;&gt;&lt;strong&gt;3. goroutine 的协程有什么特点，和线程相比？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;goroutine 非常的&lt;strong&gt;轻量&lt;/strong&gt;，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。&lt;/p&gt;
&lt;p&gt;而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。&lt;/p&gt;
&lt;h2 id=&#34;4-go-的垃圾回收机制&#34;&gt;&lt;strong&gt;4. Go 的垃圾回收机制？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Go 采用的是三色标记法，将内存里的对象分为了三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色对象：未被使用的对象；&lt;/li&gt;
&lt;li&gt;灰色对象：当前对象有引用对象，但是还没有对引用对象继续扫描过；&lt;/li&gt;
&lt;li&gt;黑色对象，对上面提到的灰色对象的引用对象已经全部扫描过了，下次不用再扫描它了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当垃圾回收开始时，Go 会把根对象标记为灰色，其他对象标记为白色，然后从根对象遍历搜索，按照上面的定义去不断的对灰色对象进行扫描标记。当没有灰色对象时，表示所有对象已扫描过，然后就可以开始清除白色对象了。&lt;/p&gt;
&lt;h2 id=&#34;5-go-的内存分配是怎么样的&#34;&gt;&lt;strong&gt;5. go 的内存分配是怎么样的？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Go 的内存分配借鉴了 Google 的 TCMalloc 分配算法，其核心思想是内存池 + 多级对象管理。内存池主要是预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan、arenas、mcentral、mcache。它们以 mspan 作为基本分配单位。具体的分配逻辑如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当要分配大于 32K 的对象时，从 mheap 分配。&lt;/li&gt;
&lt;li&gt;当要分配的对象小于等于 32K 大于 16B 时，从 P 上的 mcache 分配，如果 mcache 没有内存，则从 mcentral 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则从操作系统申请内存。&lt;/li&gt;
&lt;li&gt;当要分配的对象小于等于 16B 时，从 mcache 上的微型分配器上分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-channel-的内部实现是怎么样的&#34;&gt;&lt;strong&gt;6. channel 的内部实现是怎么样的？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;channel 内部维护了两个 goroutine 队列，一个是待发送数据的 goroutine 队列，另一个是待读取数据的 goroutine 队列。&lt;/p&gt;
&lt;p&gt;每当对 channel 的读写操作超过了可缓冲的 goroutine 数量，那么当前的 goroutine 就会被挂到对应的队列上，直到有其他 goroutine 执行了与之相反的读写操作，将它重新唤起。&lt;/p&gt;
&lt;h2 id=&#34;7-对已经关闭的-channel-进行读写会怎么样&#34;&gt;&lt;strong&gt;7. 对已经关闭的 channel 进行读写，会怎么样？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当 channel 被关闭后，如果继续往里面写数据，程序会直接 &lt;strong&gt;panic&lt;/strong&gt; 退出。如果是读取关闭后的 channel，不会产生 pannic，还可以读到数据。但关闭后的 channel 没有数据可读取时，将得到零值，即对应类型的默认值。&lt;/p&gt;
&lt;p&gt;为了能知道当前 channel 是否被关闭，可以使用下面的写法来判断。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; if v, ok := &amp;lt;-ch; !ok {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmt.Println(&amp;#34;channel 已关闭，读取不到数据&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还可以使用下面的写法不断的获取 channel 里的数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; for data := range ch {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  // get data dosomething
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种用法会在读取完 channel 里的数据后就结束 for 循环，执行后面的代码。&lt;/p&gt;
&lt;h2 id=&#34;8-map-为什么不是线程安全的&#34;&gt;&lt;strong&gt;8. map 为什么不是线程安全的？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;map 在扩缩容时，需要进行数据迁移，迁移的过程并没有采用锁机制防止并发操作，而是会对某个标识位标记为 1，表示此时正在迁移数据。如果有其他 goroutine 对 map 也进行写操作，当它检测到标识位为 1 时，将会直接 panic。&lt;/p&gt;
&lt;p&gt;如果我们想要并发安全的 map，则需要使用 sync.map。&lt;/p&gt;
&lt;h2 id=&#34;9-map-的-key-为什么得是可比较类型的&#34;&gt;&lt;strong&gt;9. map 的 key 为什么得是可比较类型的？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;map 的 key、value 是存在 buckets 数组里的，每个 bucket 又可以容纳 8 个 key 和 8 个 value。当要插入一个新的 key - value 时，会对 key 进行 hash 运算得到一个 hash 值，然后根据 hash 值 的低几位(取几位取决于桶的数量，比如一开始桶的数量是 5，则取低 5 位)来决定命中哪个 bucket。&lt;/p&gt;
&lt;p&gt;在命中某个 bucket 后，又会根据 hash 值的高 8 位来决定是 8 个 key 里的哪个位置。如果不巧，发生了 hash 冲突，即该位置上已经有&lt;strong&gt;其他 key&lt;/strong&gt; 存在了，则会去其他空位置寻找插入。如果全都满了，则使用 overflow 指针指向一个新的 bucket，重复刚刚的寻找步骤。&lt;/p&gt;
&lt;p&gt;从上面的流程可以看出，在判断 hash 冲突，即该位置是否已有&lt;strong&gt;其他 key&lt;/strong&gt; 时，肯定是要进行比较的，所以 key 必须得是可比较类型的。像 slice、map、function 就不能作为 key。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>go map数据结构</title>
        <link>https://lxb.wiki/aaf3975f/</link>
        <pubDate>Sat, 28 Aug 2021 22:30:18 +0000</pubDate>
        
        <guid>https://lxb.wiki/aaf3975f/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h1&gt;
&lt;p&gt;go的map底层实现方式是hash表（C++的map是红黑树实现，而C++ 11新增的unordered_map则与go的map类似，都是hash实现）。go map的数据被置入一个由桶组成的有序数组中，每个桶最多可以存放8个key/value对。key的hash值(32位)的低阶位用于在该数组中定位到桶，而高8位则用于在桶中区分key/value对。
go map的hash表中的基本单位是桶，每个桶最多存8个键值对，超了，则会链接到额外的溢出桶。所以go map是基本数据结构是hash数组+桶内的key-value数组+溢出的桶链表
当hash表超过阈值需要扩容增长时，会分配一个新的数组，新数组的大小一般是旧数组的2倍。这里从旧数组将数据迁移到新数组，不会一次全量拷贝，go会在每次读写Map时以桶为单位做动态搬迁疏散。&lt;/p&gt;
&lt;h1 id=&#34;2-go-map的数据结构&#34;&gt;2. go map的数据结构&lt;/h1&gt;
&lt;h2 id=&#34;21-核心结体体&#34;&gt;2.1 核心结体体&lt;/h2&gt;
&lt;p&gt;map主要由两个核心的结构，即基础结构和桶实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hmap：map的基础结构&lt;/li&gt;
&lt;li&gt;bmap：严格来说hmap.buckets指向桶组成的数组，每个桶的头部是bmap，之后是8个key，再是8个value，最后是1个溢出指针。溢出指针指向额外的桶链表，用于存储溢出的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ( &lt;span style=&#34;color:#75715e&#34;&gt;// 关键的变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCntBits&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;     = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCntBits&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 一个桶最多存储8个key-value对
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;loadFactorNum&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 扩散因子：loadFactorNum / loadFactorDen = 6.5。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;loadFactorDen&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 即元素数量 &amp;gt;= (hash桶数量(2^hmp.B) * 6.5 / 8) 时，触发扩容
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// map的基础数据结构
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;	 &lt;span style=&#34;color:#75715e&#34;&gt;// map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 记录几个特殊的位标记，如当前是否有别的线程正在写map、当前是否为相同大小的增长（扩容/缩容？）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// hash桶buckets的数量为2^B个
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;noverflow&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 溢出的桶的数量的近似值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;hash0&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// hash种子
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 指向2^B个桶组成的数组的指针，数据存在这里
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;oldbuckets&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 指向扩容前的旧buckets数组，只在map增长时有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;nevacuate&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 计数器，标示扩容后搬迁的进度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;extra&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mapextra&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 保存溢出桶的链表和未使用的溢出桶数组的首地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 桶的实现结构
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bmap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// tophash存储桶内每个key的hash值的高字节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// tophash[0] &amp;lt; minTopHash表示桶的疏散状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt; [&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 特别注意：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 实际分配内存时会申请一个更大的内存空间A，A的前8字节为bmap
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 后面依次跟8个key、8个value、1个溢出指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// map的桶结构实际指的是内存空间A
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// map.go里很多函数的第1个入参是这个结构，从成员来看很明显，此结构标示了键值对和桶的大小等必要信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 有了这个结构的信息，map.go的代码就可以与键值对的具体数据类型解耦
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 所以map.go用内存偏移量和unsafe.Pointer指针来直接对内存进行存取，而无需关心key或value的具体类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;typ&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;       &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;     &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_type&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// internal type representing a hash bucket
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;keysize&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// size of key slot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;valuesize&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// size of value slot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketsize&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// size of bucket
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++使用模板可以根据不同的类型生成map的代码。
golang则通过上述maptype结构体传递键值对的类型大小等信息，从而map.go直接用指针操作对应大小的内存来实现全局一份map代码同时适用于不同类型的键值对。这点上可以认为相比C++用模板实现map的方式，go map的目标文件的代码量会更小。&lt;/p&gt;
&lt;h2 id=&#34;22-数据结构图&#34;&gt;2.2 数据结构图&lt;/h2&gt;
&lt;p&gt;map底层创建时，会初始化一个hmap结构体，同时分配一个足够大的内存空间A。其中A的前段用于hash数组，A的后段预留给溢出的桶。于是hmap.buckets指向hash数组，即A的首地址；hmap.extra.nextOverflow初始时指向内存A中的后段，即hash数组结尾的下一个桶，也即第1个预留的溢出桶。所以当hash冲突需要使用到新的溢出桶时，会优先使用上述预留的溢出桶，hmap.extra.nextOverflow依次往后偏移直到用完所有的溢出桶，才有可能会申请新的溢出桶空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20220226143452.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图中，当需要分配一个溢出桶时，会优先从预留的溢出桶数组里取一个出来链接到链表后面，这时不需要再次申请内存。但当预留的桶被用完了，则需要申请新的内存给溢出桶。&lt;/p&gt;
&lt;h1 id=&#34;3-go-map的常用操作&#34;&gt;3. go map的常用操作&lt;/h1&gt;
&lt;h2 id=&#34;31-创建&#34;&gt;3.1 创建&lt;/h2&gt;
&lt;p&gt;使用make(map[k]v, hint)创建map时会调用makemap()函数，代码逻辑比较简单。
值得注意的是，makemap()创建的hash数组，数组的前面是hash表的空间，当hint &amp;gt;= 4时后面会追加2^(hint-4)个桶，之后再内存页帧对齐又追加了若干个桶（参见2.2章节结构图的hash数组部分）
所以创建map时一次内存分配既分配了用户预期大小的hash数组，又追加了一定量的预留的溢出桶，还做了内存对齐，一举多得。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// make(map[k]v, hint), hint即预分配大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 不传hint时，如用new创建个预设容量为0的map时，makemap只初始化hmap结构，不分配hash数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makemap&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hint&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 省略部分代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 随机hash种子
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;hash0&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;fastrand&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 2^h.B 为大于hint*6.5(扩容因子)的最小的2的幂
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; uint8(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// overLoadFactor(hint, B)只有一行代码：return hint &amp;gt; bucketCnt &amp;amp;&amp;amp; uintptr(hint) &amp;gt; loadFactorNum*(bucketShift(B)/loadFactorDen)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 即B的大小应满足 hint &amp;lt;= (2^B) * 6.5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 一个桶能存8对key-value，所以这就表示B的初始值是保证这个map不需要扩容即可存下hint个元素对的最小的B值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;overLoadFactor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;hint&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 这里分配hash数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bmap&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;makeBucketArray&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// makeBucketArray()会在hash数组后面预分配一些溢出桶，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// h.extra.nextOverflow用来保存上述溢出桶的首地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;extra&lt;/span&gt; = new(&lt;span style=&#34;color:#a6e22e&#34;&gt;mapextra&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;extra&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 分配hash数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makeBucketArray&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;dirtyalloc&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bmap&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;base&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketShift&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// base代表用户预期的桶的数量，即hash数组的真实大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;nbuckets&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// nbuckets表示实际分配的桶的数量，&amp;gt;= base，这就可能会追加一些溢出桶作为溢出的预留
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 这里追加一定数量的桶，并做内存对齐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;nbuckets&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketShift&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;sz&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nbuckets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;up&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;roundupsize&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;sz&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;up&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sz&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;nbuckets&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;up&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 后面的代码就是申请内存空间了，此处省略
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 这里大家可以思考下这个数组空间要怎么分配，其实就是n*sizeof(桶)，所以：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 每个桶前面是8字节的tophash数组，然后是8个key，再是8个value，最后放一个溢出指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// sizeof(桶) = 8 + 8*sizeof(key) + 8*sizeof(value) + 8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;nextOverflow&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;32-插入或更新&#34;&gt;3.2 插入或更新&lt;/h2&gt;
&lt;p&gt;go map的插入操作，调用mapassign()函数。
同学们或许在某些资料上了解过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go map需要初始化才能使用，对空map插入会panic。hmap指针传递的方式，决定了map在使用前必须初始化&lt;/li&gt;
&lt;li&gt;go map不支持并发读写，会panic。如果一定要并发，请用sync.Map或自己解决冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述两个限制，在mapassign()函数开头能找到答案：&lt;/p&gt;
&lt;p&gt;1 参数合法性检测，计算hash值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapassign&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 不熟悉指针操作的同学，用指针传参往往会踩空指针的坑
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这里大家可以思考下，为什么h要非空判断？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 如果一定要在这里支持空map并检测到map为空时自动初始化，应该怎么写？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 提示：指针的指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		panic(&lt;span style=&#34;color:#a6e22e&#34;&gt;plainError&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;assignment to entry in nil map&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 在这里做并发判断，检测到并发写时，抛异常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 注意：go map的并发检测是伪检测，并不保证所有的并发都会被检测出来。而且这玩意是在运行期检测。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 所以对map有并发要求时，应使用sync.map来代替普通map，通过加锁来阻断并发冲突
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hashWriting&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;throw&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;concurrent map writes&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;, uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;hash0&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 这里得到uint32的hash值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt; ^= &lt;span style=&#34;color:#a6e22e&#34;&gt;hashWriting&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 置Writing标志，key写入buckets后才会清除标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// map不能为空，但hash数组可以初始是空的，这里会初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;newobject&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// newarray(t.bucket, 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2 定位key在hash表中的位置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapassign&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;again&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketMask&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 这里用hash值的低阶位定位hash数组的下标偏移量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;growing&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;growWork&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 这里是map的扩容缩容操作，我们在第4章单独讲
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 通过下标bucket，偏移定位到具体的桶
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bmap&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketsize&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;top&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 这里取高8位用于在桶内定位键值对
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3 进一步定位key可以插入的桶及桶中的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两轮循环，外层循环遍历hash桶及其指向的溢出链表，内层循环则在桶内遍历（一个桶最多8个key-value对）&lt;/li&gt;
&lt;li&gt;有可能正好链表上的桶都满了，这时inserti为nil，第4步会链接一个新的溢出桶进来&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapassign&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inserti&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// tophash插入位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// key插入位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// value插入位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketloop&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; uintptr(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;top&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inserti&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				    &lt;span style=&#34;color:#75715e&#34;&gt;// 找到个空位，先记录下tophash、key、value的插入位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;				    &lt;span style=&#34;color:#75715e&#34;&gt;// 但要遍历完才能确定要不要插入到这个位置，因为后面有可能有重复的元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#a6e22e&#34;&gt;inserti&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;dataOffset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;keysize&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;dataOffset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;keysize&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;valuesize&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;emptyRest&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketloop&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历完整个溢出链表，退出循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;dataOffset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;keysize&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indirectkey&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;alg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// 走到这里说明map里找到一个重复的key，更新key-value，跳到第5步
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;needkeyupdate&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#a6e22e&#34;&gt;typedmemmove&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;dataOffset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;keysize&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;valuesize&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;done&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 更新Key后跳到第5步
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;ovf&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ovf&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历完整个溢出链表，没找到能插入的空位，结束循环，下一步再追加一个溢出桶进来
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;ovf&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 继续遍历下一个溢出桶
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4 插入 key&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapassign&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这里判断要不要扩容，我们第4章再讲
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;growing&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;overLoadFactor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tooManyOverflowBuckets&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;noverflow&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;hashGrow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;again&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Growing the table invalidates everything, so try again
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inserti&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// inserti == nil说明上1步没找到空位，整个链表是满的，这里添加一个新的溢出桶上去
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;newb&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;newoverflow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 分配新溢出桶，优先用3.1章节预留的溢出桶，用完了则分配一个新桶内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;inserti&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;newb&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;newb&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;dataOffset&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;keysize&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 当key或value的类型大小超过一定值时，桶只存储key或value的指针。这里分配空间并取指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indirectkey&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;kmem&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newobject&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt;) = &lt;span style=&#34;color:#a6e22e&#34;&gt;kmem&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;kmem&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indirectvalue&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;vmem&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newobject&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;elem&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;) = &lt;span style=&#34;color:#a6e22e&#34;&gt;vmem&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;typedmemmove&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;insertk&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 在桶中对应位置插入key
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inserti&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;top&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 插入tophash，hash值高8位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 插入了新的键值对，h.count数量+1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5 结束插入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapassign&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;done&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hashWriting&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;throw&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;concurrent map writes&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;^=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hashWriting&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 释放hashWriting标志位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indirectvalue&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 返回value可插入位置的指针，注意，value还没插入
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;只插入了tophash和key，就结束了吗？value还没插入呢&lt;/li&gt;
&lt;li&gt;是的，mapassign()只插入tophash和key，并返回val指针，编译器会在调用mapassign()后用汇编往val插入value&lt;/li&gt;
&lt;li&gt;google大佬这么骚气的操作，是为了减少value值传递的次数吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33-删除&#34;&gt;3.3 删除&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;删除与插入类似，前面的步骤都是参数和状态判断、定位key-value位置，然后clear对应的内存。不展开说。以下是几个关键点：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;删除过程中也会置hashWriting标志&lt;/li&gt;
&lt;li&gt;当key/value过大时，hash表里存储的是指针，这时候用软删除，置指针为nil，数据交给gc去删。当然，这是map的内部处理，外层是无感知的，拿到的都是值拷贝&lt;/li&gt;
&lt;li&gt;无论Key/value是值类型还是指针类型，删除操作都只影响hash表，外层已经拿到的数据不受影响。尤其是指针类型，外层的指针还能继续使用&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;由于定位key位置的方式是查找tophash，所以删除操作对tophash的处理是关键：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;map首先将对应位置的tophash[i]置为emptyOne，表示该位置已被删除&lt;/li&gt;
&lt;li&gt;如果tophash[i]不是整个链表的最后一个，则只置emptyOne标志，该位置被删除但未释放，后续插入操作不能使用此位置&lt;/li&gt;
&lt;li&gt;如果tophash[i]是链表最后一个有效节点了，则把链表最后面的所有标志为emptyOne的位置，都置为emptyRest。置为emptyRest的位置可以在后续的插入操作中被使用。&lt;/li&gt;
&lt;li&gt;这种删除方式，以少量空间来避免桶链表和桶内的数据移动。事实上，go 数据一旦被插入到桶的确切位置，map是不会再移动该数据在桶中的位置了。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapdelete&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;emptyOne&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 先标记删除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// 如果b.tophash[i]不是最后一个元素，则暂时先占着坑。emptyOne标记的位置暂时不能被插入新元素(见3.2章节插入函数)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;emptyRest&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notLast&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;emptyRest&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notLast&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// 如果b.tophash[i]是最后一个元素，则把末尾的emptyOne全部清除置为emptyRest
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;emptyRest&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bOrig&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;						&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// beginning of initial bucket, we&amp;#39;re done.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;					}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#75715e&#34;&gt;// Find previous bucket, continue at its last entry.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;bOrig&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tophash&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;emptyOne&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;34-查找&#34;&gt;3.4 查找&lt;/h2&gt;
&lt;p&gt;查找操作由mapaccess开头的一组函数实现。前面的章节在插入和删除之前都得先定位查找到元素，逻辑是类似的，也比较简单，就不细说了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mapaccess1()：通过Key查找，返回value指针，用于val := map[key]。未找到时返回value类型的0值。&lt;/li&gt;
&lt;li&gt;mapaccess2()：通过key查找，返回value指针，以及bool类型的是否查找成功的标志，用于val, ok := map[key]。未找到时返回value类型的0值。&lt;/li&gt;
&lt;li&gt;mapaccessK()：通过key查找，返回key和value指针，用于迭代器(range)。未找到时返回空指针&lt;/li&gt;
&lt;li&gt;mapaccess1_fat()，对mapaccess1()的封装，区别是mapaccess1_fat()多了个zero参数，未找到时返回zero&lt;/li&gt;
&lt;li&gt;mapaccess2_fat()，也是对mapaccess1()的封装。相比mapaccess1_fat()，本函数增加一个是否查找成功的标志&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;35-range迭代&#34;&gt;3.5 range迭代&lt;/h2&gt;
&lt;p&gt;map的迭代是通过hiter结构和对应的两个辅助函数实现的。hiter结构由编译器在调用辅助函数之前创建并传入，每次迭代结果也由hiter结构传回。下方的it即是hiter结构体的指针变量。&lt;/p&gt;
&lt;h3 id=&#34;351-初始化迭代器mapiterinit&#34;&gt;3.5.1 初始化迭代器mapiterinit()&lt;/h3&gt;
&lt;p&gt;mapiterinit()函数主要是决定我们从哪个位置开始迭代，为什么是从哪个位置，而不是直接从hash数组头部开始呢？《go程序设计语言》好像提到过，hash表中数据每次插入的位置是变化的（其实是因为实现的原因，一方面hash种子是随机的，这导致相同的数据在不同的map变量内的hash值不同；另一方面即使同一个map变量内，数据删除再添加的位置也有可能变化，因为在同一个桶及溢出链表中数据的位置不分先后），所以为了防止用户错误的依赖于每次迭代的顺序，map作者干脆让相同的map每次迭代的顺序也是随机的。
迭代顺序随机的实现方式也简单，直接从随机的一个位置开始就行了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it.startBucket：这个是hash数组的偏移量，表示遍历从这个桶开始&lt;/li&gt;
&lt;li&gt;it.offset：这个是桶内的偏移量，表示每个桶的遍历都从这个偏移量开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，map的遍历过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从hash数组中第it.startBucket个桶开始，先遍历hash桶，然后是这个桶的溢出链表。&lt;/li&gt;
&lt;li&gt;之后hash数组偏移量+1，继续前一步动作。&lt;/li&gt;
&lt;li&gt;遍历每一个桶，无论是hash桶还是溢出桶，都从it.offset偏移量开始。（如果只是随机一个开始的桶，range结果还是有序的；但每个桶都加it.offset偏移，这个输出结果就有点扑朔迷离，大家可以亲手试下，对同一个map多次range）&lt;/li&gt;
&lt;li&gt;当迭代器经过一轮循环回到it.startBucket的位置，结束遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapiterinit&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hiter&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 随机一个偏移量来开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;fastrand&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCntBits&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;fastrand&lt;/span&gt;()) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;startBucket&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketMask&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;offset&lt;/span&gt; = uint8(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;mapiternext&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化迭代器的同时也返回第1对key/value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;352-迭代过程mapiternext&#34;&gt;3.5.2 迭代过程mapiternext()&lt;/h3&gt;
&lt;p&gt;上一节迭代循环的过程很清晰了，这里我们说明几个重要的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it.startBucket：开始的桶&lt;/li&gt;
&lt;li&gt;it.offset：每个桶开始的偏移量&lt;/li&gt;
&lt;li&gt;it.bptr：当前遍历的桶&lt;/li&gt;
&lt;li&gt;it.i：it.bptr已经遍历的键值对数量，i初始为0，当i=8时表示这个桶遍历完了，将it.bptr移向下一个桶&lt;/li&gt;
&lt;li&gt;it.key：每次迭代的结果&lt;/li&gt;
&lt;li&gt;it.value：每次迭代的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，迭代还需要关注扩容缩容的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是在迭代开始后才growing，这种情况当前的逻辑没处理，迭代有可能异常。呃，go map不支持并发。&lt;/li&gt;
&lt;li&gt;如果是先growing，再开始迭代，这是有可能的。这种情况下，会先到旧hash表中检查key对应的桶有没有被疏散，未疏散则遍历旧桶，已疏散则遍历新hash表里对应的桶。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-go-map的扩容缩容&#34;&gt;4. go map的扩容缩容&lt;/h1&gt;
&lt;h2 id=&#34;41-扩容缩容的基本原理&#34;&gt;4.1 扩容缩容的基本原理&lt;/h2&gt;
&lt;p&gt;go map的扩容缩容都是grow相关的函数，这里扩容是真的，缩容是伪缩容，后面我会解释。我们先看下触发条件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mapassign&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;growing&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;overLoadFactor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tooManyOverflowBuckets&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;noverflow&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;hashGrow&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;again&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Growing the table invalidates everything, so try again
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// overLoadFactor()返回true则触发扩容，即map的count大于hash桶数量(2^B)*6.5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;overLoadFactor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucketCnt&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;loadFactorNum&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;bucketShift&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;loadFactorDen&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// tooManyOverflowBuckets()，顾名思义，溢出桶太多了触发缩容
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tooManyOverflowBuckets&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;noverflow&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;noverflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; uint16(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;map只在插入元素即mapassign()函数中对是否扩容缩容进行触发，条件即是上面这段代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件1：当前不处在growing状态&lt;/li&gt;
&lt;li&gt;条件2-1：触发扩容：map的数据量count大于hash桶数量(2B)*6.5。注意这里的(2B)只是hash数组大小，不包括溢出的桶&lt;/li&gt;
&lt;li&gt;条件2-2：触发缩容：溢出的桶数量noverflow&amp;gt;=32768(1&amp;laquo;15)或者&amp;gt;=hash数组大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔细观察触发的代码，扩容和缩容是同一个函数，这是怎么做到的呢？在hashGrow()开始，会先判断是否满足扩容条件，如果满足就表明这次是扩容，不满足就一定是缩容条件触发了。扩容和缩容剩下的逻辑，主要区别就在于容量变化，就是hmap.B参数，扩容时B+1则hash表容量扩大1倍，缩容时hash表容量不变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;h.oldbuckets：指向旧的hash数组，即当前的h.buckets&lt;/li&gt;
&lt;li&gt;h.buckets：指向新创建的hash数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里触发的主要工作已经完成，接下来就是怎么把元素搬迁到新hash表里了。如果现在就一次全量搬迁过去，显然接下来会有比较长的一段时间map被占用（不支持并发）。所以搬迁的工作是异步增量搬迁的。
在插入和删除的函数内都有下面一段代码用于在每次插入和删除操作时，执行一次搬迁工作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;growing&lt;/span&gt;() { &lt;span style=&#34;color:#75715e&#34;&gt;// 当前处于搬迁状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;growWork&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 调用搬迁函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;growWork&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 将当前需要处理的桶搬迁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;evacuate&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;oldbucketmask&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;growing&lt;/span&gt;() { &lt;span style=&#34;color:#75715e&#34;&gt;// 再多搬迁一个桶
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;evacuate&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nevacuate&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;每执行一次插入或删除，都会调用growWork搬迁0~2个hash桶（有可能这次需要搬迁的2个桶在此之前都被搬过了）&lt;/li&gt;
&lt;li&gt;搬迁是以hash桶为单位的，包含对应的hash桶和这个桶的溢出链表&lt;/li&gt;
&lt;li&gt;被delete掉的元素(emptyone标志)会被舍弃（这是缩容的关键）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-为什么叫伪缩容如何实现真缩容&#34;&gt;4.2 为什么叫“伪缩容”？如何实现“真缩容”？&lt;/h2&gt;
&lt;p&gt;现在可以解释为什么我把map的缩容叫做伪缩容了：因为缩容仅仅针对溢出桶太多的情况，触发缩容时hash数组的大小不变，即hash数组所占用的空间只增不减。也就是说，如果我们把一个已经增长到很大的map的元素挨个全部删除掉，hash表所占用的内存空间也不会被释放。&lt;/p&gt;
&lt;p&gt;所以如果要实现“真缩容”，需自己实现缩容搬迁，即创建一个较小的map，将需要缩容的map的元素挨个搬迁过来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// go map缩容代码示例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myMap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 假设这里我们对bigMap做了很多次插入，之后又做了很多次删除，此时bigMap的元素数量远小于hash表大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 接下来我们开始缩容
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;smallMap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;myMap&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myMap&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;smallMap&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myMap&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;smallMap&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 缩容完成，原来的map被我们丢弃，交给gc去清理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;5-qa关键知识点&#34;&gt;5 Q&amp;amp;A关键知识点&lt;/h1&gt;
&lt;h2 id=&#34;51-基本原理&#34;&gt;5.1 基本原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;底层是hash实现，数据结构为hash数组 + 桶 + 溢出的桶链表，每个桶存储最多8个key-value对&lt;/li&gt;
&lt;li&gt;查找和插入的原理：key的hash值（低阶位）与桶数量相与，得到key所在的hash桶，再用key的高8位与桶中的tophash[i]对比，相同则进一步对比key值，key值相等则找到&lt;/li&gt;
&lt;li&gt;go map不支持并发。插入、删除、搬迁等操作会置writing标志，检测到并发直接panic&lt;/li&gt;
&lt;li&gt;每次扩容hash表增大1倍，hash表只增不减&lt;/li&gt;
&lt;li&gt;支持有限缩容，delete操作只置删除标志位，释放溢出桶的空间依靠触发缩容来实现。&lt;/li&gt;
&lt;li&gt;map在使用前必须初始化，否则panic：已初始化的map是make(map[key]value)或make(map[key]value, hint)这两种形式。而new或var xxx map[key]value这两种形式是未初始化的，直接使用会panic。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-时间复杂度和空间复杂度分析&#34;&gt;5.2 时间复杂度和空间复杂度分析&lt;/h2&gt;
&lt;p&gt;时间复杂度，go map是hash实现，我们先不管具体原理，江湖套路hash实现的就叫它O(1)的时间复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正常情况，且不考虑扩容状态，复杂度O(1)：通过hash值定位桶是O(1)，一个桶最多8个元素，合理的hash算法应该能把元素相对均匀散列，所以溢出链表（如果有）也不会太长，所以虽然在桶和溢出链表上定位key是遍历，考虑到数量小也可以认为是O(1)&lt;/li&gt;
&lt;li&gt;正常情况，处于扩容状态时，复杂度也是O(1)：相比于上一种状态，扩容会增加搬迁最多2个桶和溢出链表的时间消耗，当溢出链表不太长时，复杂度也可以认为是O(1)&lt;/li&gt;
&lt;li&gt;极端情况，散列极不均匀，大部分数据被集中在一条散列链表上，复杂度退化为O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go采用的hash算法应是很成熟的算法，极端情况暂不考虑。所以综合情况下go map的时间复杂度应为O(1)&lt;/p&gt;
&lt;p&gt;空间复杂度分析：
首先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在go是留给程序员自己解决），只考虑一个持续增长状态的map的一个空间使用率：
由于溢出桶数量超过hash桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash表基本是空的，这时空间浪费O(n)。
最好的情况下，数据均匀散列在hash表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前go的扩散因子由全局变量决定，即loadFactorNum/loadFactorDen = 6.5。即平均每个hash桶被分配到6.5个元素以上时，开始扩容。所以最小的空间浪费是(8-6.5)/8 = 0.1875，即O(0.1875n)&lt;/p&gt;
&lt;p&gt;结论：go map的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是O(0.1875n) ~ O(n)之间。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】使用 gosec 检查 Go 代码中的安全问题</title>
        <link>https://lxb.wiki/a59515fd/</link>
        <pubDate>Mon, 19 Oct 2020 23:36:00 +0000</pubDate>
        
        <guid>https://lxb.wiki/a59515fd/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;来学习下 Go 语言的安全检查工具 gosec。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.linux.net.cn/data/attachment/album/202010/04/125129bh4qxxsyqpvqjtx4.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 语言&lt;/a&gt;写的代码越来越常见，尤其是在容器、Kubernetes 或云生态相关的开发中。Docker 是最早采用 Golang 的项目之一，随后是 Kubernetes，之后大量的新项目在众多编程语言中选择了 Go。&lt;/p&gt;
&lt;p&gt;像其他语言一样，Go 也有它的长处和短处（如安全缺陷）。这些缺陷可能会因为语言本身的缺陷加上程序员编码不当而产生，例如，C 代码中的内存安全问题。&lt;/p&gt;
&lt;p&gt;无论它们出现的原因是什么，安全问题都应该在开发过程的早期修复，以免在封装好的软件中出现。幸运的是，静态分析工具可以帮你以更可重复的方式处理这些问题。静态分析工具通过解析用某种编程语言写的代码来找到问题。&lt;/p&gt;
&lt;p&gt;这类工具中很多被称为 linter。传统意义上，linter 更注重的是检查代码中编码问题、bug、代码风格之类的问题，它们可能不会发现代码中的安全问题。例如，&lt;a class=&#34;link&#34; href=&#34;https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Coverity&lt;/a&gt; 是一个很流行的工具，它可以帮助寻找 C/C++ 代码中的问题。然而，也有一些工具专门用来检查源码中的安全问题。例如，&lt;a class=&#34;link&#34; href=&#34;https://pypi.org/project/bandit/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bandit&lt;/a&gt; 可以检查 Python 代码中的安全缺陷。而 &lt;a class=&#34;link&#34; href=&#34;https://github.com/securego/gosec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gosec&lt;/a&gt; 则用来搜寻 Go 源码中的安全缺陷。&lt;code&gt;gosec&lt;/code&gt; 通过扫描 Go 的 AST（抽象语法树abstract syntax tree&lt;!-- raw HTML omitted --&gt;抽象语法树&lt;!-- raw HTML omitted --&gt;abstract syntax tree&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;）来检查源码中的安全问题。&lt;/p&gt;
&lt;h3 id=&#34;开始使用-gosec&#34;&gt;开始使用 gosec&lt;/h3&gt;
&lt;p&gt;在开始学习和使用 &lt;code&gt;gosec&lt;/code&gt; 之前，你需要准备一个 Go 语言写的项目。有这么多开源软件，我相信这不是问题。你可以在 GitHub 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/trending/go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;热门 Golang 仓库&lt;/a&gt;中找一个。&lt;/p&gt;
&lt;p&gt;本文中，我随机选了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/docker/docker-ce&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker CE&lt;/a&gt; 项目，但你可以选择任意的 Go 项目。&lt;/p&gt;
&lt;h4 id=&#34;安装-go-和-gosec&#34;&gt;安装 Go 和 gosec&lt;/h4&gt;
&lt;p&gt;如果你还没安装 Go，你可以先从仓库中拉取下来。如果你用的是 Fedora 或其他基于 RPM 的 Linux 发行版本：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ dnf install golang.x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你用的是其他操作系统，请参照 &lt;a class=&#34;link&#34; href=&#34;https://golang.org/doc/install&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang 安装&lt;/a&gt;页面。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;version&lt;/code&gt; 参数来验证 Go 是否安装成功：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go version
go version go1.14.6 linux/amd64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行 &lt;code&gt;go get&lt;/code&gt; 命令就可以轻松地安装 &lt;code&gt;gosec&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go get github.com/securego/gosec/cmd/gosec
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这行命令会从 GitHub 下载 &lt;code&gt;gosec&lt;/code&gt; 的源码，编译并安装到指定位置。在仓库的 &lt;code&gt;README&lt;/code&gt; 中你还可以看到&lt;a class=&#34;link&#34; href=&#34;https://github.com/securego/gosec#install&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;安装该工具的其他方法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gosec&lt;/code&gt; 的源码会被下载到 &lt;code&gt;$GOPATH&lt;/code&gt; 的位置，编译出的二进制文件会被安装到你系统上设置的 &lt;code&gt;bin&lt;/code&gt; 目录下。你可以运行下面的命令来查看 &lt;code&gt;$GOPATH&lt;/code&gt; 和 &lt;code&gt;$GOBIN&lt;/code&gt; 目录：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ go env | grep GOBIN
GOBIN=&amp;#34;/root/go/gobin&amp;#34;
$ go env | grep GOPATH
GOPATH=&amp;#34;/root/go&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 &lt;code&gt;go get&lt;/code&gt; 命令执行成功，那么 &lt;code&gt;gosec&lt;/code&gt; 二进制应该就可以使用了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ls -l ~/go/bin/
total 9260
-rwxr-xr-x. 1 root root 9482175 Aug 20 04:17 gosec
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以把 &lt;code&gt;$GOPATH&lt;/code&gt; 下的 &lt;code&gt;bin&lt;/code&gt; 目录添加到 &lt;code&gt;$PATH&lt;/code&gt; 中。这样你就可以像使用系统上的其他命令一样来使用 &lt;code&gt;gosec&lt;/code&gt; 命令行工具（CLI）了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ which gosec
/root/go/bin/gosec
$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;gosec&lt;/code&gt; 命令行工具的 &lt;code&gt;-help&lt;/code&gt; 选项来看看运行是否符合预期：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gosec -help

gosec - Golang security checker

gosec analyzes Go source code to look for common programming mistakes that
can lead to security problems.

VERSION: dev
GIT TAG:
BUILD DATE:

USAGE:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，创建一个目录，把源码下载到这个目录作为实例项目（本例中，我用的是 Docker CE）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ mkdir gosec-demo
$ cd gosec-demo/
$ pwd
/root/gosec-demo
$ git clone https://github.com/docker/docker-ce.git
Cloning into &amp;#39;docker-ce&amp;#39;...
remote: Enumerating objects: 1271, done.
remote: Counting objects: 100% (1271/1271), done.
remote: Compressing objects: 100% (722/722), done.
remote: Total 431003 (delta 384), reused 981 (delta 318), pack-reused 429732
Receiving objects: 100% (431003/431003), 166.84 MiB | 28.94 MiB/s, done.
Resolving deltas: 100% (221338/221338), done.
Updating files: 100% (10861/10861), done.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码统计工具（本例中用的是 &lt;code&gt;cloc&lt;/code&gt;）显示这个项目大部分是用 Go 写的，恰好迎合了 &lt;code&gt;gosec&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ./cloc /root/gosec-demo/docker-ce/
   10771 text files.
    8724 unique files.                                          
    2560 files ignored.


-----------------------------------------------------------------------------------
Language                         files          blank        comment           code
-----------------------------------------------------------------------------------
Go                                7222         190785         230478        1574580
YAML                                37           4831            817         156762
Markdown                           529          21422              0          67893
Protocol Buffers                   149           5014          16562          10071
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用默认选项运行-gosec&#34;&gt;使用默认选项运行 gosec&lt;/h3&gt;
&lt;p&gt;在 Docker CE 项目中使用默认选项运行 &lt;code&gt;gosec&lt;/code&gt;，执行 &lt;code&gt;gosec ./...&lt;/code&gt; 命令。屏幕上会有很多输出内容。在末尾你会看到一个简短的 “Summary”，列出了浏览的文件数、所有文件的总行数，以及源码中发现的问题数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ pwd
/root/gosec-demo/docker-ce
$ time gosec ./...
[gosec] 2020/08/20 04:44:15 Including rules: default
[gosec] 2020/08/20 04:44:15 Excluding rules: default
[gosec] 2020/08/20 04:44:15 Import directory: /root/gosec-demo/docker-ce/components/engine/opts
[gosec] 2020/08/20 04:44:17 Checking package: opts
[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/address_pools.go
[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/env.go
[gosec] 2020/08/20 04:44:17 Checking file: /root/gosec-demo/docker-ce/components/engine/opts/hosts.go

# End of gosec run

Summary:
   Files: 1278
   Lines: 173979
   Nosec: 4
  Issues: 644

real    0m52.019s
user    0m37.284s
sys     0m12.734s
$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;滚动屏幕你会看到不同颜色高亮的行：红色表示需要尽快查看的高优先级问题，黄色表示中优先级的问题。&lt;/p&gt;
&lt;h4 id=&#34;关于误判&#34;&gt;关于误判&lt;/h4&gt;
&lt;p&gt;在开始检查代码之前，我想先分享几条基本原则。默认情况下，静态检查工具会基于一系列的规则对测试代码进行分析，并报告出它们发现的&lt;em&gt;所有&lt;/em&gt;问题。这是否意味着工具报出来的每一个问题都需要修复？非也。这个问题最好的解答者是设计和开发这个软件的人。他们最熟悉代码，更重要的是，他们了解软件会在什么环境下部署以及会被怎样使用。&lt;/p&gt;
&lt;p&gt;这个知识点对于判定工具标记出来的某段代码到底是不是安全缺陷至关重要。随着工作时间和经验的积累，你会慢慢学会怎样让静态分析工具忽略非安全缺陷，使报告内容的可执行性更高。因此，要判定 &lt;code&gt;gosec&lt;/code&gt; 报出来的某个问题是否需要修复，让一名有经验的开发者对源码做人工审计会是比较好的办法。&lt;/p&gt;
&lt;h4 id=&#34;高优先级问题&#34;&gt;高优先级问题&lt;/h4&gt;
&lt;p&gt;从输出内容看，&lt;code&gt;gosec&lt;/code&gt; 发现了 Docker CE 的一个高优先级问题，它使用的是低版本的 TLS（传输层安全Transport Layer Security&lt;!-- raw HTML omitted --&gt;传输层安全&lt;!-- raw HTML omitted --&gt;Transport Layer Security&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;）。无论什么时候，使用软件和库的最新版本都是确保它更新及时、没有安全问题的最好的方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/engine/daemon/logger/splunk/splunk.go:173] - G402 (CWE-295): TLS MinVersion too low. (Confidence: HIGH, Severity: HIGH)
    172:
  &amp;gt; 173:        tlsConfig := &amp;amp;tls.Config{}
    174:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它还发现了一个弱随机数生成器。它是不是一个安全缺陷，取决于生成的随机数的使用方式。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/engine/pkg/namesgenerator/names-generator.go:843] - G404 (CWE-338): Use of weak random number generator (math/rand instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)
    842: begin:
  &amp;gt; 843:        name := fmt.Sprintf(&amp;#34;%s_%s&amp;#34;, left[rand.Intn(len(left))], right[rand.Intn(len(right))])
    844:        if name == &amp;#34;boring_wozniak&amp;#34; /* Steve Wozniak is not boring */ {
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;中优先级问题&#34;&gt;中优先级问题&lt;/h4&gt;
&lt;p&gt;这个工具还发现了一些中优先级问题。它标记了一个通过与 &lt;code&gt;tar&lt;/code&gt; 相关的解压炸弹这种方式实现的潜在的 DoS 威胁，这种方式可能会被恶意的攻击者利用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/engine/pkg/archive/copy.go:357] - G110 (CWE-409): Potential DoS vulnerability via decompression bomb (Confidence: MEDIUM, Severity: MEDIUM)
    356:
  &amp;gt; 357:                        if _, err = io.Copy(rebasedTar, srcTar); err != nil {
    358:                                w.CloseWithError(err)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它还发现了一个通过变量访问文件的问题。如果恶意使用者能访问这个变量，那么他们就可以改变变量的值去读其他文件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/cli/cli/context/tlsdata.go:80] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)
    79:         if caPath != &amp;#34;&amp;#34; {
  &amp;gt; 80:                 if ca, err = ioutil.ReadFile(caPath); err != nil {
    81:                         return nil, err
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件和目录通常是操作系统安全的最基础的元素。这里，&lt;code&gt;gosec&lt;/code&gt; 报出了一个可能需要你检查目录的权限是否安全的问题。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/engine/contrib/apparmor/main.go:41] - G301 (CWE-276): Expect directory permissions to be 0750 or less (Confidence: HIGH, Severity: MEDIUM)
    40:         // make sure /etc/apparmor.d exists
  &amp;gt; 41:         if err := os.MkdirAll(path.Dir(apparmorProfilePath), 0755); err != nil {
    42:                 log.Fatal(err)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你经常需要在源码中启动命令行工具。Go 使用内建的 exec 库来实现。仔细地分析用来调用这些工具的变量，就能发现安全缺陷。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/engine/testutil/fakestorage/fixtures.go:59] - G204 (CWE-78): Subprocess launched with variable (Confidence: HIGH, Severity: MEDIUM)
    58:
  &amp;gt; 59:              cmd := exec.Command(goCmd, &amp;#34;build&amp;#34;, &amp;#34;-o&amp;#34;, filepath.Join(tmp, &amp;#34;httpserver&amp;#34;), &amp;#34;github.com/docker/docker/contrib/httpserver&amp;#34;)
    60:                 cmd.Env = append(os.Environ(), []string{
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;低优先级问题&#34;&gt;低优先级问题&lt;/h4&gt;
&lt;p&gt;在这个输出中，gosec 报出了一个 &lt;code&gt;unsafe&lt;/code&gt; 调用相关的低优先级问题，这个调用会绕开 Go 提供的内存保护。再仔细分析下你调用 &lt;code&gt;unsafe&lt;/code&gt; 的方式，看看是否有被别人利用的可能性。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/engine/pkg/archive/changes_linux.go:264] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)
    263:        for len(buf) &amp;gt; 0 {
  &amp;gt; 264:                dirent := (*unix.Dirent)(unsafe.Pointer(&amp;amp;buf[0]))
    265:                buf = buf[dirent.Reclen:]



[/root/gosec-demo/docker-ce/components/engine/pkg/devicemapper/devmapper_wrapper.go:88] - G103 (CWE-242): Use of unsafe calls should be audited (Confidence: HIGH, Severity: LOW)
    87: func free(p *C.char) {
  &amp;gt; 88:         C.free(unsafe.Pointer(p))
    89: }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它还标记了源码中未处理的错误。源码中出现的错误你都应该处理。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[/root/gosec-demo/docker-ce/components/cli/cli/command/image/build/context.go:172] - G104 (CWE-703): Errors unhandled. (Confidence: HIGH, Severity: LOW)
    171:                err := tar.Close()
  &amp;gt; 172:                os.RemoveAll(dockerfileDir)
    173:                return err
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;自定义-gosec-扫描&#34;&gt;自定义 gosec 扫描&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;gosec&lt;/code&gt; 的默认选项会带来很多的问题。然而，经过人工审计，随着时间推移你会掌握哪些问题是不需要标记的。你可以自己指定排除和包含哪些测试。&lt;/p&gt;
&lt;p&gt;我上面提到过，&lt;code&gt;gosec&lt;/code&gt; 是基于一系列的规则从 Go 源码中查找问题的。下面是它使用的完整的&lt;a class=&#34;link&#34; href=&#34;https://github.com/securego/gosec#available-rules&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;规则&lt;/a&gt;列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G101：查找硬编码凭证&lt;/li&gt;
&lt;li&gt;G102：绑定到所有接口&lt;/li&gt;
&lt;li&gt;G103：审计 &lt;code&gt;unsafe&lt;/code&gt; 块的使用&lt;/li&gt;
&lt;li&gt;G104：审计未检查的错误&lt;/li&gt;
&lt;li&gt;G106：审计 &lt;code&gt;ssh.InsecureIgnoreHostKey&lt;/code&gt; 的使用&lt;/li&gt;
&lt;li&gt;G107: 提供给 HTTP 请求的 url 作为污点输入&lt;/li&gt;
&lt;li&gt;G108: &lt;code&gt;/debug/pprof&lt;/code&gt; 上自动暴露的剖析端点&lt;/li&gt;
&lt;li&gt;G109: &lt;code&gt;strconv.Atoi&lt;/code&gt; 转换到 int16 或 int32 时潜在的整数溢出&lt;/li&gt;
&lt;li&gt;G110: 潜在的通过解压炸弹实现的 DoS&lt;/li&gt;
&lt;li&gt;G201：SQL 查询构造使用格式字符串&lt;/li&gt;
&lt;li&gt;G202：SQL 查询构造使用字符串连接&lt;/li&gt;
&lt;li&gt;G203：在 HTML 模板中使用未转义的数据&lt;/li&gt;
&lt;li&gt;G204：审计命令执行情况&lt;/li&gt;
&lt;li&gt;G301：创建目录时文件权限分配不合理&lt;/li&gt;
&lt;li&gt;G302：使用 &lt;code&gt;chmod&lt;/code&gt; 时文件权限分配不合理&lt;/li&gt;
&lt;li&gt;G303：使用可预测的路径创建临时文件&lt;/li&gt;
&lt;li&gt;G304：通过污点输入提供的文件路径&lt;/li&gt;
&lt;li&gt;G305：提取 zip/tar 文档时遍历文件&lt;/li&gt;
&lt;li&gt;G306: 写到新文件时文件权限分配不合理&lt;/li&gt;
&lt;li&gt;G307: 把返回错误的函数放到 &lt;code&gt;defer&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;G401：检测 DES、RC4、MD5 或 SHA1 的使用&lt;/li&gt;
&lt;li&gt;G402：查找错误的 TLS 连接设置&lt;/li&gt;
&lt;li&gt;G403：确保最小 RSA 密钥长度为 2048 位&lt;/li&gt;
&lt;li&gt;G404：不安全的随机数源（&lt;code&gt;rand&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;G501：导入黑名单列表：crypto/md5&lt;/li&gt;
&lt;li&gt;G502：导入黑名单列表：crypto/des&lt;/li&gt;
&lt;li&gt;G503：导入黑名单列表：crypto/rc4&lt;/li&gt;
&lt;li&gt;G504：导入黑名单列表：net/http/cgi&lt;/li&gt;
&lt;li&gt;G505：导入黑名单列表：crypto/sha1&lt;/li&gt;
&lt;li&gt;G601: 在 &lt;code&gt;range&lt;/code&gt; 语句中使用隐式的元素别名&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;排除指定的测试&#34;&gt;排除指定的测试&lt;/h4&gt;
&lt;p&gt;你可以自定义 &lt;code&gt;gosec&lt;/code&gt; 来避免对已知为安全的问题进行扫描和报告。你可以使用 &lt;code&gt;-exclude&lt;/code&gt; 选项和上面的规则编号来忽略指定的问题。&lt;/p&gt;
&lt;p&gt;例如，如果你不想让 &lt;code&gt;gosec&lt;/code&gt; 检查源码中硬编码凭证相关的未处理的错误，那么你可以运行下面的命令来忽略这些错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gosec -exclude=G104 ./...
$ gosec -exclude=G104,G101 ./...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时候你知道某段代码是安全的，但是 &lt;code&gt;gosec&lt;/code&gt; 还是会报出问题。然而，你又不想完全排除掉整个检查，因为你想让 &lt;code&gt;gosec&lt;/code&gt; 检查新增的代码。通过在你已知为安全的代码块添加 &lt;code&gt;#nosec&lt;/code&gt; 标记可以避免 &lt;code&gt;gosec&lt;/code&gt; 扫描。这样 &lt;code&gt;gosec&lt;/code&gt; 会继续扫描新增代码，而忽略掉 &lt;code&gt;#nosec&lt;/code&gt; 标记的代码块。&lt;/p&gt;
&lt;h4 id=&#34;运行指定的检查&#34;&gt;运行指定的检查&lt;/h4&gt;
&lt;p&gt;另一方面，如果你只想检查指定的问题，你可以通过 &lt;code&gt;-include&lt;/code&gt; 选项和规则编号来告诉 &lt;code&gt;gosec&lt;/code&gt; 运行哪些检查：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gosec -include=G201,G202 ./...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;扫描测试文件&#34;&gt;扫描测试文件&lt;/h4&gt;
&lt;p&gt;Go 语言自带对测试的支持，通过单元测试来检验一个元素是否符合预期。在默认模式下，&lt;code&gt;gosec&lt;/code&gt; 会忽略测试文件，你可以使用 &lt;code&gt;-tests&lt;/code&gt; 选项把它们包含进来：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;gosec -tests ./...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;修改输出的格式&#34;&gt;修改输出的格式&lt;/h4&gt;
&lt;p&gt;找出问题只是它的一半功能；另一半功能是把它检查到的问题以用户友好同时又方便工具处理的方式报告出来。幸运的是，&lt;code&gt;gosec&lt;/code&gt; 可以用不同的方式输出。例如，如果你想看 JSON 格式的报告，那么就使用 &lt;code&gt;-fmt&lt;/code&gt; 选项指定 JSON 格式并把结果保存到 &lt;code&gt;results.json&lt;/code&gt; 文件中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gosec -fmt=json -out=results.json ./...

$ ls -l results.json
-rw-r--r--. 1 root root 748098 Aug 20 05:06 results.json
$

         {
             &amp;#34;severity&amp;#34;: &amp;#34;LOW&amp;#34;,
             &amp;#34;confidence&amp;#34;: &amp;#34;HIGH&amp;#34;,
             &amp;#34;cwe&amp;#34;: {
                 &amp;#34;ID&amp;#34;: &amp;#34;242&amp;#34;,
                 &amp;#34;URL&amp;#34;: &amp;#34;https://cwe.mitre.org/data/definitions/242.html&amp;#34;
             },
             &amp;#34;rule_id&amp;#34;: &amp;#34;G103&amp;#34;,
             &amp;#34;details&amp;#34;: &amp;#34;Use of unsafe calls should be audited&amp;#34;,
             &amp;#34;file&amp;#34;: &amp;#34;/root/gosec-demo/docker-ce/components/engine/daemon/graphdriver/graphtest/graphtest_unix.go&amp;#34;,
             &amp;#34;code&amp;#34;: &amp;#34;304: \t// Cast to []byte\n305: \theader := *(*reflect.SliceHeader)(unsafe.Pointer(\u0026buf))\n306: \theader.      Len *= 8\n&amp;#34;,
             &amp;#34;line&amp;#34;: &amp;#34;305&amp;#34;,
             &amp;#34;column&amp;#34;: &amp;#34;36&amp;#34;
         },
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;用-gosec-检查容易被发现的问题&#34;&gt;用 gosec 检查容易被发现的问题&lt;/h3&gt;
&lt;p&gt;静态检查工具不能完全代替人工代码审计。然而，当代码量变大、有众多开发者时，这样的工具往往有助于以可重复的方式找出容易被发现的问题。它对于帮助新开发者识别和在编码时避免引入这些安全缺陷很有用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://opensource.com/article/20/9/gosec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://opensource.com/article/20/9/gosec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://opensource.com/users/gkamathe&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gaurav Kamathe&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lxbowlf&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43; Lambda 表达式</title>
        <link>https://lxb.wiki/e4d97659/</link>
        <pubDate>Fri, 21 Aug 2020 07:13:27 +0000</pubDate>
        
        <guid>https://lxb.wiki/e4d97659/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。&lt;/p&gt;
&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;p&gt;Lambda 表达式的基本语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;捕获列表&lt;/span&gt;](&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;参数列表&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;mutable&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;可选&lt;/span&gt;) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;异常属性&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;返回类型&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 函数体
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的语法规则除了 &lt;code&gt;[捕获列表]&lt;/code&gt; 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。&lt;/p&gt;
&lt;p&gt;所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：&lt;/p&gt;
&lt;h4 id=&#34;1-值捕获&#34;&gt;1. 值捕获&lt;/h4&gt;
&lt;p&gt;与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，&lt;strong&gt;被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lambda_value_capture&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; copy_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [value] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copy_value();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stored_value = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这时, stored_value == 1, 而 value == 100.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 copy_value 在创建时就保存了一份 value 的拷贝
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-引用捕获&#34;&gt;2. 引用捕获&lt;/h4&gt;
&lt;p&gt;与引用传参类似，引用捕获保存的是引用，值会发生变化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lambda_reference_capture&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; copy_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copy_value();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stored_value = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stored_value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这时, stored_value == 100, value == 100.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 因为 copy_value 保存的是引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-隐式捕获&#34;&gt;3. 隐式捕获&lt;/h4&gt;
&lt;p&gt;手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;=&lt;/code&gt; 向编译器声明采用引用捕获或者值捕获.&lt;/p&gt;
&lt;p&gt;总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[] 空捕获列表&lt;/li&gt;
&lt;li&gt;[name1, name2, …] 捕获一系列变量&lt;/li&gt;
&lt;li&gt;[&amp;amp;] 引用捕获, 让编译器自行推导捕获列表&lt;/li&gt;
&lt;li&gt;[=] 值捕获, 让编译器执行推导引用列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-表达式捕获&#34;&gt;4. 表达式捕获&lt;/h4&gt;
&lt;p&gt;上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。&lt;/p&gt;
&lt;p&gt;C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 &lt;code&gt;auto&lt;/code&gt; 本质上是相同的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;utility&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; important &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;make_unique&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; add &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [v1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, v2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(important)](&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;v1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; add(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的代码中，&lt;code&gt;important&lt;/code&gt; 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值， 在表达式中初始化。&lt;/p&gt;
&lt;h3 id=&#34;泛型-lambda&#34;&gt;泛型 Lambda&lt;/h3&gt;
&lt;p&gt;上一节中我们提到了 &lt;code&gt;auto&lt;/code&gt; 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。 这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。&lt;/p&gt;
&lt;p&gt;幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始， Lambda 函数的形式参数可以使用 &lt;code&gt;auto&lt;/code&gt; 关键字来产生意义上的泛型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; add &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [](&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; y) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>【译】Go 1.14 中接口的菱形组合</title>
        <link>https://lxb.wiki/ace0b2ab/</link>
        <pubDate>Mon, 01 Jun 2020 21:00:20 +0000</pubDate>
        
        <guid>https://lxb.wiki/ace0b2ab/</guid>
        <description>&lt;p&gt;按照&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/6977-overlapping-interfaces.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;部分重叠的接口提议&lt;/a&gt;，Go 1.14 现在允许嵌入有部分方法重叠的接口。本文是一篇解释这次修改的简要说明。&lt;/p&gt;
&lt;p&gt;我们先来看 io 包中的三个关键接口：io.Reader、io.Writer 和 io.Closer：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Reader&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Writer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在结构体中嵌入类型时，如果在结构体中声明了被嵌入的类型，那么该类型的字段和方法允许被访问&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，对于接口来说这个处理也成立。因此下面两种方式：显式声明&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和使用嵌入来组成接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Reader&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;没有区别。&lt;/p&gt;
&lt;p&gt;你甚至可以混合使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WriteCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而，在 Go 1.14 之前，如果你用这种方式来声明接口，你可能会得到类似这样的结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadWriteCloser&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadCloser&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;WriterCloser&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% Go build interfaces.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;command-line-arguments
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./interfaces.go:27:2: duplicate method Close
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;幸运的是，在 Go 1.14 中这不再是一个限制了，因此这个改动解决了在菱形嵌入时出现的问题。&lt;/p&gt;
&lt;p&gt;然而，在我向本地的用户组解释这个特性时也陷入了麻烦 — 只有 Go 编译器使用 1.14（或更高版本）语言规范时才支持这个特性。&lt;/p&gt;
&lt;p&gt;我理解的编译过程中 Go 语言规范所使用的版本的规则似乎是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你的源码是在 GOPATH 下（或者你用 GO111MODULE=off &lt;em&gt;关闭&lt;/em&gt;了 module），那么 Go 语言规范会使用你编译器的版本来编译。换句话说，如果安装了 Go 1.13，那么你的 Go 版本就是 1.13。如果你安装了 Go 1.14，那么你的版本就是 1.14。这里符合认知。&lt;/li&gt;
&lt;li&gt;如果你的源码保存在 GOPATH 外（或你用 GO111MODULE=on 强制开启了 module），那么 Go tool 会从 go.mod 文件中获取 Go 版本。&lt;/li&gt;
&lt;li&gt;如果 go.mod 中没有列出 Go 版本，那么语言规范会使用安装的 Go 的版本。这跟第 1 点是一致的。&lt;/li&gt;
&lt;li&gt;如果你用的是 Go module 模式，不管是源码在 GOPATH 外还是设置了 GO111MODULE=on，但是在当前目录或所有父目录中都没有 go.mod 文件，那么 Go 语言规范会默认用 Go 1.13 版本来编译你的代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我曾经遇到过第 4 点的情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2020/05/24/diamond-interface-composition-in-go-1-14&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dave Cheney&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;也就是说，嵌入提升了类型的字段和方法。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>【译】通过禁止比较让 Go 二进制文件变小</title>
        <link>https://lxb.wiki/27d7ea27/</link>
        <pubDate>Sat, 23 May 2020 12:24:34 +0000</pubDate>
        
        <guid>https://lxb.wiki/27d7ea27/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;大家常规的认知是，Go 程序中声明的类型越多，生成的二进制文件就越大。这个符合直觉，毕竟如果你写的代码不去操作定义的类型，那么定义一堆类型就没有意义了。然而，链接器的部分工作就是检测没有被程序引用的函数（比如说它们是一个库的一部分，其中只有一个子集的功能被使用），然后把它们从最后的编译产出中删除。常言道，“类型越多，二进制文件越大”，对于多数 Go 程序还是正确的。&lt;/p&gt;
&lt;p&gt;本文中我会深入讲解在 Go 程序的上下文中“相等”的意义，以及为什么&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/net/commit/e0ff5e5a1de5b859e2d48a2830d7933b3ab5b75f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;像这样&lt;/a&gt;的修改会对 Go 程序的大小有重大的影响。&lt;/p&gt;
&lt;h3 id=&#34;定义两个值相等&#34;&gt;定义两个值相等&lt;/h3&gt;
&lt;p&gt;Go 的语法定义了“赋值”和“相等”的概念。赋值是把一个值赋给一个标识符的行为。并不是所有声明的标识符都可以被赋值，如常量和函数就不可以。相等是通过检查标识符的内容是否相等来比较两个标识符的行为。&lt;/p&gt;
&lt;p&gt;作为强类型语言，“相同”的概念从根源上被植入标识符的类型中。两个标识符只有是相同类型的前提下，才有可能相同。除此之外，值的类型定义了如何比较该类型的两个值。&lt;/p&gt;
&lt;p&gt;例如，整型是用算数方法进行比较的。对于指针类型，是否相等是指它们指向的地址是否相同。映射和通道等引用类型，跟指针类似，如果它们指向相同的地址，那么就认为它们是相同的。&lt;/p&gt;
&lt;p&gt;上面都是按位比较相等的例子，即值占用的内存的位模式是相同的，那么这些值就相等。这就是所谓的 memcmp，即内存比较，相等是通过比较两个内存区域的内容来定义的。&lt;/p&gt;
&lt;p&gt;记住这个思路，我过会儿再来谈。&lt;/p&gt;
&lt;h3 id=&#34;结构体相等&#34;&gt;结构体相等&lt;/h3&gt;
&lt;p&gt;除了整型、浮点型和指针等标量类型，还有复合类型：结构体。所有的结构体以程序中的顺序被排列在内存中。因此下面这个声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type S struct {
    a, b, c, d int64
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会占用 32 字节的内存空间；&lt;code&gt;a&lt;/code&gt; 占用 8 个字节，&lt;code&gt;b&lt;/code&gt; 占用 8 个字节，以此类推。Go 的规则说如果结构体所有的字段都是可以比较的，那么结构体的值就是可以比较的。因此如果两个结构体所有的字段都相等，那么它们就相等。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a := S{1, 2, 3, 4}
b := S{1, 2, 3, 4}
fmt.Println(a == b) // 输出 true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器在底层使用 memcmp 来比较 &lt;code&gt;a&lt;/code&gt; 的 32 个字节和 &lt;code&gt;b&lt;/code&gt; 的 32 个字节。&lt;/p&gt;
&lt;h3 id=&#34;填充和对齐&#34;&gt;填充和对齐&lt;/h3&gt;
&lt;p&gt;然而，在下面的场景下过分简单化的按位比较的策略会返回错误的结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type S struct {
    a byte
    b uint64
    c int16
    d uint32
}

func main()
    a := S{1, 2, 3, 4}
    b := S{1, 2, 3, 4}
    fmt.Println(a == b) // 输出 true
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译代码后，这个比较表达式的结果还是 &lt;code&gt;true&lt;/code&gt;，但是编译器在底层并不能仅依赖比较 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的位模式，因为结构体有&lt;em&gt;填充&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;Go 要求结构体的所有字段都对齐。2 字节的值必须从偶数地址开始，4 字节的值必须从 4 的倍数地址开始，以此类推。编译器根据字段的类型和底层平台加入了填充来确保字段都&lt;em&gt;对齐&lt;/em&gt;。在填充之后，编译器实际上看到的是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type S struct {
    a byte
    _ [7]byte // 填充
    b uint64
    c int16
    _ [2]int16 // 填充
    d uint32
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;填充的存在保证了字段正确对齐，而填充确实占用了内存空间，但是填充字节的内容是未知的。你可能会认为在 Go 中 填充字节都是 0，但实际上并不是 — 填充字节的内容是未定义的。由于它们并不是被定义为某个确定的值，因此按位比较会因为分布在 &lt;code&gt;s&lt;/code&gt; 的 24 字节中的 9 个填充字节不一样而返回错误结果。&lt;/p&gt;
&lt;p&gt;Go 通过生成所谓的相等函数来解决这个问题。在这个例子中，&lt;code&gt;s&lt;/code&gt; 的相等函数只比较函数中的字段略过填充部分，这样就能正确比较类型 &lt;code&gt;s&lt;/code&gt; 的两个值。&lt;/p&gt;
&lt;h3 id=&#34;类型算法&#34;&gt;类型算法&lt;/h3&gt;
&lt;p&gt;呵，这是个很大的设置，说明了为什么，对于 Go 程序中定义的每种类型，编译器都会生成几个支持函数，编译器内部把它们称作类型的算法。如果类型是一个映射的键，那么除相等函数外，编译器还会生成一个哈希函数。为了维持稳定，哈希函数在计算结果时也会像相等函数一样考虑诸如填充等因素。&lt;/p&gt;
&lt;p&gt;凭直觉判断编译器什么时候生成这些函数实际上很难，有时并不明显，（因为）这超出了你的预期，而且链接器也很难消除没有被使用的函数，因为反射往往导致链接器在裁剪类型时变得更保守。&lt;/p&gt;
&lt;h3 id=&#34;通过禁止比较来减小二进制文件的大小&#34;&gt;通过禁止比较来减小二进制文件的大小&lt;/h3&gt;
&lt;p&gt;现在，我们来解释一下 Brad 的修改。向类型添加一个不可比较的字段，结构体也随之变成不可比较的，从而强制编译器不再生成相等函数和哈希函数，规避了链接器对那些类型的消除，在实际应用中减小了生成的二进制文件的大小。作为这项技术的一个例子，下面的程序：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
    type t struct {
        // _ [0][]byte // 取消注释以阻止比较
        a byte
        b uint16
        c int32
        d uint64
    }
    var a t
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用 Go 1.14.2（darwin/amd64）编译，大小从 2174088 降到了 2174056，节省了 32 字节。单独看节省的这 32 字节似乎微不足道，但是考虑到你的程序中每个类型及其传递闭包都会生成相等和哈希函数，还有它们的依赖，这些函数的大小随类型大小和复杂度的不同而不同，禁止它们会大大减小最终的二进制文件的大小，效果比之前使用 &lt;code&gt;-ldflags=&amp;quot;-s -w&amp;quot;&lt;/code&gt; 还要好。&lt;/p&gt;
&lt;p&gt;最后总结一下，如果你不想把类型定义为可比较的，可以在源码层级强制实现像这样的奇技淫巧，会使生成的二进制文件变小。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/author/davecheney&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dave Cheney&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Go：异步抢占</title>
        <link>https://lxb.wiki/5698ca18/</link>
        <pubDate>Tue, 05 May 2020 15:24:46 +0000</pubDate>
        
        <guid>https://lxb.wiki/5698ca18/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/00.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ℹ️ 本文基于 Go 1.14。&lt;/p&gt;
&lt;p&gt;抢占是调度器的重要部分，基于抢占调度器可以在各个协程中分配运行的时间。实际上，如果没有抢占机制，一个长时间占用 CPU 的协程会阻塞其他的协程被调度。1.14 版本引入了一项新的异步抢占的技术，赋予了调度器更大的能力和控制力。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我推荐你阅读我的文章&lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”Go：协程和抢占“&lt;/a&gt;来了解更多之前的特性和它的弊端。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;工作流&#34;&gt;工作流&lt;/h2&gt;
&lt;p&gt;我们以一个需要抢占的例子来开始。下面一段代码开启了几个协程，在几个循环中没有其他的函数调用，意味着调度器没有机会抢占它们：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然而，当把这个程序的追踪过程可视化后，我们清晰地看到了协程间的抢占和切换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们还可以看到表示协程的每个块儿的长度都相等。所有的协程运行时间相同（约 10 到 20 毫秒）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/03.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;异步抢占是基于一个时间条件触发的。当一个协程运行超过 10ms 时，Go 会尝试抢占它。&lt;/p&gt;
&lt;p&gt;抢占是由线程 &lt;code&gt;sysmon&lt;/code&gt; 初始化的，该线程专门用于监控包括长时间运行的协程在内的运行时。当某个协程被检测到运行超过 10ms 后，&lt;code&gt;sysmon&lt;/code&gt; 向当前的线程发出一个抢占信号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;之后，当信息被信号处理器接收到时，线程中断当前的操作来处理信号，因此不会再运行当前的协程，在我们的例子中是 &lt;code&gt;G7&lt;/code&gt;。取而代之的是，&lt;code&gt;gsignal&lt;/code&gt; 被调度为管理发送来的信号。当它发现它是一个抢占指令后，在程序处理信号后恢复时它准备好指令来中止当前的协程。下面是这第二个阶段的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/05.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你想了解更多关于 &lt;code&gt;gsignal&lt;/code&gt; 的信息，我推荐你读一下我的文章&lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-gsignal-master-of-signals-329f7ff39391&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”Go：gsignal，信号的掌控者“&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;我们在被选中的信号 &lt;code&gt;SIGURG&lt;/code&gt; 中第一次看到了实现的细节。这个选择在提案&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”提案：非合作式协程抢占“&lt;/a&gt;中有详细的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;它应该是调试者默认传递过来的一个信号。&lt;/li&gt;
&lt;li&gt;它不应该是 Go/C 混合二进制中 libc 内部使用的信号。&lt;/li&gt;
&lt;li&gt;它应该是一个可以伪造而没有其他后果的信号。&lt;/li&gt;
&lt;li&gt;我们需要在没有实时信号时与平台打交道。
然后，当信号被注入和接收时，Go 需要一种在程序恢复时能终止当前协程的方式。为了实现这个过程，Go 会把一条指令推进程序计数器，这样看起来运行中的程序调用了运行时的函数。该函数暂停了协程并把它交给了调度器，调度器之后还会运行其他的协程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;我们应该注意到 Go 不能做到在任何地方终止程序；当前的指令必须是一个安全点。例如，如果程序现在正在调用运行时，那么抢占协程并不安全，因为运行时很多函数不应该被抢占。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个新的抢占机制也让垃圾回收器受益，可以用更高效的方式终止所有的协程。诚然，STW 现在非常容易，Go 仅需要向所有运行的线程发出一个信号就可以了。下面是垃圾回收器运行时的一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20200501-Go-Asynchronous-Preemption/06.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后，所有的线程都接收到这个信号，在垃圾回收器重新开启全局之前会暂停执行。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你想了解更多关于 STW 的信息，我建议你阅读我的文章&lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;”Go：Go 怎样实现 STW？“&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最后，这个特性被封装在一个参数中，你可以用这个参数关闭异步抢占。你可以用 &lt;code&gt;GODEBUG=asyncpreemptoff=1&lt;/code&gt; 来运行你的程序，如果你因为升级到了 Go 1.14 发现了不正常的现象就可以调试你的程序，或者观察你的程序有无异步抢占时的不同表现。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@blanchon.vincent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Vincent Blanchon&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Inlining Optimisations in Go</title>
        <link>https://lxb.wiki/6ce34c49/</link>
        <pubDate>Wed, 29 Apr 2020 21:05:10 +0000</pubDate>
        
        <guid>https://lxb.wiki/6ce34c49/</guid>
        <description>&lt;h1 id=&#34;go-中的内联优化&#34;&gt;Go 中的内联优化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文讨论 Go 编译器是如何实现内联的，以及这种优化方法如何影响你的 Go 代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;*请注意：*本文重点讨论 &lt;em&gt;gc&lt;/em&gt;，这是来自 &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;golang.org&lt;/a&gt; 的事实标准的 Go 编译器。讨论到的概念可以广泛适用于其它 Go 编译器，如 gccgo 和 llgo，但它们在实现方式和功效上可能有所差异。&lt;/p&gt;
&lt;h3 id=&#34;内联是什么&#34;&gt;内联是什么？&lt;/h3&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;内联&lt;!-- raw HTML omitted --&gt;inlining&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;就是把简短的函数在调用它的地方展开。在计算机发展历程的早期，这个优化是由程序员手动实现的。现在，内联已经成为编译过程中自动实现的基本优化过程的其中一步。&lt;/p&gt;
&lt;h3 id=&#34;为什么内联很重要&#34;&gt;为什么内联很重要？&lt;/h3&gt;
&lt;p&gt;有两个原因。第一个是它消除了函数调用本身的开销。第二个是它使得编译器能更高效地执行其他的优化策略。&lt;/p&gt;
&lt;h4 id=&#34;函数调用的开销&#34;&gt;函数调用的开销&lt;/h4&gt;
&lt;p&gt;在任何语言中，调用一个函数 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 都会有消耗。把参数编组进寄存器或放入栈中（取决于 ABI），在返回结果时的逆反过程都会有开销。引入一次函数调用会导致程序计数器从指令流的一点跳到另一点，这可能导致管道滞后。函数内部通常有&lt;!-- raw HTML omitted --&gt;前置处理&lt;!-- raw HTML omitted --&gt;preamble&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，需要为函数执行准备新的栈帧，还有与前置相似的&lt;!-- raw HTML omitted --&gt;后续处理&lt;!-- raw HTML omitted --&gt;epilogue&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;，需要在返回给调用方之前释放栈帧空间。&lt;/p&gt;
&lt;p&gt;在 Go 中函数调用会消耗额外的资源来支持栈的动态增长。在进入函数时，goroutine 可用的栈空间与函数需要的空间大小进行比较。如果可用空间不同，前置处理就会跳到&lt;!-- raw HTML omitted --&gt;运行时&lt;!-- raw HTML omitted --&gt;runtime&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;的逻辑中，通过把数据复制到一块新的、更大的空间的来增长栈空间。当这个复制完成后，运行时就会跳回到原来的函数入口，再执行栈空间检查，现在通过了检查，函数调用继续执行。这种方式下，goroutine 开始时可以申请很小的栈空间，在有需要时再申请更大的空间。&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;这个检查消耗很小，只有几个指令，而且由于 goroutine 的栈是成几何级数增长的，因此这个检查很少失败。这样，现代处理器的分支预测单元可以通过假定检查肯定会成功来隐藏栈空间检查的消耗。当处理器预测错了栈空间检查，不得不放弃它在推测性执行所做的操作时，与为了增加 goroutine 的栈空间运行时所需的操作消耗的资源相比，管道滞后的代价更小。&lt;/p&gt;
&lt;p&gt;虽然现代处理器可以用预测性执行技术优化每次函数调用中的泛型和 Go 特定的元素的开销，但那些开销不能被完全消除，因此在每次函数调用执行必要的工作过程中都会有性能消耗。一次函数调用本身的开销是固定的，与更大的函数相比，调用小函数的代价更大，因为在每次调用过程中它们做的有用的工作更少。&lt;/p&gt;
&lt;p&gt;因此，消除这些开销的方法必须是要消除函数调用本身，Go 的编译器就是这么做的，在某些条件下通过用函数的内容来替换函数调用来实现。这个过程被称为&lt;em&gt;内联&lt;/em&gt;，因为它在函数调用处把函数体展开了。&lt;/p&gt;
&lt;h4 id=&#34;改进的优化机会&#34;&gt;改进的优化机会&lt;/h4&gt;
&lt;p&gt;Cliff Click 博士把内联描述为现代编译器做的优化措施，像常量传播（LCTT 译注：此处作者笔误，原文为 constant proportion，修正为 constant propagation）和死代码消除一样，都是编译器的基本优化方法。实际上，内联可以让编译器看得更深，使编译器可以观察调用的特定函数的上下文内容，可以看到能继续简化或彻底消除的逻辑。由于可以递归地执行内联，因此不仅可以在每个独立的函数上下文处进行这种优化决策，也可以在整个函数调用链中进行。&lt;/p&gt;
&lt;h3 id=&#34;实践中的内联&#34;&gt;实践中的内联&lt;/h3&gt;
&lt;p&gt;下面这个例子可以演示内联的影响：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;testing&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//go:noinline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行这个基准，会得到如下结果：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% go test -bench&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;. 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkMax-4   &lt;span style=&#34;color:#ae81ff&#34;&gt;530687617&lt;/span&gt;         2.24 ns/op
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我的 2015 MacBook Air 上 &lt;code&gt;max(-1, i)&lt;/code&gt; 的耗时约为 2.24 纳秒。现在去掉 &lt;code&gt;//go:noinline&lt;/code&gt; 编译指令，再看下结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% go test -bench&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;. 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkMax-4   &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000000&lt;/span&gt;         0.514 ns/op
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从 2.24 纳秒降到了 0.51 纳秒，或者从 &lt;code&gt;benchstat&lt;/code&gt; 的结果可以看出，有 78% 的提升。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% benchstat &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;old,new&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name   old time/op  new time/op  delta
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Max-4  2.21ns ± 1%  0.49ns ± 6%  -77.96%  &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0.000 n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;18+19&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个提升是从哪儿来的呢？&lt;/p&gt;
&lt;p&gt;首先，移除掉函数调用以及与之关联的前置处理 &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 是主要因素。把 &lt;code&gt;max&lt;/code&gt; 函数的函数体在调用处展开，减少了处理器执行的指令数量并且消除了一些分支。&lt;/p&gt;
&lt;p&gt;现在由于编译器优化了 &lt;code&gt;BenchmarkMax&lt;/code&gt;，因此它可以看到 &lt;code&gt;max&lt;/code&gt; 函数的内容，进而可以做更多的提升。当 &lt;code&gt;max&lt;/code&gt; 被内联后，&lt;code&gt;BenchmarkMax&lt;/code&gt; 呈现给编译器的样子，看起来是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再运行一次基准，我们看一下手动内联的版本和编译器内联的版本的表现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% benchstat &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;old,new&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name   old time/op  new time/op  delta
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Max-4  2.21ns ± 1%  0.48ns ± 3%  -78.14%  &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0.000 n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;18+18&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在编译器能看到在 &lt;code&gt;BenchmarkMax&lt;/code&gt; 里内联 &lt;code&gt;max&lt;/code&gt; 的结果，可以执行以前不能执行的优化措施。例如，编译器注意到 &lt;code&gt;i&lt;/code&gt; 初始值为 &lt;code&gt;0&lt;/code&gt;，仅做自增操作，因此所有与 &lt;code&gt;i&lt;/code&gt; 的比较都可以假定 &lt;code&gt;i&lt;/code&gt; 不是负值。这样条件表达式 &lt;code&gt;-1 &amp;gt; i&lt;/code&gt; 永远不是 &lt;code&gt;true&lt;/code&gt;。&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;证明了 &lt;code&gt;-1 &amp;gt; i&lt;/code&gt; 永远不为 true 后，编译器可以把代码简化为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并且因为分支里是个常量，编译器可以通过下面的方式移除不会走到的分支：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，通过内联和由内联解锁的优化过程，编译器把表达式 &lt;code&gt;r = max(-1, i))&lt;/code&gt; 简化为 &lt;code&gt;r = i&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;内联的限制&#34;&gt;内联的限制&lt;/h3&gt;
&lt;p&gt;本文中我论述的内联称作&lt;!-- raw HTML omitted --&gt;叶子内联&lt;!-- raw HTML omitted --&gt;leaf inlining&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;：把函数调用栈中最底层的函数在调用它的函数处展开的行为。内联是个递归的过程，当把函数内联到调用它的函数 A 处后，编译器会把内联后的结果代码再内联到 A 的调用方，这样持续内联下去。例如，下面的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkMaxMaxMax&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与之前的例子中的代码运行速度一样快，因为编译器可以对上面的代码重复地进行内联，也把代码简化到 &lt;code&gt;r = i&lt;/code&gt; 表达式。&lt;/p&gt;
&lt;p&gt;下一篇文章中，我会论述当 Go 编译器想要内联函数调用栈中间的某个函数时选用的另一种内联策略。最后我会论述编译器为了内联代码准备好要达到的极限，这个极限 Go 现在的能力还达不到。&lt;/p&gt;
&lt;h4 id=&#34;相关文章&#34;&gt;相关文章：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使 Go 变快的 5 件事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;为什么 Goroutine 的栈空间会无限增长？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中怎么写基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中隐藏的编译指令&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/author/davecheney&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Dave Cheney&lt;/a&gt;
选题：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lujun9972&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lujun9972&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LCTT/TranslateProject&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
&lt;p&gt;[3]: tmp.gBQ2tEtMHc#easy-footnote-bottom-2-4053 &amp;ldquo;Up until Go 1.14 the stack check preamble was also used by the garbage collector to stop the world by setting all active goroutine’s stacks to zero, forcing them to trap into the runtime the next time they made a function call. This system was &lt;!-- raw HTML omitted --&gt;recently replaced&lt;!-- raw HTML omitted --&gt; with a mechanism which allowed the runtime to pause an goroutine without waiting for it to make a function call.&amp;rdquo;
[4]: tmp.gBQ2tEtMHc#easy-footnote-bottom-3-4053 &amp;ldquo;I’m using the &lt;!-- raw HTML omitted --&gt;//go:noinline&lt;!-- raw HTML omitted --&gt; pragma to prevent the compiler from inlining &lt;!-- raw HTML omitted --&gt;max&lt;!-- raw HTML omitted --&gt;. This is because I want to isolate the effects of inlining on &lt;!-- raw HTML omitted --&gt;max&lt;!-- raw HTML omitted --&gt; rather than disabling optimisations globally with &lt;!-- raw HTML omitted --&gt;-gcflags=&amp;rsquo;-l -N&amp;rsquo;&lt;!-- raw HTML omitted --&gt;. I go into detail about the &lt;!-- raw HTML omitted --&gt;//go:&lt;!-- raw HTML omitted --&gt; comments in &lt;!-- raw HTML omitted --&gt;this presentation&lt;!-- raw HTML omitted --&gt;.&amp;rdquo;
[5]: tmp.gBQ2tEtMHc#easy-footnote-bottom-4-4053 &amp;ldquo;You can check this for yourself by comparing the output of &lt;!-- raw HTML omitted --&gt;go test -bench=. -gcflags=-S&lt;!-- raw HTML omitted --&gt; with and without the &lt;!-- raw HTML omitted --&gt;//go:noinline&lt;!-- raw HTML omitted --&gt; annotation.&amp;rdquo;
[6]: tmp.gBQ2tEtMHc#easy-footnote-bottom-5-4053 &amp;ldquo;You can check this yourself with the &lt;!-- raw HTML omitted --&gt;-gcflags=-d=ssa/prove/debug=on&lt;!-- raw HTML omitted --&gt; flag.&amp;rdquo;
[7]: tmp.gBQ2tEtMHc#easy-footnote-1-4053
[8]: &lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md&lt;/a&gt;
[9]: tmp.gBQ2tEtMHc#easy-footnote-2-4053
[10]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&lt;/a&gt;
[11]: tmp.gBQ2tEtMHc#easy-footnote-3-4053
[12]: tmp.gBQ2tEtMHc#easy-footnote-4-4053
[13]: tmp.gBQ2tEtMHc#easy-footnote-5-4053
[14]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&lt;/a&gt; &amp;ldquo;Five things that make Go fast&amp;rdquo;
[15]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&lt;/a&gt; &amp;ldquo;Why is a Goroutine’s stack infinite ?&amp;rdquo;
[16]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go&lt;/a&gt; &amp;ldquo;How to write benchmarks in Go&amp;rdquo;
[17]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2018/01/08/gos-hidden-pragmas&lt;/a&gt; &amp;ldquo;Go’s hidden #pragmas&amp;rdquo;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;在 Go 中，一个方法就是一个有预先定义的形参和接受者的函数。假设这个方法不是通过接口调用的，调用一个无消耗的函数所消耗的代价与引入一个方法是相同的。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;在 Go 1.14 以前，栈检查的前置处理也被垃圾回收器用于 STW，通过把所有活跃的 goroutine 栈空间设为 0，来强制它们切换为下一次函数调用时的运行时状态。这个机制[最近被替换][8]为一种新机制，新机制下运行时可以不用等 goroutine 进行函数调用就可以暂停 goroutine。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;我用 &lt;code&gt;//go:noinline&lt;/code&gt; 编译指令来阻止编译器内联 &lt;code&gt;max&lt;/code&gt;。这是因为我想把内联 &lt;code&gt;max&lt;/code&gt; 的影响与其他影响隔离开，而不是用 &lt;code&gt;-gcflags=&#39;-l -N&#39;&lt;/code&gt; 选项在全局范围内禁止优化。关于 &lt;code&gt;//go:&lt;/code&gt; 注释在[这篇文章][10]中详细论述。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;你可以自己通过比较 &lt;code&gt;go test -bench=. -gcflags=-S&lt;/code&gt; 有无 &lt;code&gt;//go:noinline&lt;/code&gt; 注释时的不同结果来验证一下。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;你可以用 &lt;code&gt;-gcflags=-d=ssa/prove/debug=on&lt;/code&gt; 选项来自己验证一下。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>【译】关于 CGo 的字符串函数的解释</title>
        <link>https://lxb.wiki/8c45788a/</link>
        <pubDate>Sun, 09 Feb 2020 20:55:26 +0000</pubDate>
        
        <guid>https://lxb.wiki/8c45788a/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/wiki/cgo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cgo&lt;/a&gt; 的大量文档都提到过，它提供了四个用于转换 Go 和 C 类型的字符串的函数，都是通过复制数据来实现。在 CGo 的文档中有简洁的解释，但我认为解释得太简洁了，因为文档只涉及了定义中的某些特定字符串，而忽略了两个很重要的注意事项。我曾经踩过这里的坑，现在我要详细解释一下。&lt;/p&gt;
&lt;p&gt;四个函数分别是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CString&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoString&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoStringN&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoBytes&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;C.CString()&lt;/code&gt; 等价于 C 的 &lt;code&gt;strdup()&lt;/code&gt;，像文档中提到的那样，把 Go 的字符串复制为可以传递给 C 函数的 C 的 &lt;code&gt;char *&lt;/code&gt;。很讨厌的一件事是，由于 Go 和 CGo 类型的定义方式，调用 &lt;code&gt;C.free&lt;/code&gt; 时需要做一个转换：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CString&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a string&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;free&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请留意，Go 字符串中可能嵌入了 &lt;code&gt;\0&lt;/code&gt; 字符，而 C 字符串不会。如果你的 Go 字符串中有 &lt;code&gt;\0&lt;/code&gt; 字符，当你调用 &lt;code&gt;C.CString()&lt;/code&gt; 时，C 代码会从 &lt;code&gt;\0&lt;/code&gt; 字符处截断你的字符串。这往往不会被注意到，但&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;有时文本并不保证不含 null 字符&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoString()&lt;/code&gt; 也等价于 &lt;code&gt;strdup()&lt;/code&gt;，但与 &lt;code&gt;C.CString()&lt;/code&gt; 相反，是把 C 字符串转换为 Go 字符串。你可以用它定义结构体的字段，或者是声明为 C 的 &lt;code&gt;char *&lt;/code&gt;（在 Go 中叫 &lt;code&gt;*C.cahr&lt;/code&gt;） 的其他变量，抑或其他的一些变量（我们后面会看到）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoStringN()&lt;/code&gt; 等价于 C 的 &lt;code&gt;memmove()&lt;/code&gt;，与 C 中普通的字符串函数不同。**它把整个 N 长度的 C buffer 复制为一个 Go 字符串，不单独处理 null 字符。**再详细点，它也通过复制来实现。如果你有一个定义为 &lt;code&gt;char feild[64]&lt;/code&gt; 的结构体的字段，然后调用了 &lt;code&gt;C.GoStringN(&amp;amp;field, 64)&lt;/code&gt;，那么你得到的 Go 字符串一定是 64 个字符，字符串的末尾有可能是一串 &lt;code&gt;\0&lt;/code&gt; 字符。&lt;/p&gt;
&lt;p&gt;(我认为这是 cgo 文档中的一个 bug。它宣称 GoStringN 的入参是一个 C 的字符串，但实际上很明显不是，因为 C 的字符串不能以 null 字符结束，而 GoStringN 不会在 null 字符处结束处理。)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoBytes()&lt;/code&gt; 是 &lt;code&gt;C.GoStringN()&lt;/code&gt; 的另一个版本，不返回 &lt;code&gt;string&lt;/code&gt; 而是返回 &lt;code&gt;[]byte&lt;/code&gt;。它没有宣称以 C 字符串作为入参，它仅仅是对整个 buffer 做了内存拷贝。&lt;/p&gt;
&lt;p&gt;如果你要拷贝的东西不是以 null 字符结尾的 C 字符串，而是固定长度的 memory buffer，那么 &lt;code&gt;C.GoString()&lt;/code&gt; 正好能满足需求；它避开了 C 中传统的问题&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/BeSureItsACString&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;处理不是 C 字符串的 ’string‘&lt;/a&gt;。然而，如果你要处理定义为 &lt;code&gt;char field[N]&lt;/code&gt; 的结构体字段这种限定长度的 C 字符串时，这些函数&lt;em&gt;都不能&lt;/em&gt;满足需求。&lt;/p&gt;
&lt;p&gt;传统语义的结构体中固定长度的字符串变量，定义为 &lt;code&gt;char field[N]&lt;/code&gt; 的字段，以及“包含一个字符串”等描述，都表示当且仅当字符串有足够空间时以 null 字符结尾，换句话说，字符串最多有 N-1 个字符。如果字符串正好有 N 个字符，那么它不会以 null 字符结尾。这是 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/UnixAPIMistake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C 代码中诸多 bug 的根源&lt;/a&gt;，也不是一个好的 API，但我们却摆脱不了这个 API。每次我们遇到这样的字段，文档不会明确告诉你字段的内容并不一定是 null 字符结尾的，你需要自己假设你有这种 API。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C.GoString()&lt;/code&gt; 或 &lt;code&gt;C.GoStringN()&lt;/code&gt; 都不能正确处理这些字段。使用 &lt;code&gt;GoStringN()&lt;/code&gt; 相对来说出错更少；它仅仅返回一个末尾有一串 &lt;code&gt;\0&lt;/code&gt; 字符长度为 N 的 Go 字符串（如果你仅仅是把这些字段打印出来，那么你可能不会留意到；我经常干这种事）。使用有诱惑力的 &lt;code&gt;GoString()&lt;/code&gt; 更是引狼入室，因为它内部会对入参做 &lt;code&gt;strlen()&lt;/code&gt;；如果字符末尾没有 null 字符，&lt;code&gt;strlen()&lt;/code&gt; 会访问越界的内存地址。如果你走运，你得到的 Go 字符串末尾会有大量的垃圾。如果你不走运，你的 Go 程序出现段错误，因为 &lt;code&gt;strlen()&lt;/code&gt; 访问了未映射的内存地址。&lt;/p&gt;
&lt;p&gt;（总的来说，如果字符串末尾出现了大量垃圾，通常意味着在某处有不含结束符的 C 字符串。）&lt;/p&gt;
&lt;p&gt;你需要的是与 C 的 &lt;code&gt;strndup()&lt;/code&gt; 等价的 Go 函数，以此来确保复制不超过 N 个字符且在 null 字符处终止。下面是我写的版本，不保证无错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strndup&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoStringN&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.int(&lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strings&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IndexByte&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于有 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 的字符串怎样占用内存&lt;/a&gt;的问题，这段代码做了些额外的工作来最小化额外的内存占用。你可能想用另一种方法，返回一个 &lt;code&gt;GoStringN()&lt;/code&gt; 字符串的切片。你也可以写复杂的代码，根据 i 和 len 的不同来决定选用哪种方法。&lt;/p&gt;
&lt;p&gt;更新：&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues/12428#issuecomment-136581154&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ian Lance Taylor 给我展示了份更好的代码&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strndup&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GoStringN&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.int(&lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;strnlen&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size_t&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt;))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是的，这里有大量的转换。这篇文章就是你看到的 Go 和 Gco 类型的结合。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ChrisSiebenmann&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Go 字符串中的潜在问题</title>
        <link>https://lxb.wiki/10e5e8ba/</link>
        <pubDate>Fri, 17 Jan 2020 00:12:58 +0000</pubDate>
        
        <guid>https://lxb.wiki/10e5e8ba/</guid>
        <description>&lt;p&gt;在我之前的文章 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoThingsILike&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中我喜欢的东西&lt;/a&gt;中提到过，我喜欢的 &lt;a class=&#34;link&#34; href=&#34;https://golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go&lt;/a&gt; 的东西其中之一就是它的字符串（通常还有切片）。从一个 Python 开发者的角度看，它们之所以伟大，是因为创建它们时开销很少，因为它们通常不需要复制。在 Python 中，任何时候操作字符串都需要复制一部分或全部字符串，而 &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/python/StringSpeedSurprises&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这很容易对性能造成影响&lt;/a&gt;。想要写高性能的 Python 代码需要谨慎考虑复制的问题。在 Go 中，几乎所有的字符串操作都是不复制的，仅仅是从原字符串取一个子集（例如去除字符串首尾的空白字符），因此你可以更自由地操作字符串。这个机制可以非常直接地解决你的问题，并且非常高效。&lt;/p&gt;
&lt;p&gt;（当然，不是所有的字符串操作都不复制。例如，把一个字符串转换成大写需要复制，尽管 Go 中的实现已经足够智能，在不需要改变原字符串时 — 例如由于它已经是一个全大写的字符串 — 可以规避掉复制。）&lt;/p&gt;
&lt;p&gt;但是这个优势也带来了潜在的坏处，那些没有开销的子字符串使原来的整个字符串一直存在于内存中。Go 中的字符串（和切片）操作之所以内存开销很少，是因为它们只是底层存储（字符串或切片底层的数组的真实数据）的一些部分的引用；创建一个字符串做的操作就是创建了一个新的引用。但是 Go（目前）不会对字符串数据或数组进行部分的垃圾回收，所以即使它一个很小的 bit 被其它元素引用，整个对象也会一直保持在内存中。换句话说，一个单字符的字符串（目前）足够让一个巨大的字符串不被 GC 回收。&lt;/p&gt;
&lt;p&gt;当然，不会有很多人遇到这个问题。为了遇到它，你需要处理一个非常庞大的原字符串，或造成大量的内存消耗（或者两者都做），在这个基础上，你必须创建那些不持久的字符串的持久的小子字符串（好吧，你是多么希望它是非持久的）。很多使用场景不会复现这个问题；要么你的原字符串不够大，要么你的子集获取了大部分原字符串（例如你把原字符串进行了分词处理），要么子字符串生命周期不够长。简而言之，如果你是一个普通的 Go 开发者，你可以忽略这个问题。处理长字符串并且长时间维持原字符串的很小部分的人才会关注这个问题。&lt;/p&gt;
&lt;p&gt;（我之所以关注到这个问题，是因为一次我花了大量精力用尽可能少的内存写 Python 程序，尽管它是从一个大的配置文件解析结果然后分块储存。这让我联想到了一些其他的事，如字符串的生命周期、限制字符串只复制一次，等等。然后我用 Go 语言写了一个解析器，这让我由重新考虑了一下这些问题，我意识到由于我的解析器截取出和维持的 bit 一直存在于内存中，从输入文件解析出的庞大字符串也会一直存在与内存中。）&lt;/p&gt;
&lt;p&gt;顺便说一下，我认为这是 Go 做了权衡之后的正确结果。大部分使用字符串的开发者不会遇到这个问题，而且截取子字符串开销很小对于开发者来说用处很大。这种低开销的截取操作也减轻了 GC 的负担；当代码使用大量的子字符串截取（像 Python 中那样）时，你只需要处理固定长度的字符串引用就可以了，而不是需要处理长度变化的字符串。&lt;/p&gt;
&lt;p&gt;当你的代码遇到这个问题时，当然有明显的解决方法：创建一个函数，通过把字符串转换成 &lt;code&gt;[]byte&lt;/code&gt; 来 ”最小化“ 字符串，然后返回。这种方法生成了一个最小化的字符串，内存开销是理论上最完美实现的只复制一次，而 Go 现在很容易就可以实现。&lt;/p&gt;
&lt;h2 id=&#34;附加问题stringstoupper-等怎样规避没有必要的复制&#34;&gt;附加问题：&lt;code&gt;strings.ToUpper()&lt;/code&gt; 等怎样规避没有必要的复制&lt;/h2&gt;
&lt;p&gt;所有的主动转换函数像 &lt;code&gt;ToUpper()&lt;/code&gt; 和 &lt;code&gt;ToTitle()&lt;/code&gt; 是用 &lt;code&gt;strings.Map()&lt;/code&gt; 和 &lt;a class=&#34;link&#34; href=&#34;http://golang.org/pkg/unicode/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;unicode 包&lt;/a&gt; 中的函数实现的。&lt;code&gt;Map()&lt;/code&gt; 足够智能，在映射的函数返回一个与已存在的 &lt;code&gt;rune&lt;/code&gt; 不同的结果之前不会创建新的字符串。因此，你代码中所有类似的直接使用 &lt;code&gt;Map()&lt;/code&gt; 的地方都不会有内存开销。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://utcc.utoronto.ca/~cks/space/blog/programming/GoStringsMemoryHolding&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://utcc.utoronto.ca/~cks/space/People/ChrisSiebenmann&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Chris Siebenmann&lt;/a&gt;
译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lxbwolf&lt;/a&gt;
校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/%e6%a0%a1%e5%af%b9%e8%80%85ID&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;校对者ID&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[译]Go GC 怎么标记内存</title>
        <link>https://lxb.wiki/b3baee92/</link>
        <pubDate>Tue, 14 Jan 2020 00:06:31 +0000</pubDate>
        
        <guid>https://lxb.wiki/b3baee92/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/00.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ℹ️ 本文基于 &lt;em&gt;Go 1.13&lt;/em&gt;。关于内存管理的概念的讨论在我的文章 &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中的内存管理和分配&lt;/a&gt; 中有详细的解释。&lt;/p&gt;
&lt;p&gt;Go GC 的作用是回收不再使用的内存。实现的算法是并发的三色标记和清除回收法。本中文，我们研究三色标记法，以及各个颜色的不同用处。&lt;/p&gt;
&lt;p&gt;你可以在 Ken Fox 的 &lt;a class=&#34;link&#34; href=&#34;https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;解读垃圾回收算法&lt;/a&gt; 中了解更多关于不同垃圾回收机制的信息。&lt;/p&gt;
&lt;h2 id=&#34;标记阶段&#34;&gt;标记阶段&lt;/h2&gt;
&lt;p&gt;这个阶段浏览内存来了解哪些块儿是在被我们的代码使用和哪些块儿应该被回收。&lt;/p&gt;
&lt;p&gt;然而，因为 GC 和我们的 Go 程序并行，GC 扫描期间内存中某些对象的状态可能被改变，所以需要一个检测这种可能的变化的方法。为了解决这个潜在的问题，实现了 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Write_barrier&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;写屏障&lt;/a&gt; 算法，GC 可以追踪到任何的指针修改。使写屏障生效的唯一条件是短暂终止程序，又名 “Stop the World”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在进程启动时，Go 也在每个 processor 起了一个标记 worker 来辅助标记内存。&lt;/p&gt;
&lt;p&gt;然后，当 root 被加入到处理队列中后，标记阶段就开始遍历和用颜色标记内存。&lt;/p&gt;
&lt;p&gt;为了了解在标记阶段的每一步，我们来看一个简单的程序示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;struct1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;struct2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;struct2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allocStruct1&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allocStruct2&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;allocStruct2&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;runtime&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GC&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s1 = %X, s2 = %X\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//go:noinline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allocStruct1&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;struct1&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;struct1&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;allocStruct2&lt;/span&gt;(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//go:noinline
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allocStruct2&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;struct2&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;struct2&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;struct2&lt;/code&gt; 不包含指针，因此它被储存在一个专门存放不被其他对象引用的对象的 span 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;不包含指针的结构体储存在专有的 span 中&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这减少了 GC 的工作，因为标记内存时不需要扫描这个 span。&lt;/p&gt;
&lt;p&gt;分配工作结束后，我们的程序强迫 GC 重复前面的步骤。下面是流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/03.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;扫描内存&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。扫描到被标记为 &lt;code&gt;no scan&lt;/code&gt; 的 span 时，停止扫描。然而，这个工作是在多个协程中完成的，每个指针被加入到一个 work pool 中的队列。然后，后台运行的标记 worker 从这个 work pool 中拿到前面出列的 work，扫描这个对象然后把在这个对象里找到的指针加入到队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;garbage collector work pool&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;颜色标记&#34;&gt;颜色标记&lt;/h2&gt;
&lt;p&gt;worker 需要一种记录哪些内存需要扫描的方法。GC 使用一种 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;三色标记算法&lt;/a&gt;，工作流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始时，所有对象都被认为是&lt;strong&gt;白色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;root 对象（栈，堆，全局变量）被标记为&lt;strong&gt;灰色&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个初始步骤完成后，GC 会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择一个&lt;strong&gt;灰色&lt;/strong&gt;的对象，标记为&lt;strong&gt;黑色&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;追踪这个对象的所有指针，把所有引用的对象标记为&lt;strong&gt;灰色&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，GC 重复以上两步，直到没有对象可被标记。在这一时刻，对象非黑即白，没有灰色。白色的对象表示没有其他对象引用，可以被回收。&lt;/p&gt;
&lt;p&gt;下面是前面例子的图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/05.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;初始状态下，所有的对象被认为是白色的。然后，遍历到的且被其他对象引用的对象，被标记为灰色。如果一个对象在被标记为 &lt;code&gt;no scan&lt;/code&gt; 的 span 中，因为它不需要被扫描，所以可以标记为黑色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/06.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;现在灰色的对象被加入到扫描队列并被标记为黑色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/07.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对加入到扫描队列的所有对象重复做相同的操作，直到没有对象需要被处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/08.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;处理结束时，黑色对象表示内存中在使用的对象，白色对象是要被回收的对象。我们可以看到，由于 &lt;code&gt;struct2&lt;/code&gt; 的实例是在一个匿名函数中创建的且不再存在于栈上，因此它是白色的且可以被回收。&lt;/p&gt;
&lt;p&gt;归功于每一个 span 中的名为 &lt;code&gt;gcmarkBits&lt;/code&gt; 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 scan。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/09.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，黑色和灰色表示的意义相同。处理的不同之处在于，标记为灰色时是把对象加入到扫描队列，而标记为黑色时，不再扫描。&lt;/p&gt;
&lt;p&gt;GC 最终 STW，清除每一次写屏障对 work pool 做的改变，继续后续的标记。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你可以在我的文章 &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go GC 怎样监控你的应用&lt;/a&gt; 中找到关于并发处理和 GC 的标记阶段更详细的描述&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;runtime-分析器&#34;&gt;runtime 分析器&lt;/h2&gt;
&lt;p&gt;Go 提供的工具使我们可以对每一步进行可视化，观察 GC 在我们的程序中的影响。开启 tracing 运行我们的代码，可以看到前面所有步骤的一个概览。下面是追踪结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/10.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;traces of the garbage collector&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;标记 worker 的生命周期也可以在追踪结果中以协程等级可视化。下面是在启动之前先在后台等待标记内存的 goroutine #33 的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191103-Go-How-Does-the-Garbage-Collector-Mark-the-Memory/11.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;marking worker&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@blanchon.vincent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Vincent Blanchon&lt;/a&gt; 译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lxbwolf&lt;/a&gt; 校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】协程，操作系统线程和 CPU 管理</title>
        <link>https://lxb.wiki/4e717bb5/</link>
        <pubDate>Thu, 12 Dec 2019 23:01:35 +0000</pubDate>
        
        <guid>https://lxb.wiki/4e717bb5/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210657.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French.&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ℹ️ &lt;em&gt;本文运行环境为 Go 1.13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对于一个程序来说，从内存和性能角度讲创建一个 OS 线程或切换线程花费巨大。Go 志在极尽所能地充分利用内核资源。从第一天开始，它就是为并发而生的。&lt;/p&gt;
&lt;h2 id=&#34;m-p-g-编排&#34;&gt;M, P, G 编排&lt;/h2&gt;
&lt;p&gt;为了解决这个问题，Go 有它自己的在线程间调度协程的调度器。这个调度器定义了三个主要概念，如源码中解释的这样：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;The main concepts are:
G - goroutine.
M - worker thread, or machine.
P - processor, a resource that is required to execute Go code.
    M must have an associated P to execute Go code[...].
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;P&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt; 模型图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210733.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;P, M, G diagram&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每个协程（&lt;code&gt;G&lt;/code&gt;）运行在与一个逻辑 CPU（&lt;code&gt;P&lt;/code&gt;）相关联的 OS 线程（&lt;code&gt;M&lt;/code&gt;）上。我们一起通过一个简单的示例来看 Go 是怎么管理他们的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WaitGroup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;`hello`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;`world`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，Go 根据机器逻辑 CPU 的个数来创建不同的 &lt;code&gt;P&lt;/code&gt;，并且把它们保存在一个空闲 &lt;code&gt;P&lt;/code&gt; 的 list 里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206210931.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;P initialization&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后，为了更好地工作新创建的已经准备好的协程会唤醒一个 &lt;code&gt;P&lt;/code&gt;。这个 &lt;code&gt;P&lt;/code&gt; 通过与之相关联的 OS 线程来创建一个 &lt;code&gt;M&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211012.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;OS thread creation&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然而，像 &lt;code&gt;P&lt;/code&gt; 那样，系统调用返回的甚至被 gc 强行停止的空闲的 &lt;code&gt;M&lt;/code&gt; — 比如没有协程在等待运行 — 也会被加到一个空闲 list：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211040.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;M and P idle list&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在程序启动阶段，Go 就已经创建了一些 OS 线程并与 &lt;code&gt;M&lt;/code&gt; 想关联了。在我们的例子中，打印 &lt;code&gt;hello&lt;/code&gt; 的第一个协程会使用主协程，第二个会从这个空闲 list 中获取一个 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211126.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;M and P pulled from the idle list&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经掌握了协程和线程管理的基本要义，来一起看看什么情形下 Go 会用比 &lt;code&gt;P&lt;/code&gt; 多的 &lt;code&gt;M&lt;/code&gt;，在系统调用时怎么管理协程。&lt;/p&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;系统调用&lt;/h2&gt;
&lt;p&gt;Go 会优化系统调用 — 无论阻塞与否 — 通过运行时封装他们。封装的那一层会把 &lt;code&gt;P&lt;/code&gt; 和线程 &lt;code&gt;M&lt;/code&gt; 分离，并且可以让另一个线程在它上面运行。我们拿文件读取举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;fd&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;number.txt&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;fd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;fd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   println(string(&lt;span style=&#34;color:#a6e22e&#34;&gt;buf&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// 42
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文件读取的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211158.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Syscall handoffs P&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P0&lt;/code&gt; 现在在空闲 list 中，有可能被唤醒。当系统调用 exit 时，Go 会遵守下面的规则，直到有一个命中了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试去捕获相同的 &lt;code&gt;P&lt;/code&gt;，在我们的例子中就是 &lt;code&gt;P0&lt;/code&gt;，然后 resume 执行过程&lt;/li&gt;
&lt;li&gt;尝试从空闲 list 中捕获一个 &lt;code&gt;P&lt;/code&gt;，然后 resume 执行过程&lt;/li&gt;
&lt;li&gt;把协程放到全局队列里，把与之相关联的 &lt;code&gt;M&lt;/code&gt; 放回空闲 list 去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，在像 http 请求等 non-blocking I/O 情形下，Go 在资源没有准备好时也会处理请求。在这种情形下，第一个系统调用 — 遵循上述流程图 — 由于资源还没有准备好所以不会成功，（这样就）迫使 Go 使用 network poller 并使协程停驻。请看示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`https://httpstat.us/200`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当第一个系统调用完成且显式地声明了资源还没有准备好，协程会在 network poller 通知它资源准备就绪之前一直处于停驻状态。在这种情形下，线程 &lt;code&gt;M&lt;/code&gt; 不会阻塞：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211227.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Network poller waiting for the resource&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在 Go 调度器在等待信息时协程会再次运行。调度器在获取到等待的信息后会询问 network poller 是否有协程在等待被运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211256.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果多个协程都准备好了，只有一个会被运行，其他的会被加到全局的可运行队列中，以备后续的调度。&lt;/p&gt;
&lt;h2 id=&#34;os-线程方面的限制&#34;&gt;OS 线程方面的限制&lt;/h2&gt;
&lt;p&gt;在系统调用中，Go 不会限制可阻塞的 OS 线程数，源码中有解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译注：&lt;strong&gt;GOMAXPROCS&lt;/strong&gt; 变量表示可同时运行用户级 Go 代码的操作系统线程的最大数量。系统调用中可被阻塞的最大线程数并没有限制；可被阻塞的线程数对 &lt;strong&gt;GOMAXPROCS&lt;/strong&gt; 没有影响。这个包的 &lt;em&gt;&lt;strong&gt;GOMAXPROCS&lt;/strong&gt;&lt;/em&gt; 函数查询和修改这个最大数限制。&lt;/p&gt;
&lt;p&gt;对这种情形举例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WaitGroup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; ;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`https://httpstat.us/200?sleep=10000`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;利用追踪工具得到的线程数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201206211320.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;由于 Go 优化了线程使用，所以当协程阻塞时，它仍可复用，这就解释了为什么图中的数跟示例代码循环中的数不一致。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@blanchon.vincent&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Vincent Blanchon&lt;/a&gt; 译者：&lt;a class=&#34;link&#34; href=&#34;https://github.com/lxbwolf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xiaobin.Liu&lt;/a&gt; 校对：&lt;a class=&#34;link&#34; href=&#34;https://github.com/polaris1119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;polaris1119&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/studygolang/GCTT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCTT&lt;/a&gt; 原创编译，&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/25292&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go语言中文网&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言的坑: String Format 带来的 Dead Lock</title>
        <link>https://lxb.wiki/1dadf84f/</link>
        <pubDate>Tue, 19 Nov 2019 23:03:37 +0800</pubDate>
        
        <guid>https://lxb.wiki/1dadf84f/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;如果类型定义了 String() 方法，它会被用在 fmt.Printf() 中生成默认的输出：等同于使用格式化描述符 %v 产生的输出。还有 fmt.Print() 和 fmt.Println() 也会自动使用 String() 方法。&lt;/p&gt;
&lt;p&gt;那么我们看看下面的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RWMutex&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;UpdateAge&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Errorf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age should be positive for customer %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;enter string method&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RLock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RUnlock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;id %s, age %d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt;)}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个例子中，如果调用 UpdateAge 方法 age 小于0会调用 fmt.Errorf，格式化输出，这个时候 String() 方法里面也进行了加锁，那么这样会造成死锁。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mutex.Lock -&amp;gt; check age -&amp;gt; Format error -&amp;gt; call String&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; -&amp;gt; mutex.RLock
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解决方法也很简单，一个是缩小锁的范围，在 check age 之后再加锁，另一种方法是 Format error 的时候不要 Format 整个结构体，可以改成 Format id 就行了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>go匿名函数和闭包</title>
        <link>https://lxb.wiki/e2c91def/</link>
        <pubDate>Sun, 17 Nov 2019 14:38:20 +0000</pubDate>
        
        <guid>https://lxb.wiki/e2c91def/</guid>
        <description>&lt;h3 id=&#34;函数变量函数值&#34;&gt;函数变量(函数值)&lt;/h3&gt;
&lt;p&gt;在 Go 语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func square(x int) {
	println(x * x)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;直接调用：square(1)&lt;/li&gt;
&lt;li&gt;把函数当成变量一样赋值：&lt;code&gt;s := square&lt;/code&gt;；接着可以调用这个函数变量：s(1)。 注意：这里 square 后面没有圆括号，调用才有。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;nil&lt;/code&gt; 的函数变量会导致 panic。&lt;/li&gt;
&lt;li&gt;函数变量的零值是 nil，这意味着它可以跟 nil 比较，但两个函数变量之间不能比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;匿名函数&#34;&gt;匿名函数&lt;/h3&gt;
&lt;p&gt;作用: 在go语言中目前了解的作用就是用于构成闭包&lt;/p&gt;
&lt;h3 id=&#34;闭包&#34;&gt;闭包&lt;/h3&gt;
&lt;p&gt;闭包通过引用的方式使用外部函数的变量
函数与 与其(直接)相关的环境形成闭包&lt;/p&gt;
&lt;p&gt;简单来说: 因为把返回的函数赋给了一个变量, 虽然函数在执行完一瞬间会销毁其执行环境, 但是如果有闭包的话, 闭包会保存外部函数的活动对象(变量), 所以如果不对闭包的引用消除掉, 闭包会一直存在内存中, 垃圾收集器不会销毁闭包占用的内存&lt;/p&gt;
&lt;h4 id=&#34;实例1&#34;&gt;实例1&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//函数A是一个不带参数，返回值是一个匿名函数，且该函数
//带有一个int类型参数，返回值为一个int类型
func A() func(int) int {
	sum := 0
	return func(bb int) int {
		sum += bb
		fmt.Println(&amp;#34;bb=&amp;#34;, bb, &amp;#34;\tsum=&amp;#34;, sum)
		return sum
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用1:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	a := A()//定义变量a,并将函数A的返回值赋给a // 这个时候, 虽然有小括号, 但是func A()还未真正执行, 只是赋值给了变量a
	b := a(4) //真正执行func A()
	fmt.Println(b)
}
/*
**    输出：   
**    bb= 4   sum= 4
**    4
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用2&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	a := A()
	a(0)
	a(1)
	a(5)
}
/*
**　　输出：
**　　bb= 0 	sum= 0
**　　bb= 1 	sum= 1
**　　bb= 5 	sum= 6
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上调用通过闭包实现了sum的累加&lt;/p&gt;
&lt;p&gt;调用3&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	a := A()
	c := A()
	a(0)
	a(5)
	c(10)
	c(20)
}
/*
**　　输出：
**　　bb= 0 	sum= 0
**　　bb= 5 	sum= 5
**　　bb= 10 	sum= 10
**　　bb= 20 	sum= 30   
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　可以看出，上例中调用了两次函数A，构成了两个闭包，这两个闭包维护的变量sum不是同一个变量。
　
　&lt;/p&gt;
&lt;h4 id=&#34;实例2&#34;&gt;实例2&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func B() []func() {
	b := make([]func(), 3, 3)
	for i := 0; i &amp;lt; 3; i++ {
		b[i] = func() {
			fmt.Println(i)
		}
	}
	return b
}

func main() {
	c := B() // 这个时候并未真正执行函数, 只是定义, 所以不会print
	c[0]() // 这个时候真正执行, 但是由于闭包, c[0] 中拿的i的引用
	c[1]()
	c[2]()
}
/*
**　　输出：
**　　3
**　　3
**　　3
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;闭包通过引用的方式使用外部函数的变量。&lt;/p&gt;
&lt;p&gt;　　上例中只调用了一次函数B,构成一个闭包(&lt;code&gt;func() {fmt.Println(i)}&lt;/code&gt; 与它的环境&lt;code&gt;func B() []func(){}&lt;/code&gt; 构成闭包)，i 在外部函数B中定义，所以闭包维护该变量 i ，c[0]、c[1]、c[2]中的 i 都是闭包中 i 的引用。&lt;/p&gt;
&lt;p&gt;　　因此执行&lt;code&gt;c:=B()&lt;/code&gt;后，i 的值已经变为3，故再调用c&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;0&lt;/a&gt;时的输出是3而不是0。
　　
可作如下修改：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func B() []func() {
	b := make([]func(), 3, 3)
	for i := 0; i &amp;lt; 3; i++ {
		b[i] = (func(j int) func() {
			return func() {
				fmt.Println(j)
			}
		})(i) // 这个地方的小括号是真正执行了
	}
	return b
}

func main() {
	c := B()
	c[0]()
	c[1]()
	c[2]()
}
/*
**    输出：
**        0
**        1
**        2
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数&lt;code&gt;func() {fmt.Println(j)}&lt;/code&gt; 与它的环境&lt;code&gt;func(j int) func() {}&lt;/code&gt; 构成闭包, 变量&lt;code&gt;i&lt;/code&gt;(实参) 并没有在它的环境范围内, 且 &lt;code&gt;j&lt;/code&gt;是形参
以上修改可能没有什么实际意义，此处仅为说明问题使用。&lt;/p&gt;
&lt;p&gt;在使用defer的时候可能出现类似问题，需要注意：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for j := 0; j &amp;lt; 2; j++ {
	defer (func() {
		fmt.Println(j)
	})()
}
/*
**    输出：    
**    2    
**    2
*/
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;实例3&#34;&gt;实例3:&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func incr() func() int {
	var x int
	return func() int {
		x++
		return x
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用这个函数会返回一个函数变量。
&lt;code&gt;i := incr()&lt;/code&gt; : 通过把这个函数变量赋值给&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; 就成为了一个闭包
所以&lt;code&gt;i&lt;/code&gt; 保存着对&lt;code&gt;x&lt;/code&gt; 的引用, 可以想象&lt;code&gt;i&lt;/code&gt; 中有着一个指针指向&lt;code&gt;x&lt;/code&gt; 或者 &lt;code&gt;i&lt;/code&gt; 中有&lt;code&gt;x&lt;/code&gt; 的地址&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;i&lt;/code&gt; 有着指向&lt;code&gt;x&lt;/code&gt; 的指针, 所以可以修改&lt;code&gt;x&lt;/code&gt; , 且保持着状态:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;println(i()) // 1
println(i()) // 2
println(i()) // 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说, &lt;code&gt;x&lt;/code&gt; 逃逸了, 它的声明周期没有随着它的作用域结束而结束
但是这段代码却不会递增：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;println(incr()()) // 1
println(incr()()) // 1
println(incr()()) // 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为这里调用了三次 &lt;code&gt;incr()&lt;/code&gt;，返回了三个闭包，这三个闭包引用着三个不同的 &lt;code&gt;x&lt;/code&gt;，它们的状态是各自独立的。&lt;/p&gt;
&lt;h4 id=&#34;实例4-闭包引用产生的问题&#34;&gt;实例4: 闭包引用产生的问题&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x := 1
f := func() {
	println(x)
}
x = 2
x = 3
f() // 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为闭包对外层词法域变量是引用的，所以这段代码会输出 3。
可以想象 f 中保存着 x 的地址，它使用 x 时会直接解引用，所以 x 的值改变了会导致 f 解引用得到的值也会改变。
但是，这段代码却会输出 1：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x := 1
func() {
	println(x) // 1
}()
x = 2
x = 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为 f 调用时就已经解引用取值了，这之后的修改就与它无关了。&lt;/p&gt;
&lt;p&gt;不过如果再次调用 f 还是会输出 3，这也再一次证明了 f 中保存着 x 的地址。
可以通过在闭包内外打印所引用变量的地址来证明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x := 1
func() {
	println(&amp;amp;x) // 0xc0000de790
}()
println(&amp;amp;x) // 0xc0000de790
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到引用的是同一个地址。&lt;/p&gt;
&lt;h4 id=&#34;实例51-循环闭包引用&#34;&gt;实例5.1: 循环闭包引用&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 0; i &amp;lt; 3; i++ {
	func() {
		println(i) // 0, 1, 2
	}()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码相当于：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 0; i &amp;lt; 3; i++ {
	f := func() {
		println(i) // 0, 1, 2
	}
	f()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每次迭代后都对 i 进行了解引用并使用得到的值且不再使用，所以这段代码会正常输出。&lt;/p&gt;
&lt;h4 id=&#34;实例52&#34;&gt;实例5.2&lt;/h4&gt;
&lt;p&gt;正常代码：输出 0, 1, 2：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var dummy [3]int
for i := 0; i &amp;lt; len(dummy); i++ {
	println(i) // 0, 1, 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而这段代码会输出 3：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var dummy [3]int
var f func()
for i := 0; i &amp;lt; len(dummy); i++ {
	f = func() {
		println(i)
	}
}
f() // 3 这个地方i最后的值是3, 而不是2, 因为只有i的值是3时, 才会跳出循环
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;实例53&#34;&gt;实例5.3&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var funcSlice []func()
for i := 0; i &amp;lt; 3; i++ {
	funcSlice = append(funcSlice, func() {
		println(i)
	})

}
for j := 0; j &amp;lt; 3; j++ {
	funcSlice[j]() // 3, 3, 3
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了解决上面这种情况, 可以声明新的匿名函数并传参:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var funcSlice []func()
for i := 0; i &amp;lt; 3; i++ {
	func(k int) {
		funcSlice = append(funcSlice, func() {
			println(k)
		})
	}(i)

}
for j := 0; j &amp;lt; 3; j++ {
	funcSlice[j]() // 0, 1, 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在 &lt;code&gt;println(k)&lt;/code&gt; 使用的 &lt;code&gt;k&lt;/code&gt; 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。(把&lt;code&gt;k&lt;/code&gt;换成&lt;code&gt;i&lt;/code&gt;也没有问题, 即使它与for条件的中的&lt;code&gt;i&lt;/code&gt; 和func的入参&lt;code&gt;i&lt;/code&gt; 重名也能正常运行)&lt;/p&gt;
&lt;p&gt;所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。&lt;/p&gt;
&lt;p&gt;这里的解决方法可以用在大多数跟闭包引用有关的问题上，不局限于第三个例子。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言的坑: Happens Before 保证</title>
        <link>https://lxb.wiki/a81f14e2/</link>
        <pubDate>Sat, 16 Nov 2019 23:01:24 +0800</pubDate>
        
        <guid>https://lxb.wiki/a81f14e2/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;创建 goroutine 发生先于 goroutine 执行，所以下面这段代码先读一个变量，然后在 goroutine 中写变量不会发生 data race 问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;goroutine 退出没有任何 happen before保证，例如下面代码会有 data race ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }()    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;channel 操作中 send 操作是 happens before receive 操作 ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  print(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面执行顺序应该是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;variable change -&amp;gt; channel send -&amp;gt; channel receive -&amp;gt; variable read
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面能够保证一定输出 &amp;ldquo;hello, world&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;close channel 是 happens before receive 操作，所以下面这个例子中也不会有 data race 问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    close(&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在无缓冲的 channel 中 receive 操作是 happens before send 操作的，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  print(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里同样能保证输出 hello, world。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言的坑: String 相关</title>
        <link>https://lxb.wiki/b23a493c/</link>
        <pubDate>Fri, 15 Nov 2019 22:58:48 +0800</pubDate>
        
        <guid>https://lxb.wiki/b23a493c/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&#34;迭代带来的问题&#34;&gt;迭代带来的问题&lt;/h3&gt;
&lt;p&gt;在 Go 语言中，字符串是一种基本类型，&lt;strong&gt;默认是通过 utf8 编码的字符序列&lt;/strong&gt;，当字符为 ASCII 码时则占用 1 个字节，其他字符根据需要占用 2-4 个字节，比如中文编码通常需要 3 个字节。&lt;/p&gt;
&lt;p&gt;那么我们在做 string 迭代的时候可能会产生意想不到的问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hêllo&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;position %d: %c\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;len=%d\n&amp;#34;&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 0: h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 1: Ã
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 3: l
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 4: l
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 5: o
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的输出中发现第二个字符是 Ã，不是 ê，并且位置2的输出”消失“了，这其实就是因为 ê 在 utf8 里面实际上占用 2 个 byte：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;s&lt;/th&gt;
&lt;th&gt;h&lt;/th&gt;
&lt;th&gt;ê&lt;/th&gt;
&lt;th&gt;l&lt;/th&gt;
&lt;th&gt;l&lt;/th&gt;
&lt;th&gt;o&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[]byte(s)&lt;/td&gt;
&lt;td&gt;68&lt;/td&gt;
&lt;td&gt;c3 aa&lt;/td&gt;
&lt;td&gt;6c&lt;/td&gt;
&lt;td&gt;6c&lt;/td&gt;
&lt;td&gt;6f&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以我们在迭代的时候 s[1] 等于 c3 这个 byte 等价 Ã 这个 utf8 值，所以输出的是 hÃllo 而不是 hêllo。&lt;/p&gt;
&lt;p&gt;那么根据上面的分析，我们就可以知道在迭代获取字符的时候不能只获取单个 byte，应该使用 range 返回的 value值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hêllo&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;position %d: %c\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者我们可以把 string 转成 rune 数组，在 go 中 rune 代表 Unicode码位，用它可以输出单个字符：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hêllo&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;runes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []rune(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;runes&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;position %d: %c\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;runes&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;])  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 0: h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 1: ê
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 2: l
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 3: l
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;position 4: o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;截断带来的问题&#34;&gt;截断带来的问题&lt;/h2&gt;
&lt;p&gt;Go 中&lt;strong&gt;在对slice使用 ：操作符进行截断的时候，底层的数组实际上指向同一个&lt;/strong&gt;，在 string 里面也需要注意这个问题，比如下面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;handleLog&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;) &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log is not correctly formatted&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;uuid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;[:&lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;uuid&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// Do something    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码用了 ：操作符进行截断，但是如果 log 这个对象很大，比如上面的 store 方法把 uuid 一直存在内存里，可能会造成底层的数组一直不释放，从而造成内存泄露。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以先复制一份再处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;handleLog&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;) &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log is not correctly formatted&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;uuid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strings&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Clone&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;[:&lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt;]) &lt;span style=&#34;color:#75715e&#34;&gt;// copy一份
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;uuid&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// Do something    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Go语言的坑: Defer</title>
        <link>https://lxb.wiki/725e70e6/</link>
        <pubDate>Thu, 14 Nov 2019 22:56:42 +0800</pubDate>
        
        <guid>https://lxb.wiki/725e70e6/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&#34;注意-defer-的调用时机&#34;&gt;注意 defer 的调用时机&lt;/h2&gt;
&lt;p&gt;有时候我们会像下面一样使用 defer 去关闭一些资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFiles&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;// Do something with file
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为defer会在方法结束的时候调用，但是&lt;strong&gt;如果上面的 readFiles 函数永远没有 return，那么 defer 将永远不会被调用&lt;/strong&gt;，从而造成内存泄露。并且 defer 写在 for 循环里面，编译器也无法做优化，会影响代码执行性能。&lt;/p&gt;
&lt;p&gt;为了避免这种情况，我们可以 wrap 一层：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFiles&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          } 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;readFile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Do something with file
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;注意-defer-的参数&#34;&gt;注意 defer 的参数&lt;/h2&gt;
&lt;p&gt;defer 声明时会先计算确定参数的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个例子中，变量 i 在 defer 被调用的时候就已经确定了，而不是在 defer执行的时候，所以上面的语句输出的是 0。&lt;/p&gt;
&lt;p&gt;所以我们想要获取这个变量的真实值，应该用引用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;notice&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;defer-下的闭包&#34;&gt;defer 下的闭包&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;//12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TestA&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;()) &lt;span style=&#34;color:#75715e&#34;&gt;//11
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果换成闭包的话，&lt;strong&gt;实际上闭包中对变量i是通过&lt;/strong&gt;指针传递&lt;strong&gt;的&lt;/strong&gt;，所以可以读到真实的值。但是上面的例子中 a 函数返回的是 11 是因为执行顺序是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;先计算（i+10）-&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;call defer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; -&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Go语言的坑: Range</title>
        <link>https://lxb.wiki/ad6a336e/</link>
        <pubDate>Wed, 13 Nov 2019 22:53:37 +0800</pubDate>
        
        <guid>https://lxb.wiki/ad6a336e/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&#34;copy-的问题&#34;&gt;copy 的问题&lt;/h2&gt;
&lt;p&gt;使用 range 的时候如果我们直接修改它返回的数据会不生效，因为返回的数据并不是原始数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;account&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;account&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100.&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;200.&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;300.&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果像上面这么做，那么输出的 accounts 是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[{&lt;/span&gt;100&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;200&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;300&lt;span style=&#34;color:#f92672&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以我们想要改变 range 中的数据可以这么做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;accounts&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;range slice 的话也会 copy 一份：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这份代码在 range 的时候会 copy 一份，因此只会调用三次 append 后停止。&lt;/p&gt;
&lt;h2 id=&#34;指针问题&#34;&gt;指针问题&lt;/h2&gt;
&lt;p&gt;比方我们想要 range slice 并将返回值存到 map 里面供后面业务使用，类似这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Balance&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      {&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Balance&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      {&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Balance&lt;/span&gt;: &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      {&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Balance&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Customer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;] = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是这样遍历 map 里面存的并不是我们想要的，你会发现存的 value 都是最后一个：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;:{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ID&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Balance&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;},&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;:{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ID&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Balance&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;},&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;:{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ID&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Balance&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;}}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是因为当我们使用 range 遍历 slice 的时候，返回的 customer 变量实际上是一个固定的地址：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%p\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;//我们想要获取这个指针的时候
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1400000e240
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1400000e2400x1400000e240
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是因为迭代器会把数据都放入到 0x1400000e240 这块空间里面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072255914.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以这样在 range 里面获取指针：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customer&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 使用局部变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%p\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 这里获取的指针是 range copy 出来元素的指针  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;// 使用局部变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%p\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Go语言的坑: Slice 相关</title>
        <link>https://lxb.wiki/46d0864d/</link>
        <pubDate>Tue, 12 Nov 2019 22:35:22 +0800</pubDate>
        
        <guid>https://lxb.wiki/46d0864d/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&#34;slice-的-length-和-capacity&#34;&gt;slice 的 length 和 capacity&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 make 函数里面，capacity 是可选的参数。上面这段代码我们创建了一个 length 是 3，capacity 是 6 的 slice，那么底层的数据结构是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072236023.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;slice 的底层实际上指向了一个数组。当然，由于我们的 length 是 3，所以这样设置 s[4] = 0 会 panic 的。需要使用 append 才能添加新元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;panic: runtime error: index out of range &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;4&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; with length &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 appned 超过 cap 大小的时候，slice 会自动帮我们扩容，&lt;strong&gt;在元素数量小于 1024 的时候每次会扩大一倍，当超过了 1024 个元素每次扩大 25%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有时候我们会使用 ：操作符从另一个 slice 上面创建一个新切片：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上这两个 slice 还是指向了底层同样的数组，构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072242263.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;由于指向了同一个数组，那么当我们改变第一个槽位的时候，比如 s1[1]=2，实际上两个 slice 的数据都会发生改变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072242344.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;但是当我们使用 append 的时候情况会有所不同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [0 2 0]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [2 0 3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072245415.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;s1 的 len 并没有被改变，所以看到的还是3元素。&lt;/p&gt;
&lt;p&gt;还有一件比较有趣的细节是，如果再接着 append s1 那么第四个元素会被覆盖掉：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [0 2 0 4]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// [2 0 4]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072246667.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;再继续 append s2 直到 s2 发生扩容，这个时候会发现 s2 实际上和 s1 指向的不是同一个数组了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;//[0 2 0 4]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;//[2 0 4 5 6 7]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072247151.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;除了上面这种情况，还有一种情况 append 会产生意想不到的效果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072249781.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果 print 它们应该是这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s1&lt;/span&gt;=[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;s2&lt;/span&gt;=[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;s3&lt;/span&gt;=[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;slice-初始化&#34;&gt;slice 初始化&lt;/h2&gt;
&lt;p&gt;slice 的初始化有很多种方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = []string(&lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d: empty=%t\tnil=%t\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;empty&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;empty&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;empty&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;empty&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;=&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;前两种方式会创建一个 nil 的 slice，后两种会进行初始化，并且这些 slice 的大小都为 0 。&lt;/p&gt;
&lt;p&gt;对于 var s []string 这种方式来说，好处就是&lt;strong&gt;不用做任何的内存分配&lt;/strong&gt;。比如下面场景可能可以节省一次内存分配:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;() []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bar&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 s := []string{} 这种方式来说，它&lt;strong&gt;比较适合初始化一个已知元素的 slice&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bar&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;baz&amp;#34;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果没有这个需求其实用 var s []string 比较好，反正在使用的适合都是通过 append 添加元素， var s []string 还能节省一次内存分配。&lt;/p&gt;
&lt;p&gt;如果我们初始化了一个空的 slice， 那么&lt;strong&gt;最好是使用&lt;/strong&gt; len(xxx) == 0&lt;strong&gt;来判断 slice 是不是空的&lt;/strong&gt;，如果使用 nil 来判断可能会永远非空的情况，因为对于 s := []string{} 和 s = make([]string, 0) 这两种初始化都是非 nil 的。&lt;/p&gt;
&lt;p&gt;对于 []string(nil) 这种初始化的方式，使用场景很少，一种比较方便地使用场景是用它来进行 slice 的 copy：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; append([]int(&lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 make 来说，它可以初始化 slice 的 length 和 capacity，如果我们能确定 slice 里面会存放多少元素，&lt;strong&gt;从性能的角度考虑最好使用 make 初始化好&lt;/strong&gt;，因为对于一个空的 slice append 元素进去每次达到阈值都需要进行扩容，下面是填充 100 万元素的 benchmark：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkConvert_EmptySlice-4 &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;49739882&lt;/span&gt; ns/op
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkConvert_GivenCapacity-4 &lt;span style=&#34;color:#ae81ff&#34;&gt;86&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;13438544&lt;/span&gt; ns/op
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BenchmarkConvert_GivenLength-4 &lt;span style=&#34;color:#ae81ff&#34;&gt;91&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12800411&lt;/span&gt; ns/op
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，如果我们提前填充好 slice 的容量大小，性能是空 slice 的四倍，因为少了扩容时元素复制以及重新申请新数组的开销。&lt;/p&gt;
&lt;h2 id=&#34;copy-slice&#34;&gt;copy slice&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;copy(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 copy 函数 copy slice 的时候需要注意，上面这种情况实际上会 copy 失败，因为对 slice 来说是由 length 来控制可用数据，copy 并没有复制这个字段，要想 copy 我们可以这么做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;copy(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;//[0 1 2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除此之外也可以用上面提到的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; append([]int(&lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;slice-capacity内存释放问题&#34;&gt;slice capacity内存释放问题&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keepFirstTwoElementsOnly&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;) []&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;[:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1_000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printAlloc&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;: make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printAlloc&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;two&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keepFirstTwoElementsOnly&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;runtime&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GC&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printAlloc&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;runtime&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;KeepAlive&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;two&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这个例子中使用 printAlloc 函数来打印内存占用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printAlloc&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;runtime&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;MemStats&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;runtime&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadMemStats&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d KB\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Alloc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面 foos 初始化了 1000 个容量的 slice ，里面 Foo struct 每个都持有 1M 内存的 slice，然后通过 keepFirstTwoElementsOnly 返回持有前两个元素的 Foo 切片，我们的想法是手动执行 GC 之后其他的 998 个 Foo 会被 GC 销毁，但是输出结果如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;387&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;KB&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024315&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;KB1024319&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;KB&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上并没有，原因就是实际上 keepFirstTwoElementsOnly 返回的 slice 底层持有的数组是和 foos 持有的同一个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072252699.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;所以我们真的要只返回 slice 的前2个元素的话应该这样做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keepFirstTwoElementsOnly&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;) []&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        copy(&lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过上面这种方法会初始化一个新的 slice，然后将两个元素 copy 过去。不想进行多余的分配可以这么做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keepFirstTwoElementsOnly&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;) []&lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foos&lt;/span&gt;[:&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Go语言的坑: Float 的精度</title>
        <link>https://lxb.wiki/b936d10f/</link>
        <pubDate>Sun, 10 Nov 2019 22:26:32 +0800</pubDate>
        
        <guid>https://lxb.wiki/b936d10f/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;在 Go 中浮点数表示方式和其他语言一样，都是通过科学计数法表示，float 在存储中分为三部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;符号位（Sign）: 0代表正，1代表为负
指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
尾数部分（Mantissa）：尾数部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072227340.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这种计数法在 Go 里面会有哪些问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100000.001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0002&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;200030.00200030004
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;200030.0020003
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果想要准确计算浮点的话，可以尝试 &lt;a class=&#34;link&#34; href=&#34;https://github.com/shopspring/decimal&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/shopspring/decimal&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decimal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewFromFloat&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;100000.001&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decimal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewFromFloat&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0001&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decimal&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewFromFloat&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0002&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Mul&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;))) &lt;span style=&#34;color:#75715e&#34;&gt;//200030.0020003
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/14407&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在 Go 中探索 IEEE-754 标准 - Go语言中文网 - Golang中文社区 (studygolang.com)&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言的坑: 八进制整数</title>
        <link>https://lxb.wiki/8f80ddfc/</link>
        <pubDate>Sat, 09 Nov 2019 22:23:08 +0800</pubDate>
        
        <guid>https://lxb.wiki/8f80ddfc/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;011&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行之后，不会输出 111，而是 108， 因为&lt;strong&gt;在 Go 中以 0 开头的整数表示八进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它经常用在处理 Linux 权限相关的代码上，如下面打开一个文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;OpenFile&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;O_RDONLY&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0644&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以为了可读性，我们在用八进制的时候最好使用 &amp;ldquo;0o&amp;rdquo; 的方式表示，比如上面这段代码可以表示为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;OpenFile&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;O_RDONLY&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;o644&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Go语言的坑: Init 函数</title>
        <link>https://lxb.wiki/dc53dc63/</link>
        <pubDate>Fri, 08 Nov 2019 22:19:41 +0800</pubDate>
        
        <guid>https://lxb.wiki/dc53dc63/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&#34;init-函数会在全局变量之后被执行&#34;&gt;init 函数会在全局变量之后被执行&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;init 函数并不是最先被执行的，如果声明了 const 或全局变量，那么 init 函数会在它们之后执行：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;init&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// output
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;initmain&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;init-初始化按解析的依赖关系顺序执行&#34;&gt;init 初始化按解析的依赖关系顺序执行&lt;/h2&gt;
&lt;p&gt;比如 main 包里面有 init 函数，依赖了 redis 包，main 函数执行了 redis 包的 Store 函数，恰好 redis 包里面也有 init 函数，那么执行顺序会是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/202306072221755.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况，如果是使用 &amp;ldquo;import _ foo&amp;rdquo; 这种方式引入的，也是会先调用 foo 包中的 init 函数。&lt;/p&gt;
&lt;h2 id=&#34;扰乱单元测试&#34;&gt;扰乱单元测试&lt;/h2&gt;
&lt;p&gt;比如我们在 init 函数中初始了一个全局的变量，但是单测中并不需要，那么实际上会增加单测得复杂度，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sql&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DB&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;dataSourceName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Getenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MYSQL_DATA_SOURCE_NAME&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sql&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mysql&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;dataSourceName&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Panic&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面这个例子中 init 函数初始化了一个 db 全局变量，那么在单测的时候也会初始化一个这样的变量，但是很多单测其实是很简单的，并不需要依赖这个东西。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go语言的坑: Shadow 变量</title>
        <link>https://lxb.wiki/7edb3d45/</link>
        <pubDate>Thu, 07 Nov 2019 22:13:56 +0800</pubDate>
        
        <guid>https://lxb.wiki/7edb3d45/</guid>
        <description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Client&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tracing&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createClientWithTracing&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createDefaultClient&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;)  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面这段代码中，声明了一个 client 变量，然后使用 tracing 控制变量的初始化，可能是因为没有声明 err 的缘故，使用的是 := 进行初始化，那么会导致&lt;strong&gt;外层的 client 变量永远是 nil&lt;/strong&gt;。这个例子实际上是很容易发生在我们实际的开发中，尤其需要注意。&lt;/p&gt;
&lt;p&gt;如果是因为 err 没有初始化的缘故，我们在初始化的时候可以这么做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Client&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tracing&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;createClientWithTracing&lt;/span&gt;() 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// 防止重复代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者内层的变量声明换一个变量名字，这样就不容易出错了。&lt;/p&gt;
&lt;p&gt;我们也可以使用工具分析代码是否有 shadow，先安装一下工具：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用 shadow 命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go vet -vettool&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/path/to/shadow ./main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# command-line-arguments&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./main.go:15:3: declaration of &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;client&amp;#34;&lt;/span&gt; shadows declaration at line &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./main.go:21:3: declaration of &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;client&amp;#34;&lt;/span&gt; shadows declaration at line &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Golang的反射</title>
        <link>https://lxb.wiki/1d3c1f0e/</link>
        <pubDate>Sun, 03 Nov 2019 21:21:59 +0000</pubDate>
        
        <guid>https://lxb.wiki/1d3c1f0e/</guid>
        <description>&lt;h4 id=&#34;编程语言中反射的概念&#34;&gt;编程语言中反射的概念&lt;/h4&gt;
&lt;p&gt;在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。&lt;/p&gt;
&lt;p&gt;每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。&lt;/p&gt;
&lt;p&gt;Golang的gRPC也是通过反射实现的。&lt;/p&gt;
&lt;h4 id=&#34;interface-和反射&#34;&gt;interface 和反射&lt;/h4&gt;
&lt;p&gt;先来看看Golang关于类型设计的一些原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量包括（value, type）两部分
&lt;ul&gt;
&lt;li&gt;理解这一点就知道为什么nil != nil了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型&lt;/li&gt;
&lt;li&gt;类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。&lt;/p&gt;
&lt;p&gt;在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(value, type)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。&lt;/p&gt;
&lt;p&gt;例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tty, err := os.OpenFile(&amp;#34;/dev/tty&amp;#34;, os.O_RDWR, 0)

var r io.Reader
r = tty
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var w io.Writer
w = r.(io.Writer)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。&lt;/p&gt;
&lt;p&gt;interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。&lt;/p&gt;
&lt;h4 id=&#34;reflect-基本功能typeof和valueof&#34;&gt;reflect 基本功能TypeOf和ValueOf&lt;/h4&gt;
&lt;p&gt;既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i.  ValueOf(nil) returns the zero 
func ValueOf(i interface{}) Value {...}

翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0


// TypeOf returns the reflection Type that represents the dynamic type of i.
// If i is a nil interface value, TypeOf returns nil.
func TypeOf(i interface{}) Type {...}

翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;reflect&amp;#34;
)

func main() {
	var num float64 = 1.2345

	fmt.Println(&amp;#34;type: &amp;#34;, reflect.TypeOf(num))
	fmt.Println(&amp;#34;value: &amp;#34;, reflect.ValueOf(num))
}

运行结果:
type:  float64
value:  1.2345
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;说明&#34;&gt;说明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型&lt;/li&gt;
&lt;li&gt;reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;amp;{1 &amp;ldquo;Allen.Wu&amp;rdquo; 25} 这样的结构体struct的值&lt;/li&gt;
&lt;li&gt;也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;从relfectvalue中获取接口interface的信息&#34;&gt;从relfect.Value中获取接口interface的信息&lt;/h4&gt;
&lt;p&gt;当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;已知原有类型【进行“强制转换”】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;realValue := value.Interface().(已知的类型)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;reflect&amp;#34;
)

func main() {
	var num float64 = 1.2345

	pointer := reflect.ValueOf(&amp;amp;num)
	value := reflect.ValueOf(num)

	// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic
	// Golang 对类型要求非常严格，类型一定要完全符合
	// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic
	convertPointer := pointer.Interface().(*float64)
	convertValue := value.Interface().(float64)

	fmt.Println(convertPointer)
	fmt.Println(convertValue)
}

运行结果：
0xc42000e238
1.2345
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;说明-1&#34;&gt;说明&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！&lt;/li&gt;
&lt;li&gt;转换的时候，要区分是指针还是指&lt;/li&gt;
&lt;li&gt;也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;未知原有类型【遍历探测其Filed】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;reflect&amp;#34;
)

type User struct {
	Id   int
	Name string
	Age  int
}

func (u User) ReflectCallFunc() {
	fmt.Println(&amp;#34;Allen.Wu ReflectCallFunc&amp;#34;)
}

func main() {

	user := User{1, &amp;#34;Allen.Wu&amp;#34;, 25}

	DoFiledAndMethod(user)

}

// 通过接口来获取任意参数，然后一一揭晓
func DoFiledAndMethod(input interface{}) {

	getType := reflect.TypeOf(input)
	fmt.Println(&amp;#34;get Type is :&amp;#34;, getType.Name())

	getValue := reflect.ValueOf(input)
	fmt.Println(&amp;#34;get all Fields is:&amp;#34;, getValue)

	// 获取方法字段
	// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历
	// 2. 再通过reflect.Type的Field获取其Field
	// 3. 最后通过Field的Interface()得到对应的value
	for i := 0; i &amp;lt; getType.NumField(); i++ {
		field := getType.Field(i)
		value := getValue.Field(i).Interface()
		fmt.Printf(&amp;#34;%s: %v = %v\n&amp;#34;, field.Name, field.Type, value)
	}

	// 获取方法
	// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历
	for i := 0; i &amp;lt; getType.NumMethod(); i++ {
		m := getType.Method(i)
		fmt.Printf(&amp;#34;%s: %v\n&amp;#34;, m.Name, m.Type)
	}
}

运行结果：
get Type is : User
get all Fields is: {1 Allen.Wu 25}
Id: int = 1
Name: string = Allen.Wu
Age: int = 25
ReflectCallFunc: func(main.User)
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;说明-2&#34;&gt;说明&lt;/h5&gt;
&lt;p&gt;通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先获取interface的reflect.Type，然后通过NumField进行遍历&lt;/li&gt;
&lt;li&gt;再通过reflect.Type的Field获取其Field&lt;/li&gt;
&lt;li&gt;最后通过Field的Interface()得到对应的value&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先获取interface的reflect.Type，然后通过NumMethod进行遍历&lt;/li&gt;
&lt;li&gt;再分别通过reflect.Type的Method获取对应的真实的方法（函数）&lt;/li&gt;
&lt;li&gt;最后对结果取其Name和Type得知具体的方法名&lt;/li&gt;
&lt;li&gt;也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”&lt;/li&gt;
&lt;li&gt;struct 或者 struct 的嵌套都是一样的判断处理方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;通过reflect.Value设置实际变量的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;reflect&amp;#34;
)

func main() {

	var num float64 = 1.2345
	fmt.Println(&amp;#34;old value of pointer:&amp;#34;, num)

	// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值
	pointer := reflect.ValueOf(&amp;amp;num)
	newValue := pointer.Elem()

	fmt.Println(&amp;#34;type of pointer:&amp;#34;, newValue.Type())
	fmt.Println(&amp;#34;settability of pointer:&amp;#34;, newValue.CanSet())

	// 重新赋值
	newValue.SetFloat(77)
	fmt.Println(&amp;#34;new value of pointer:&amp;#34;, num)

	////////////////////
	// 如果reflect.ValueOf的参数不是指针，会如何？
	pointer = reflect.ValueOf(num)
	//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”
}

运行结果：
old value of pointer: 1.2345
type of pointer: float64
settability of pointer: true
new value of pointer: 77
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;说明-3&#34;&gt;说明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，&lt;strong&gt;注意一定要是指针&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果传入的参数不是指针，而是变量，那么
&lt;ul&gt;
&lt;li&gt;通过Elem获取原始值对应的对象则直接panic&lt;/li&gt;
&lt;li&gt;通过CanSet方法查询是否可以设置返回false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。&lt;/li&gt;
&lt;li&gt;reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的&lt;/li&gt;
&lt;li&gt;也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】&lt;/li&gt;
&lt;li&gt;struct 或者 struct 的嵌套都是一样的判断处理方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;通过reflect.ValueOf来进行方法的调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;reflect&amp;#34;
)

type User struct {
	Id   int
	Name string
	Age  int
}

func (u User) ReflectCallFuncHasArgs(name string, age int) {
	fmt.Println(&amp;#34;ReflectCallFuncHasArgs name: &amp;#34;, name, &amp;#34;, age:&amp;#34;, age, &amp;#34;and origal User.Name:&amp;#34;, u.Name)
}

func (u User) ReflectCallFuncNoArgs() {
	fmt.Println(&amp;#34;ReflectCallFuncNoArgs&amp;#34;)
}

// 如何通过反射来进行方法的调用？
// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call

func main() {
	user := User{1, &amp;#34;Allen.Wu&amp;#34;, 25}
	
	// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理
	getValue := reflect.ValueOf(user)

	// 一定要指定参数为正确的方法名
	// 2. 先看看带有参数的调用方法
	methodValue := getValue.MethodByName(&amp;#34;ReflectCallFuncHasArgs&amp;#34;)
	args := []reflect.Value{reflect.ValueOf(&amp;#34;wudebao&amp;#34;), reflect.ValueOf(30)}
	methodValue.Call(args)

	// 一定要指定参数为正确的方法名
	// 3. 再看看无参数的调用方法
	methodValue = getValue.MethodByName(&amp;#34;ReflectCallFuncNoArgs&amp;#34;)
	args = make([]reflect.Value, 0)
	methodValue.Call(args)
}


运行结果：
ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu
ReflectCallFuncNoArgs
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;说明-4&#34;&gt;说明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理&lt;/li&gt;
&lt;li&gt;reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。&lt;/li&gt;
&lt;li&gt;[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。&lt;/li&gt;
&lt;li&gt;reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value&amp;rsquo;Kind不是一个方法，那么将直接panic。&lt;/li&gt;
&lt;li&gt;本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;golang的反射reflect性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Field field = clazz.getField(&amp;#34;hello&amp;#34;);
field.get(obj1);
field.get(obj2);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。&lt;/p&gt;
&lt;p&gt;但是Golang的反射不是这样设计的:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type_ := reflect.TypeOf(obj)
field, _ := type_.FieldByName(&amp;#34;hello&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type_ := reflect.ValueOf(obj)
fieldValue := type_.FieldByName(&amp;#34;hello&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。&lt;/p&gt;
&lt;p&gt;Golang reflect慢主要有两个原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;涉及到内存分配以及后续的GC；&lt;/li&gt;
&lt;li&gt;reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地
&lt;ul&gt;
&lt;li&gt;反射必须结合interface才玩得转&lt;/li&gt;
&lt;li&gt;变量的type要是concrete type的（也就是interface变量）才有反射一说&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反射可以将“接口类型变量”转换为“反射类型对象”
&lt;ul&gt;
&lt;li&gt;反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反射可以将“反射类型对象”转换为“接口类型变量
&lt;ul&gt;
&lt;li&gt;reflect.value.Interface().(已知的类型)&lt;/li&gt;
&lt;li&gt;遍历reflect.Type的Field获取其Field&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反射可以修改反射类型对象，但是其值必须是“addressable”
&lt;ul&gt;
&lt;li&gt;想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过反射可以“动态”调用方法&lt;/li&gt;
&lt;li&gt;因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Golang编译器漏洞和标准库设计失误</title>
        <link>https://lxb.wiki/4fe063a2/</link>
        <pubDate>Sun, 20 Oct 2019 11:29:37 +0000</pubDate>
        
        <guid>https://lxb.wiki/4fe063a2/</guid>
        <description>&lt;p&gt;字节切片（byte slice）相关的编译器漏洞和标准库设计失误&lt;/p&gt;
&lt;p&gt;假如一个类型MyByte定义如下，如何将一个[]MyByte切片值和一个[]byte切片值互相转换为对方的类型？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)

func main() {
  x = []byte(y) // error: 非法的转换
  y = []MyByte(x) // error: 非法的转换
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上例所示，在Go中，这两个类型的值之间的类型转换是非法的。因为Go规定两个切片只有在它们的类型的底层类型（underlying type）相同的情况下才能转换到对方的类型。而一个非定义类型（undefined type）的底层类型为此非定义类型本身。类型[]MyByte和[]byte均为非定义类型，所以它们的底层类型不同，从而它们的值也就不能转换到对方的类型。&lt;/p&gt;
&lt;p&gt;难道真没有办法实现它们之间的转换了？有，而且有好几种。第一种方法是使用类型非安全指针来实现双向转换，另外两种方法只能实现单向转换。另外的这两种方法要么利用了编译器的漏洞，要么利用了reflect标准库包的设计失误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用类型非安全指针的实现。&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;unsafe&amp;#34;

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)

func main() {
  p := unsafe.Pointer(&amp;amp;y)
  x = *(*[]byte)(p)
  x[0] = 99
  println(y[0]) // 99
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在使用类型非安全指针的实现中，转换结果和原切片共享底层元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用标准编译器的bug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以将一个[]byte切片值转换为string, 再把string转换为类型[]MyByte。转换结果和原切片不共享底层元素。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)

func main() {
  // 下一行利用了编译器漏洞
  y = []MyByte(string(x))
  y[0] = 99
  println(x[0]) // 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go白皮书提到一个字节切片可以转换为一个字符串，反之亦然。但是什么是字节切片类型呢？底层类型为[]byte的切片类型还是元素类型的底层类型为byte的切片类型？如果字节切片类型定义为&lt;strong&gt;元素类型的底层类型为byte的切片类型&lt;/strong&gt;，则[]MyByte和[]byte都可称为字节切片类型。如果字节切片类型定义为&lt;strong&gt;底层类型为[]byte的切片类型&lt;/strong&gt;，则只有[]byte可以被称为字节切片类型。我们认为标准编译器采纳了&lt;strong&gt;底层类型为[]byte的切片类型才称为字节切片&lt;/strong&gt;这一定义，因为下面这个程序使用标准编译器是编译不过的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)
func main() {
  _ = string(y) // error: 非法转换
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，标准编译器（v1.12）却认为转换[]MyByte(&amp;ldquo;abc&amp;rdquo;)是合法的。这显然是一个漏洞。&lt;/p&gt;
&lt;p&gt;对于码点切片（rune slice）和字符串之间的转换，同样的情况也存在。&lt;/p&gt;
&lt;p&gt;对于gccgo编译器来说，此漏洞是对称的，因而更严重。此更严重的漏洞使得上述两种类型的值之间的转换是双向有效的。比如，下面这段代码使用gccgo（v8.0）编译是没问题的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)

func main() {
  // 下一行利用了编译器漏洞
  y = []MyByte(string(x))
  y[0] = 99
  println(x[0]) // 1
  
  // 下一行利用了编译器漏洞
  x = []byte(string(y))
  x[0] = 127
  println(y[0]) // 99
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事实上，gccgo编译器在内置copy和append函数的实现中也存在着同样的漏洞。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)

func main() {
  // 下一行利用了编译器漏洞
  copy(y, string(x))
  y[0] = 99
  println(x[0]) // 1
  
  
  // 下一行利用了编译器漏洞
  y = append([]MyByte(nil), string(x)...)
  y[0] = 99
  println(x[0]) // 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第三种方法利用了&lt;code&gt;reflect&lt;/code&gt;标准库包的设计失误。此失误导致将&lt;code&gt;[]MyByte&lt;/code&gt;值单向转换为类型&lt;code&gt;[]byte&lt;/code&gt;是可行的，虽然这违反了Go类型系统确定的规则。使用第三种方法得到的结果切片和原切片共享底层元素。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;reflect&amp;#34;

type MyByte byte
var (
  x = []byte{1, 2, 3}
  y = []MyByte{1, 2, 3}
)

func main() {
  v := reflect.ValueOf(y)
  x = v.Bytes()
  x[0] = 99
  println(y[0]) // 99
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Go闭包技术</title>
        <link>https://lxb.wiki/eb01d7dc/</link>
        <pubDate>Fri, 04 Oct 2019 19:25:07 +0000</pubDate>
        
        <guid>https://lxb.wiki/eb01d7dc/</guid>
        <description>&lt;p&gt;斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&amp;gt;=3，n∈N*）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201002956.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和.
为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 0 1 1 2 3 5 8 13 21 34 55
// a b
// a b
a, b := 0, 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func fibonacciByNormal() {
    a, b := 0, 1
    a, b = b, a+b
    fmt.Print(a, &amp;#34; &amp;#34;)
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何?&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func fibonacciByNormal() {
    a, b := 0, 1
    for i := 0; i &amp;lt; 10; i++ {
        a, b = b, a+b
        fmt.Print(a, &amp;#34; &amp;#34;)
    }
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1 1 2 3 5 8 13 21 34 55
func TestFibonacciByNormal(t *testing.T) {
    fibonacciByNormal()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路!&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1 1 2 3 5 8 13 21 34 55
func fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1 1 2 3 5 8 13 21 34 55
func TestFibonacci(t *testing.T) {
    f := fibonacci()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Print(f(), &amp;#34; &amp;#34;)
    }
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为&amp;quot;闭包&amp;quot;!&lt;/p&gt;
&lt;p&gt;闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func autoIncrease() func() int {
    i := 0
    return func() int {
        i = i + 1
        return i
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestAutoIncrease(t *testing.T) {
    a := autoIncrease()
    // 1 2 3
    t.Log(a(), a(), a())
    b := autoIncrease()
    // 1 2 3
    t.Log(b(), b(), b())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果.&lt;/p&gt;
&lt;p&gt;普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生.&lt;/p&gt;
&lt;p&gt;但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会&amp;quot;长生不老&amp;quot;,并不会因为出身于函数内就和普通变量拥有一样的短暂人生.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func fightWithHorse() func() int {
    horseShowTime := 0
    return func() int {
        horseShowTime++
        fmt.Printf(&amp;#34;(%d)祖国需要我,我就提枪上马立即战斗!\n&amp;#34;,horseShowTime)
        return horseShowTime
    }
}

func TestFightWithHorse(t *testing.T) {
    f := fightWithHorse()
    // 1 2 3
    t.Log(f(), f(), f())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心!
下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func countByClosureButWrong() []func() int {
    var arr []func() int
 for i := 1; i &amp;lt;= 3; i++ {
        arr = append(arr, func() int {
            return i
        })
    }
    return arr
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestCountByClosure(t *testing.T) {
    // 4 4 4
    for _, c := range countByClosureButWrong() {
        t.Log(c())
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c.&lt;/p&gt;
&lt;p&gt;当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003531.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003721.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4.&lt;/p&gt;
&lt;p&gt;既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛!&lt;/p&gt;
&lt;p&gt;最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func countByClosureButWrong() []func() int {
    var arr []func() int
 for i := 1; i &amp;lt;= 3; i++ {
        n := i
        fmt.Printf(&amp;#34;for i=%d n=%d \n&amp;#34;, i,n)
        arr = append(arr, func() int {
            fmt.Printf(&amp;#34;append i=%d n=%d\n&amp;#34;, i, n)
            return n
        })
    }
    return arr
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201201003831.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级.&lt;/p&gt;
&lt;p&gt;既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func countByClosureWithOk() []func() int {
    var arr []func() int
 for i := 1; i &amp;lt;= 3; i++ {
        fmt.Printf(&amp;#34;for i=%d \n&amp;#34;, i)
        func(n int) {
            arr = append(arr, func() int {
                fmt.Printf(&amp;#34;append n=%d \n&amp;#34;, n)
                return n
            })
        }(i)
    }
    return arr
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestCountByClosureWithOk(t *testing.T) {
    // 1 2 3
    for _, c := range countByClosureWithOk() {
        t.Log(c())
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;模拟类和对象的关系,也可以实现封装,具备一定面向对象能力
&lt;ul&gt;
&lt;li&gt;每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本.
&lt;ul&gt;
&lt;li&gt;长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现闭包成本较高,同时也增加了理解难度.
&lt;ul&gt;
&lt;li&gt;普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;滥用容易占用过多内存,可能造成内存泄漏.
&lt;ul&gt;
&lt;li&gt;过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>大小端</title>
        <link>https://lxb.wiki/7ee0edaa/</link>
        <pubDate>Fri, 24 May 2019 18:37:53 +0000</pubDate>
        
        <guid>https://lxb.wiki/7ee0edaa/</guid>
        <description>&lt;p&gt;计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构而已），比如C/C++中，short类型一般是2个字节，int类型一般4个字节等。因此这里就存在着一个如何安排多个字节数据中各字节存放顺序的问题。正是因为不同的安排顺序导致了大端存储模式和小端存储模式的存在。&lt;/p&gt;
&lt;h4 id=&#34;1-解释&#34;&gt;1. 解释&lt;/h4&gt;
&lt;p&gt;假如有一个4字节的数据为 0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址 0x4000 8000中，则有：&lt;/p&gt;
&lt;p&gt;内存地址&lt;/p&gt;
&lt;p&gt;0x4000 8000（低地址）&lt;/p&gt;
&lt;p&gt;0x4000 8001&lt;/p&gt;
&lt;p&gt;0x4000 8002&lt;/p&gt;
&lt;p&gt;0x4000 8003（高地址）&lt;/p&gt;
&lt;p&gt;大端模式&lt;/p&gt;
&lt;p&gt;0x12（高字节）&lt;/p&gt;
&lt;p&gt;0x34&lt;/p&gt;
&lt;p&gt;0x56&lt;/p&gt;
&lt;p&gt;0x78（低字节）&lt;/p&gt;
&lt;p&gt;小端模式&lt;/p&gt;
&lt;p&gt;0x78（低字节）&lt;/p&gt;
&lt;p&gt;0x56&lt;/p&gt;
&lt;p&gt;0x34&lt;/p&gt;
&lt;p&gt;0x12（高字节）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中&lt;/li&gt;
&lt;li&gt;小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么截然相反的大小端存储模式能够并存至今？在标准化备受推崇的今天，为什么大小端谁都没有被另外一个所同化？我想这除了历史的惯性使然，还与它们各自的优缺点有关。 大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小 小端模式优点：1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）； 2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持（见1.3节），因此在多字节存储顺序上始终没有一个统一的标准&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel的80×86系列芯片使用小端存储模式&lt;/li&gt;
&lt;li&gt;ARM芯片默认采用小端，但可以切换为大端&lt;/li&gt;
&lt;li&gt;MIPS芯片采用大端，但可以在大小端之间切换&lt;/li&gt;
&lt;li&gt;在网络上传输的数据普遍采用的都是大端&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-判断&#34;&gt;2. 判断&lt;/h4&gt;
&lt;p&gt;方法一：通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @Ret: 大端，返回true; 小端，返回false
bool IsBigEndian_1()
{
    int nNum = 0x12345678;
    char cLowAddressValue = *(char*)&amp;amp;nNum;

    // 低地址处是高字节，则为大端
    if ( cLowAddressValue == 0x12 )    return true;

    return false; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二：利用联合体union的存放顺序是所有成员都从低地址开始存放这一特性进行检测&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// @Ret: 大端，返回true; 小端，返回false
bool isBigEndian_2()
{
    union uendian
    {
       int nNum;
       char cLowAddressValue;
    };

    uendian u;
    u.nNum = 0x12345678;

    if ( u.cLowAddressValue == 0x12 )     return true;

    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-转换&#34;&gt;3. 转换&lt;/h4&gt;
&lt;p&gt;大小端转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 实现16bit的数据之间的大小端转换
#define BLSWITCH16(A)   (  ( ( (uint16)(A) &amp;amp; 0xff00 ) &amp;gt;&amp;gt; 8  )    | \  
                           ( ( (uint16)(A) &amp;amp; 0x00ff ) &amp;lt;&amp;lt; 8  )     )  

// 实现32bit的数据之间的大小端转换
#define BLSWITCH32(A)   (  ( ( (uint32)(A) &amp;amp; 0xff000000) &amp;gt;&amp;gt; 24) |\
         (((uint32)(A) &amp;amp; 0x00ff0000) &amp;gt;&amp;gt; 8) | \
         (((unit32)(A) &amp;amp; 0x0000ff00) &amp;lt;&amp;lt; 8) | \
         (((uint32)(A) &amp;amp; 0x000000ff) &amp;lt;&amp;lt; 32)  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go 基础语法</title>
        <link>https://lxb.wiki/936ea20/</link>
        <pubDate>Fri, 03 May 2019 23:19:02 +0000</pubDate>
        
        <guid>https://lxb.wiki/936ea20/</guid>
        <description>&lt;p&gt;有意思的变量和不安分的常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量默认初始化有零值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestVariableZeroValue(t *testing.T) {
    var a int
    var s string
    // 0
    t.Log(a, s)
    // 0 &amp;#34;&amp;#34;
    t.Logf(&amp;#34;%d %q&amp;#34;, a, s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;int 类型的变量初始化默认零值是零 0, string 类型的变量默认初始化零值是空字符串 ,其他类型也有相应的零值.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个变量可以同时赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestVariableInitialValue(t *testing.T) {
    var a, b int = 1, 2
    var s string = &amp;#34;hello Go&amp;#34;
    // 1 2 hello Go
    t.Log(a, b, s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他主要的编程语言大多支持多个变量初始化,但极少数有像 Go 语言这样,不仅支持同时初始化,还可以同时赋值.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个变量可以用小括号 () 统一定义&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestVariableShorter(t *testing.T) {
    var (
    a int    = 1
    b int    = 2
    s string = &amp;#34;hello go&amp;#34;
    )
    // 1 2 hello Go
    t.Log(a, b, s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用小括号 () 方式,省略了相同的 var 关键字,看起来更加统一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量类型可以被自动推断&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TestVariableTypeDeduction&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello Go&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1 2 hello Go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Go 语言可以根据变量值推测出变量类型,所以可以省略变量类型,再一次简化了变量定义,但是变量类型仍然是强类型,并不像 Js 那样的弱类型.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量可以用 := 形式更加简化&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TestVariableTypeDeductionShorter(t *testing.T) {
    a, b, s := 1, 2, &amp;#34;hello Go&amp;#34;
    // 1 2 hello Go
    t.Log(a, b, s)
    s = &amp;#34;hello golang&amp;#34;
    // 1 2 hello golang

    t.Log(a, b, s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;省略了关键字 var,转而使用 := 符号声明并初始化变量值且利用自动类型推断能力进一步就简化变量定义,再次赋值时不能再使用 := 符号.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量 var 声明作用域大于变量 := 声明&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. var globalTestId = 2

2. // globalTestName := &amp;#34;type_test&amp;#34; is not supported

3. var globalTestName = &amp;#34;type_test&amp;#34;

4. 

5. func TestVariableScope(t *testing.T) {

6. ```
    // 2 type_test
    ```

7. ```
    t.Log(globalTestId, globalTestName)
    ```

8. 

9. ```
    globalTestName = &amp;#34;TestVariableScope&amp;#34;
    ```

10. 

11. ```
    // 2 TestVariableScope
    ```

12. ```
    t.Log(globalTestId, globalTestName)
    ```

13. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;var 声明的变量可以作用于函数外或函数内,而 := 声明的变量只能作用于函数内, Go 并没有全局变量的概念,变量的作用范围只是针对包而言.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量的使用方式和变量一致&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestConstant(t *testing.T) {

2. ```
    const a, b = 3, 4
    ```

3. ```
    const s = &amp;#34;hello Go&amp;#34;
    ```

4. 

5. ```
    // 3 4 hello Go
    ```

6. ```
    t.Log(a, b, s)
    ```

7. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常量声明关键字 const,常量和变量的使用方式一致,具备类型推断能力,也存在多种简化常量定义的形式.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然没有枚举类型,但可以用 iota 配合常量来实现枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestConstant2Enum(t *testing.T) {

2. ```
    const (
    ```

3. ```
    java = iota
    ```

4. ```
    golang
    ```

5. ```
    cpp
    ```

6. ```
    python
    ```

7. ```
    javascript
    ```

8. ```
    )
    ```

9. ```
    // 0 1 2 3 4
    ```

10. ```
    t.Log(java, golang,cpp,python,javascript)
    ```

11. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;iota 在一组常量定义中首次出现时,其值为 0,应用到下一个常量时,其值为开始自增 1,再次遇到 iota 恢复 0 .效果非常像 for 循环中的循环索引 i,明明是常量,偏偏玩出了变量的味道,也是我觉得 iota 不安分的原因.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量 iota 有妙用,还可以进行位运算&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestConstantIotaBitCalculate(t *testing.T){

2. ```
    const (
    ```

3. ```
    Readable = 1 &amp;lt;&amp;lt; iota
    ```

4. ```
    Writable
    ```

5. ```
    Executable
    ```

6. ```
    )
    ```

7. ```
    // 0001 0010 0100 即 1 2 4
    ```

8. ```
    t.Log(Readable, Writable, Executable)
    ```

9. 

10. ```
    // 0111 即 7,表示可读,可写,可执行
    ```

11. ```
    accessCode := 7
    ```

12. ```
    t.Log(accessCode&amp;amp;Readable == Readable, accessCode&amp;amp;Writable == Writable, accessCode&amp;amp;Executable == Executable)
    ```

13. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义二进制位最低位为 1 时表示可读的,左移一位表示可写的,左移两位表示可执行的,按照按位与运算逻辑,目标权限位若拥有可读权限,此时和可读常量进行按位与运算之后的结果一定是可读的,由此可见, iota 非常适合此类操作.&lt;/p&gt;
&lt;p&gt;总体来说, Go 语言中的变量很有意思,常量 iota 不那么安分,从上述归纳总结中不难看出, Go 语言和其他主流的编程语言还是有很大不同的,学习时要侧重于这些特殊之处.&lt;/p&gt;
&lt;p&gt;如果想要回顾本节知识点,可以关注公众号[雪之梦技术驿站]找到&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s?__biz=MzU3NTc1MDMwOQ==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=e93944978b6b88d2594e40d8ca9527fa&amp;amp;scene=21#wechat_redirect&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go 学习笔记之有意思的变量和不安分的常量&lt;/a&gt; 这篇文章进行查看.&lt;/p&gt;
&lt;p&gt;简洁的类型中格外关照了复数&lt;/p&gt;
&lt;p&gt;在学习 Go 语言中的变量和常量时,虽然没有特意强调变量或常量的类型,但是大多数编程语言的类型基本都是差不多的,毕竟大家所处的现实世界是一样的嘛!&lt;/p&gt;
&lt;p&gt;光是猜测是不够的,现在我们要梳理一遍 Go 语言的类型有哪些,和其他主流的编程语言相比有什么不同?&lt;/p&gt;
&lt;p&gt;Go 语言的变量类型大致可以分为以下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布尔类型 bool,表示真假 true|false&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(u)int , (u)int8 , (u)int16, (u)int32, (u)int64, uintptr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;int 类型表示整数,虽然不带位数并不表示没有位数, 32 位操作系统时长度为 32 位, 64 位操作系统时长度为 64 位.最后一个 uintptr 是指针类型.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;byte(uint8) , rune(int32), string&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;byte 是字节类型,也是 uint8 的别名,而 rune 是 Go 中的字符类型,也是 int32 的别名.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float32 , float64 , complex64 , complex128&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有 float 类型表示小数,没有 double 类型,类型越少对于开发者而言越简单,不是吗? complex64=float32+float32 是复数类型,没错!就是高中数学书本上的复数, 3+4i 那种奇怪的数字!&lt;/p&gt;
&lt;p&gt;Go 的类型还是比较简单的,整数,小数,复数,字节,字符和布尔类型,相同种类的类型没有继续细分不同的名称而是直接根据类型长度进行命名的,这样是非常直观的,见名知意,根据数据大小直接选用类型,不费脑!&lt;/p&gt;
&lt;p&gt;作为一种通用的编程语言, Go 内建类型中居然格外关照了复数这种数学概念类型,是一件有意思的事情,是不是意味着 Go 在工程化项目上做得更好?就像 Go 天生支持并发一样?&lt;/p&gt;
&lt;p&gt;既然为数不多的类型中格外关照了复数类型,那我们简单使用下复数类型吧,毕竟其他类型和其他主流的编程语言相差不大.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestComplex(t *testing.T) {

2. ```
    c := 3 + 4i
    ```

3. 

4. ```
    // 5
    ```

5. ```
    t.Log(cmplx.Abs(c))
    ```

6. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生命苦短,直接利用变量类型推断简化变量声明,求出复数类型 c 的模(绝对值)&lt;/p&gt;
&lt;p&gt;既然学习了复数,怎么能少得了欧拉公式,毕竟是&amp;quot;世界上最美的公式&amp;quot;,刚好用到了复数的相关知识,那我们就简单验证一下吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;//note.youdao.com/src/39fd719ebc6278f7fddaf5a345fde1be&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;e&lt;!-- raw HTML omitted --&gt;iπ&lt;!-- raw HTML omitted --&gt; + 1 = 0&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestEuler(t *testing.T) {

2. ```
    // (0+1.2246467991473515e-16i)
    ```

3. ```
    t.Log(cmplx.Pow(math.E, 1i*math.Pi) + 1)
    ```

4. 

5. ```
    // (0+1.2246467991473515e-16i)
    ```

6. ```
    t.Log(cmplx.Exp(1i*math.Pi) + 1)
    ```

7. 

8. ```
    // (0.000+0.000i)
    ```

9. ```
    t.Logf(&amp;#34;%.3f&amp;#34;, cmplx.Exp(1i*math.Pi)+1)
    ```

10. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于复数 complex 是使用 float 类型表示的,而 float 类型无论是什么编程语言都是不准确的,所以欧拉公式的计算结果非常非常接近于零,当只保留小数点后三位时,计算结果便是 (0.000+0.000i) ,复数的模也就是 0,至此验证了欧拉公式.&lt;/p&gt;
&lt;p&gt;看过复数还是要研究类型特点&lt;/p&gt;
&lt;p&gt;复数很重要,但其他类型也很重要,简单了解过复数的相关知识后,我们仍然要把注意力放到研究这些内建类型的特殊之处上或者说这些类型总体来说相对于其他主流的编程语言有什么异同.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有显示类型转换,不存在隐式类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestExplicitTypeConvert(t *testing.T) {

2. ```
    var a, b int = 3, 4
    ```

3. ```
    var c int
    ```

4. ```
    c = int(math.Sqrt(float64(a*a + b*b)))
    ```

5. 

6. ```
    // 3 4 5
    ```

7. ```
    t.Log(a, b, c)
    ```

8. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;已知勾股定理的两条直角边计算斜边,根据勾股定理得,直角边长度的平方和再开根号即斜边长度,然而 math.Sqrt 方法接收的 float64 类型,返回的也是 float64 类型,可实际值全是 int 类型,这种情况下并不会自动进行类型转换,只能进行强制类型转换才能得到我们的期望值,这就是显示类型转换.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;别名类型和原类型也不能进行隐式类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestImplicitTypeConvert2(t *testing.T) {

2. ```
    type MyInt64 int64
    ```

3. 

4. ```
    var a int64 = 1
    ```

5. ```
    var b MyInt64
    ```

6. 

7. ```
    // b = a : cannot use a (type int64) as type MyInt64 in assignment
    ```

8. ```
    b = MyInt64(a)
    ```

9. ```
    t.Log(a, b)
    ```

10. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MyInt64 是 int64 的别名,别名类型的 b 和原类型的 a 也不能进行也不能进行隐式类型转换,会报错 cannotusea(type int64)astypeMyInt64inassignment,只能进行显示类型转换.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持指针类型,但不支持任何形式的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. func TestPointer(t *testing.T) {

2. ```
    var a int = 1
    ```

3. ```
    var pa *int = &amp;amp;a
    ```

4. 

5. ```
    // 0xc0000921d0 1 1
    ```

6. ```
    t.Log(pa, *pa, a)
    ```

7. 

8. ```
    *pa = 2
    ```

9. 

10. ```
    // 0xc0000901d0 2 2
    ```

11. ```
    t.Log(pa, *pa, a)
    ```

12. }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样的,指针类型也是其他编程语言反过来书写的,个人觉得这种反而不错,指向 int 类型的指针 *int, &amp;amp;a是变量 a 的内存地址,所以变量 pa 存的就是变量 a 的地址, *pa 刚好也就是变量 a 的值.&lt;/p&gt;
&lt;p&gt;上例显示声明了变量类型却没有利用到 Go 的类型推断能力,摆在那的能力却不利用简直是浪费,所以提供一种更简短的方式重写上述示例,并顺便解释后半句: &amp;ldquo;指针类型不支持任何形式的计算&amp;rdquo;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func TestPointerShorter(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a := 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pa := &amp;amp;a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 0xc0000e6010 1 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(pa, *pa, a)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*pa = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 0xc0000e6010 2 2&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(pa, *pa, a)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// pa = pa + 1 : invalid operation: pa + 1 (mismatched types *int and int)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;14. ```
//pa = pa + 1
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// *int int int&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;17. ```
t.Logf(&amp;#34;%T %T %T&amp;#34;, pa, *pa,a)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;18&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;变量 pa 是指针类型,存储的是变量的内存地址,只可远观而不可亵玩, *pa 就是指针所指向的变量的值,可以进行修改,当然没问题就像可以重新赋值变量 a 一样,但是指针 pa 是不可以进行任何形式的运算的, pa=pa+1 就会报错 invalid operation.&lt;/p&gt;
&lt;p&gt;你猜运算符操作有没有彩蛋呢&lt;/p&gt;
&lt;p&gt;变量和类型还只是孤立的声明语句,没有计算不成逻辑,并不是所有的程序都是预定义的变量, Go 的运算符是简单还是复杂呢,让我们亲自体验一下!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术运算符少了 ++i 和 &amp;ndash;i&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestArithmeticOperator(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a := 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a = a + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a = a * 2&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
// 2
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(a)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;13. 
14. ```
a = a % 2
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 0&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;16. ```
t.Log(a)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a++&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;19. ```
// 1
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;20&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(a)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;21. }

支持大部分正常的运算符,不支持前置自增,前置自减,这也是好事,再也不会弄错 i++ 和 ++i 的运算结果啦,因为根本不支持 ++i !

* 比较运算符是否相等有花样

1. func TestComparisonOperator(t *testing.T) {
2. ```
a, b := 0, 1
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// false true true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(a &amp;gt; b, a &amp;lt; b, a != b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大于,小于,不等于这种关系很正常, Golang 也没玩出新花样,和其他主流的编程语言逻辑一样,不用特别关心.但是关于比较数组 ==, Go 表示有话要说!&lt;/p&gt;
&lt;p&gt;Go 中的数组是可以进行比较的,当待比较的两个数组的维度和数组元素的个数相同时,两个数组元素顺序一致且相同时,则两个数组相等,而其他主流的编程语言一般而言比较的都是数组的引用,所以这一点需要特别注意.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func TestCompareArray(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a := [...]int{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//b := [...]int{2, 4}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;c := [...]int{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;d := [...]int{1, 2, 4}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// a == b --&amp;gt; invalid operation: a == b (mismatched types [3]int and [2]int)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//t.Log(a == b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// true false&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(a == c,a == d)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数组 a 和 c 均是一维数组且元素个数都是 3,因此两个数组可以比较且相等,若数组 a 和 b 进行比较,则报错 invalid operation,是因为两个数组的元素个数不相同,无法比较!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑运算符老实本分无异常&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestLogicalOperator(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a, b := true, false
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// false true false true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(a&amp;amp;&amp;amp;b,a||b,!a,!b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;位运算符新增按位清零 &amp;amp;^ 很巧妙&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go 语言中定义按位清零运算符是 &amp;amp;^,计算规律如下:&lt;/p&gt;
&lt;p&gt;当右边操作位数为 1 时,左边操作为不论是 1 还是 0 ,结果均为 0;
当右边操作位数为 0 时,结果同左边操作位数.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func TestClearZeroOperator(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(1&amp;amp;^1, 0&amp;amp;^1, 1&amp;amp;^0, 0&amp;amp;^1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不知道还记不记得,在介绍常量 iota 时,曾经以文件权限为例,判断给定的权限码是否拥有特定权限,同样是给定的权限码,又该如何撤销特定权限呢?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func TestClearZeroOperator(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Readable = 1 &amp;lt;&amp;lt; iota
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Writable
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Executable
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 0001 0010 0100 即 1 2 4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(Readable, Writable, Executable)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 0111 即 7,表示可读,可写,可执行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
accessCode := 7
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(accessCode&amp;amp;Readable == Readable, accessCode&amp;amp;Writable == Writable, accessCode&amp;amp;Executable == Executable)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;13. 
14. ```
// 0111 &amp;amp;^ 0001 = 0110 即清除可读权限
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;accessCode = accessCode &amp;amp;^ Readable&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;16. ```
t.Log(accessCode&amp;amp;Readable == Readable, accessCode&amp;amp;Writing == Writing, accessCode&amp;amp;Executable == Executable)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;accessCode=accessCode&amp;amp;^Readable 进行按位清零操作后就失去了可读权限, accessCode&amp;amp;Readable==Readable 再次判断时就没有可读权限了.&lt;/p&gt;
&lt;p&gt;流程控制语句也有自己的傲娇&lt;/p&gt;
&lt;p&gt;if 有话要说&lt;/p&gt;
&lt;p&gt;有了变量类型和各种运算符的加入,现在实现简单的语句已经不是问题了,如果再辅助流程控制语句,那么实现较为复杂拥有一定逻辑的语句便可更上一层楼.&lt;/p&gt;
&lt;p&gt;Go 语言的 if 条件语句和其他主流的编程语言的语义是一样的,不一样的是书写规则和一些细节上有着自己特点.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件表达式不需要小括号 ()&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestIfCondition(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 0; i &amp;lt; 10; i++ {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if i%2 == 0 {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Go 语言的各种省略形式使得整体上非常简洁,但也让拥有其他主流编程语言的开发者初次接触时很不习惯,语句结束不用分号 ;,条件表达式不用小括号 () 等等细节,如果不用 IDE 的自动提示功能,这些细节肯定要耗费不少时间.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件表达式中可以定义变量,只要最后的表达式结果是布尔类型即可&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;func TestIfConditionMultiReturnValue(t *testing.T) {&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const filename = &amp;#34;test.txt&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if content, err := ioutil.ReadFile(filename); err != nil {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(err)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;} else {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Logf(&amp;#34;%s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ldquo;, content)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Go 语言的函数支持返回多个值,这一点稍后再细说, ioutil.ReadFile 函数返回文件内容和错误信息,当存在错误信息时 err!=nil,输出错误信息,否则输出文件内容.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件表达式中定义的变量作用域仅限于当前语句块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;//note.youdao.com/src/fd5c4b52006416939abd0b6a472d596c&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果尝试在 if 语句块外访问变量 content,则报错 undefined:content&lt;/p&gt;
&lt;p&gt;switch 不甘示弱&lt;/p&gt;
&lt;p&gt;同其他主流的编程语言相比, switch 语句最大的特点就是多个 case 不需要 break, Go 会自动进行 break,这一点很人性化.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch 会自动 break,除非使用 fallthrough&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestSwitchCondition(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch os := runtime.GOOS; os {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &amp;#34;darwin&amp;#34;:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;Mac&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &amp;#34;linux&amp;#34;:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;Linux&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &amp;#34;windows&amp;#34;:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;Windows&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;default:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(os)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;条件表达式不限制为常量或整数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他主流的编程语言中 switch 的条件表达式仅支持有限类型,使用方式存在一定局限性, Go 语言则不同,这一点变化也是很有意思的,使用 switch 做分支控制时不用担心变量类型了!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;case 语言支持多种条件,用逗号 , 分开,逻辑或&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestSwitchMultiCase(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 0; i &amp;lt; 10; i++ {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch i {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case 0, 2, 4, 6, 8, 10:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;Even&amp;#34;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case 1, 3, 5, 7, 9:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;odd&amp;#34;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;default:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;default&amp;#34;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;省略 switch 的条件表达式时, switch 的逻辑和多个 ifelse 逻辑相同&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestSwitchCaseCondition(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 0; i &amp;lt; 10; i++ {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case i%2 == 0:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;Even&amp;#34;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case i%2 == 1:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;odd&amp;#34;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;default:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(&amp;#34;default&amp;#34;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;for 姗姗来迟&lt;/p&gt;
&lt;p&gt;最后登场的是 for 循环,一个人完成了其他主流编程语言三个人的工作, Go 语言中既没有 while 循环也,也没有 dowhile 循环,有的只是 for 循环.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环条件不需要小括号 ()&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func TestForLoop(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum := 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 1; i &amp;lt;= 100; i++ {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum += i
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1+2+3+...+99+100=5050
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(sum)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再一次看到条件表达式不需要小括号 () 应该不会惊讶了吧? if 的条件语句表达式也是类似的,目前为止,接触到明确需要小括号的 () 也只有变量或常量定义时省略形式了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以省略初始条件&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func convert2Binary(n int) string {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;result := &amp;#34;&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for ; n &amp;gt; 0; n /= 2 {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lsb := n % 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;result = strconv.Itoa(lsb) + result
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;return result
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestConvert2Binary(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 1 100 101 1101&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12. ```
t.Log(
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;convert2Binary(1),&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;14. ```
convert2Binary(4),
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;convert2Binary(5),&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;16. ```
convert2Binary(13),
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;18. }

利用整数相除法,不断取余相除,得到给定整数的二进制字符串,这里就省略了初始条件,只有结束条件和递增表达式.这种写法同样在其他主流的编程语言是没有的,体现了 Go 设计的简洁性,这种特性在以后的编程中会越来越多的用到,既然可以省略初始条件,相信你也能猜到可不可以省略其他两个条件呢?

* 可以省略初始条件和递增表达式

1. func printFile(filename string) {
2. ```
if file, err := os.Open(filename); err != nil {
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic(err)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;} else {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;scanner := bufio.NewScanner(file)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for scanner.Scan() {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(scanner.Text())
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestPrintFile(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;const filename = &amp;ldquo;test.txt&amp;rdquo;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;14. ```
printFile(filename)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开文件并逐行读取内容,其中 scanner.Scan() 的返回值类型是 bool,这里省略了循环的初始条件和递增表达式,只有循环的终止条件,也顺便实现了 while 循环的效果.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始条件,终止条件和递增表达式可以全部省略&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func forever() {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;hello go&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestForever(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;forever()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;for 循环中没有任何表达式,意味着这是一个死循环,常用于 Web 请求中监控服务端口,是不是比 while(true) 要更加简单?&lt;/p&gt;
&lt;p&gt;压轴的一等公民函数隆重登场&lt;/p&gt;
&lt;p&gt;虽然没有特意强制函数,但是示例代码中全部都是以函数形式给出的,函数是封装的一种形式,更是 Go语言的一等公民.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回值在函数声明的最后,多个返回值时用小括号 ()&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func eval(a, b int, op string) int {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var result int
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch op {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &amp;#34;+&amp;#34;:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;result = a + b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &amp;#34;-&amp;#34;:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;result = a - b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;case &amp;#34;*&amp;#34;:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;result = a * b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;case &amp;ldquo;/&amp;rdquo;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
result = a / b
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;default:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;13. ```
panic(&amp;#34;unsupported operator: &amp;#34; + op)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;15. ```
return result
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestEval(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;20. ```
eval(1, 2, &amp;#34;+&amp;#34;),
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;21&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;eval(1, 2, &amp;ldquo;-&amp;rdquo;),&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;22. ```
eval(1, 2, &amp;#34;*&amp;#34;),
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;23&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;eval(1, 2, &amp;ldquo;/&amp;rdquo;),&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;24. ```
//eval(1, 2, &amp;#34;%&amp;#34;),
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;25&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;26. }

不论是变量的定义还是函数的定义, Go 总是和其他主流的编程语言相反,个人觉得挺符合思维顺序,毕竟都是先有输入才能输出,多个输出当然要统一隔离在一块了.

* 可以有零个或一个或多个返回值

1. func divide(a, b int) (int, int) {
2. ```
return a / b, a % b
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestDivide(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 2 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(divide(5, 2))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;小学时就知道两个整数相除,除不尽的情况下还有余数.只不过编程中商和余数都是分别计算的, Go 语言支持返回多个结果,终于可以实现小学除法了!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回多个结果时可以给返回值起名字&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;func divideReturnName(a, b int) (q, r int) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;return a / b, a % b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestDivideReturnName(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;q, r := divideReturnName(5, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 2 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(q, r)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还是整数除法的示例,只不过给返回值起了变量名称 (q,rint),但这并不影响调用者,某些 IDE 可能会基于次特性自动进行代码补全,调用者接收时的变量名不一定非要是 q,r .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他函数可以作为当前函数的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;func apply(op func(int, int) int, a, b int) int {&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p := reflect.ValueOf(op).Pointer()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;opName := runtime.FuncForPC(p).Name()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Printf(&amp;#34;Calling function %s with args (%d,%d)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ldquo;, opName, a, b)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;return op(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;func pow(a, b int) int {&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;return int(math.Pow(float64(a), float64(b)))&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. }
12. 
13. func TestApply(t *testing.T) {
14. ```
// 1
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(apply(func(a int, b int) int {&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;16. ```
return a % b
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;}, 5, 2))&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;18. 
19. ```
// 25
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;20&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;t.Log(apply(pow, 5, 2))&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;21. }

apply 函数的第一个参数是 op 函数,第二,第三个参数是 int 类型的 a,b.其中 op 函数也接收两个 int参数,返回一个 int 结果,因此 apply 函数的功能就是将 a,b 参数传递给 op 函数去执行,这种方式比 switch 固定运算类型要灵活方便!

* 没有默认参数,可选参数等复杂概念,只有可变参数列表

1. func sum(numbers ...int) int {
2. ```
result := 0
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := range numbers {
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;result += numbers[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;return result
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestSum(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 15&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(sum(1, 2, 3, 4, 5))
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;range 遍历方式后续再说,这里可以简单理解为其他主流编程语言中的 foreach 循环,一般包括当前循环索引和循环项.&lt;/p&gt;
&lt;p&gt;指针类型很方便同时也很简单&lt;/p&gt;
&lt;p&gt;Go 的语言整体上比较简单,没有太多花里胡哨的语法,稍微有点特殊的当属变量的定义方式了,由于具备类型推断能力,定义变量的方式有点多,反而觉得选择困难症,不知道这种情况后续会不会有所改变?&lt;/p&gt;
&lt;p&gt;在 Go 语言的为数不多的类型中就有指针类型,指针本来是 c 语言的概念,其他主流的编程语言也有类似的概念,可能不叫做指针而是引用,但 Go 语言的发展和 c++ 有一定关系,保留了指针的概念.&lt;/p&gt;
&lt;p&gt;但是这并不意味着 Go 语言的指针像 C 语言那样复杂,相反, Go 语言的指针很方便也很简单,方便是由于提供我们操作内存地址的方式,简单是因为不能对指针做任何运算!&lt;/p&gt;
&lt;p&gt;简单回忆一下指针的基本使用方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func TestPointerShorter(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a := 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pa := &amp;amp;a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 0xc0000e6010 1 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t.Log(pa, *pa, a)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*pa = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 0xc0000e6010 2 2&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(pa, *pa, a)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// pa = pa + 1 : invalid operation: pa + 1 (mismatched types *int and int)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;14. ```
//pa = pa + 1
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// *int int int&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;17. ```
t.Logf(&amp;#34;%T %T %T&amp;#34;, pa, *pa,a)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;18&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;amp; 可以获取变量的指针类型, * 指向变量,但不可以对指针进行运算,所以指针很简单!&lt;/p&gt;
&lt;p&gt;当指针类型和其他类型和函数一起发生化学反应时,我们可能更加关心参数传递问题,其他主流的编程语言可能有值传递和引用传递两种方式, Go 语言进行参数传递时又是如何表现的呢?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func swapByVal(a, b int) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a, b = b, a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestSwapByVal(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a, b := 3, 4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;swapByVal(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 3 4&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;swapByVal 函数内部实现了变量交换的逻辑,但外部函数 TestSwapByVal 调用后变量 a,b 并没有改变,可见 Go 语言这种参数传递是值传递而不是引用传递.&lt;/p&gt;
&lt;p&gt;上面示例中参数传递的类型都是普通类型,如果参数是指针类型的话,结果会不会不一样呢?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func swapByRef(a, b *int) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*a, *b = *b, *a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestSwapByRef(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a, b := 3, 4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;swapByRef(&amp;amp;a, &amp;amp;b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 4 3&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指针类型进行参数传递时可以交换变量的值,拷贝的是内存地址,更改内存地址的指向实现了原始变量的交换,参数传递的仍然是值类型.&lt;/p&gt;
&lt;p&gt;实际上, Go 语言进行参数传递的只有值类型一种,这一点不像其他主流的编程语言那样可能既存在值类型又存在引用类型.&lt;/p&gt;
&lt;p&gt;既然是值类型进行参数传递,也就意味着参数传递时直接拷贝一份变量供函数调用,函数内部如何修改参数并不会影响到调用者的原始数据.&lt;/p&gt;
&lt;p&gt;如果只是简单类型并且不希望参数值被修改,那最好不过,如果希望参数值被修改呢?那只能像上例那样传递指针类型.&lt;/p&gt;
&lt;p&gt;简单类型不论是传递普通类型还是指针类型,变量的拷贝过程不会太耗费内存也不会影响状态.&lt;/p&gt;
&lt;p&gt;如果传递的参数本身是比较复杂的类型,仍然进行变量拷贝过程估计就不能满足特定需求了,可能会设计成出传递复杂对象的某种内部指针,不然真的要进行值传递,那还怎么玩?&lt;/p&gt;
&lt;p&gt;Go 只有值传递一种方式,虽然简单,但实际中如何使用应该有特殊技巧,以后再具体分析,现在回到交换变量的例子,换一种思路.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func swap(a, b int) (int, int) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;return b, a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;func TestSwap(t *testing.T) {&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a, b := 3, 4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a, b = swap(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// 4 3&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11. ```
t.Log(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用 Go 函数可以返回多个值特性,返回交换后的变量值,调用者接收时相当于重新赋值,比传递指针类型要简单不少!&lt;/p&gt;
&lt;p&gt;基础语法知识总结和下文预告&lt;/p&gt;
&lt;p&gt;刚刚接触 Go 语言时觉得 Go 的语言很简单也很特别,和其他主流的编程语言相比,有着自己独特的想法.&lt;/p&gt;
&lt;p&gt;语句结束不用分号 ; 而是直接回车换行,这一点有些不习惯,好在强大的 IDE 可以纠正这些细节.&lt;/p&gt;
&lt;p&gt;变量声明时变量名在前,变量类型在后,可能更加符合大脑思维,但是习惯了先写变量类型再写变量名,这确实有一定程度的不方便,后来索性不写变量类型,自然就没有问题了.&lt;/p&gt;
&lt;p&gt;函数声明同变量声明类似,返回值放到了最后部分,并且还可以有多个返回值,经过了变量的洗礼,再熟悉函数的这一特点也就不那么惊讶了,先输入后输出,想一想也有道理,难道其他编程语言的顺序都是错的?&lt;/p&gt;
&lt;p&gt;接下来就是语法的细节,比如 if 的条件表达式可以进行变量赋值, switch 表达式可以不用 break,只有 for 循环一种形式等等.&lt;/p&gt;
&lt;p&gt;这些细节总体来说比较简单方便,不用关心细节,放心大胆使用,从而专注于业务逻辑,等到语法不对时, IDE 自然会给出相应的报错提醒,放心大胆 Go !&lt;/p&gt;
&lt;p&gt;本文主要介绍了 Go 的基本语法以及和其他主流的编程语言的异同,你 Get 到了吗?&lt;/p&gt;
&lt;p&gt;下文将开始介绍 Go 的内建容器类型,数组,切片, Map 来一遍!&lt;/p&gt;
&lt;p&gt;欢迎大家一起学习交流,如有不当之处,恳请指正,如需完整源码,请在公众号[雪之梦技术驿站]留言回复,感谢你的评论与转发!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;//note.youdao.com/src/b06096c411b66b176cfc4c48c64b44fd&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go 发送邮件</title>
        <link>https://lxb.wiki/c296dcc8/</link>
        <pubDate>Sat, 01 Sep 2018 22:26:49 +0000</pubDate>
        
        <guid>https://lxb.wiki/c296dcc8/</guid>
        <description>&lt;p&gt;需要引入 smtp包 mail.go&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;bytes&amp;quot;
    &amp;quot;encoding/base64&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/smtp&amp;quot;
    &amp;quot;strings&amp;quot;
)

const const_smtp_server = &amp;quot;server-ip:port&amp;quot;

//const const_email_content_type = &amp;quot;Content-Type: text/plain; charset=UTF-8&amp;quot;
const const_email_content_type = &amp;quot;Content-Type: text/html; charset=UTF-8&amp;quot;
const const_boundary = &amp;quot;THIS_IS_THE_BOUNDARY_FOR_EMAIL_BY_LXB&amp;quot;

func SendEmail(sender string, receivers []string, subject string, content string, attach_files []string) error {

    var buf bytes.Buffer
    buf.WriteString(&amp;quot;To: &amp;quot;)
    buf.WriteString(strings.Join(receivers, &amp;quot;,&amp;quot;))
    buf.WriteString(&amp;quot;\r\nFrom: &amp;quot;)
    //nickname := strings.Split(sender,&amp;quot;@&amp;quot;)[0]
    //buf.WriteString(nickname)
    buf.WriteString(&amp;quot;&amp;lt;&amp;quot;)
    buf.WriteString(sender)
    buf.WriteString(&amp;quot;&amp;gt;&amp;quot;)
    buf.WriteString(&amp;quot;\r\nSubject: &amp;quot;)
    buf.WriteString(subject)
    buf.WriteString(&amp;quot;\r\nContent-Type: multipart/mixed; boundary=&amp;quot;)
    buf.WriteString(const_boundary)
    buf.WriteString(&amp;quot;\r\n--&amp;quot;)
    buf.WriteString(const_boundary)
    buf.WriteString(&amp;quot;\r\n&amp;quot;)
    buf.WriteString(const_email_content_type)
    buf.WriteString(&amp;quot;\r\n\r\n&amp;quot;)
    buf.WriteString(content)
    buf.WriteString(&amp;quot;\r\n\r\n--&amp;quot;)
    buf.WriteString(const_boundary)
    buf.WriteString(&amp;quot;\r\n&amp;quot;)

    for _, filepath := range attach_files {
        // 第一个附件
        filedepts := strings.Split(filepath, &amp;quot;/&amp;quot;)
        filename := filedepts[len(filedepts)-1]
        buf.WriteString(&amp;quot;Content-Type: application/octet-stream\r\n&amp;quot;)
        buf.WriteString(&amp;quot;Content-Description: 附件\r\n&amp;quot;)
        buf.WriteString(&amp;quot;Content-Transfer-Encoding: base64\r\n&amp;quot;)
        buf.WriteString(&amp;quot;Content-Disposition: attachment; filename=\&amp;quot;&amp;quot; + filename + &amp;quot;\&amp;quot;\r\n\r\n&amp;quot;)
        //读取并编码文件内容
        attaData, err := ioutil.ReadFile(filepath)
        if err != nil {
            print(err)
            return err
        }
        b := make([]byte, base64.StdEncoding.EncodedLen(len(attaData)))
        base64.StdEncoding.Encode(b, attaData)
        buf.Write(b)
        buf.WriteString(fmt.Sprintf(&amp;quot;\r\n--%s\r\n&amp;quot;, const_boundary))
    }

    fmt.Println(buf.String())
    err := smtp.SendMail(const_smtp_server, nil, sender, receivers, buf.Bytes())

    fmt.Println(&amp;quot;send mail err:&amp;quot;, err)
    return err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;main.go&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
    //&amp;quot;flag&amp;quot;
    //&amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {

    //var task string

    //flag.StringVar(&amp;amp;task, &amp;quot;t&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;task id&amp;quot;)
    //flag.Parse()

    //if task == &amp;quot;&amp;quot; {
    //  fmt.Println(&amp;quot;task is required.&amp;quot;)
    //  flag.Usage()
    //  os.Exit(2)
    //}

    testStr := os.Args[1]

    cont := &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p align=\&amp;quot;center\&amp;quot;&amp;gt;表: 1&amp;lt;/p&amp;gt;&amp;lt;table align=\&amp;quot;center\&amp;quot; border=\&amp;quot;1\&amp;quot; cellpadding=\&amp;quot;10\&amp;quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;任务ID&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;列1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;列2&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;列3&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + testStr + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + testStr + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + testStr + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;quot; + testStr + &amp;quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;

    sender := &amp;quot;&amp;quot;
    rcvs := []string{}
    sbj := &amp;quot;test email&amp;quot;
    //  cont := &amp;quot;This is content&amp;quot;
    file := []string{}

    SendEmail(sender, rcvs, sbj, cont, file)

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Golang select 的用法</title>
        <link>https://lxb.wiki/e353ee8e/</link>
        <pubDate>Mon, 27 Aug 2018 00:27:40 +0000</pubDate>
        
        <guid>https://lxb.wiki/e353ee8e/</guid>
        <description>&lt;h4 id=&#34;基本使用&#34;&gt;基本使用&lt;/h4&gt;
&lt;p&gt;select 是 Go 中的一个控制结构, 类似于switch 语句, 用于处理异步 IO 操作. select 语句会监听 case语句中channel 的读写操作, 当case 中 channel 读写操作为非阻塞状态(即能读写)时, 将会触发相应的动作.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select 中的 case 语句必须是一个 channel 操作
select 中的 default 子句总是可运行的
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;如果有多个 case 都可以运行, select 会随机公平地选出一个执行, 其他不会执行&lt;/li&gt;
&lt;li&gt;如果没有可运行的 case 语句, 且有 default 语句, 则会执行 default 的动作&lt;/li&gt;
&lt;li&gt;如果没有可运行的 case 语句, 且没有 default 语句, select 将阻塞, 知道某个 case 通信可以运行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
   var c1, c2, c3 chan int
   var i1, i2 int
   select {
      case i1 = &amp;lt;-c1:
         fmt.Printf(&amp;quot;received &amp;quot;, i1, &amp;quot; from c1\n&amp;quot;)
      case c2 &amp;lt;- i2:
         fmt.Printf(&amp;quot;sent &amp;quot;, i2, &amp;quot; to c2\n&amp;quot;)
      case i3, ok := (&amp;lt;-c3):  // same as: i3, ok := &amp;lt;-c3
         if ok {
            fmt.Printf(&amp;quot;received &amp;quot;, i3, &amp;quot; from c3\n&amp;quot;)
         } else {
            fmt.Printf(&amp;quot;c3 is closed\n&amp;quot;)
         }
      default:
         fmt.Printf(&amp;quot;no communication\n&amp;quot;)
   }    
}

//输出：no communication
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;典型用法&#34;&gt;典型用法&lt;/h4&gt;
&lt;h5 id=&#34;1-超时判断&#34;&gt;1. 超时判断&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;//比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行
var resChan = make(chan int)
// do request
func test() {
    select {
    case data := &amp;lt;-resChan:
        doData(data)
    case &amp;lt;-time.After(time.Second * 3):
        fmt.Println(&amp;quot;request time out&amp;quot;)
    }
}

func doData(data int) {
    //...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-退出&#34;&gt;2. 退出&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;//主线程（协程）中如下：
var shouldQuit=make(chan struct{})
fun main(){
    {
        //loop
    }
    //...out of the loop
    select {
        case &amp;lt;-c.shouldQuit:
            cleanUp()
            return
        default:
        }
    //...
}

//再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行
close(shouldQuit)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-判断-channel-是否阻塞&#34;&gt;3. 判断 channel 是否阻塞&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;//在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断
ch := make (chan int, 5)
//...
data：=0
select {
case ch &amp;lt;- data:
default:
    //做相应操作，比如丢弃data。视需求而定
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Go 环境变量</title>
        <link>https://lxb.wiki/2ddd6919/</link>
        <pubDate>Wed, 18 Jul 2018 00:57:36 +0000</pubDate>
        
        <guid>https://lxb.wiki/2ddd6919/</guid>
        <description>&lt;h5 id=&#34;goroot&#34;&gt;GOROOT&lt;/h5&gt;
&lt;p&gt;，在Linux系统中一般安装在&lt;code&gt;/usr/go&lt;/code&gt;或者&lt;code&gt;/usr/local/go&lt;/code&gt;，这样Linux系统中的PATH变量一般都包含了这两个目录，所以就可以直接运行go命令，而Windows系统中一般默认安装在&lt;code&gt;C:\go&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;自定义 GO安装路径, 可修改环境变量配置文件 &lt;code&gt;export GOROOT=$HOME/go&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;gopath&#34;&gt;GOPATH&lt;/h5&gt;
&lt;p&gt;go的工作目录，这个目录指定了需要从哪个地方寻找GO的包、可执行程序等，这个目录可以是多个目录表示，go编译或者运行时会从这个环境变量中去对应查找，工作目录或者如官方文档中说的workspace 在这个目录进行编译、链接最后生成所需要的库、可执行文件，我们对比C程序的目录，也许更能方便理解，一般在C的工程项目中包含三个文件，一个include目录、src目录、Makefile文件。 &lt;code&gt;include&lt;/code&gt;目录存放了所有的头文件可供其他地方包含 &lt;code&gt;src&lt;/code&gt;目录则存放所有的.c后缀的源文件 &lt;code&gt;Makefile&lt;/code&gt;则是该项目的编译，在编译整个工程时需要执行make命令，这里就发现GO就不需要去写什么Makefile了，执行&lt;code&gt;go build xxx.go&lt;/code&gt;命令就可以编译&lt;/p&gt;
&lt;p&gt;GOPATH 下的目录下, 一般有三个 目录 &lt;code&gt;bin&lt;/code&gt; &lt;code&gt;pkg&lt;/code&gt; &lt;code&gt;src&lt;/code&gt; &lt;code&gt;bin&lt;/code&gt;目录包含了可执行程序，注意是可执行的，不需要解释执行。 &lt;code&gt;pkg&lt;/code&gt;目录包含了使用的包或者说库。 &lt;code&gt;src&lt;/code&gt;里面包含了go的代码源文件，其中仍按包的不同进行组织&lt;/p&gt;
&lt;p&gt;包名一般和目录名相同, 编译时, 可以在某个包下, 执行&lt;code&gt;go build&lt;/code&gt; , 也可以在包上层直接编译包名&lt;code&gt;go build pkg_name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go install &amp;lt;pkg_name/exe_name/all&amp;gt;&lt;/code&gt; 先编译后把编译生成的可执行文件复制到&lt;code&gt;bin&lt;/code&gt; 下&lt;/p&gt;
</description>
        </item>
        <item>
        <title>qt 同步方式发送post 请求</title>
        <link>https://lxb.wiki/c57f4e3b/</link>
        <pubDate>Tue, 22 May 2018 11:12:38 +0000</pubDate>
        
        <guid>https://lxb.wiki/c57f4e3b/</guid>
        <description>&lt;p&gt;不成功的方式: 1. QNetworkReply的isFinished()函数, 通过while循环判断reply是否已经结束, 结束后再调用readAll()读取响应信息, 结果与判断isRunning() 方式结果一样, 都会进入死循环, 没有响应. 2. QNetworkReply继承自QIODevice, 尝试调用QIODevice的waitForReadyRead()方法, 结果不阻塞, 直接返回&lt;/p&gt;
&lt;p&gt;成功的方式: 使用QEventLoop来阻塞运行, 知道信号发出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;QNetworkReply *reply = _manager-&amp;gt;post(QNetworkRequest(QUrl(SERVER_URL)), data);
QByteArray responseData;
QEventLoop eventLoop;
connect(_manager, SIGNAL(finished(QNetworkReply*)), &amp;amp;eventLoop, SLOT(quit()));
eventLoop.exec();       //block until finish
responseData = reply-&amp;gt;readAll();
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>qt 程序打包</title>
        <link>https://lxb.wiki/7e8574d1/</link>
        <pubDate>Thu, 03 May 2018 23:03:09 +0000</pubDate>
        
        <guid>https://lxb.wiki/7e8574d1/</guid>
        <description>&lt;h6 id=&#34;设置程序图标&#34;&gt;设置程序图标&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;把ico文件放到源文件目录下, 命名为&amp;quot;test.ico&amp;quot;&lt;/li&gt;
&lt;li&gt;创建一个&lt;code&gt;myico.rc&lt;/code&gt; 文件, 输入如下内容 &lt;code&gt;IDI_ICON1 ICON DISCARDABLE &amp;quot;test.ico&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在pro文件写入 &lt;code&gt;RC_FILE = myico.rc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行qmake, 编译&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;编译-打包&#34;&gt;编译, 打包&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;选择release编译运行&lt;/li&gt;
&lt;li&gt;将生成的exe文件放到某个路径下, 如 &lt;code&gt;Desktop/Test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在cmd里, 进入到exe存放路径, 使用wendeployqt工具拷贝exe运行需要的dll&lt;/li&gt;
&lt;li&gt;使用Inno Setup Compiler生成安装文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;inno-setup-工具使用注意事项&#34;&gt;Inno Setup 工具使用注意事项&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;添加主执行文件外的其他应用程序文件夹下的文件时, 需要编辑一次, 重新指定目标子文件夹&lt;/li&gt;
&lt;li&gt;编译脚本为&lt;code&gt;*.iss&lt;/code&gt; 文件, 编译后默认在源exe的Base 目录下生成Output文件夹, 指定的setup.exe文件生成在Output 文件夹下&lt;/li&gt;
&lt;li&gt;Inno Setup 工具基础版不支持中文. 如需显示中文, 需要找汉化版&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Qt 工程的几种文件</title>
        <link>https://lxb.wiki/924904f6/</link>
        <pubDate>Fri, 20 Apr 2018 22:25:51 +0000</pubDate>
        
        <guid>https://lxb.wiki/924904f6/</guid>
        <description>&lt;h4 id=&#34;pro&#34;&gt;&lt;code&gt;*.pro&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;qmake的工程(project)文件 例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATE = app
CONFIG += QT
QT += core gui

TARGET = somename

SOURCES += main.cpp \
          widget.cpp
HEADERS += widget.h
FORMS += widget.ui
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;前三行是qmake的默认值, 都可以省略&lt;/li&gt;
&lt;li&gt;TARGET 行指定工程名, 也可以省略&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pri&#34;&gt;&lt;code&gt;*.pri&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;include 文件 接上面的例子, 我们可以将源文件的设置独立处理, 放到somename.pri文件内:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SOURCES += main.cpp \
          widget.cpp
HEADERS += widget.h
FORMS += widget.ui
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时, pro 文件就可以简化为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATE = app
CONFIG += QT
QT += core gui

TARGET = somename
include(somename.pri)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;prf&#34;&gt;&lt;code&gt;*.prf&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;特性(feature) 文件 和pri文件类似, prf文件也是要被包含进pro文件. 只是它更隐蔽.&lt;/p&gt;
&lt;p&gt;在上面的例子中, 其实已经用到了prf, 就是 &lt;code&gt;CONFIG += QT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当在CONFIG 中指定一个值时, qmake就会尝试去加载相应的feature文件: - Qt安装目录下的&lt;code&gt;mkspecs/features/qt.prf&lt;/code&gt; - features 文件的文件名必须小写&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;win32:CONFIG += console // 为win32程序添加控制台
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把该文件命名为&lt;code&gt;a.prf&lt;/code&gt;, 放到前面提到的目录中, 然后在pro文件内添加 &lt;code&gt;CONFIG += a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用load命令来加载prf文件 &lt;code&gt;load(a)&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Qt UI 编码规范</title>
        <link>https://lxb.wiki/9c64b54d/</link>
        <pubDate>Mon, 02 Apr 2018 11:27:52 +0000</pubDate>
        
        <guid>https://lxb.wiki/9c64b54d/</guid>
        <description>&lt;h5 id=&#34;变量声明&#34;&gt;变量声明&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每行只声明一个变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用短的/无意义的命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当一个变量被用到时再声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Wrong
int a, b;
char* c, * d;

// Correct
int height;
int width;
char* nameOfOne;
char* nameOfOther;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;变量命名&#34;&gt;变量命名&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量名/函数名采用驼峰命名法(lowerCaseCamel), 首字母缩写词出现的命名中, 缩写也用驼峰命名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Wrong 
short Cntr;
char ITEM_DELIM = &#39;&#39;;

void myXMLStreamReader();

// Correct
short counter;
char itemDelimiter = &#39;&#39;;

void myXmlStreamReader();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;空行空格&#34;&gt;空行/空格&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用一个且仅用一个空行在适当的地方划分代码块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在关键词和小括号之间总是只用一个空格符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Wrong
if(foo)
{
}

// Correct
if (foo)
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;指针引用&#34;&gt;指针/引用&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在类型名和&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;&amp;amp;&lt;/code&gt;之间没有空格, 在&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;&amp;amp;&lt;/code&gt;与变量名之间有一个空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char* someValue;
const QString&amp;amp; myString;
const char* const WOR = &amp;quot;hello&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;符号与空格&#34;&gt;符号与空格&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;二元操作符左右两边都有一个空格&lt;/li&gt;
&lt;li&gt;一元操作符与变量之间不留空格&lt;/li&gt;
&lt;li&gt;逗号左右没有空格, 右边一个空格&lt;/li&gt;
&lt;li&gt;分号左边没有空格; 分号作为语句的结束符, 右边一般不再有内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;号右边没有空格&lt;/li&gt;
&lt;li&gt;左引号的左边和右引号的各一个空格, 左引号的右边和右引号的左边没有空格&lt;/li&gt;
&lt;li&gt;如果右引号右边是右括号, 它们之间没有空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;cast&#34;&gt;cast&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免C语言的cast, 尽量用C++的cast(static_cast, const_cast, reinterpret_cast). reinterpret_cast 和 C风格的cast用起来都是危险的，但至少 reinterpret_cast 不会把const修饰符去掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;涉及到QObjects或重构自己的代码时，不要使用dynamic_cast,而是用qobject_cast，例如在引进一个类型的方法时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用构造函数去cast简单类型,例如：用int(myFloat)代替(int)myFloat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Wrong
char* blockOfMemory = (char* ) malloc(data.size());

// Correct
char *blockOfMemory = reinterpret_cast&amp;lt;char *&amp;gt;(malloc(data.size()));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;语句&#34;&gt;语句&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;不要在一行写多条语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;括号&#34;&gt;括号&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个大括号单独一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不论条件语句的执行部分有几行, 必须使用大括号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小括号用来给语句分组&lt;/p&gt;
&lt;p&gt;// Wrong
if (address.isEmpty()) {
return false;
}&lt;/p&gt;
&lt;p&gt;for (int i = 0; i &amp;lt; 10; +&amp;lsquo;&amp;lsquo;i) {
qDebug(&amp;quot;%i&amp;quot;, i);
}&lt;/p&gt;
&lt;p&gt;// Correct
if (address.isEmpty())
{
return false;
}
else
{
return true;
}&lt;/p&gt;
&lt;p&gt;for (int i = 0; i &amp;lt; 10;i)
{
qDebug(&amp;quot;%i&amp;quot;, i);
}&lt;/p&gt;
&lt;p&gt;// Wrong
if (a &amp;amp;&amp;amp; b || c)&lt;/p&gt;
&lt;p&gt;// Correct
if ((a &amp;amp;&amp;amp; b) || c)&lt;/p&gt;
&lt;p&gt;// Wrong
a + b &amp;amp; c&lt;/p&gt;
&lt;p&gt;// Correct
(a + b) &amp;amp; c&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;switch语句&#34;&gt;switch语句&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;case缩进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除enum外, 每组case最后都要加default;&lt;/p&gt;
&lt;p&gt;switch (myEnum)
{
case Value1:
doSomething();
break;
case Value2:
case Value3:
doSomethingElse();
// fall through
break;
default:
defaultHandling();
break;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;goto&#34;&gt;goto&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;禁止使用goto&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;换行&#34;&gt;换行&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每行代码不多于120字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逗号在行尾. 操作符在新行的开头位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;换行时尽量避免行与行之间看起来参差不齐&lt;/p&gt;
&lt;p&gt;// Wrong
if (longExpression +
otherLongExpression +
otherOtherLongExpression) {
}&lt;/p&gt;
&lt;p&gt;// Correct
if (longExpression
+ otherLongExpression
+ otherOtherLongExpression) {
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;c特性&#34;&gt;&lt;code&gt;C++&lt;/code&gt;特性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;不要使用异常处理&lt;/li&gt;
&lt;li&gt;不要使用运行时类型识别&lt;/li&gt;
&lt;li&gt;理智地使用模板&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;qt源码中的规范&#34;&gt;Qt源码中的规范&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;所有代码都是ascii，使用者如果不确定的话，只可能是7字节&lt;/li&gt;
&lt;li&gt;每一个QObject的子类都必须有Q_OBJECT宏，即使这个类没用到信号或槽。否则qobject_cast将不能使用&lt;/li&gt;
&lt;li&gt;在connect语句中，使信号和槽的参数规范化（参看 QMetaObject::normalizedSignature），可以加快信号/槽的查找速度。可以使用qtrepotools/util/normalize规范已有代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;包含头文件顺序&#34;&gt;包含头文件顺序&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;源文件对应的头文件&lt;/li&gt;
&lt;li&gt;&amp;lt;分隔&amp;gt;&lt;/li&gt;
&lt;li&gt;C系统文件&lt;/li&gt;
&lt;li&gt;&amp;lt;分隔&amp;gt;&lt;/li&gt;
&lt;li&gt;C++系统文件&lt;/li&gt;
&lt;li&gt;&amp;lt;分隔&amp;gt;&lt;/li&gt;
&lt;li&gt;Qt库文件&lt;/li&gt;
&lt;li&gt;&amp;lt;分隔&amp;gt;&lt;/li&gt;
&lt;li&gt;其他目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每组文件按字母升序排列&lt;/p&gt;
&lt;h5 id=&#34;编译器平台&#34;&gt;编译器/平台&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用三目运算符 ？时要特别小心，如果每次的返回值的类型可能不一样的话，一些编译器会在运行时生成冲突的代码（此时编译器甚至不会报错） &lt;code&gt;QString s; return condition ? s : &amp;quot;nothing&amp;quot;; // crash at runtime - QString vs. const char *&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要特别小心对齐问题。无论何时，当一个指针被cast后的对齐数是增加的时候，它都可能会崩溃。例如一个const char 被cast成了cons int，当cast之后的数字不得不在2或4个字节之间对齐时，指针就会在机器上崩溃&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何需要需要执行构造函数或相关代码进行初始化的实例，都不能用作库代码中的全局实例。因为当构造函数或代码将要运行的时候，该实例还没有被定义（在第一次调用该实例时，在加载库时，在执行main()之前） &lt;code&gt;// global scope static const QString x; // Wrong - default constructor needs to be run to initialize x static const QString y = &amp;quot;Hello&amp;quot;; // Wrong - constructor that takes a const char * has to be run QString z; // super wrong static const int i = foo(); // wrong - call time of foo() undefined, might not be called at all&lt;/code&gt; 可以使用下面方法: &lt;code&gt;// global scope static const char x[] = &amp;quot;someText&amp;quot;; // Works - no constructor must be run, x set at compile time static int y = 7; // Works - y will be set at compile time static MyStruct s = {1, 2, 3}; // Works - will be initialized statically, no code being run static QString *ptr = 0; // Pointers to objects are ok - no code needed to be run to initialize ptr&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用Q_GLOBAL_STATIC定义全局实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Q_GLOBAL_STATIC(QString, s)

void foo()
{
 s()-&amp;gt;append(&amp;quot;moo&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;char型变量是有符号的还是无符号的取决于它运行环境的架构。如果你明确地想使用一个signed或unsinged char，就使用signed char或unsigned char。以下代码运行在把char默认为无符号的平台上时，其条件判断恒为真 &lt;code&gt;char c; // c can&#39;t be negative if it is unsigned /********/ /*******/ if (c &amp;gt; 0) { … } // WRONG - condition is always true on platforms where the default is unsigned&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免64位的枚举值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌入式应用系统二进制接口将所有的枚举类型的值硬编码成32位int值&lt;/li&gt;
&lt;li&gt;微软的编译器不支持64位的枚举值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;编程偏好&#34;&gt;编程偏好&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;用枚举值定义常量而非用const int或defines
&lt;ul&gt;
&lt;li&gt;枚举值会在编译时被编译器用实际值替换掉，因而运行时得出结果的速度更快&lt;/li&gt;
&lt;li&gt;defines不是命名空间安全的（并且看起来很丑）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当重新实现一个虚方法时，在Qt5中，用 Q_DECL_OVERRIDE宏在函数声明之后，分号之前注解它&lt;/li&gt;
&lt;li&gt;不要把const-iterator和none-const iterator搞混 &lt;code&gt;for (Container::const_iterator it = c.begin(); it != c.end(); ++it) // Wrong for (Container::const_iterator it = c.cbegin(); it != c.cend(); ++it) // Right&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;命名空间&#34;&gt;命名空间&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;除跟UI直接交互的类外, 其他类必须处在命名空间内&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;float值&#34;&gt;float值&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;用qFuzzyCompare去和delta比较其值&lt;/li&gt;
&lt;li&gt;用qIsNull去判断float值是不是二进制0，而不是和0.0比较 &lt;code&gt;[static] bool qFuzzyCompare(double p1, double p2) // Instead of comparing with 0.0 qFuzzyCompare(0.0,1.0e-200); // This will return false // Compare adding 1 to both values will fix the problem qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;类的成员命名&#34;&gt;类的成员命名&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;成员变量一般为名词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数成员一般为动词/动词+名词，但是当动词为get时，get常常省略。当返回值为Bool型变量时，函数名一般以前缀’is’开头&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public:
    void setColor(const QColor&amp;amp; c);
    QColor color() const;
    void setDirty(bool b);
    bool isDirty() const;

private Q_SLOTS:
    void onParentChanged();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;构造函数&#34;&gt;构造函数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;为了使构造函数被错误使用的可能性降到最小，每一个构造函数（除了拷贝构函数）都应该检查自己是否需要加上explicit 符号&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;注意代码陷阱&#34;&gt;注意代码陷阱&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;不要为了图方便少些一些代码。因为代码是一次书写，后期不止一次地要去理解。例如 &lt;code&gt;QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, &amp;quot;volume&amp;quot;);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改成下面的方式会更容易理解 &lt;code&gt;QSlider *slider = new QSlider(Qt::Vertical); slider-&amp;gt;setRange(12, 18); slider-&amp;gt;setPageStep(3); slider-&amp;gt;setValue(13); slider-&amp;gt;setObjectName(&amp;quot;volume&amp;quot;);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;参考资料&#34;&gt;参考资料&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.qt.io/Qt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.qt.io/Qt&lt;/a&gt;_Contribution_Guidelines&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.qt.io/Qt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.qt.io/Qt&lt;/a&gt;_Coding_Style&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.qt.io/Coding_Conventions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.qt.io/Coding_Conventions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://community.kde.org/Policies/Library&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://community.kde.org/Policies/Library&lt;/a&gt;_Code_Policy&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.qt.io/UI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.qt.io/UI&lt;/a&gt;_Text_Conventions&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.qt.io/API&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.qt.io/API&lt;/a&gt;_Design_Principles&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://doc.qt.io/qt-5/qml-codingconventions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://doc.qt.io/qt-5/qml-codingconventions.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://google.github.io/styleguide/cppguide.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://google.github.io/styleguide/cppguide.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>qt 的 pro 文件</title>
        <link>https://lxb.wiki/8304997e/</link>
        <pubDate>Wed, 21 Mar 2018 09:49:25 +0000</pubDate>
        
        <guid>https://lxb.wiki/8304997e/</guid>
        <description>&lt;h4 id=&#34;注释&#34;&gt;注释&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;#&lt;/code&gt; 进行行注释&lt;/p&gt;
&lt;h4 id=&#34;模板&#34;&gt;模板&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;TEMPLATE = app&lt;/code&gt; 告诉&lt;code&gt;qmake&lt;/code&gt;为这个应用程序生成哪种&lt;code&gt;makefile&lt;/code&gt;. - app 默认值. 生成app的makefile - lib 生成一个库的makefile - vcapp 生成一个应用程序的&lt;code&gt;VisualStudio&lt;/code&gt;项目文件 - vclib 生成一个库的&lt;code&gt;VisualStudio&lt;/code&gt; 项目文件 - subdirs 生成&lt;code&gt;makefile&lt;/code&gt;文件编译&lt;code&gt;subdirs&lt;/code&gt;指定的子文件夹&lt;/p&gt;
&lt;h4 id=&#34;应用程序目录&#34;&gt;应用程序目录&lt;/h4&gt;
&lt;p&gt;指定生成的应用程序放置的目录 &lt;code&gt;DESTDIR += ../bin&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;配置信息&#34;&gt;配置信息&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;COFNIG&lt;/code&gt; 用来告诉&lt;code&gt;qmake&lt;/code&gt; 关于应用程序的配置信息 &lt;code&gt;CONFIG += qt warn_on release&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;ui目录&#34;&gt;ui目录&lt;/h4&gt;
&lt;p&gt;指定uic命令将&lt;code&gt;.ui&lt;/code&gt;文件转化成的&lt;code&gt;ui_*.h&lt;/code&gt;文件的存放目录 &lt;code&gt;UI_DIR += forms&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;rcc目录&#34;&gt;rcc目录&lt;/h4&gt;
&lt;p&gt;指定rcc命令将&lt;code&gt;.qrc&lt;/code&gt;文件转换成的&lt;code&gt;qrc_*.h&lt;/code&gt;文件的存放目录 &lt;code&gt;RCC_DIR += ../tmp&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;moc目录&#34;&gt;moc目录&lt;/h4&gt;
&lt;p&gt;指定moc命令将&lt;strong&gt;含Q_OBJECT的头文件转换成标准&lt;code&gt;.h&lt;/code&gt;文件的存放目录&lt;/strong&gt; &lt;code&gt;MOC_DIR += ../tmp&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;目标文件目录&#34;&gt;目标文件目录&lt;/h4&gt;
&lt;p&gt;指定目标文件(obj)的存放目录 &lt;code&gt;OBJECTS_DIR += ../tmp&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;依赖相关路径&#34;&gt;依赖相关路径&lt;/h4&gt;
&lt;p&gt;程序编译时依赖的相关路径 &lt;code&gt;DEPENDPATH += . forms include qrc sources&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;头文件包含路径&#34;&gt;头文件包含路径&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;INCLUDEPATH += .&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;qmake时产生的信息&#34;&gt;qmake时产生的信息&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;message($$(PATH))&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;源文件编码方式&#34;&gt;源文件编码方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;CODECFORSRC = GBK&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;工程中包含的头文件&#34;&gt;工程中包含的头文件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;HEADERS += include/aa.h&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;工程中包含的ui文件&#34;&gt;工程中包含的&lt;code&gt;.ui&lt;/code&gt;文件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;FORMS += forms/aa.ui&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;工程中包含的源文件&#34;&gt;工程中包含的源文件&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SOURCES += sources/main.cpp sources/aa.cpp&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;工程中包含的资源文件&#34;&gt;工程中包含的资源文件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;RESOURCES += qrc/aa.qrc
LIBS += -LfolderPath
Release: LIBS += -LfolderReleasePath
Debug: LIBS += -LfolderDebugPath
DEFINES += XX_XX_XXX // 定义编译选项, 在.h文件中就可以用 #ifdefine XX_XX_XXX
RC_FIELS = xxx.icns
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;平台相关性处理&#34;&gt;平台相关性处理&lt;/h4&gt;
&lt;p&gt;根据qmake所运行的平台来使用相应的作用域来进行处理.&lt;/p&gt;
&lt;p&gt;为Windows平台添加的依赖平台的文件示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;win32{
SOURCES += hello_win.cpp
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;生成makefile&#34;&gt;生成Makefile&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;qmake -oMakefile hello.pro&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于VisualStudio用户, qmake也可以生成&lt;code&gt;.dsp&lt;/code&gt;文件 &lt;code&gt;qmake -tvcapp -o hello.dsp hello.pro&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&#34;pro文件实例&#34;&gt;pro文件实例&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATE = app #模块配置
LANGUAGE = C++ #C++语言

CONFIG += qt warn_on debug release

#引入的lib文件,用于引入动态链接库
LIBS += qaxcontainer.lib

#头文件包含路径
INCLUDEPATH += ../../qtcompnent/qtchklisten/inc ../../qtcompnent/qtclearfile/inc ../../validator/inc/validerrcode ../../qtcompnent/qtdir/inc ../inc ../../utillib/inc/xmlapi ../../utillib/inc/util ../../xercesc ../../qtcompnent/qteditor/inc ../../qtcompnent/qtfunreview/inc ../../qtcompnent/qttable/inc ../../qtcompnent/qtversion/inc ../../qtcompnent/qtini/inc ../../icdtool/icdservices/inc ../../icdtool/dataset/inc ../../icdtool/doi/inc ../../icdtool/reportcontrol/inc ../../icdtool/GSEconctrol/inc ../../icdtool/inputs/inc ../../icdtool/SMVconctrol/inc ../../icdtool/logcontrol/inc ../../scdpreview/inc/scdpreviewtoollib ../../scdpreview/form ../../icdtool/sclcontrol/inc ../../icdtool/log/inc ../../icdtool/settingcontrol/inc ../../qtcompnent/qteditor/inc ../../qtcompnent/qttreeview/inc ../../qtcompnent/qttabwidget/inc ../../communication/inc ../../qtcompnent/qtabout/inc ../iedmanage/inc ../ldmanage/inc ../foriecrun/inc ../../qtcompnent/validset/inc

#工程中包含的头文件
HEADERS += ../inc/exportstable.h /
../inc/maintabwidget.h /
../inc/outputtab.h /
../inc/strutil.h /
../inc/treeeditview.h /
../inc/MainForm.h /
../inc/recenfileini.h /
../inc/ExportCIDFunction.h

#工程中包含的源文件
SOURCES += ../src/main.cpp /
../src/exportstable.cpp /
../src/maintabwidget.cpp /
../src/outputtab.cpp /
../src/treeeditview.cpp /
../src/MainForm.cpp /
../src/recenfileini.cpp /
../src/ExportCIDFunction.cpp

#工程中包含的.ui设计文件
FORMS = ../form/scdmainform.ui /
../form/exportiedform.ui /
../form/Exportsedform.ui /
../form/Importsedform.ui /
../form/formiminputs.ui

#图像文件

IMAGES = images/substation.png /
images/communication.png /
images/autocom.png /
images/reportcfg.png /
images/comcfg.png /
images/filetrans.png /
images/review.png /
images/setting.png

#工程中包含的资源文件
RESOURCES = Scintilla.qrc

#CONFIG -= release
CONFIG -= debug


RC_FILE = scdtool.rc


BINLIB = ../../bin ../../xercesc/lib

UI_HEADERS_DIR = ../inc # .ui文件转会为**.h 存放的目录
UI_SOURCES_DIR = ../src # .ui文件转会为**.cpp 存放的目录
QMAKE_LIBDIR = $${BINLIB}

release {
TARGET = scdtool #指定生成的应用程序名
OBJECTS_DIR = ../../obj/scdtool/release #指定目标文件(obj)的存放目录
}
debug {
TARGET = scdtool_d #指定生成的应用程序名
OBJECTS_DIR = ../../obj/scdtool/debug #指定目标文件(obj)的存放目录
}

MOC_DIR = $${OBJECTS_DIR}
DESTDIR = ../../bin #指定生成的应用程序放置的目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充: &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Braveliu/p/5107550.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cnblogs&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】How to split a string in C&#43;&#43;</title>
        <link>https://lxb.wiki/9747854a/</link>
        <pubDate>Sun, 04 Jun 2017 18:40:14 +0000</pubDate>
        
        <guid>https://lxb.wiki/9747854a/</guid>
        <description>&lt;p&gt;这个问题是说, 怎么得到组成一句话的各个单词, 或者得到CSV中的各个数据片段. 这在C++中是个很简单的问题, 却有很多种答案.&lt;/p&gt;
&lt;p&gt;有3种方案, 每种有利有弊. 使用时请自己选择最佳方案. 这篇文章的目的是说明 迭代器的接口是如何优胜于简单的容器的, 并且阐明 &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;design of the STL&lt;/a&gt; 是何等强大.&lt;/p&gt;
&lt;p&gt;方案1使用的标准组件(虽然方案1.2 做了微调). 方案2相对好点但使用了&lt;code&gt;boost&lt;/code&gt;. 而方案3 更好但使用了&lt;code&gt;ranges&lt;/code&gt;. 所以到底应该用哪个, 取决于你需要什么和你能使用什么.&lt;/p&gt;
&lt;h3 id=&#34;solution-1-iterating-on-a-stream&#34;&gt;Solution 1: Iterating on a stream&lt;/h3&gt;
&lt;h4 id=&#34;stepping-into-the-world-of-streams&#34;&gt;Stepping into the world of streams&lt;/h4&gt;
&lt;p&gt;&amp;ldquo;流&amp;rdquo; 是一个 能生成 与源或希望连接的目标 的联系 的对象. 流可以从源中获取信息(&lt;code&gt;std::istream&lt;/code&gt;), 或为目标提供信息(&lt;code&gt;std::ostream&lt;/code&gt;), 或者两者皆可(&lt;code&gt;std::iostream&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;源和目标可以是标准输入(&lt;code&gt;std::cin&lt;/code&gt;), 标准输出(&lt;code&gt;std::cout&lt;/code&gt;), 一个文件, 或者一个字符串, 前提是方式得当. 对流的主要操作包括: - 对于输入流: 使用操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 从里面读取信息 - 对于输出流: 使用操作符&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, 向它推入信息&lt;/p&gt;
&lt;p&gt;一个指向字符串的输入流, &lt;code&gt;std::istringstream&lt;/code&gt;, 有个有趣的特性: 它的操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 在源字符串中制造出去向下一个空格的字符串.&lt;/p&gt;
&lt;h4 id=&#34;istream_iterator&#34;&gt;istream_iterator&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;std::istream_iterator&lt;/code&gt; 是连接输入流的迭代器. 它代表了输入迭代器的普遍接口, 但它的操作符&lt;code&gt;++&lt;/code&gt; 更像是输入流.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream_iterator&lt;/code&gt; 以它从流里读取的类型为模板. 我们现在使用&lt;code&gt;istream_iterator&amp;lt;std::string&amp;gt;&lt;/code&gt;, 它从流里读取字符串, 分离时为我们提供一个字符串.&lt;/p&gt;
&lt;p&gt;当到达流的终点时, 流向它的迭代器发送信号, 然后迭代器被标记为结束.&lt;/p&gt;
&lt;h3 id=&#34;solution-11&#34;&gt;Solution 1.1&lt;/h3&gt;
&lt;p&gt;现在, 我们可以借迭代器的接口使用算法, 这真切地证明了&lt;code&gt;STL&lt;/code&gt; 设计的灵活性. 为了使用&lt;code&gt;STL&lt;/code&gt;, 我们需要一个&lt;code&gt;begin&lt;/code&gt; 和一个&lt;code&gt;end&lt;/code&gt; (请参考&lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/03/28/inserting-several-elements-into-an-stl-container/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Inserting several elements into an STL container efficiently&lt;/a&gt;). &lt;code&gt;begin&lt;/code&gt; 是一个 还没开始着手分割的字符串的&lt;code&gt;istreamstream&lt;/code&gt; 的迭代器: &lt;code&gt;std::istream_iterator&amp;lt;std::string&amp;gt;(iss)&lt;/code&gt; . 按照惯例, &lt;code&gt;end&lt;/code&gt; 的默认值也是个&lt;code&gt;istream_iterator&lt;/code&gt; : &lt;code&gt;std::istream_iterator&amp;lt;string&amp;gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let me split this into words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;std::string&amp;gt;(iss)), std::istream_iterator&amp;lt;std::string&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第一个参数的额外的括号是为了避免与一个函数调用的歧义&amp;ndash;请参考Scott Meyers的著作Effective STL 条目6 &amp;ldquo;most vexing parse&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优: - 仅使用标准组件 - 除字符串外, 对所有流都适用 劣: - 只能以空格为分隔符进行分割, 而且这在解析CSV时会是个至关重要的问题 - 在性能方面有待优化(但如果这不是影响你整个程序的瓶颈, 这也不是个大问题) - 很多人认为仅为了分割一个字符串, 写了太多代码&lt;/p&gt;
&lt;h3 id=&#34;solution12-pimp-my-operator&#34;&gt;Solution1.2: Pimp my operator&amp;raquo;&lt;/h3&gt;
&lt;p&gt;导致上面两条劣势的原因是同一个: &lt;code&gt;istream_iterator&lt;/code&gt; 从流里读取字符串时调用的操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. 这个操作符做了很多事: 在下一个空格处停止(这是我们的最初的需求, 但这个不能自定义), 格式化, 读取然后设置一些标志位, 构造对象, 等等. 而以上这些, 大部分我们是不需要的. 所以我们希望自己实现下面的函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream&amp;amp; is, std::string&amp;amp; output)
{
    // ...does lots of things...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上, 我们无法改变这些, 因为这是在标注库里的. 我们可以用另一个类型重载它, 但是这个类型需要是&lt;code&gt;string&lt;/code&gt; 的一种.&lt;/p&gt;
&lt;p&gt;所以现在的需求就是, 用另一种类型伪装成&lt;code&gt;string&lt;/code&gt;. 有两种方案: 继承&lt;code&gt;std::string&lt;/code&gt; 和 用显式转换封装&lt;code&gt;string&lt;/code&gt;. 这里我们选择继承.&lt;/p&gt;
&lt;p&gt;假如我们希望以逗号为分割符分割一个字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class WordDelimitedByCommas: pulic std::string
{};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我必须承认这是有争议的. 有人会说:&amp;quot;&lt;code&gt;std::string&lt;/code&gt; 没有虚析构函数, 所以你不应该继承它!&amp;quot; 这可能, 大概, 也许是有一点点点点武断. 这里我要说的是, 继承本身不会产生问题. 诚然, 当一个指向&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 的指针以&lt;code&gt;std::string&lt;/code&gt; 的形式被&lt;code&gt;delete&lt;/code&gt; 掉时, 会产生问题. 继续读, 你会发现, 我们不会这么做. 现在我们可以阻止写代码的人借&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 突发冷箭破坏程序吗? 我们不能. 但是这个险值得我们冒吗? 请继续读, 然后你自己判断.&lt;/p&gt;
&lt;p&gt;现在为了仅实现我们需要的功能, 我们可以重载操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : 获取下一个逗号之前的所有字符. 这个可以借用&lt;code&gt;getline&lt;/code&gt; 函数实现:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream* is, std::WordDelimitedByCommas&amp;amp;)
{
    std::getline(is, output, &#39;,&#39;);
    return is;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;code&gt;is&lt;/code&gt; 保证了可以连续调用操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以写初级代码了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let,me,split,this,into,words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;WordDelimitedByCommas&amp;gt;(iss)), std::istream_iterator&amp;lt;WordDelimitedByCommas&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过模板化&lt;code&gt;WordDelimitedByCommas&lt;/code&gt; 泛华所有的分隔符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;char delemiter&amp;gt;
class WordDelimitedBy: pulic std::string
{};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在以分号举例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let;me;split;this;into;words&amp;quot;;
std::istringstream iss(text);
std::vector&amp;lt;std::string&amp;gt; results((std::istream_iterator&amp;lt;WordDelimitedBy&amp;lt;&#39;;&#39;&amp;gt;&amp;gt;(iss)), std::istream_iterator&amp;lt;WordDelimitedBy&amp;lt;&#39;;&#39;&amp;gt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优: - 编译时允许任何分隔符 - 不仅是字符串, 对任何流都可以操作 - 比方案1更快(快20%到30%) 劣: - 虽然可以很方便的复用, 但仍不是标准 - 仅仅为了分割一个字符串, 这个方案仍然使用了大量代码&lt;/p&gt;
&lt;h3 id=&#34;solution2-using-boostsplit&#34;&gt;Solution2: Using &lt;code&gt;boost::split&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这个方案比方案1高级, 除非你需要对所有的流都进行操作.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost/algorithm/string.hpp&amp;gt;

std::string text = &amp;quot;Let me split this into words&amp;quot;;
std::vector&amp;lt;std::string&amp;gt; result;
boost::split&amp;lt;results, text, [](char c){return &#39; &#39; == c;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传给&lt;code&gt;boost::split&lt;/code&gt; 的第三个参数是一个函数或函数对象, 确定一个字符是不是分隔符. 上面的例子是使用&lt;code&gt;lambda&lt;/code&gt; 表达式, 传入一个&lt;code&gt;char&lt;/code&gt;, 返回这个&lt;code&gt;char&lt;/code&gt; 是否是空格.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::split&lt;/code&gt; 的实现很简单: 在到达字符串的结束位置之前, 重复地调用&lt;code&gt;find_if&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;优: - 非常直观的接口 - 允许任何分隔符, 甚至是多个 - 高效: 比方案1.1 快 60% 劣: - 暂不是标准: 需要用到&lt;code&gt;boost&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;solution-3未来-usingranges&#34;&gt;Solution 3(未来): Using&lt;code&gt;ranges&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;虽然它们现在还没有像标准库甚至&lt;code&gt;boost&lt;/code&gt; 里的组件一样被广泛使用, &lt;code&gt;ranges&lt;/code&gt; 是&lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/01/12/ranges-stl-to-the-next-level/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;future of the STL&lt;/a&gt; . 在未来几年, 会大量面世.&lt;/p&gt;
&lt;p&gt;Eric Neiber 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ericniebler/range-v3/blob/master/test/view/split.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;range-v3&lt;/a&gt; 库 提供了非常友好的接口. 为了生成一个字符串的分割&lt;code&gt;view&lt;/code&gt;, 代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::string text = &amp;quot;Let me split this into words&amp;quot;;
auto splitText = text | view::split(&#39; &#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它有很多有趣的特性, 诸如 使用一个子字符串作为分隔符. &lt;code&gt;ranges&lt;/code&gt; 会被&lt;code&gt;C++20&lt;/code&gt; 引入, 所以我们应该能在几年之内就可以使用这个功能了.&lt;/p&gt;
&lt;h3 id=&#34;so-how-do-i-split-my-string&#34;&gt;So, how do I split my string?&lt;/h3&gt;
&lt;p&gt;如果你能使用&lt;code&gt;boost&lt;/code&gt;, 务必使用方案2. 或者你可以自己写算法, 像&lt;code&gt;boost&lt;/code&gt; 那样基于&lt;code&gt;find_if&lt;/code&gt; 分割字符串.&lt;/p&gt;
&lt;p&gt;如果你不想这么做, 你可以使用标准, 即方案1.1, 如果你需要自定义分隔符, 或者发现1.1是个瓶颈, 那么你可以选择方案1.2 .&lt;/p&gt;
&lt;p&gt;如果你可以使用&lt;code&gt;ranges&lt;/code&gt; , 那么就应该选择方案3.&lt;/p&gt;
&lt;p&gt;翻译原文: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>strict weak ordering</title>
        <link>https://lxb.wiki/22f34ac7/</link>
        <pubDate>Sat, 27 May 2017 14:42:41 +0000</pubDate>
        
        <guid>https://lxb.wiki/22f34ac7/</guid>
        <description>&lt;p&gt;A strict weak ordering is a &lt;em&gt;binary relation&lt;/em&gt; &amp;lt; on a set S that is a strict partial order (a transitive relation that is irreflexive, or equivalently, that is asymmetric) in which the relation &lt;code&gt;neither a &amp;lt; b nor b &amp;lt; a&lt;/code&gt; is transitive. Therefore, a strict weak ordering has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For all x in S, it is not the case that x &amp;lt; x (irreflexivity).&lt;/li&gt;
&lt;li&gt;For all x, y in S, if x &amp;lt; y then it is not the case that y &amp;lt; x (asymmetry).&lt;/li&gt;
&lt;li&gt;For all x, y, z in S, if x &amp;lt; y and y &amp;lt; z then x &amp;lt; z (transitivity).&lt;/li&gt;
&lt;li&gt;For all x, y, z in S, if x is incomparable with y (neither x &amp;lt; y nor y &amp;lt; x hold), and y is incomparable with z, then x is incomparable with z (transitivity of incomparability).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list of properties is somewhat redundant, as asymmetry follows readily from irreflexivity and transitivity.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散数学中的relation:&lt;/strong&gt; Given a function f (which models a binary relation) over a domain D, and a, b ∈ D:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reflexivity: f (a, a) is true.&lt;/li&gt;
&lt;li&gt;Asymmetry: For a ≠ b, if f(a, b) is true, f(b,a) is false&lt;/li&gt;
&lt;li&gt;Anti-symmetry: If f(a, b) and f(b, a) are both true iff a ≡ b&lt;/li&gt;
&lt;li&gt;Transitivity: If f(a, b) and f(b, c) are true, then f(a, c) is true&lt;/li&gt;
&lt;li&gt;Incomparability: Neither f(a, b) nor f(b, a) is true&lt;/li&gt;
&lt;li&gt;Transitivity of incomparability: If a and b are incomparable, and so are b and c, then a and c are incomparable.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;摘自WikiPedia&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Move semantics of RapidJSON</title>
        <link>https://lxb.wiki/e5a4892c/</link>
        <pubDate>Wed, 10 May 2017 10:10:27 +0000</pubDate>
        
        <guid>https://lxb.wiki/e5a4892c/</guid>
        <description>&lt;p&gt;RapidJSON 的设计有一个特性, 进行赋值操作时, 不是把源value复制(copy)到目的 value, 而是转移(move)到目的value. 例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Value a(123);
Value b(456);
b = a; // a becomes a Null value, b becomes number 123.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207003749.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这样的设计的目的是 为了提高性能. 对于固定大小的JSON类型(Number, True, False, Null), 复制很简单快捷. 而对于可变大小的类型(String, Array, Object), 复制时会产生大量不容易被察觉的开销. 尤其是当我们需要创建一个临时的值, 把它复制给另一个变量, 然后析构它. 若使用正常的&lt;strong&gt;复制&lt;/strong&gt; 语义:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Document d;
Value o(kObjectType);
{
    Value contacts(kArrayType);
    // Adding elements to contacts array.
    // ...
    o.AddMember(&amp;quot;contacts&amp;quot;, contacts, d.GetAllocator(); // deep clone contacts(may be with lots of allocations)
    // destruct contact
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207003815.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;o&lt;/code&gt; 需要分配跟&lt;code&gt;contacts&lt;/code&gt; 大小一样的缓冲区, 做深度复制, 然后析构&lt;code&gt;contacts&lt;/code&gt; . 这样会产生大量不必要的内存分配/释放 和内存复制. 有一些方案可以避免实质的复制这些数据, 如引用计数, 垃圾回收等等. 为了使RapidJSON简单和快速, 我们选择使用转移语义来进行赋值. 这与&lt;code&gt;std::auto_ptr&lt;/code&gt;类似, 都是在赋值时转移拥有权. 转移比复制简捷地多, 它只需 析构原来的值, 把源值&lt;code&gt;memcpy()&lt;/code&gt; 到目的值, 最后再把源值 设为Null类型.&lt;/p&gt;
&lt;p&gt;使用转移语义, 上面的例子变成:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Document d;
Value o(kObjectType);
{
    Value contacts(kArraryType);
    // Adding elements to contacts array.
    o.AddMember(&amp;quot;contacts&amp;quot;, contacts, d.GetAllocator()); // Just memcpy() of contacts itself to the value of new member(16 bytes)
    // contacts became Null here. Its destructiong is trivial.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201207003854.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转移语义和临时值&lt;/strong&gt; 有时, 我们想直接构造一个临时变量传给&amp;quot;转移&amp;quot;函数, 如&lt;code&gt;PushBack()&lt;/code&gt; , &lt;code&gt;AddMember()&lt;/code&gt; . 由于临时对象不能直接转化成正常的值引用, 我们可以调用&lt;code&gt;Move()&lt;/code&gt; 函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Value a(kArrayType);
Document::AllocatorType&amp;amp; allocator = document.GetAllocator();
// a.PushBack(Value(42), allocator); // Compiling error
a.PushBack(Value().SetInt(42), allocator); // fluent API
a.PushBack(Value(42).Move(), allocator); // same as above
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;翻译原文: &lt;a class=&#34;link&#34; href=&#34;http://rapidjson.org/md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://rapidjson.org/md&lt;/a&gt;_doc_tutorial.html#MoveSemantics&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】C&#43;&#43;11 sort using function objects</title>
        <link>https://lxb.wiki/e754bcbe/</link>
        <pubDate>Wed, 19 Apr 2017 21:58:53 +0000</pubDate>
        
        <guid>https://lxb.wiki/e754bcbe/</guid>
        <description>&lt;p&gt;如果你用C++编码， 需要对容器内的元素进行排序， 这个容器提供任意访问的迭代器， 比如&lt;code&gt;std::vector&lt;/code&gt;， 那么简单快捷的方法是使用里的&lt;code&gt;std::sort&lt;/code&gt; 函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Basic sorting&lt;/strong&gt; &lt;code&gt;std::sort&lt;/code&gt; 函数需要两个参数, 这两个参数分别指向你要排序的序列容器的开始(initial)和终点(final). 这个序列容易内除final指向的那个元素外 所有元素都会被排序. 下面是一个简单的排序例子:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;0 5 10 15 20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More complex sorting&lt;/strong&gt; 在某些时候, 根据数值升序排序已经足够解决问题了, 但是当我们需要按某个特定的参数进行排序, 或者降序排列时, 就需要一些其他的东西了. 对于这种需求, &lt;code&gt;std::sort&lt;/code&gt; 需要引入第三个参数: 比较函数. 这个比较函数有两个参数, 分别是序列容器的两个元素, 返回值可以隐式地转为bool. 如果第一个参数应该排在第二个参数前面, 则返回true.&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescOrderInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end(), DescOrderInt);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;DescOrderInt的实现:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DescOrderInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;20 15 10 5 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++11 sort using function objects&lt;/strong&gt; 网上很多例子说, 为了排列元素, 可以使用&lt;code&gt;std::binary_function&lt;/code&gt; 定义比较函数, 但不幸的是, &lt;code&gt;std::binary_function&lt;/code&gt; 在C++11 中已经被标为 &amp;ldquo;将被弃用的&amp;rdquo;, 在C++17中会被完全移除, 所以写新的C++代码时, 最好不要用这个.&lt;/p&gt;
&lt;p&gt;我们可以使用C++11中引入的&lt;code&gt;std::function&lt;/code&gt; 来定义这个函数指针. 例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;function&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;&amp;lt;/function&amp;gt;&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StrDescOrderInt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; array[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec(array, array &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sorter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StrDescOrderInt();&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(vec.begin(), vec.end(), sorter);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出: &lt;code&gt;20 15 10 5 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A real-life example: providing multiple sorting options&lt;/strong&gt; 我们假设有一队足球运动员, 我们想让用户按他们自己的意愿去排列这些运动员. 有一个图表的UI, 上面有几个按钮, 每个按钮对应不用的排序规则.&lt;/p&gt;
&lt;p&gt;Plaer 类的代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -- Player.h --
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&amp;lt;/string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Player(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; name, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; caps, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; goals);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;amp; GetName() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetCaps&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetGoals&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string mName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mCaps;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mGoals;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;现在我们新写一个类或结构体来列出所有的比较函数. 比较函数是一个结构体并实现操作符&lt;code&gt;()&lt;/code&gt;, 操作符&lt;code&gt;()&lt;/code&gt; 带有两个参数, 分别为两个指向Player的指针, 返回bool值.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PlayerSorting&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// name
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByNameAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByNameDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// caps
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByCapsAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByCapsDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// goals
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByGoalsAsc&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SortPlayerByGoalsDes&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1, Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后, 在调用它的地方, 我们可以先把所有的&lt;code&gt;std::function&lt;/code&gt; 存在一个&lt;code&gt;std::vector&lt;/code&gt; 里, 使用的时候, 用索引访问vector的元素.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(player &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; player&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sorters;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByNameAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByCapsAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByGoalsAsc());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByNameDes());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByCapsDes());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sorters.push_back(PlayerSorting&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SortPlayerByGoalsDes());&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;(player&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;例如, 根据得分降序排列:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;player &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; players;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;player&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ...init players...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(players.begin(), players.end(), sorters[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     CAPS  GOALS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Lionel Messi             &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;David Villa              &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Asamoah Gyan             &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Arjen Robben             &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mesut Oezil              &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Diego Forlan             &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Andres Iniesta           &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Wesley Sneijder          &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Xavi                     &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bastian Schweinsteiger   &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假如需要实现一种新的排序方式, 我们只需要在PlayerSorting类中添加一个新的仿函数即可.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>core文件被截断问题的解决办法</title>
        <link>https://lxb.wiki/d12416f0/</link>
        <pubDate>Mon, 10 Apr 2017 21:09:35 +0000</pubDate>
        
        <guid>https://lxb.wiki/d12416f0/</guid>
        <description>&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;
通过gdb打开core，但看不到core的内容，信息如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gdb XXX core.XXX
GNU gdb (GDB) Red Hat Enterprise Linux ( 7.0.1-32.el5)
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;#34;show copying&amp;#34;
and &amp;#34;show warranty&amp;#34; for details.
This GDB was configured as &amp;#34;x86_64-redhat-linux-gnu&amp;#34;.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...
Reading symbols from /home/XXX/XXX...done.
BFD: Warning: /home/XXX/core.XXX is truncated: expected core file size &amp;gt;= 747175936, found: 1236992.
 
warning: core file may not match specified executable file.
Cannot access memory at address 0x344201cc88
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;调查&lt;/strong&gt;
ulimit -a的结果如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;core file size          (blocks, -c) 1000
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 40960
max locked memory       (kbytes, -l) 32
max memory size         (kbytes, -m) unlimited
open files                      (-n) 65000
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 536870912
real-time priority              (-r) 0
stack size              (kbytes, -s) 1024000
cpu time               (seconds, -t) unlimited
max user processes              (-u) 40960
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经别人指点，说是“core file size”的值太小了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改core file size的方法&lt;/strong&gt;
1 使用root用户登录，在&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;文件中，添加了“* hard core   unlimited”行，添加后此文件的内容大致如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# /etc/security/limits.conf
#
# Each line describes a limit for a user in the form:
#
# &amp;lt;domain&amp;gt; &amp;lt;type&amp;gt; &amp;lt;item&amp;gt; &amp;lt;value&amp;gt;
#
* - msgqueue 536870912
* soft nofile 65000
* hard nofile 65000
* soft core   unlimited
* hard core   unlimited
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2 修改这个文件后，退出root用户
3 退出自己的账户的全部登录的终端，然后关闭telnet工具，重新使用自己的账户登录系统，键入下面的命令，都会返回unlimited&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ulimit -S -c
unlimited
$ ulimit -H -c
unlimited
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时core文件就不会被截断了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;
How do I enable core dumps for everybody
&lt;a class=&#34;link&#34; href=&#34;http://www.akadia.com/services/ora_enable_core.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.akadia.com/services/ora_enable_core.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://blog.sina.com.cn/s/blog_537f4d9b0100wi88.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.sina.com.cn/s/blog_537f4d9b0100wi88.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】String&amp;#039;s interface</title>
        <link>https://lxb.wiki/4c3249cd/</link>
        <pubDate>Sun, 09 Apr 2017 22:00:41 +0000</pubDate>
        
        <guid>https://lxb.wiki/4c3249cd/</guid>
        <description>&lt;p&gt;考虑以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool fun(const string&amp;amp;amp; code)
{
assert(code.length() &amp;amp;gt;= 2);
if (code.substr(0, 2) == string(&amp;quot;XX&amp;quot;))
{
// ...
}
// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有没有发现什么问题? 不要纠结于assert(), 它只是为了保证 string &amp;ldquo;code&amp;rdquo; 长度大于2而已.&lt;/p&gt;
&lt;p&gt;很显然, 这段代码用来检查string是否以&amp;quot;XX&amp;quot;开头. 基于它长度大于2 的前提, 这段代码能正常运行. 我们的关心的问题是, 表达式能否达到正确的结果.&lt;/p&gt;
&lt;p&gt;绝大多数情况下, 我们之所以使用C++, 是希望能使我们的程序达到最优的性能. 基于这个目标, 上面的代码看起来就不是很正确了. 为了检查&amp;quot;code&amp;quot;是否以&amp;quot;XX&amp;quot;开头, 我们生成了两个临时的string, 每个string都可能潜在地申请堆上的内存. 有人可能会为此辩解: std::string应该能为一个 2字母的序列实现 短字符串最优化(SSO). 就算这个辩解是正确的, 这段代码也已经 耗费了 一些不能被优化掉的开销, 更何况, 并不是所有的都会实现SSO. 例如, 我使用的GCC 4.4.7 就不会为string实现SSO.&lt;/p&gt;
&lt;p&gt;类模板&lt;code&gt;std::basic_string&lt;/code&gt; 的接口很复杂. 它提供了大量的成员函数, 似乎不用它们显得不领情, 同时开发者也不会有自己一遍遍重新解析的冲动.&lt;/p&gt;
&lt;p&gt;因为开发者模糊地记得应用于NTBS(null-terminated byte strings)(可以被隐式地转为&lt;code&gt;const char*&lt;/code&gt; )的 操作符 &lt;code&gt;==&lt;/code&gt; 会使结果出错, 所以他通过 确保参与比较的两个值都是&lt;code&gt;std::string&lt;/code&gt; 类型来避开这个错误. 他可能在想, 在运行操作符&lt;code&gt;==&lt;/code&gt; 前文本&amp;quot;XX&amp;quot; 已经被显式地转成了&lt;code&gt;std::string&lt;/code&gt;, 那么这么做也没有坏处. &lt;strong&gt;但是&lt;/strong&gt;, 这是错误的, 因为对于操作符&lt;code&gt;==&lt;/code&gt;, 标准提供了两种版本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool operator==(const std::string&amp;amp;amp; lhs, const char* rhs);
bool operator==(const char* lhs, const std::string&amp;amp;amp; rhs);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然实际上他们是带有多个参数的函数模板, 远比这个复杂. &lt;code&gt;std::string&lt;/code&gt; 可以直接跟NTBS比较, 没有必要生成临时的&lt;code&gt;std::string&lt;/code&gt;. 我们开头的例子, 可以通过去除显式生成的临时副本 进行优化: &lt;code&gt;if (code.substr(0, 2) == &amp;quot;XX&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更进一步, 不可否认, 在有些地方使用操作符&lt;code&gt;==&lt;/code&gt; 看起来很高雅, 但是仅仅为了检查一个&lt;code&gt;string&lt;/code&gt; 本身的一部分而去新申请一部分资源(生成一个新的&lt;code&gt;string&lt;/code&gt;) 这种做法是错误的. 开发者的初衷, 并不是要是程序看起来高雅. 实际上, 如果我们深入研究&lt;code&gt;std::basic_string&lt;/code&gt; 的官方文档, 就会发现, &lt;code&gt;std::basic_string&lt;/code&gt;提供了一种比较它的子字符串和NTBS的方法: &lt;code&gt;if(code.compare(0, 2, &amp;quot;XX&amp;quot;) == 0)&lt;/code&gt; 这个比较是三方比较, 结果等于0表示相等. 它可以达到目的, 并且不需要生成任何临时的&lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;尽管这个&lt;code&gt;compare()&lt;/code&gt; 使性能达到了很大的优化, 但我并不满足于此. 虽然它做了正确的事情, 但如果我们是第一次遇到他, 很难抓住他的精髓. 如果你可以使用boost库, 我的建议性的解决方案是使用&lt;code&gt;Boost String Algorithms Library&lt;/code&gt; 中的算法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost algorithm=&amp;quot;&amp;quot; string=&amp;quot;&amp;quot; predicate.hpp=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/boost&amp;gt;

bool func(const string&amp;amp;amp; code)
{
if (boost::algorithm::starts_with(code, &amp;quot;XX&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码很好地体现了我想说的意思, 没有任何多余的开销.&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;https://akrzemi1.wordpress.com/2015/04/15/strings-interface/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://akrzemi1.wordpress.com/2015/04/15/strings-interface/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C/C&#43;&#43;返回内部静态成员的陷阱</title>
        <link>https://lxb.wiki/d66df6b4/</link>
        <pubDate>Sun, 02 Apr 2017 23:43:17 +0000</pubDate>
        
        <guid>https://lxb.wiki/d66df6b4/</guid>
        <description>&lt;p&gt;在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多开发人员。如果你的内存是在函数内栈上分配的，那么这个内存会随着函数的返回而被弹栈释放，所以，你一定要返回一块函数外部还有效的内存。&lt;/p&gt;
&lt;p&gt;这是一个让无数人困扰的问题。如果你一不小心，你就很有可能在这个上面犯错误。当然目前有很多解决方法，如果你熟悉一些标准库的话，你可以看到许多各式各样的解决方法。大体来说有下面几种：&lt;/p&gt;
&lt;p&gt;1）在函数内部通过malloc或new在堆上分配内存，然后把这块内存返回（因为在堆上分配的内存是全局可见的）。这样带来的问题就是潜在的内存问题。因为，如果返回出去的内存不释放，那么就是memory Leak。或者是被多次释放，从而造成程序的crash。这两个问题都相当的严重，所以这种设计方法并不推荐。（在一些Windows API中，当你调用了一些API后，你必需也要调用他的某些API来释放这块内存）&lt;/p&gt;
&lt;p&gt;2）让用户传入一块他自己的内存地址，而在函数中把要返回的内存放到这块内存中。这是一个目前普遍使用的方式。很多Windows API函数或是标准C函数都需要你传入一个buffer和这个buffer的长度。这种方式对我们来说应该是屡见不鲜了。这种方式的好处就是由函数外部的程序来维护这块内存，比较简显直观。但问题就是在使用上稍许有些麻烦。不过这种方式把犯错误的机率减到了最低。&lt;/p&gt;
&lt;p&gt;3）第三种方式显得比较另类，他利用了static的特性，static的栈内存一旦分配，那这块内存不会随着函数的返回而释放，而且，它是全局可见的（只要你有这块内存的地址）。所以，有一些函数使用了static的这个特性，即不用使用堆上的内存，也不需要用户传入一个buffer和其长度。从而，使用得自己的函数长得很漂亮，也很容易使用。&lt;/p&gt;
&lt;p&gt;这里，我想对第三个方法进行一些讨论。使用static内存这个方法看似不错，但是它有让你想象不到的陷阱。让我们来用一个实际发生的案例来举一个例子吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有过socket编程经验的人一定知道一个函数叫：inet_ntoa，这个函数主要的功能是把一个数字型的IP地址转成字符串，这个函数的定义是这样的（注意它的返回值）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char *inet_ntoa(struct in_addr in);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显然，这个函数不会分配堆上的内存，而他又没有让你传一下字符串的buffer进入，那么他一定使用“返回static char[]”这种方法。在我们继续我们的讨论之前，让我们先了解一下IP地址相关的知识，下面是inet_ntoa这个函数需要传入的参数：（也许你会很奇怪，只有一个member的struct还要放在struct中干什么？这应该是为了程序日后的扩展性的考虑）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;in_addr&lt;/span&gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; s_addr;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于IPV4来说，一个IP地址由四个8位的bit组成，其放在&lt;code&gt;s_addr&lt;/code&gt;中，高位在后，这是为了方便网络传输。如果你得到的一个&lt;code&gt;s_addr&lt;/code&gt;的整型值是：3776385196。那么，打开你的Windows计算器吧，看看它的二进制是什么？让我们从右到左，8位为一组（如下所示）。&lt;/p&gt;
&lt;p&gt;11100001   00010111    00010000    10101100&lt;/p&gt;
&lt;p&gt;再把每一组转成十进制，于是我们就得到：225   23   16   172， 于是IP地址就是 172.16.23.225。&lt;/p&gt;
&lt;p&gt;好了，言归正传。我们有这样一个程序，想记录网络包的源地址和目地地址，于是，我们有如下的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;in_addr&lt;/span&gt; src, des;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;........  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;........  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fprintf(fp, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;源IP地址&amp;lt;%s&amp;gt;/t目的IP地址&amp;lt;%s&amp;gt;/n&amp;#34;&lt;/span&gt;, inet_ntoa(src),   inet_ntoa(des));  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会发生什么样的结果呢？你会发现记录到文件中的源IP地址和目的IP地址完全一样。这是什么问题呢？于是你开始调试你的程序，你发现src.s_addr和des.s_addr根本不一样（如下所示）。可为什么输出到文件的源和目的都是一样的？难道说是inet_ntoa的bug？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;src.s_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3776385196&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;//对应于172.16.23.225  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;des.s_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1678184620&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;//对应于172.16.7.100  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原因就是&lt;code&gt;inet_ntoa()&lt;/code&gt;“自作聪明”地把内部的static char[]返回了，而我们的程序正是踩中了这个陷阱。让我们来分析一下fprintf代码。在我们fprintf时，编译器先计算&lt;code&gt;inet_ntoa(des)&lt;/code&gt;，于是其返回一个字符串的地址，然后程序再去求&lt;code&gt;inet_ntoa(src)&lt;/code&gt;表达式，又得到一个字符串的地址。这两个字符串的地址都是&lt;code&gt;inet_ntoa()&lt;/code&gt;中那个&lt;code&gt;static char[]&lt;/code&gt;，显然是同一个地址，而第二次求src的IP时，这个值的des的IP地址内容必将被src的IP覆盖。所以，这两个表达式的字符串内存都是一样的了，此时，程序会调用fprintf把这两个字符串（其实是一个）输出到文件。所以，得到相同的结果也就不奇怪。&lt;/p&gt;
&lt;p&gt;仔细看一下inet_ntoa的man，我们可以看到这句话：&lt;code&gt;The string is returned in a statically allocated buffer,  which  subsequent calls will overwrite. &lt;/code&gt;证实了我们的分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们大家都扪心自问一下，我们在写程序的过程当中是否使用了这种方法？这是一个比较危险，容易出错的方法。这种陷阱让人防不胜防。想想，如果你有这样的程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( strcmp( inet_ntoa(ip1), inet_ntoa(ip2) )&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; ) {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;. &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;.  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;本想判断一下两个IP地址是否一样，却不料掉入了那个陷阱——让这个条件表达式永真。&lt;/p&gt;
&lt;p&gt;这个事情告诉我们下面几个道理：&lt;/p&gt;
&lt;p&gt;1）慎用这种方式的设计。返回函数内部的static内存有很大的陷阱。&lt;/p&gt;
&lt;p&gt;2）如果一定要使用这种方式的话。你就必须严肃地告诉所有使用这个函数的人，千万不要在一个表达式中多次使用这个函数。而且，还要告诉他们，不copy函数返回的内存的内容，而只是保存返回的内存地址或是引用是没用的。不然的话，后果概不负责。&lt;/p&gt;
&lt;p&gt;3）C/C++是很危险的世界，如果你不清楚他的话。还是回火星去吧。&lt;/p&gt;
&lt;p&gt;附：看过Efftive C++的朋友一定知道其中有一个条款（item 23）：不要试图返回对象的引用。这个条款中也对是否返回函数内部的static变量进行了讨论。结果也是持否定态度的。&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://www.tuicool.com/articles/JNZZfiZ&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.tuicool.com/articles/JNZZfiZ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Custom comparison, equality and equivalence with the STL</title>
        <link>https://lxb.wiki/55f488ad/</link>
        <pubDate>Wed, 29 Mar 2017 19:01:51 +0000</pubDate>
        
        <guid>https://lxb.wiki/55f488ad/</guid>
        <description>&lt;p&gt;从一段代码引用开始:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;amp;lt; std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt; &amp;amp;gt; v1 = ... // v1 is filled with data
std::vector&amp;amp;lt; std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt; &amp;amp;gt; v2 = ... // v2 is filled with data
std::vector&amp;amp;lt; std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt; &amp;amp;gt; results;&amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;

std::sort(v1.begin(), v1.end());
std::sort(v2.begin(), v2.end());

std::set_difference(v1.begin(), v1.end(),
v2.begin(), v2.end(),
std::back_inserter(result),
compareFirst);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在两个排好序的vector v1 和 v2上调用&lt;code&gt;std::set_difference&lt;/code&gt;. &lt;code&gt;std::set_difference&lt;/code&gt; 把结果写入 &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;std::back_inserter&lt;/code&gt; 确保输出的结果从&lt;code&gt;result&lt;/code&gt; 的后面添入. 自定义的&lt;code&gt;compareFirst&lt;/code&gt; 作为比较函数提供给&lt;code&gt;std::set_difference&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认地, &lt;code&gt;std::set_difference&lt;/code&gt; 通过 &lt;code&gt;std::pair&lt;/code&gt; 默认的比较函数来比较里面的元素(比较pair的first和second), 我们自定义了&lt;code&gt;compareFirst&lt;/code&gt;, 希望只比较pair的first. &lt;code&gt;compareFirst&lt;/code&gt;不是STL的函数, 需要我们自己实现.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::set_difference&lt;/code&gt; 使用的前提是input已经排好序, 倘若我们自定义比较函数C, 而通过C我们能把元素排好序, 那么我们使用这个C代替sort的默认排序也是可以的.&lt;/p&gt;
&lt;p&gt;在此例中, 我们使用&lt;code&gt;std::set_difference&lt;/code&gt; 只对pair的first进行排序, 尽管它们已经通过&amp;quot;first + second&amp;quot;的方式排序完了.&lt;/p&gt;
&lt;p&gt;下面来实现&lt;code&gt;compareFirst&lt;/code&gt;. 初版:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool compareFirst(const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp;amp; p1, const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp;amp; p2)
{
return p1.first == p2.first; // not final code, bug lurking here!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上, 上面的代码不会得到我们预期的结果. 为什么? 毕竟&lt;code&gt;std::set_difference&lt;/code&gt; 会检查元素跟另一个容器的元素是否相等(equal), 不是吗?&amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;&lt;/p&gt;
&lt;p&gt;为了理解上面的内容, 我们把STL大概地分为两类: 操作排序元素的 和操作乱序元素的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Comparing elements&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++中描述&amp;quot;a is the same as b&amp;quot; 有两种方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- the natural way: a == b. This is called equality. Equality is based on operator==.
- the other way: a is not smaller than b and b is not smaller than a, so !(a&amp;lt;b) &amp;amp;&amp;amp;=&amp;quot;&amp;quot; !(b&amp;lt;a).=&amp;quot;&amp;quot; this=&amp;quot;&amp;quot; is=&amp;quot;&amp;quot; called=&amp;quot;&amp;quot; equivalence.=&amp;quot;&amp;quot; equivalence=&amp;quot;&amp;quot; based=&amp;quot;&amp;quot; on=&amp;quot;&amp;quot; operator&amp;lt;.=&amp;quot;&amp;quot; ```=&amp;quot;&amp;quot; 这两个问题涉及到另一个名词:=&amp;quot;&amp;quot; `equivalence`=&amp;quot;&amp;quot; &amp;lt;u=&amp;quot;&amp;quot;&amp;gt;How is it different from equality?&amp;lt;/b)&amp;gt;

对于基本类型如int, 甚至实践中大多数类型, `equivalence` 和`quality` 是相通的. 但是正如*Scott Meyers* 在&amp;amp;lt;&amp;amp;lt; Effective STL&amp;amp;gt;&amp;amp;gt;  一书条目19中指出的, 对于有一些类型, 即使&amp;quot;并非罕见&amp;quot;, `equivalence` 和 `equality` 是不同的, 如 大小写不敏感的string类型.

&amp;lt;u&amp;gt;Why such a far-fetched way to express a simple thing?&amp;lt;/u&amp;gt;

当我们使用算法对容器内元素进行排序时, 很容易理解必须有独一无二的排序方法(如有多种排序方法, 会很笨重, 并可能产生不一致的结果). 所以对于一个特定的容器, 排序时, &amp;quot;==&amp;quot; 和&amp;quot;&amp;amp;lt;&amp;quot; 只能选一个. 

对于STL中排序的部分, 我们别无选择: 排序时必须使用&amp;quot;&amp;amp;lt;&amp;quot;;
而乱序部分, 则没有这个约束, 我们可以使用&amp;quot;==&amp;quot;.

**Implementing the comparator**

STL的乱序部分使用&amp;quot;==&amp;quot;, 而排序部分使用&amp;quot;&amp;amp;lt;&amp;quot;. 我们自定义的比较函数也必须遵循这种逻辑. 

现在我们可以理解怎么自定义实现`std::set_difference` 的比较函数`compareFirst` 了.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;bool compareFirst(const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp; p1, const std::pair&amp;lt;int, std::string=&amp;quot;&amp;quot;&amp;gt;&amp;amp; p2) { return p1.first &amp;lt; p2.first; // correct, STL-compatible code. } ```&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/&lt;/a&gt; &amp;lt;/int,&amp;gt;&amp;lt;/int,&amp;gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】How to (std::)find something efficiently with the STL</title>
        <link>https://lxb.wiki/56dc57bb/</link>
        <pubDate>Thu, 16 Mar 2017 22:07:59 +0000</pubDate>
        
        <guid>https://lxb.wiki/56dc57bb/</guid>
        <description>&lt;p&gt;本文分3部分: 1. 怎么使用STL进行高效的查找: 借用传统STL算法对元素进行范围搜索 2. 搜索STL容器: 当你有直接读取STL容器里元素的权限时, 怎么进行高效准确的搜索(与简单的范围搜索相比较) 3. STL搜索算法的秘密: 向公众展示不为人知的算法, 这些算法在已经学习过的人眼里确实是很有用的&lt;/p&gt;
&lt;p&gt;STL根据查看方式的不同, 一共分为两种: 排序的和不排序的. * 排序集合的遍历, 通常需要对数时长, 而乱序集合的遍历, 需要线性时长 * 排序容器中比较元素大小的函数根据equivalence(comparing with &amp;lt;), 而乱序容器中的函数根据equality(comparing with ==).&lt;/p&gt;
&lt;p&gt;本文将展示对于在一个范围内搜索一个给定的值, C++怎么样去阐述下面3个问题: * 它存在否 * 它在哪 * 它应该在什么位置(排序容器)&lt;/p&gt;
&lt;h3 id=&#34;is-it-there&#34;&gt;Is it there?&lt;/h3&gt;
&lt;h4 id=&#34;乱序容器的元素&#34;&gt;乱序容器的元素&lt;/h4&gt;
&lt;p&gt;这个问题可以用std::find来表达(需要和与范围的终点值的比较相结合):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v = ... // v filled with values
if (std::find(v.begin(), v.end(), 42) != v.end())
{
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Is it there&amp;quot;这个问题也可以用std::count来表达:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v = ... // v filled with values
if (std::count(v.begin(), v.end(), 42))
{
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::count()的返回值会被隐式地转换成if条件里的bool值: 如果该范围里有至少一个值为42, 则返回true.&lt;/p&gt;
&lt;p&gt;与std::find相比, std::count的优劣: 优势:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::count避免了与范围的end值相比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;弊端:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::count遍历整个集合, 而std::find在第一个与要查找的值相等的位置停下&lt;/li&gt;
&lt;li&gt;可以证明, 对于&amp;quot;想要查找某个值&amp;quot;这件事, std::find 表达得更明确 基于以上, std::find用得更多.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; 若要确认某个值存在而非是与要搜索的值相等, 请使用&lt;code&gt;std::count_if, std::find_if, std::find_if_not&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;排序容器的元素&#34;&gt;排序容器的元素&lt;/h4&gt;
&lt;p&gt;使用的算法是&lt;code&gt;std::binary_search&lt;/code&gt;, 此函数返回一个bool值, 此bool值表示在集合中是否存在与搜索的值相等的元素.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::set&amp;lt;int&amp;gt; numbers = // sorted elements
bool is42InThere = std::binary_search(numbers.begin(), numbers.end(), 42);
```&amp;lt;/int&amp;gt;

### Where is it?
(当确定了要搜索的值存在后,) 我们想更进一步, 得到指向那个元素的迭代器.

#### 乱序容器的元素

使用std::find. 返回指向第一个与搜索的值相等的元素的迭代器, 如果找不到, 则返回集合的终点.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;std::vector numbers = &amp;hellip; auto searchResult = std::find(numbers.begin(), numbers.end(), 42);&lt;/p&gt;
&lt;p&gt;if (searchResult != numbers.end()) { &amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 排序容器的元素

对于排序集合, STL并没有像std::find一样直接的算法. std::find并不是为排序容器设计的, 因为它依据的是&amp;quot;==&amp;quot;而不是&amp;quot;&amp;amp;lt;&amp;quot;, 消耗的时间为线性时长而不是对数时长.
对于一个给定的容器, 如果容器内元素的&amp;quot;equality&amp;quot;和&amp;quot;equivalence&amp;quot;是相同的, 且你能接受消耗的线性时长, 那么std::find会为你返回正确的结果, 你也能从它简单直接的接口中获益. **但是,** 不能忘记, std::find并不是为排序容器设计的.

这里推荐使用`std::equal_range`. (并非`std::lower_bound`)
函数原型: 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;template&amp;lt; class ForwardIt, class T &amp;gt; std::pair&amp;lt;forwardit,forwardit&amp;gt; equal_range( ForwardIt first, ForwardIt last, const T&amp;amp; value );&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`std::equal_range` 返回与搜索值相等的元素的范围, 这个范围用一对集合内的迭代器表示. 这两个迭代器分别指向 与搜索值相等的范围里第一个元素和最后一个元素的下一个位置.&amp;lt;/forwardit,forwardit&amp;gt;

然而, 它的接口有些笨重:
例A:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&lt;/p&gt;
&lt;p&gt;// equal_range, attempt 1: natively clumsy std::pair&amp;lt;std::vector::iterator, std::vector::iterator&amp;gt; range1 = equal_range(v.begin(), v.end(), 3); std::for_each(range1.first, range1.second, doSomething);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用一个`typedef` 或者`using`让它更简洁:
例B:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&amp;lt;/std::vector&lt;/p&gt;
&lt;p&gt;using IteratorPair = std::pair&amp;lt;std::vector::iterator, std::vector::iterator&amp;gt;;&amp;lt;/std::vector&lt;/p&gt;
&lt;p&gt;// equal_range, attempt 2: with the classical typedef IteratorPair range2 = equal_range(v.begin(), v.end(), 3); std::for_each(range2.first, range2.second, doSomething);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例B确实简洁了很多, 但是仍有一个根本问题: 没有考虑 抽象等级.
尽管返回的是一个范围, 但这对迭代器强迫我们在操作返回的范围时必须按照&amp;quot;第一&amp;quot;&amp;quot;第二&amp;quot;这种方式来写代码. 范围就应该用&amp;quot;首&amp;quot;&amp;quot;尾&amp;quot;这种方式来表达. 这不仅给我们在其他地方使用这个返回值时造成很大的麻烦, 而且使代码很别扭.

为了解决这个问题, 我么可以把`std::equal_range` 返回的迭代器对封装进一个有&amp;quot;范围&amp;quot;这种语义的`object`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;template&lt;/p&gt;
&lt;p&gt;class Range&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;public:&lt;/p&gt;
&lt;p&gt;Range(std::pair range)&lt;/p&gt;
&lt;p&gt;m_begin(range.first), m_end(range.second) {} typename Container::iterator begin() { return m_begin; } typename Container::iterator end() { return m_end; }&lt;/p&gt;
&lt;p&gt;private: typename Container::iterator m_begin; typename Container::iterator m_end; };&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意: 尽管`std::equal_range` 返回的结果是一个&amp;quot;范围&amp;quot;, 但是`std::begin` 和 `std::end` 不能用在这个结果上. 而上面的封装解决了这个问题.
可以像下面这样使用:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;std::vector v = {3, 7, 3, 11, 3, 3, 2}; sort(v.begin(), v.end());&lt;/p&gt;
&lt;p&gt;// equal_range, attempt 3: natural al last Range&lt;a class=&#34;link&#34; href=&#34;std::vector%5c&#34; &gt;std::vector\&lt;/a&gt; range3 = equal_range(v.begin(), v.end(), 3); std::for_each(range3.begin(), range3.end(), doSomething);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不管你使用上面的哪种方式, `std::equal_range` 都会返回一个范围, 要确定它是否为空, 可以通过检查那两个迭代器(是否相等)或者使用`std::distance` 检查它的大小. &amp;lt;/std::vector&amp;lt;int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;bool noElementFound = range3.begin() == range3.end(); size_t numberOfElementFound = std::distance(range3.begin(), range3.end()) ```&lt;/p&gt;
&lt;h3 id=&#34;where-should-it-be&#34;&gt;Where should it be?&lt;/h3&gt;
&lt;p&gt;这个问题仅仅针对排序的范围, 因为对于乱序的范围, 某个元素可能会存在任何位置.&lt;/p&gt;
&lt;p&gt;对于排序的范围, 这个问题可以简化为: 如果它存在, 那么它在哪儿? 如果它不存在, 那么它应该在哪儿?&lt;/p&gt;
&lt;p&gt;这个问题可以用算法&lt;code&gt;std::lower_bound&lt;/code&gt; 和&lt;code&gt;std::upper_bound&lt;/code&gt; 来解释.&lt;/p&gt;
&lt;p&gt;当你理解了&lt;code&gt;std::equal_range&lt;/code&gt; 后, 上面这句话就很容易理解了: &lt;code&gt;std::lower_bound&lt;/code&gt; 和&lt;code&gt;std::upper_bound&lt;/code&gt; 都会返回 &lt;code&gt;std::equal_range&lt;/code&gt; 返回的那个迭代器对的第一个和第二个迭代器.&lt;/p&gt;
&lt;p&gt;要插入某个值x, 使用&lt;code&gt;std::lower_bound&lt;/code&gt; 得到指向 在范围里与x相等的元素之前的位置的迭代器, 使用&lt;code&gt;std::upper_bound&lt;/code&gt; 得到指向 在范围里与x相等的元素之后的位置的迭代器.&lt;/p&gt;
&lt;p&gt;注意: 如果仅仅是搜索某个元素, 永远不要使用&lt;code&gt;std::lower_bound&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;std::find&lt;/code&gt; 相反, 你不能根据 判断&lt;code&gt;std::lower_bound&lt;/code&gt; 返回的迭代器是否与终点的迭代器相等 来判断要搜索的值是否存在于这个集合. 事实上, 如果这个值在集合里不存在, 则&lt;code&gt;std::lower_bound&lt;/code&gt; 返回它应该在的位置, 而不是终点的迭代器. 所以, 你不仅需要确认返回的迭代器不是终点的迭代器, 还要确认它指向的元素跟要搜索的值是相等的.&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;Question to express in C++&lt;/p&gt;
&lt;p&gt;NOT SORTED&lt;/p&gt;
&lt;p&gt;SORTED&lt;/p&gt;
&lt;p&gt;Is it there?&lt;/p&gt;
&lt;p&gt;std::find != end&lt;/p&gt;
&lt;p&gt;std::binary_search&lt;/p&gt;
&lt;p&gt;Where is it?&lt;/p&gt;
&lt;p&gt;std::find&lt;/p&gt;
&lt;p&gt;std::equal_range&lt;/p&gt;
&lt;p&gt;Where should it be?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;std::lower_bound / std::upper_bound&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a class=&#34;link&#34; href=&#34;http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;amp;utm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm&lt;/a&gt;_medium=toutiao.io&amp;amp;utm_source=toutiao.io&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【译】Effective STL 9</title>
        <link>https://lxb.wiki/978f4b48/</link>
        <pubDate>Thu, 09 Mar 2017 21:09:09 +0000</pubDate>
        
        <guid>https://lxb.wiki/978f4b48/</guid>
        <description>&lt;p&gt;条款9：在删除选项中仔细选择 假定你有一个标准STL容器，c，容纳int， &lt;code&gt;Container&amp;lt;int&amp;gt; c;&lt;/code&gt; 而你想把c中所有值为&lt;code&gt;1963&lt;/code&gt;的对象都去掉。令人吃惊的是，完成这项任务的方法因不同的容 器类型而不同：没有一种方法是通用的。&lt;/p&gt;
&lt;p&gt;如果你有一个连续内存容器（vector、deque或string——参见条款1），最好的方法是erase-remove惯用法（参见条款32）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.erase(remove(c.begin(), c.end(), &lt;span style=&#34;color:#ae81ff&#34;&gt;1963&lt;/span&gt;),       &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是vector、string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;c.end());                               &lt;span style=&#34;color:#75715e&#34;&gt;// 或deque时，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// erase-remove惯用法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 是去除特定值的元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这方法也适合于list，但是，正如条款44解释的，list的成员函数remove更高效：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.remove(&lt;span style=&#34;color:#ae81ff&#34;&gt;1963&lt;/span&gt;);     &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是list时，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// remove成员函数是去除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 特定值的元素的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当c是标准关联容器（即，set、multiset、map或multimap）时，使用任何叫做remove的东 西都是完全错误的。这样的容器没有叫做remove的成员函数，而且使用remove算法可能覆 盖容器值（参见条款32），潜在地破坏容器。（关于这样的破坏的细节，参考条款22，那 个条款也解释了为什么试图在map和multimap上使用remove肯定不能编译，而试图在set和 multiset上使用可能不能编译。）&lt;/p&gt;
&lt;p&gt;不，对于关联容器，解决问题的适当方法是调用erase：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.erase(&lt;span style=&#34;color:#ae81ff&#34;&gt;1963&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是标准关联容器时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// erase成员函数是去除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 特定值的元素的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这不仅是正确的，而且很高效，只花费对数时间。（序列容器的基于删除的技术需要线性 时间。）并且，关联容器的erase成员函数有基于等价而不是相等的优势，条款19解释了这 一区别的重要性。&lt;/p&gt;
&lt;p&gt;让我们现在稍微修改一下这个问题。不是从c中除去每个有特定值的物体，让我们消除下面 判断式（参见条款39）返回真的每个对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;badValue&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x);   &lt;span style=&#34;color:#75715e&#34;&gt;// 返回x是否是“bad”
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对于序列容器（&lt;/span&gt;vector&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;string&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;deque&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;和&lt;/span&gt;list&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;），我们要做的只是把每个&lt;/span&gt;remove()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;替换为&lt;/span&gt;remove_if()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，然后就完成了：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.erase(remove_if(c.begin(), c.end(), badValue),    &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是vector、string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;c.end());           &lt;span style=&#34;color:#75715e&#34;&gt;// 或deque时这是去掉
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// badValue返回真
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的对象的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;c.remove_if(badValue);              &lt;span style=&#34;color:#75715e&#34;&gt;// 当c是list时这是去掉
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// badValue返回真
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的对象的最佳方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于标准关联容器，它不是很直截了当。有两种方法处理该问题，一个更容易编码，另一 个更高效。“更容易但效率较低”的解决方案用&lt;code&gt;remove_copy_if()&lt;/code&gt;把我们需要的值拷贝到一 个新容器中，然后把原容器的内容和新的交换：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;              &lt;span style=&#34;color:#75715e&#34;&gt;// c现在是一种
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;...                                 &lt;span style=&#34;color:#75715e&#34;&gt;// 标准关联容器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; goodValues;         &lt;span style=&#34;color:#75715e&#34;&gt;// 用于容纳不删除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的值的临时容器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;remove_copy_if(c.begin(), c.end(),          &lt;span style=&#34;color:#75715e&#34;&gt;// 从c拷贝不删除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;inserter(goodValues,        &lt;span style=&#34;color:#75715e&#34;&gt;// 的值到
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;goodValues.end()),          &lt;span style=&#34;color:#75715e&#34;&gt;// goodValues
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;badValue);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.swap(goodValues);             &lt;span style=&#34;color:#75715e&#34;&gt;// 交换c和goodValues
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 的内容
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种方法的缺点是它拷贝了所有不删除的元素，而这样的拷贝开销可能大于我们期望的底线。&lt;/p&gt;
&lt;p&gt;我们可以通过直接从原容器删除元素来避开拷贝的开销。不过，因为关联容器没有提供类似&lt;code&gt;remove_if()&lt;/code&gt;的成员函数，所以我们必须写一个循环来迭代c中的元素，和原来一样删除元素.&lt;/p&gt;
&lt;p&gt;看起来，这个任务很简单，而且实际上，代码也很简单。不幸的是，那些正确工作的代码 很少是跃出脑海的代码。例如，这是很多程序员首先想到的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();   &lt;span style=&#34;color:#75715e&#34;&gt;// 清晰，直截了当
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; c.end();                                &lt;span style=&#34;color:#75715e&#34;&gt;// 而漏洞百出的用于
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {                                      &lt;span style=&#34;color:#75715e&#34;&gt;// 删除c中badValue返回真
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)) c.erase(i);                   &lt;span style=&#34;color:#75715e&#34;&gt;// 的每个元素的代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}                                                   &lt;span style=&#34;color:#75715e&#34;&gt;// 不要这么做！&amp;lt;/int&amp;gt;&amp;lt;/int&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;唉，这有未定义的行为。当容器的一个元素被删时，指向那个元素的所有迭代器都失效了 。当c.erase(i)返回时，i已经失效。那对于这个循环是个坏消息，因为在erase()返回后， i通过for循环的++i部分自增。&lt;/p&gt;
&lt;p&gt;为了避免这个问题，我们必须保证在调用erase之前就得到了c中下一元素的迭代器。最容 易的方法是当我们调用时在i上使用后置递增：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();   &lt;span style=&#34;color:#75715e&#34;&gt;// for循环的第三部分
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; c.end();                                   &lt;span style=&#34;color:#75715e&#34;&gt;// 是空的；i现在在下面
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*nothing*/&lt;/span&gt; ){                                 &lt;span style=&#34;color:#75715e&#34;&gt;// 自增
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)) c.erase(i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;);     &lt;span style=&#34;color:#75715e&#34;&gt;// 对于坏的值，把当前的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i;                           &lt;span style=&#34;color:#75715e&#34;&gt;// i传给erase，然后
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}                                       &lt;span style=&#34;color:#75715e&#34;&gt;// 作为副作用增加i；
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 对于好的值，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 只增加i
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种调用erase()的解决方法可以工作，因为表达式i++的值是i的旧值，但作为副作用，i增 加了。因此，我们把i的旧值（没增加的）传给erase，但在erase开始执行前i已经自增了 。那正好是我们想要的。正如我所说的，代码很简单，只不过不是大多数程序员在第一次 尝试时想到的。&lt;/p&gt;
&lt;p&gt;现在让我们进一步修改该问题。不仅删除badValue返回真的每个元素，而且每当一个元素 被删掉时，我们也想把一条消息写到日志文件中。&lt;/p&gt;
&lt;p&gt;对于关联容器，这说多容易就有多容易，因为只需要对我们刚才开发的循环做一个微不足 道的修改就行了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ofstream logFile;                   &lt;span style=&#34;color:#75715e&#34;&gt;// 要写入的日志文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (AssocContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();   &lt;span style=&#34;color:#75715e&#34;&gt;// 循环条件和前面一样
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;c.end();){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logFile &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Erasing &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 写日志文件 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        c.erase(i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;);           &lt;span style=&#34;color:#75715e&#34;&gt;// 删除元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在是vector、string和deque给我们带来麻烦。我们不能再使用&lt;code&gt;erase-remove&lt;/code&gt;惯用法，因为没有办法让erase()或remove()写日志文件。而且，我们不能使用刚刚为关联容器开发的循环, 因为它为vector、string和deque产生未定义的行为！要记得对于那样的容器，调用erase不仅使所有指向被删元素的迭代器失效，也使被删元素之后的所有迭代器失效。在我们的情况里，那包括所有i之后的迭代器。我们写i++，++i或你能想起的其它任何东西都没有用，因为没有能导致迭代器有效的。&lt;/p&gt;
&lt;p&gt;我们必须对vector、string和deque采用不同的战略。特别是，我们必须利用erase()的返回值。那个返回值正是我们需要的：一旦删除完成，它就是指向紧接在被删元素之后的元素的有效迭代器。换句话说，我们这么写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (SeqContainer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.begin();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; c.end();){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (badValue(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i)){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logFile &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Erasing &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.erase(i);         &lt;span style=&#34;color:#75715e&#34;&gt;// 通过把erase的返回值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }                   &lt;span style=&#34;color:#75715e&#34;&gt;// 赋给i来保持i有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这可以很好地工作，但只用于标准序列容器。由于论证一个可能的问题（条款5做了），标准关联容器的erase()的返回类型是void[1]。对于那些容器，你必须使用“后置递增你要传给erase()的迭代器”技术。（顺便说说，在为序列容器编码和为关联容器编码之间的这种差别是为什么写容器无关代码一般缺乏考虑的一个例子——参见条款2。)&lt;/p&gt;
&lt;p&gt;为了避免你奇怪list的适当方法是什么，事实表明对于迭代和删除，你可以像vector/str ing/deque一样或像关联容器一样对待list；两种方法都可以为list工作。&lt;/p&gt;
&lt;p&gt;如果我们观察在本条款中提到的所有东西，我们得出下列结论：&lt;/p&gt;
&lt;p&gt;去除一个容器中有特定值的所有对象： 如果容器是vector、string或deque，使用erase-remove惯用法。&lt;/p&gt;
&lt;p&gt;如果容器是list，使用list::remove。&lt;/p&gt;
&lt;p&gt;如果容器是标准关联容器，使用它的erase成员函数。&lt;/p&gt;
&lt;p&gt;去除一个容器中满足一个特定判定式的所有对象： 如果容器是vector、string或deque，使用&lt;code&gt;erase-remove_if&lt;/code&gt;惯用法。&lt;/p&gt;
&lt;p&gt;如果容器是list，使用list::remove_if。&lt;/p&gt;
&lt;p&gt;如果容器是标准关联容器，使用&lt;code&gt;remove_copy_if&lt;/code&gt;和&lt;code&gt;swap&lt;/code&gt;，或写一个循环来遍历容器元素， 当你把迭代器传给erase时记得后置递增它。&lt;/p&gt;
&lt;p&gt;在循环内做某些事情（除了删除对象之外）： 如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。 如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。&lt;/p&gt;
&lt;p&gt;如你所见，与仅仅调用erase相比，有效地删除容器元素有更多的东西。解决问题的最好方法取决于你是怎样鉴别出哪个对象是要被去掉的，储存它们的容器的类型，和当你删除它们的时候你还想要做什么（如果有的话）。只要你小心而且注意了本条款的建议，你将毫不费力。如果你不小心，你将冒着产生不必要低效的代码或未定义行为的危险。&lt;/p&gt;
&lt;h2 id=&#34;------------------------------------------------------------------------------&#34;&gt;------------------------------------------------------------------------------&lt;/h2&gt;
&lt;p&gt;[1] 这仅对带有迭代器实参的erase()形式是正确的。关联容器也提供一个带有一个值的实参 的erase()形式，而那种形式返回被删掉的元素个数。但这里，我们只关心通过迭代器删除东 西。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_3%2FC%2Fnetres%2Feffstl%2Ffile10.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>STL 的 erase( ) 陷阱-迭代器失效总结</title>
        <link>https://lxb.wiki/b12cd95a/</link>
        <pubDate>Thu, 02 Mar 2017 23:10:19 +0000</pubDate>
        
        <guid>https://lxb.wiki/b12cd95a/</guid>
        <description>&lt;p&gt;STL中的容器按存储方式分为两类，一类是按以数组形式存储的容器（如：vector 、deque)；另一类是以不连续的节点形式存储的容器（如：list、set、map）。在使用erase方法来删除元素时，需要注意一些问题。&lt;/p&gt;
&lt;h4 id=&#34;1listsetmap容器&#34;&gt;&lt;strong&gt;1.list,set,map容器&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在使用 list、set 或 map遍历删除某些元素时可以这样使用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;del&gt;1.1 正确写法 1&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::list&amp;lt;int&amp;gt; list;
std::list&amp;lt;int&amp;gt;::iterator it_list;
for (it_list = list.begin(); it_list != list.end();)
{
if (willDelete(*it_list))
{
it_list = list.erase(it_list);
}
else
{
++it_list;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 以上方法仅适用于standard sequence container, 因为对于standard associative container, erase()的返回类型为void. (查阅Effective STL Item 9)以下为原文:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This works wonderfully, but only for the standard sequence containers. Due to reasoning one might question, erase()&#39;s return type for the standard associative containers is void. For those containers, you have to use the postincrement-the-iterator-you-pass-to-erase technique.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1.2 正确写法2&lt;/strong&gt; 查阅原版Effctive STL Item 9, 证实, 下面这种写法不能用于标准序列容器, 而适用于标准关联容器, 而List也可以使用这种方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::list&amp;lt;int&amp;gt; list;
std::list&amp;lt;int&amp;gt;::iterator it_list;
for (it_list = list.begin(); it_list != list.end();)
{
if (willDelete(*it_list))
{
list.erase(it_list++); // 必须使用后缀自增, 不能使用前缀自增
}
else
{
++it_list;
}
}
```&amp;lt;/int&amp;gt;&amp;lt;/int&amp;gt;

**1.3 错误写法 1**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::list&amp;lt; int&amp;gt; List; std::list&amp;lt; int&amp;gt;::iterator itList; for( itList = List.begin(); itList != List.end(); itList++) { if( WillDelete( *itList) ) { List.erase( itList); } }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**1.4 错误写法 2**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::list&amp;lt; int&amp;gt; List; std::list&amp;lt; int&amp;gt;::iterator itList; for( itList = List.begin(); itList != List.end(); ) { if( WillDelete( *itList) ) { itList = List.erase( ++itList); } else itList++; }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**1.5 分析**

正确方法1: 通过erase()方法的返回值来获取下一个元素的位置;
正确方法2: 在调用erase()方法之前先使用&amp;quot;++&amp;quot; 来获取下一个元素的位置;
错误使用方法1: 在调用erase()方法之后使用&amp;quot;++&amp;quot; 来获取下一个元素的位置, 由于在调用erase()方法之后, 该元素的位置已经被删除, 如果再根据这个旧的位置来获取下一个位置, 则会出现异常;
错误使用方法2: 同上

####**2. vector,deque 容器**
在使用 vector、deque遍历删除元素时，也可以通过erase的返回值来获取下一个元素的位置：

**2.1 正确写法:**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std::vector vec; std::vector::iterator it_vec; for (it_vec = vec.begin(); it_vec != vec.end();) { if (willDelete(*it_vec)) { it_vec = vec.erase(it_vec); } else { ++it_vec; } } ```&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vector, deque 不能像上面的&amp;quot;正确方法2&amp;quot; 的办法来遍历删除. 原因请参考Effective STL条款9。摘录到下面： 1) 对于关联容器(如map, set, multimap, multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (iter = cont.begin(); it != cont.end();)
{
(*iter)-&amp;amp;gt;doSomething();
if (shouldDelete(*iter))
cont.erase(iter++);
else
++iter;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为iter传给erase方法的是一个副本，iter++会指向下一个元素。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;对于序列式容器(如vector, deque)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor, deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase()方法可以返回下一个有效的iterator。&lt;/p&gt;
&lt;p&gt;for (iter = cont.begin(); iter != cont.end();)
{
(*it)-&amp;gt;doSomething();
if (shouldDelete(*iter))
iter = cont.erase(iter);
else
++iter;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3)对于list来说，它使用了不连续分配的内存，并且它的erase()方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。&lt;/p&gt;
&lt;h4 id=&#34;3-其他&#34;&gt;&lt;strong&gt;3. 其他&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt; 键和值相等。 键唯一。 元素默认按升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt; 键唯一。 元素默认按键的升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://mp.weixin.qq.com/s/qonNrKKZLladvIwvurQCTA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作成参考地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>用GDB调试程序</title>
        <link>https://lxb.wiki/13b68d49/</link>
        <pubDate>Thu, 23 Feb 2017 19:12:02 +0000</pubDate>
        
        <guid>https://lxb.wiki/13b68d49/</guid>
        <description>&lt;h3 id=&#34;使用gdb&#34;&gt;使用GDB&lt;/h3&gt;
&lt;p&gt;一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$gcc -g -Wall hello.c -o hello
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$g++ -g -Wall hello.cpp -o hello
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 启动GDB的方法有以下几种： &lt;code&gt;gdb &amp;lt;program&amp;gt;&lt;/code&gt; program也就是你的执行文件，一般在当前目录下。 &lt;code&gt;gdb &amp;lt;program&amp;gt; core&lt;/code&gt; 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。 &lt;code&gt;gdb &amp;lt;program&amp;gt; &amp;lt;pid&amp;gt;&lt;/code&gt; 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 以上三种都是进入gdb环境和加载被调试程序同时进行的。也可以先进入gdb环境，在加载被调试程序，方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;*在终端输入：gdb
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;*在gdb环境中：file &amp;lt;program&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;这两步等价于：gdb &amp;lt;program&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下面只例举一些比较常用的参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-symbols &amp;lt;file&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-s &amp;lt;file&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;从指定文件中读取符号表。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-se file
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;从指定文件中读取符号表信息，并把他用在可执行文件中。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-core &amp;lt;file&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-c &amp;lt;file&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;调试时core dump的core文件。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-directory &amp;lt;directory&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-d &amp;lt;directory&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;```&lt;/span&gt;&amp;lt;/directory&amp;gt;&amp;lt;/directory&amp;gt;&amp;lt;/file&amp;gt;&amp;lt;/file&amp;gt;&amp;lt;/file&amp;gt;&amp;lt;/file&amp;gt;&amp;lt;/program&amp;gt;&amp;lt;/program&amp;gt;&amp;lt;/pid&amp;gt;&amp;lt;/program&amp;gt;&amp;lt;/program&amp;gt;&amp;lt;/program&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;###GDB的命令概貌&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;启动gdb后，你就被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb的命令可以使用help命令来查看，如下所示：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;```&lt;/span&gt;bash
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ gdb
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GNU gdb 6.7.1-debian
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Copyright &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2007&lt;/span&gt; Free Software Foundation, Inc.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;License GPLv3+: GNU GPL version &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; or later &amp;lt;http: gnu.org&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; licenses&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; gpl.html&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;This is free software: you are free to change and redistribute it.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;There is NO WARRANTY, to the extent permitted by law.  Type &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;show copying&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;and &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;show warranty&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; details.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;This GDB was configured as &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;i486-linux-gnu&amp;#34;&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; help
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;List of classes of commands:&amp;lt;/http:&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;aliases -- Aliases of other commands
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;breakpoints -- Making program stop at certain points
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;data -- Examining data
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;files -- Specifying and examining files
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;internals -- Maintenance commands
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;obscure -- Obscure features
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;running -- Running the program
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stack -- Examining the stack
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;status -- Status inquiries
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;support -- Support facilities
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tracepoints -- Tracing of program execution without stopping the program
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user-defined -- User-defined commands
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Type &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help&amp;#34;&lt;/span&gt; followed by a class name &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; a list of commands in that class.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Type &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help all&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; the list of all commands.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Type &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help&amp;#34;&lt;/span&gt; followed by command name &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; full documentation.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Type &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;apropos word&amp;#34;&lt;/span&gt; to search &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; commands related to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;word&amp;#34;&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command name abbreviations are allowed &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; unambiguous.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gdb 的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用&lt;code&gt;help &amp;lt;class&amp;gt;&lt;/code&gt;命令，如：help breakpoints，查看设置断点的所有命令。也可以直接&lt;code&gt;help &amp;lt;command&amp;gt;&amp;lt;/command&amp;gt;&lt;/code&gt;来查看命令的帮助。 gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其列出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例一&lt;/strong&gt;：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; b func
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Breakpoint &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; at 0x804837a: file tst.c, line 5.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例二&lt;/strong&gt;：敲入b按两次TAB键，你会看到所有b打头的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;backtrace break bt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例三&lt;/strong&gt;：只记得函数的前缀，可以这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; b make_ &amp;amp;lt;按TAB键&amp;amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;（再按下一次TAB键，你会看到:）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make_a_section_from_file make_environ
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make_abs_section make_function_type
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make_blockvector make_pointer_type
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make_cleanup make_reference_type
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make_command make_symbol_completion_list
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; b make_
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GDB把所有make开头的函数全部列出来给你查看。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例四&lt;/strong&gt;：调试C++的程序时，有可以函数名一样。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; b &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bubble( M-?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;bubble(double,double) bubble(int,int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;(gdb) b &amp;#39;&lt;/span&gt;bubble&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思） 要退出gdb时，只用发quit或命令简称q就行了&lt;/p&gt;
&lt;h3 id=&#34;gdb中运行unix的shell程序&#34;&gt;GDB中运行UNIX的shell程序&lt;/h3&gt;
&lt;p&gt;在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成： &lt;code&gt;shell &amp;lt;command string=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/command&amp;gt;&lt;/code&gt; 调用UNIX的shell来执行&lt;code&gt;&amp;lt;command string=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/command&amp;gt;&lt;/code&gt;，环境变量SHELL中定义的UNIX的shell将会被用来执行&lt;code&gt;&amp;lt;command string=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/command&amp;gt;&lt;/code&gt;，如果SHELL没有定义，那就使用UNIX的标准&lt;code&gt;shell：/bin/sh&lt;/code&gt;。（在Windows中使用Command.com或cmd.exe） 还有一个gdb命令是make： &lt;code&gt;make &amp;lt;make-args&amp;gt;&lt;/code&gt; 可以在gdb中执行make命令来重新build自己的程序。这个命令等价于&lt;code&gt;shell make &amp;lt;make-args&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;在gdb中运行程序&#34;&gt;在GDB中运行程序&lt;/h3&gt;
&lt;p&gt;当以&lt;code&gt;gdb &amp;lt;program&amp;gt;&lt;/code&gt;方式启动gdb后，gdb会在PATH路径和当前目录中搜索&lt;code&gt;&amp;lt;program&amp;gt;&lt;/code&gt;的源文件。如要确认gdb是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。 在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。 &lt;strong&gt;1、程序运行参数。&lt;/strong&gt; set args 可指定运行时参数。（如：set args 10 20 30 40 50） show args 命令可以查看设置好的运行参数。 &lt;strong&gt;2、运行环境。&lt;/strong&gt; `path&lt;/p&gt;
&lt;p&gt;&lt;code&gt;可设定程序的运行路径。 show paths 查看程序的运行路径。 set environment varname [=value] 设置环境变量。如：set env USER=hchen show environment [varname] 查看环境变量。 **3、工作目录。**&lt;/code&gt;cd&lt;/p&gt;
&lt;p&gt;` 相当于shell的cd命令。 pwd 显示当前的所在目录。 &lt;strong&gt;4、程序的输入输出。&lt;/strong&gt; info terminal 显示你程序用到的终端的模式。 使用重定向控制程序输出。如：run &amp;gt; outfile tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb&lt;/p&gt;
&lt;h3 id=&#34;调试已运行的程序&#34;&gt;调试已运行的程序&lt;/h3&gt;
&lt;p&gt;两种方法： 1. 在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用&lt;code&gt;gdb &amp;lt;program&amp;gt; PID&lt;/code&gt;格式挂接正在运行的程序。 2. 先用&lt;code&gt;gdb &amp;lt;program&amp;gt;&lt;/code&gt;关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。&lt;/p&gt;
&lt;h3 id=&#34;暂停恢复程序运行&#34;&gt;暂停/恢复程序运行&lt;/h3&gt;
&lt;p&gt;调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。 当进程被gdb停住时，你可以使用&lt;code&gt;info program&lt;/code&gt; 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（Watch Point）、捕捉点（Catch Point）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可以使用c或是 continue命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面为重要的使用步骤, 只摘抄了部分必要的信息, 如设置断点, 查看栈信息, 其余操作, 可以在&lt;a class=&#34;link&#34; href=&#34;http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki.ubuntu&lt;/a&gt;查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置断点（Break Points）&lt;/strong&gt; 我们用break命令来设置断点。下面有几点设置断点的方法： &lt;code&gt;break &amp;lt;function&amp;gt;&lt;/code&gt; 在进入指定函数时停住。C++中可以使用&lt;code&gt;class::function&lt;/code&gt;或&lt;code&gt;function(type,type)&lt;/code&gt;格式来指定函数名。 &lt;code&gt;break &amp;lt;linenum&amp;gt;&lt;/code&gt; 在指定行号停住。 &lt;code&gt;break +offset&lt;/code&gt; &lt;code&gt;break -offset&lt;/code&gt; 在当前行号的前面或后面的offset行停住。offiset为自然数。 &lt;code&gt;break filename：linenum&lt;/code&gt; 在源文件filename的linenum行处停住。 &lt;code&gt;break filename：function&lt;/code&gt; 在源文件filename的function函数的入口处停住。 &lt;code&gt;break *address&lt;/code&gt; 在程序运行的内存地址处停住。 &lt;code&gt;break&lt;/code&gt; break命令没有参数时，表示在下一条指令处停住。 &lt;code&gt;break ... if &amp;lt;condition&amp;gt;&lt;/code&gt; &amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置&lt;code&gt;break if i==100&lt;/code&gt;，表示当i为100时停住程序。 查看断点时，可使用info命令，如下所示：（注：n表示断点号） &lt;code&gt;info breakpoints [n]&lt;/code&gt; &lt;code&gt;info break [n]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;维护停止点&lt;/strong&gt; 上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;、&lt;code&gt;disable&lt;/code&gt;、&lt;code&gt;enable&lt;/code&gt;这几个命令来进行维护。 &lt;code&gt;clear&lt;/code&gt; 清除所有的已定义的停止点。 &lt;code&gt;clear &amp;lt;function&amp;gt;&lt;/code&gt; &lt;code&gt;clear &amp;lt;filename：function&amp;gt;&lt;/code&gt; 清除所有设置在函数上的停止点。 &lt;code&gt;clear &amp;lt;linenum&amp;gt;&lt;/code&gt; &lt;code&gt;clear &amp;lt;filename：linenum&amp;gt;&lt;/code&gt; 清除所有设置在指定行上的停止点。 &lt;code&gt;delete [breakpoints] [range...]&lt;/code&gt; 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。&amp;lt;/filename：linenum&amp;gt;&amp;lt;/filename：function&amp;gt;&lt;/p&gt;
&lt;p&gt;比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。 &lt;code&gt;disable [breakpoints] [range...]&lt;/code&gt; disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis. &lt;code&gt;enable [breakpoints] [range...]&lt;/code&gt; enable所指定的停止点，breakpoints为停止点号。 &lt;code&gt;enable [breakpoints] once range...&lt;/code&gt; enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。 &lt;code&gt;enable [breakpoints] delete range...&lt;/code&gt; enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;恢复程序运行和单步调试&lt;/strong&gt; 当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用step或next命令单步跟踪程序。 &lt;code&gt;continue [ignore-count]&lt;/code&gt; &lt;code&gt;c [ignore-count]&lt;/code&gt; &lt;code&gt;fg [ignore-count]&lt;/code&gt; 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。 &lt;code&gt;step &amp;lt;count&amp;gt;&lt;/code&gt; 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 &lt;code&gt;next &amp;lt;count&amp;gt;&lt;/code&gt; 同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 &lt;code&gt;set step-mode&lt;/code&gt; &lt;code&gt;set step-mode on&lt;/code&gt; 打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数很有利于查看机器码。 &lt;code&gt;set step-mode off&lt;/code&gt; 关闭step-mode模式。 &lt;code&gt;finish&lt;/code&gt; 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。 &lt;code&gt;until 或 u&lt;/code&gt; 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 &lt;code&gt;stepi 或 si&lt;/code&gt; &lt;code&gt;nexti 或 ni&lt;/code&gt; 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是&lt;code&gt;“display/i $pc”&lt;/code&gt; ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看栈信息&lt;/strong&gt; 当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。 下面是一些查看函数调用栈信息的GDB命令： &lt;code&gt;backtrace&lt;/code&gt; &lt;code&gt;bt&lt;/code&gt; 打印当前的函数调用栈的所有信息。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; bt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#0  func (n=250) at tst.c:6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#2  0x400409ed in __libc_start_main () from /lib/libc.so.6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上可以看出函数的调用栈信息：&lt;code&gt;__libc_start_main --&amp;amp;gt; main() --&amp;amp;gt; func()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;backtrace &amp;lt;n&amp;gt;&lt;/code&gt; &lt;code&gt;bt &amp;lt;n&amp;gt;&lt;/code&gt; n是一个正整数，表示只打印栈顶上n层的栈信息。 &lt;code&gt;backtrace &amp;amp;lt;-n&amp;amp;gt;&lt;/code&gt; &lt;code&gt;bt &amp;amp;lt;-n&amp;amp;gt;&lt;/code&gt; -n表一个负整数，表示只打印栈底下n层的栈信息。 如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。 &lt;code&gt;frame &amp;lt;n&amp;gt;&lt;/code&gt; &lt;code&gt;f &amp;lt;n&amp;gt;&lt;/code&gt; n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。 &lt;code&gt;up &amp;lt;n&amp;gt;&lt;/code&gt; 表示向栈的上面移动n层，可以不打n，表示向上移动一层。 &lt;code&gt;down &amp;lt;n&amp;gt;&lt;/code&gt; 表示向栈的下面移动n层，可以不打n，表示向下移动一层。&lt;/p&gt;
&lt;p&gt;上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令： &lt;code&gt;select-frame &amp;lt;n&amp;gt;&lt;/code&gt; 对应于 frame 命令。 &lt;code&gt;up-silently &amp;lt;n&amp;gt;&lt;/code&gt;对应于 up 命令。 &lt;code&gt;down-silently &amp;lt;n&amp;gt;&lt;/code&gt; 对应于 down 命令。 查看当前栈层的信息，你可以用以下GDB命令： &lt;code&gt;frame&lt;/code&gt; 或 &lt;code&gt;f&lt;/code&gt; 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。 &lt;code&gt;info frame&lt;/code&gt; &lt;code&gt;info f&lt;/code&gt; 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如： &lt;code&gt;bash (gdb) info f Stack level 0, frame at 0xbffff5d4: eip = 0x804845d in func (tst.c:6); saved eip 0x8048524 called by frame at 0xbffff60c source language c. Arglist at 0xbffff5d4, args: n=250 Locals at 0xbffff5d4, Previous frame&#39;s sp is 0x0 Saved registers: ebp at 0xbffff5d4, eip at 0xbffff5d8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info args&lt;/code&gt; 打印出当前函数的参数名及其值。 &lt;code&gt;info locals&lt;/code&gt; 打印出当前函数中所有局部变量及其值。 &lt;code&gt;info catch&lt;/code&gt; 打印出当前的函数中的异常处理信息。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>编译器工作过程</title>
        <link>https://lxb.wiki/49fab9fa/</link>
        <pubDate>Thu, 09 Feb 2017 22:13:33 +0000</pubDate>
        
        <guid>https://lxb.wiki/49fab9fa/</guid>
        <description>&lt;p&gt;代码要运行，必须先转成二进制的机器码。这是编译器的任务。&lt;/p&gt;
&lt;p&gt;比如，下面这段源码（假定文件名叫做test.c）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
fputs(&amp;quot;Hello, world!\n&amp;quot;, stdout);
return 0;
}
```&amp;lt;/stdio.h&amp;gt;

要先用编译器处理一下，才能运行。

```bash
$ gcc test.c
$ ./a.out
Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于复杂的项目，编译过程还必须分成三步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./configure
$ make
$ make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。&lt;/p&gt;
&lt;p&gt;本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了Alex Smith的文章《Building C Projects》。需要声明的是，本文主要针对gcc编译器，也就是针对C和C++，不一定适用于其他语言的编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170105233325494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;这里写图片描述&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;第一步-配置configure&#34;&gt;第一步 配置（configure）&lt;/h4&gt;
&lt;p&gt;编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。&lt;/p&gt;
&lt;p&gt;这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。&lt;/p&gt;
&lt;p&gt;configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ ./configure --prefix=/www --with-mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。&lt;/p&gt;
&lt;h4 id=&#34;第二步-确定标准库和头文件的位置&#34;&gt;第二步 确定标准库和头文件的位置&lt;/h4&gt;
&lt;p&gt;源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。&lt;/p&gt;
&lt;p&gt;编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。&lt;/p&gt;
&lt;h4 id=&#34;第三步-确定依赖关系&#34;&gt;第三步 确定依赖关系&lt;/h4&gt;
&lt;p&gt;对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。&lt;/p&gt;
&lt;p&gt;（1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。&lt;/p&gt;
&lt;p&gt;编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。&lt;/p&gt;
&lt;p&gt;在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。&lt;/p&gt;
&lt;h4 id=&#34;第四步-头文件的预编译precompilation&#34;&gt;第四步 头文件的预编译（precompilation）&lt;/h4&gt;
&lt;p&gt;不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。&lt;/p&gt;
&lt;p&gt;不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。&lt;/p&gt;
&lt;h4 id=&#34;第五步-预处理preprocessing&#34;&gt;第五步 预处理（Preprocessing）&lt;/h4&gt;
&lt;p&gt;预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern int fputs(const char *, FILE *);
extern FILE *stdout;
int main(void)
{
fputs(&amp;quot;Hello, world!\n&amp;quot;, stdout);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。&lt;/p&gt;
&lt;p&gt;这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。&lt;/p&gt;
&lt;h4 id=&#34;第六步-编译compilation&#34;&gt;第六步 编译（Compilation）&lt;/h4&gt;
&lt;p&gt;预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。&lt;/p&gt;
&lt;p&gt;下面是本文开头的那段源码转成的汇编码。&lt;/p&gt;
&lt;p&gt;```` .file &amp;ldquo;test.c&amp;rdquo; .section .rodata .LC0: .string &amp;ldquo;Hello, world!\n&amp;rdquo; .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movq stdout(%rip), %rax movq %rax, %rcx movl $14, %edx movl $1, %esi movl $.LC0, %edi call fwrite movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident &amp;ldquo;GCC: (Debian 4.9.1-19) 4.9.1&amp;rdquo; .section .note.GNU-stack,&amp;quot;&amp;quot;,@progbits ```&lt;/p&gt;
&lt;p&gt;这种转码后的文件称为对象文件（object file）。&lt;/p&gt;
&lt;h4 id=&#34;第七步-连接linking&#34;&gt;第七步 连接（Linking）&lt;/h4&gt;
&lt;p&gt;对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。&lt;/p&gt;
&lt;p&gt;编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;第八步-安装installation&#34;&gt;第八步 安装（Installation）&lt;/h4&gt;
&lt;p&gt;上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。&lt;/p&gt;
&lt;p&gt;表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。&lt;/p&gt;
&lt;h4 id=&#34;第九步-操作系统连接&#34;&gt;第九步 操作系统连接&lt;/h4&gt;
&lt;p&gt;可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。&lt;/p&gt;
&lt;p&gt;这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在&lt;code&gt;/usr/share/applications&lt;/code&gt;目录下的&lt;code&gt;.desktop&lt;/code&gt;文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。&lt;/p&gt;
&lt;p&gt;这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。&lt;/p&gt;
&lt;h4 id=&#34;第十步-生成安装包&#34;&gt;第十步 生成安装包&lt;/h4&gt;
&lt;p&gt;写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。&lt;/p&gt;
&lt;p&gt;所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。&lt;/p&gt;
&lt;h4 id=&#34;第十一步-动态连接dynamic-linking&#34;&gt;第十一步 动态连接（Dynamic linking）&lt;/h4&gt;
&lt;p&gt;正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。&lt;/p&gt;
&lt;p&gt;前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。&lt;/p&gt;
&lt;p&gt;现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>unordered_map笔记</title>
        <link>https://lxb.wiki/d97ca7/</link>
        <pubDate>Thu, 12 Jan 2017 20:05:01 +0000</pubDate>
        
        <guid>https://lxb.wiki/d97ca7/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;unordered_map与map的区别 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&amp;lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&amp;lt; 定义的大小排序。 而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。 用法的区别就是，stl::map 的key需要定义operator&amp;lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator== 或者hash_value()了。 最后，说，当不需要结果排好序时，最好用unordered_map。&lt;/p&gt;
&lt;p&gt;linux下使用 普通的key就不说了和map一样 看一下用sockaddr_in 作为key的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef CSESSION_H  
#define CSESSION_H  

#include &amp;lt;netinet in.h=&amp;quot;&amp;quot;&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;/time.h&amp;gt;&amp;lt;/netinet&amp;gt;

&amp;lt;map&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;tr1 unordered_map=&amp;quot;&amp;quot;&amp;gt;  //头文件
#include &amp;lt;iostream&amp;gt;

using namespace std;
using namespace std::tr1;

struct Terminal
{
int             nid ; //id  the key for terminal
sockaddr_in     addr; //ip  the key for Client
time_t          tm;   //last alive time
enTerminalStat  enStat;//status
Terminal();
~Terminal();
Terminal &amp;amp;amp;operator =(const Terminal&amp;amp;amp; term);
};

struct hash_func  //hash 函数
{
size_t operator()(const sockaddr_in &amp;amp;amp;addr) const
{
return addr.sin_port*9999 + addr.sin_addr.s_addr;
}
};
struct cmp_fun //比较函数 ==
{
bool operator()(const sockaddr_in &amp;amp;amp;addr1, const sockaddr_in &amp;amp;amp;addr2) const
{
return memcmp(&amp;amp;amp;addr1, &amp;amp;amp;addr2, sizeof(sockaddr_in)) == 0 ? true:false;
}
};

//typedef unordered_map&amp;lt;int,terminal*&amp;gt; MapTerminal; // Terminal socket 作为key
//typedef unordered_map&amp;lt;int,terminal*&amp;gt;::iterator MapTerminal_It; //  &amp;lt;/int,terminal*&amp;gt;&amp;lt;/int,terminal*&amp;gt;

typedef unordered_map&amp;lt;sockaddr_in, terminal*,hash_func,=&amp;quot;&amp;quot; cmp_fun=&amp;quot;&amp;quot;&amp;gt; MapClientSession; // sockaddr_in作为key
typedef unordered_map&amp;lt;sockaddr_in, terminal*,hash_func,=&amp;quot;&amp;quot; cmp_fun=&amp;quot;&amp;quot;&amp;gt;::iterator MapClientSession_It; //  &amp;lt;/sockaddr_in,&amp;gt;&amp;lt;/sockaddr_in,&amp;gt;

#endif // CSESSION_H
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;operator==&lt;/code&gt;有两种方式 一种是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct st
{
bool operator==(const st &amp;amp;amp;s) const
...
}；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种就是自定义函数体，代码中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct cmp_fun
{
bool operator()(...)
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须要自定义&lt;code&gt;operator==&lt;/code&gt;和&lt;code&gt;hash_value&lt;/code&gt;。 重载&lt;code&gt;operator==&lt;/code&gt;是因为，如果两个元素的&lt;code&gt;hash_value&lt;/code&gt;的值相同，并不能断定这两个元素就相同，必须再调用&lt;code&gt;operator==&lt;/code&gt;。 当然，如果&lt;code&gt;hash_value&lt;/code&gt;的值不同，就不需要调用&lt;code&gt;operator==&lt;/code&gt;了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>unordered_set笔记</title>
        <link>https://lxb.wiki/14decfad/</link>
        <pubDate>Thu, 05 Jan 2017 23:14:47 +0000</pubDate>
        
        <guid>https://lxb.wiki/14decfad/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.cplusplus.com/reference/unordered_set/unordered_set/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.cplusplus.com/reference/unordered_set/unordered_set/&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;unordered_set&lt;/strong&gt; 模板原型:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Key&lt;/span&gt;,  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Pred&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; equal_to&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Alloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; allocator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;key&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unordered_set&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当比较unordered_set中某两个元素时, 先调用&lt;code&gt;hash&amp;lt;key&amp;gt;&lt;/code&gt;, 如果&lt;code&gt;hash&amp;lt;key&amp;gt;&lt;/code&gt;  不相等, 说明两个元素不同, 如果&lt;code&gt;hash&amp;lt;key&amp;gt;&lt;/code&gt; 值相等, 则调用&lt;code&gt;equal_to&amp;lt;key&amp;gt;&lt;/code&gt;, 判断两个元素是否完全相等. (Hash函数和Compare函数都可以自定义)&lt;/p&gt;
&lt;p&gt;C++ 11中对unordered_set描述大体如下：无序集合容器（unordered_set）是一个存储唯一(unique，即无重复）的关联容器（Associative container），容器中的元素无特别的秩序关系，该容器允许基于值的快速元素检索，同时也支持正向迭代。
在一个unordered_set内部，元素不会按任何顺序排序，而是通过元素值的hash值将元素分组放置到各个槽(Bucker，也可以译为“桶”），这样就能通过元素值快速访问各个对应的元素（均摊耗时为O（1））。
原型中的Key代表要存储的类型，而hash&lt;!-- raw HTML omitted --&gt;也就是你的hash函数，equal_to&lt;!-- raw HTML omitted --&gt;用来判断两个元素是否相等，allocator&lt;!-- raw HTML omitted --&gt;是内存的分配策略。一般情况下，我们只关心hash&lt;!-- raw HTML omitted --&gt;和equal_to&lt;!-- raw HTML omitted --&gt;参数，下面将介绍这两部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;hash&amp;lt;key&amp;gt;&lt;/code&gt;&lt;/strong&gt;
&lt;code&gt; hash&amp;lt;key&amp;gt;&lt;/code&gt;通过相应的hash函数，将传入的参数转换为一个size_t类型值，然后用该值对当前hashtable的bucket取模算得其对应的hash值。而C++标准库，为我们提供了基本数据类型的hash函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Primary class template hash. template struct hash;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Partial specializations for pointer types. template struct hash&amp;lt;\_Tp*&amp;gt; : public \_\_hash\_base&amp;lt;size\_t, \_tp*=&amp;#34;&amp;#34;&amp;gt; { size\_t operator()(\_Tp* \_\_p) const noexcept { return reinterpret_cast(__p); } }; &amp;lt;/size_t,&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Explicit specializations for integer types.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;define &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_Cxx&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_hashtable&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_define&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_trivial&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_hash(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_Tp) \
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;======================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_Tp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_hash&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_base&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_t, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_tp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; { &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; size&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_t &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_Tp &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;_val) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static_cast&lt;/span&gt;(__val); } &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; }; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/&lt;/span&gt;size_t,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for bool. \_Cxx\_hashtable\_define\_trivial_hash(bool)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for char. \_Cxx\_hashtable\_define\_trivial_hash(char)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for signed char. \_Cxx\_hashtable\_define\_trivial_hash(signed char)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for unsigned char. \_Cxx\_hashtable\_define\_trivial_hash(unsigned char)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for wchar\_t. \_Cxx\_hashtable\_define\_trivial\_hash(wchar_t)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for char16\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char16_t)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for char32\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char32_t)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for short. \_Cxx\_hashtable\_define\_trivial_hash(short)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for int. \_Cxx\_hashtable\_define\_trivial_hash(int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for long. \_Cxx\_hashtable\_define\_trivial_hash(long)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for long long. \_Cxx\_hashtable\_define\_trivial_hash(long long)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for unsigned short. \_Cxx\_hashtable\_define\_trivial_hash(unsigned short)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for unsigned int. \_Cxx\_hashtable\_define\_trivial_hash(unsigned int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for unsigned long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// Explicit specialization for unsigned long long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long long)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于指针类型，标准库只是单一将地址转换为一个size_t值作为hash值，这里特别需要注意的是&lt;code&gt;char *&lt;/code&gt;类型的指针，其标准库提供的hash函数只是将指针所指地址转换为一个sieze_t值，如果，你需要用&lt;code&gt;char *&lt;/code&gt;所指的内容做hash，那么，你需要自己写hash函数或者调用系统提供的&lt;code&gt;hash&amp;lt;string&amp;gt;&lt;/code&gt;。
标准库为string类型对象提供了一个hash函数，即：Murmur hash，。对于float、double、long double标准库也有相应的hash函数，这里，不做过多的解释，相应的可以参看functional_hash.h头文件。
上述只是介绍了基本数据类型，而在实际应用中，有时，我们需要使用自己写的hash函数，那怎么自定义hash函数？参考标准库基本数据类型的hash函数，我们会发现这些hash函数有个共同的特点：通过定义函数对象，实现相应的hash函数，这也就意味我们可以通过自定义相应的函数对象，来实现自定义hash函数。比如：已知平面上有N，每个点的x轴、y轴范围为[0，100]，现在需要统计有多少个不同点？hash函数设计为：将每个点的x、y值看成是101进制，如下所示:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;bits\stdc++.h&amp;gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;myHash&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_t &lt;span style=&#34;color:#a6e22e&#34;&gt;operator&lt;/span&gt;()(pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; __val) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(__val.first &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;101&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; __val.second);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    unordered_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, myHash&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; S;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, y;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; y)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        S.insert(make_pair(x, y));  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; it &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; S.begin(); it &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; S.end(); &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;it)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; it&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;first &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; it&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;second &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;equal_to&amp;lt;key&amp;gt;&lt;/code&gt;&lt;/strong&gt;
该参数用于实现比较两个关键字是否相等，至于为什么需要这个参数？这里做点解释，前面我们说过，当不同关键字，通过hash函数，可能会得到相同的关键字值，每当我们在unordered_set里面做数据插入、删除时，由于unordered_set关键字唯一性，所以我们得确保唯一性。标准库定义了基本类型的比较函数，而对于自定义的数据类型，我们需要自定义比较函数。这里有两种方法:重载==操作符和使用函数对象，下面是STL中实现&lt;code&gt;equal_to&amp;lt;key&amp;gt;&lt;/code&gt;的源代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; _Arg, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; _Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unary_function&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;/// @c argument_type is the type of the argument  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; _Arg  argument_type;     
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;/// @c result_type is the return type  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; _Result   result_type;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; _Tp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;equal_to&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_Tp, _Tp, &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; _Tp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; __x, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; _Tp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; __y) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; __x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; __y; }  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;扩容与缩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在vector中，每当我们插入一个新元素时，如果当前的容量（capacity)已不足，需要向系统申请一个更大的空间，然后将原始数据拷贝到新空间中。这种现象在unordered_set中也存在，比如当前的表长为100，而真实存在表中的数据已经大于1000个元素，此时，每个bucker均摊有10个元素，这样就会影响到unordered_set的存取效率，而标准库通过采用某种策略来对当前空间进行扩容，以此来提高存取效率。当然，这里也存在缩容，原理和扩容类似，不过，需要注意的是，每当unordered_set内部进行一次扩容或者缩容，都需要对表中的数据重新计算，也就是说，扩容或者缩容的时间复杂度至少为。&lt;/p&gt;
&lt;p&gt;code：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// unordered_set::find
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;unordered_set&amp;gt;  &amp;lt;/unordered_set&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/iostream&amp;gt;

int main ()
{
std::unordered_set&amp;lt;std::string&amp;gt; myset = { &amp;quot;red&amp;quot;,&amp;quot;green&amp;quot;,&amp;quot;blue&amp;quot; };  &amp;lt;/std::string&amp;gt;

std::string input;
std::cout &amp;amp;lt;&amp;amp;lt; &amp;quot;color? &amp;quot;;  
  getline (std::cin,input);  

  std::unordered_set&amp;lt;std::string&amp;gt;::const_iterator got = myset.find (input);  &amp;lt;/std::string&amp;gt;

if ( got == myset.end() )
std::cout &amp;amp;lt;&amp;amp;lt; &amp;quot;not found in myset&amp;quot;;  
  else  
    std::cout &amp;amp;lt;&amp;amp;lt; *got &amp;amp;lt;&amp;amp;lt; &amp;quot; is in myset&amp;quot;;  

  std::cout &amp;amp;lt;&amp;amp;lt; std::endl;  

  return 0;  
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>c&#43;&#43;代码优化建议</title>
        <link>https://lxb.wiki/8e72ff9a/</link>
        <pubDate>Sat, 17 Dec 2016 22:02:36 +0000</pubDate>
        
        <guid>https://lxb.wiki/8e72ff9a/</guid>
        <description>&lt;ol&gt;
&lt;li&gt;记住阿姆达尔定律： Ahmdal&amp;rsquo;s rule $$Speedup =\dfrac{ time_{old}}{time_{new}} = \dfrac{1}{(1-func_{cost})+func_{cost}/func_{speedup}}$$&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;func_cost是函数func运行时间百分比，func_speedup是你优化函数的运行的系数。&lt;/li&gt;
&lt;li&gt;所以，如果你优化了函数TriangleIntersect执行40%的运行时间，使它运行快了近两倍，而你的程序会运行快25%。&lt;/li&gt;
&lt;li&gt;这意味着不经常使用的代码不需要做较多优化考虑（或者完全不优化）。&lt;/li&gt;
&lt;li&gt;这里有句俗语：让经常执行的路径运行更加高效，而运行稀少的路径正确运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码先保证正确，然后再考虑优化 这并不意味着用8周时间写一个全功能的射线追踪算法，然后用8周时间去优化它。 分多步来做性能优化。 先写正确的代码，当你意识到这个函数可能会被经常调用，进行明显的优化。 然后再寻找算法的瓶颈，并解决（通过优化或者改进算法）。通常，改进算法能显著地改进瓶颈——也许是采用一个你还没有预想到的方法。所有频繁调用的函数，都需要优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我所了解的那些写出非常高效代码的人说，他们优化代码的时间，是写代码时间的两倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转和分支执行代价高，如果可能，尽量少用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数调用需要两次跳转，外加栈内存操作。 优先使用迭代而不是递归。 使用内联函数处理短小的函数来消除函数调用开销。 将循环内的函数调用移动到循环外(例如，将for(i=0;i&amp;lt;100;i++) DoSomething();改为DoSomething() { for(i=0;i&amp;lt;100;i++) { … }})。 if…else if…else if…else if…很长的分支链执行到最后的分支需要很多的跳转。如果可能，将其转换为一个switch声明语句，编译器有时候会将其转换为一个表查询单次跳转。如果switch声明不可行，将最常见的场景放在if分支链的最前面。 5. 仔细思考函数下标的顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;两阶或更高阶的数组在内存中还是以一维的方式在存储在内存中，这意味着（对于C/C++数组）array[i][j] 和 array[i][j+1]是相邻的，但是array[i][j] 和array[i+1][j]可能相距很远。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以适当的方式访问存储实际内存中的数据，可以显著地提升你代码的执行效率（有时候可以提升一个数量级甚至更多）。 现代处理器从主内存中加载数据到处理器cache，会加载比单个值更多的数据。该操作会获取请求数据和相邻数据（一个cache行大小）的整块数据。这意味着，一旦array[i][j]已经在处理器cache中，array[i][j+1]很大可能也已经在cache中了，而array[i+1][j]可能还在内存中。 6. 使用指令层的并行机制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;尽管许多程序还是依赖单线程的执行，现代处理器在单核中也提供了不少的并行性。例如：单个CPU可以同时执行4个浮点数乘，等待4个内存请求并执行一个分支预判。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了最大化利用这种并行性，代码块（在跳转之间的）需要足够的独立指令来允许处理器被充分利用。 考虑展开循环来改进这一点。 这也是使用内联函数的一个好理由。 7. 避免或减少使用本地变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;本地变量通常都存储在栈上。不过如果数量比较少，它们可以存储在CPU寄存器中。在这种情况下，函数不但得到了更快访问存储在寄存器中的数据的好处，也避免了初始化一个栈帧的开销。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要将大量数据转换为全局变量。 8. 减少函数参数的个数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;和减少使用本地变量的理由一样——它们也是存放在栈上。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9. 通过引用传递结构体而不是传值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我在射线追踪中还找不到一个场景需要将结构体使用传值方式（包括一些简单结构如：Vector，Point和Color）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10. 如果你的函数不需要返回值，不要定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽量避免数据转换。&lt;/p&gt;
&lt;p&gt;整数和浮点数指令通常操作不同的寄存器，所以转换需要进行一次拷贝操作。 短整型（char和short）仍然使用一整个寄存器，并且它们需要被填充为32/64位，然后在存储回内存时需要再次转换为小字节（不过，这个开销一定比一个更大的数据类型的内存开销要多一点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义C++对象时需要注意。&lt;/p&gt;
&lt;p&gt;使用类初始化而不是使用赋值（Color c(black); 比Color c; c = black;更快）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使类构造函数尽可能轻量。 尤其是常用的简单类型（比如，color，vector，point等等），这些类经常被复制。 这些默认构造函数通常都是在隐式执行的，这或许不是你所期望的。 使用类初始化列表(Use Color::Color() : r(0), g(0), b(0) {}，而不是初始化函数Color::Color() { r= g = b = 0; } .)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果可以的话，使用位移操作&amp;raquo;和&amp;laquo;来代替整数乘除法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心使用表查找函数&lt;/p&gt;
&lt;p&gt;许多人都鼓励将复杂的函数（比如：三角函数）转化为使用预编译的查找表。对于射线追踪功能来说，这通常导致了不必要的内存查找，这很昂贵（并不断增长），并且这和计算一个三角函数并从内存中获取值一样快（尤其你考虑到三角查找打乱了cpu的cache存取）。 在其他情况下，查找表会很有用。对于GPU编程通常优先使用表查找而不是复杂函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对大多数类，优先使用+= 、 -= 、 *= 和 /=，而不是使用+ 、 – 、 * 、 和?/&lt;/p&gt;
&lt;p&gt;这些简单操作需要创建一个匿名临时中间变量。 例如：Vector v = Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1);?创建了五个匿名临时Vector: Vector(1,0,0), Vector(0,1,0), Vector(0,0,1), Vector(1,0,0) + Vector(0,1,0), 和 Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1). 对上述代码进行简单转换：Vector v(1,0,0); v+= Vector(0,1,0); v+= Vector(0,0,1);仅仅创建了两个临时Vector: Vector(0,1,0) 和 Vector(0,0,1)。这节约了6次函数调用（3次构造函数和3次析构函数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于基本数据类型，优先使用+?、?-?、?&lt;em&gt;?、?和?/，而不是+=?、?-=?、?&lt;/em&gt;= 和 /=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推迟定义本地变量&lt;/p&gt;
&lt;p&gt;定义一个对象变量通常需要调用一次函数（构造函数）。 如果一个变量只在某些情况下需要（例如在一个if声明语句内），仅在其需要的时候定义，这样，构造函数仅在其被使用的时候调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于对象，使用前缀操作符（++obj），而不是后缀操作符（obj++）&lt;/p&gt;
&lt;p&gt;这在你的射线追踪算法中可能不是一个问题 使用后缀操作符需要执行一次对象拷贝（这也导致了额外的构造和析构函数调用），而前缀的构造函数不需要一个临时的拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心使用模板&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;对不同的是实例实现进行不同的优化。 标准模板库已经经过良好的优化，不过我建议你在实现一个交互式射线追踪算法时避免使用它。 使用自己的实现，你知道它如何使用算法，所以你知道如何最有效的实现它。 最重要的是，我的经历告诉我：调试STL库非常低效。通常这也不是一个问题，除非你使用debug版本做性能分析。你会发现STL的构造函数，迭代器和其他一些操作，占用了你15%的运行时间，这会导致你分析性能输出更加费劲。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;避免在计算时进行动态内存分配&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;动态内存对于存储场景和运行期间其他数据都很有用。 但是，在许多（大多数）的系统动态内存分配需要获取控制访问分配器的锁。对于多线程应用程序，现实中使用动态内存由于额外的处理器导致了性能下降，因为需要等待分配器锁和释放内存。 即便对于单线程应用，在堆上分配内存也比在栈上分配内存开销大得多。操作系统还需要执行一些操作来计算并找到适合尺寸的内存块。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;找到你系统内存cache的信息并利用它们&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;如果一个是数据结构正好适合一个cache行，处理整个类从内存中只需要做一次获取操作。 确保所有的数据结构都是cache行大小对齐（如果你的数据结构和一个cache行大小都是128字节，仍有可能因为你的结构体中的一个字节在一个cache行中，而其他127字节在另外一个cahce行中）。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;避免不需要的数据初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;如果你需要初始化一大段的内存，考虑使用memset。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;尽早结束循环和尽早返回函数调用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;考虑一个射线和三角形交叉，通常的情况是射线会越过三角，所以这里可以优化。 如果你决定将射线和三角面板交叉。如果射线和面板交叉t值是负数，你可以立即返回。这允许你跳过射线三角交叉一大半的质心坐标计算。这是一个大的节约，一旦你知道这个交叉不存在，你就应该立即返回交叉计算函数。 同样的，一些循环也应该尽早结束。例如，当设置阴影射线，对于近处的交叉通常都是不必须的，一旦有类似的的交叉，交叉计算就应该尽早返回。（这里的交叉含义不太明白，可能是专业词汇，译者注）
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;在稿纸上简化你的方程式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;许多方程式中，通常都可以或者在某些条件中取消计算。 编译器不能发现这些简化，但是你可以。取消一个内部循环的一些昂贵操作可以抵消你在其他地方的好几天的优化工作。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;整数、定点数、32位浮点数和64位双精度数字的数学运算差异，没有你想象的那么大&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;在现代CPU，浮点数运算和整数运算差不多拥有同样的效率。在计算密集型应用（比如射线追踪），这意味这可以忽略整数和浮点数计算的开销差异。这也就是说，你不必要对算数进行整数处理优化。 双精度浮点数运算也不比单精度浮点数运算更慢，尤其是在64位机器上。我在同一台机器测试射线追踪算法全部使用double比全部使用floats运行有时候更快，反过来测试也看到了一样的现象（这里的原文是：I have seen ray tracers run faster using all doubles than all floats on the same machine. I have also seen the reverse）。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;不断改进你的数学计算，以消除昂贵的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sqrt()经常可以被优化掉，尤其是在比较两个值的平方根是否一致时。 如果你重复地需要处理 除x 操作，考虑计算1/x的值，乘以它。这在向量规范化（3次除法）运算中赢得了大的改进，不过我最近发现也有点难以确定的。不过，这仍然有所改进，如果你要进行三次或更多除法运算。 如果你在执行一个循环，那些在循环中执行不发生变化的部分，确保提取到循环外部。 考虑看看你的计算值是否可以在循环中修改得到（而不每次都重新开始循环计算）。
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>x == x</title>
        <link>https://lxb.wiki/72da8a18/</link>
        <pubDate>Sat, 19 Nov 2016 20:40:58 +0000</pubDate>
        
        <guid>https://lxb.wiki/72da8a18/</guid>
        <description>&lt;p&gt;C的表达式 x == x，何时为假呢？即下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (x == x)
{
printf(&amp;quot;Equal\n&amp;quot;);
}
else
{
printf(&amp;quot;Not equal\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;什么时候输出为&amp;quot;Not equal&amp;quot;呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;&amp;lt;/string.h&amp;gt;&amp;lt;/stdio.h&amp;gt;&amp;lt;/stdlib.h&amp;gt;

int main(void)
{
float x = 0xffffffff;

if (x == x)
{
printf(&amp;quot;Equal\n&amp;quot;);
}
else
{
printf(&amp;quot;Not equal\n&amp;quot;);
}

if (x &amp;amp;gt;= 0)
{
printf(&amp;quot;x(%f) &amp;amp;gt;= 0\n&amp;quot;, x);
}
else if (x &amp;amp;lt; 0) 
    {
        printf(&amp;quot;x(%f) &amp;amp;lt; 0\n&amp;quot;, x);
    }

    int a = 0xffffffff;
    memcpy(&amp;amp;amp;x, &amp;amp;amp;a, sizeof(x));
    if (x == x) 
    {
        printf(&amp;quot;Equal\n&amp;quot;);
    }
    else 
    {
        printf(&amp;quot;Not equal\n&amp;quot;);
    }

    if (x &amp;amp;gt;= 0)
{
printf(&amp;quot;x(%f) &amp;amp;gt;= 0\n&amp;quot;, x);
}
else if (x &amp;amp;lt; 0) 
    {
        printf(&amp;quot;x(%f) &amp;amp;lt; 0\n&amp;quot;, x);
    }
    else 
    {
        printf(&amp;quot;Surprise x(%f)!!!\n&amp;quot;, x);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译&lt;code&gt;gcc -g -Wall test.c&lt;/code&gt;，看执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./a.out
Equal
x(4294967296.000000) &amp;amp;gt;= 0
Not equal
Surprise x(-nan)!!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后两行输出是不是有点surprise啊。&lt;/p&gt;
&lt;p&gt;下面先简单解释一下： 1. 当&lt;code&gt;float x = 0xffffffff&lt;/code&gt;：这时将整数赋给一个浮点数，由于float和int的size都是4，而浮点数的存储格式与整数不同，其需要将某些位作为小数位，所以float的范围要小于int的范围。因此这里涉及到了整数转换浮点的规定。因为这个转换其实很少用到，我也就不查了。但是总之，这个转换是合法的。但是最终的值很可能不是你想要的结果——尤其是当浮点的范围小于整数的范围时。 2. 即使整数转换成浮点，数值再不是期望值，但它也一定是一个合法的浮点数值。所以第一个&lt;code&gt;x == x&lt;/code&gt;，一定为true，且x不是大于0，就是小于0。这时x存的并不是0xffffffff。 3. 当使用memcpy将0xff填充到x的地址时，这时x存的保证为0xffffffff。但是这个不是一个合法的float的值。因此奇怪的现象发生了，x并不等于x。原因则是与cpu的浮点指令相关. 4. 作为一个非法的float值，当它与其它任何数值比较时，都会返回false。这也就造成了，后面惊奇的结果，x既不大于等于0，也不小于0。&lt;/p&gt;
&lt;p&gt;总结一下：一般来说，浮点类型很少被使用，也不应该在程序中鼓励使用。不仅其效率比整数低，且由于浮点类型特殊的存储格式，很容易造成一些意想不到的错误。如果真的无法避免时，一定要小心小心再小心。特别要注意今天的主题，这种非法的浮点值，会导致任何比较判断都失败。而判断这种浮点值的方法也很简单，如果&lt;code&gt;x != x&lt;/code&gt;，那么该浮点即为非法浮点值。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;在重载operator=为带模板的函数的时候的陷阱</title>
        <link>https://lxb.wiki/a25c4e07/</link>
        <pubDate>Sat, 29 Oct 2016 20:20:32 +0000</pubDate>
        
        <guid>https://lxb.wiki/a25c4e07/</guid>
        <description>&lt;p&gt;原文地址 &lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000004467381&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://segmentfault.com/a/1190000004467381&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近被一个语法问题缠了半天，终于找到了原因。不仔细思考一下写的时候真的很容易忽略。先看代码：&lt;/p&gt;
&lt;p&gt;template class A { public: const T t = 0;&lt;/p&gt;
&lt;p&gt;template A&amp;amp; operator=(const A&amp;amp; a) { return *this; } };&lt;/p&gt;
&lt;p&gt;int main() { A a, b;&lt;/p&gt;
&lt;p&gt;b = a; // error } 这会带来一个编译错误，然而横睇掂睇都看不出问题。于是我就试了一下这样的代码：A c; b = c;居然通过了编译。F**k，这个模板居然胳膊肘往外拐。&lt;/p&gt;
&lt;p&gt;其实我在写这个代码的时候忽略了一点，就是default assignment operator，它是你在定义类的时候编译器默认给你加上去的，行为是对所有成员变量赋值。它的声明是A&amp;amp; operator=(const A&amp;amp; a);，跟我们自己定义的放在一起：&lt;/p&gt;
&lt;p&gt;template A&amp;amp; operator=(const A&amp;amp; a) { return *this; }&lt;/p&gt;
&lt;p&gt;A&amp;amp; operator=(const A&amp;amp; a) /&lt;em&gt;= delete&lt;/em&gt;/; 恰好构成了模板特化，这就糟了。一旦构成了特化，OtherT可以匹配的类型就会除去int，用A赋值时只能调用系统给我们定义的那个。然而它也不起作用，因为成员里面有常量（这样它就会被标记为= delete，留意delete并不会令OtherT可以匹配到int，反而令它匹配不到）。&lt;/p&gt;
&lt;p&gt;知道了原因之后，解决就很方便了，只要重新定义这个默认赋值运算符就好：&lt;/p&gt;
&lt;p&gt;A&amp;amp; operator=(const A&amp;amp; a) { /&lt;em&gt;&amp;hellip;&lt;/em&gt;/ }&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Makefile学习笔记</title>
        <link>https://lxb.wiki/31dc5dc1/</link>
        <pubDate>Sun, 09 Oct 2016 22:21:25 +0000</pubDate>
        
        <guid>https://lxb.wiki/31dc5dc1/</guid>
        <description>&lt;p&gt;关于Makefile怎么写,参考http://blog.csdn.net/haoel/article/details/2886&lt;/p&gt;
&lt;p&gt;一 关于编译和链接&lt;/p&gt;
&lt;p&gt;    一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。&lt;/p&gt;
&lt;p&gt;编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。&lt;/p&gt;
&lt;p&gt;    链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。&lt;/p&gt;
&lt;p&gt;    总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.&lt;/p&gt;
&lt;p&gt;二 Makefile的规则&lt;/p&gt;
&lt;p&gt;三条:&lt;/p&gt;
&lt;p&gt;    1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。     2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。     3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。&lt;/p&gt;
&lt;p&gt;    target &amp;hellip; : prerequisites &amp;hellip;             command             &amp;hellip;             &amp;hellip;&lt;/p&gt;
&lt;p&gt;    target也就是一个目标文件，可以是Object File，也可以是执行文件,还可以是一个标签（Label）.&lt;/p&gt;
&lt;p&gt;    prerequisites就是，要生成那个target所需要的东西(文件或是目标)。&lt;/p&gt;
&lt;p&gt;    command也就是make需要执行的命令。（任意的Shell命令）&lt;/p&gt;
&lt;p&gt;    这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;    edit : main.o kbd.o command.o display.o \            insert.o search.o files.o utils.o             cc -o edit main.o kbd.o command.o display.o \                        insert.o search.o files.o utils.o&lt;/p&gt;
&lt;p&gt;    main.o : main.c defs.h             cc -c main.c     kbd.o : kbd.c defs.h command.h             cc -c kbd.c     command.o : command.c defs.h command.h             cc -c command.c     display.o : display.c defs.h buffer.h             cc -c display.c     insert.o : insert.c defs.h buffer.h             cc -c insert.c     search.o : search.c defs.h buffer.h             cc -c search.c     files.o : files.c defs.h buffer.h command.h             cc -c files.c     utils.o : utils.c defs.h             cc -c utils.c     clean :             rm edit main.o kbd.o command.o display.o \                insert.o search.o files.o utils.o&lt;/p&gt;
&lt;p&gt;    在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个[Tab]键作为开头(在Makefile中的命令，必须要以[Tab]键开始)。make并不管命令是怎么工作的，它只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，make就会执行后续定义的命令。&lt;/p&gt;
&lt;p&gt;    clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，如果其冒号后什么也没有，那么make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。&lt;/p&gt;
&lt;p&gt;三 Makefile里有什么&lt;/p&gt;
&lt;p&gt;1 显示规则&lt;/p&gt;
&lt;p&gt;2 隐晦规则&lt;/p&gt;
&lt;p&gt;3 变量的定义&lt;/p&gt;
&lt;p&gt;4 文件指示: 其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。&lt;/p&gt;
&lt;p&gt;5 注释: Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。&lt;/p&gt;
&lt;p&gt;四 Makefile的文件名&lt;/p&gt;
&lt;p&gt;    默认情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了就解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。&lt;/p&gt;
&lt;p&gt;当然，也可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，可以使用make的“-f”和“&amp;ndash;file”参数，如：make -f Make.Linux或make &amp;ndash;file Make.AIX。&lt;/p&gt;
&lt;p&gt;五 引用其它的Makefile&lt;/p&gt;
&lt;p&gt;include的语法是：&lt;/p&gt;
&lt;p&gt;    include&lt;/p&gt;
&lt;p&gt;filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）&lt;/p&gt;
&lt;p&gt;    在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。例如,有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：&lt;/p&gt;
&lt;p&gt;    include foo.make *.mk $(bar)&lt;/p&gt;
&lt;p&gt;    等价于：&lt;/p&gt;
&lt;p&gt;    include foo.make a.mk b.mk c.mk e.mk f.mk&lt;/p&gt;
&lt;p&gt;make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：&lt;/p&gt;
&lt;p&gt;    1、如果make执行时，有“-I”或“&amp;ndash;include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。     2、如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。&lt;/p&gt;
&lt;p&gt;如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：&lt;/p&gt;
&lt;p&gt;    -include     其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。&lt;/p&gt;
&lt;p&gt;六 环境变量 MAKEFILES&lt;/p&gt;
&lt;p&gt;    如果当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。&lt;/p&gt;
&lt;p&gt;    但是在这里还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当使用make时，所有的Makefile都会受到它的影响，这绝不是想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。&lt;/p&gt;
&lt;p&gt;    当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明.&lt;/p&gt;
&lt;p&gt;七 关于命令&lt;/p&gt;
&lt;p&gt;    通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：&lt;/p&gt;
&lt;p&gt;    @echo 正在编译XXX模块&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;当make执行时，会输出“正在编译XXX模块&amp;hellip;&amp;hellip;”字串，但不会输出命令，如果没有“@”，那么，make将输出：&lt;/p&gt;
&lt;p&gt;    echo 正在编译XXX模块&amp;hellip;&amp;hellip;     正在编译XXX模块&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;如果make执行时，带入make参数“-n”或“&amp;ndash;just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于调试Makefile，看看书写的命令执行起来是什么样子的或是什么顺序的,而make参数“-s”或“&amp;ndash;slient”则是全面禁止命令的显示。&lt;/p&gt;
&lt;p&gt;    如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令。比如第一条命令是cd，希望第二条命令在cd之后的基础上运行，那么就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：&lt;/p&gt;
&lt;p&gt;    示例一：         exec:                 cd /home/hchen                 pwd&lt;/p&gt;
&lt;p&gt;    示例二：         exec:                 cd /home/hchen; pwd&lt;/p&gt;
&lt;p&gt;当执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。&lt;/p&gt;
&lt;p&gt;    每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;/p&gt;
&lt;p&gt;    有些时候，命令的出错并不表示就是错误的。例如mkdir，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。之所以使用mkdir的意思就是一定要有这样的一个目录，只要这个目录存在了,就不希望mkdir出错而终止规则的运行。为了做到这一点，忽略命令的出错，可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：&lt;/p&gt;
&lt;p&gt;   clean:             -rm -f *.o&lt;/p&gt;
&lt;p&gt;还有一个全局的办法是，给make加上“-i”或是“&amp;ndash;ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。还有一个要提一下的make的参数的是“-k”或是“&amp;ndash;keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。&lt;/p&gt;
&lt;p&gt;    在一些大的工程中，会把不同模块或是不同功能的源文件放在不同的目录中，这种情况可以在每个目录中都书写一个该目录的Makefile，例如，有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么总控的Makefile可以这样书写：&lt;/p&gt;
&lt;p&gt;    subsystem:             cd subdir &amp;amp;&amp;amp; $(MAKE)&lt;/p&gt;
&lt;p&gt;其等价于：&lt;/p&gt;
&lt;p&gt;    subsystem:             $(MAKE) -C subdir&lt;/p&gt;
&lt;p&gt;这两个例子的意思都是先进入“subdir”目录，然后执行make命令。总控Makefile的变量可以传递到下级的Makefile中，但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。&lt;/p&gt;
&lt;p&gt;如果要传递变量到下级Makefile中，那么可以使用这样的声明：&lt;/p&gt;
&lt;p&gt;    export&lt;/p&gt;
&lt;p&gt;如果不想让某些变量传递到下级Makefile中，那么可以这样声明：&lt;/p&gt;
&lt;p&gt;    unexport&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;    示例一：&lt;/p&gt;
&lt;p&gt;        export variable = value&lt;/p&gt;
&lt;p&gt;        其等价于：&lt;/p&gt;
&lt;p&gt;        variable = value         export variable&lt;/p&gt;
&lt;p&gt;        其等价于：&lt;/p&gt;
&lt;p&gt;        export variable := value&lt;/p&gt;
&lt;p&gt;        其等价于：&lt;/p&gt;
&lt;p&gt;        variable := value         export variable&lt;/p&gt;
&lt;p&gt;    示例二：&lt;/p&gt;
&lt;p&gt;        export variable += value&lt;/p&gt;
&lt;p&gt;        其等价于：&lt;/p&gt;
&lt;p&gt;        variable += value         export variable&lt;/p&gt;
&lt;p&gt;如果要传递所有的变量，那么，只要一个export就行了,后面什么也不用跟，表示传递所有的变量。&lt;/p&gt;
&lt;p&gt;八 变量&lt;/p&gt;
&lt;p&gt;两种高级用法:&lt;/p&gt;
&lt;p&gt;         我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;    foo := a.o b.o c.o     bar := $(foo:.o=.c)&lt;/p&gt;
&lt;p&gt;这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有的“.o”字串“结尾”全部替换成“.c”，所以“$(bar)”的值就是“a.c b.c c.c”。&lt;/p&gt;
&lt;p&gt;第二种高级用法是——“把变量的值再当成变量”。先看一个例子：&lt;/p&gt;
&lt;p&gt;    x = y     y = z     a := $($(x))&lt;/p&gt;
&lt;p&gt;在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）&lt;/p&gt;
&lt;p&gt;我们还可以使用更多的层次：&lt;/p&gt;
&lt;p&gt;    x = y     y = z     z = u     a := $($($(x)))&lt;/p&gt;
&lt;p&gt;这里的$(a)的值是“u”.&lt;/p&gt;
&lt;p&gt;    还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令.定义是以endef关键字结束,其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。命令需要以[Tab]键开头，define定义的命令也不例外.&lt;/p&gt;
&lt;p&gt;下面的这个示例展示了define的用法：&lt;/p&gt;
&lt;p&gt;define two-lines     echo foo     echo $(bar) endef&lt;/p&gt;
&lt;p&gt;九 目标变量&lt;/p&gt;
&lt;p&gt;    前面所有的在Makefile中定义的变量都是“全局变量”，在整个文件，都可以访问这些变量。当然，“自动化变量”除外，如“$&amp;lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。&lt;/p&gt;
&lt;p&gt;    当然，我们同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效,而不会影响规则链以外的全局变量的值。&lt;/p&gt;
&lt;p&gt;其语法是：&lt;/p&gt;
&lt;p&gt;    :&lt;/p&gt;
&lt;p&gt;    : overide&lt;/p&gt;
&lt;p&gt;可以是各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。&lt;/p&gt;
&lt;p&gt;这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：&lt;/p&gt;
&lt;p&gt;    prog : CFLAGS = -g     prog : prog.o foo.o bar.o             $(CC) $(CFLAGS) prog.o foo.o bar.o&lt;/p&gt;
&lt;p&gt;    prog.o : prog.c             $(CC) $(CFLAGS) prog.c&lt;/p&gt;
&lt;p&gt;    foo.o : foo.c             $(CC) $(CFLAGS) foo.c&lt;/p&gt;
&lt;p&gt;    bar.o : bar.c             $(CC) $(CFLAGS) bar.c&lt;/p&gt;
&lt;p&gt;在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”.&lt;/p&gt;
&lt;p&gt;十 条件判断语法&lt;/p&gt;
&lt;p&gt;条件表达式的语法为：&lt;/p&gt;
&lt;p&gt;        else         endif&lt;/p&gt;
&lt;p&gt;其中表示条件关键字，如“ifeq”。这个关键字有四个。&lt;/p&gt;
&lt;p&gt;第一个是我们前面所见过的“ifeq”&lt;/p&gt;
&lt;p&gt;    ifeq (, )     ifeq &amp;rsquo;&amp;rsquo; &amp;rsquo;&amp;rsquo;     ifeq &amp;quot;&amp;quot; &amp;quot;&amp;quot;     ifeq &amp;quot;&amp;quot; &amp;rsquo;&amp;rsquo;     ifeq &amp;rsquo;&amp;rsquo; &amp;quot;&amp;quot;&lt;/p&gt;
&lt;p&gt;比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：&lt;/p&gt;
&lt;p&gt;    ifeq ($(strip $(foo)),)         endif&lt;/p&gt;
&lt;p&gt;这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么就生效。&lt;/p&gt;
&lt;p&gt;第二个条件关键字是“ifneq”。&lt;/p&gt;
&lt;p&gt;第三个条件关键字是“ifdef”。语法是：&lt;/p&gt;
&lt;p&gt;    ifdef&lt;/p&gt;
&lt;p&gt;如果变量的值非空，那到表达式为真。否则，表达式为假。当然，同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：&lt;/p&gt;
&lt;p&gt;    示例一：     bar =     foo = $(bar)     ifdef foo     frobozz = yes     else     frobozz = no     endif&lt;/p&gt;
&lt;p&gt;    示例二：     foo =     ifdef foo     frobozz = yes     else     frobozz = no     endif&lt;/p&gt;
&lt;p&gt;第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。&lt;/p&gt;
&lt;p&gt;第四个条件关键字是“ifndef”。&lt;/p&gt;
&lt;p&gt;    在这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。&lt;/p&gt;
&lt;p&gt;    特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。&lt;/p&gt;
&lt;p&gt;十一 foreach 函数     foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，它的语法是：&lt;/p&gt;
&lt;p&gt;    $(foreach ,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;list&amp;gt;,&amp;lt;text&amp;gt;)这个函数的意思是，把参数

&amp;lt;list&amp;gt;中的单词逐一取出放到参数&amp;lt;var&amp;gt;所指定的变量中，然后再执行&amp;lt;text&amp;gt;所包含的表达式。每一次&amp;lt;text&amp;gt;会返回一个字符串，循环过程中，&amp;lt;text&amp;gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&amp;lt;text&amp;gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。&amp;amp;nbsp; &amp;amp;nbsp;所以，&amp;lt;var&amp;gt;最好是一个变量名，&amp;lt;/var&amp;gt;

&amp;lt;list&amp;gt;可以是一个表达式，而&amp;lt;text&amp;gt;中一般会使用&amp;lt;var&amp;gt;这个参数来依次枚举
&amp;lt;list&amp;gt;中的单词。举个例子：&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;names := a b c d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;    files := $(foreach n,$(names),$(n).o) &lt;/p&gt;
&lt;p&gt;  $(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。 &lt;/p&gt;
&lt;p&gt;十二 检查规则&lt;/p&gt;
&lt;p&gt;有时候，我们不想让我们的makefile中的规则执行起来，只想检查一下命令，或是执行的序列。可以使用make命令的下述参数：&lt;/p&gt;
&lt;p&gt;    “-n”     “&amp;ndash;just-print”     “&amp;ndash;dry-run”&lt;/p&gt;
&lt;p&gt;------------------   &lt;/p&gt;
&lt;p&gt;    “-t”     “&amp;ndash;touch”     这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;    “-W ”     这个参数需要指定一个文件。一般是是源文件（或依赖文件），make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。假定目标需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。&lt;/p&gt;
&lt;p&gt;十三 make的其他参数&lt;/p&gt;
&lt;p&gt;“-B” “&amp;ndash;always-make” 认为所有的目标都需要更新（重编译）。&lt;/p&gt;
&lt;p&gt;“-C&lt;/p&gt;
&lt;p&gt;” “&amp;ndash;directory=&lt;/p&gt;
&lt;p&gt;” 指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。&lt;/p&gt;
&lt;p&gt;“-i” “&amp;ndash;ignore-errors” 在执行时忽略所有的错误。&lt;/p&gt;
&lt;p&gt;“-k” “&amp;ndash;keep-going” 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。 十四 隐含规则&lt;/p&gt;
&lt;p&gt;    在使用Makefile时，有一些会经常使用，而且使用频率非常高的东西，比如，编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）,这些就是早先约定了的，不需要我们再写出来的规则。&lt;/p&gt;
&lt;p&gt;    “隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，即使Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，根本就不用写出来，make会自动推导出这种规则，并生成需要的[.o]文件。&lt;/p&gt;
&lt;p&gt;    “隐含规则”会使用一些系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。&lt;/p&gt;
&lt;p&gt;1 使用隐含规则&lt;/p&gt;
&lt;p&gt;    如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：&lt;/p&gt;
&lt;p&gt;    foo : foo.o bar.o             cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)&lt;/p&gt;
&lt;p&gt;这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。&lt;/p&gt;
&lt;p&gt;    make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：&lt;/p&gt;
&lt;p&gt;    foo.o : foo.c             cc –c foo.c $(CFLAGS)     bar.o : bar.c         cc –c bar.c $(CFLAGS)&lt;/p&gt;
&lt;p&gt;因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。&lt;/p&gt;
&lt;p&gt;    当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。&lt;/p&gt;
&lt;p&gt;    还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：&lt;/p&gt;
&lt;p&gt;    foo.o : foo.p&lt;/p&gt;
&lt;p&gt;依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。当然，我们也可以使用make的参数“-r”或“&amp;ndash;no-builtin-rules”选项来取消所有的预设置的隐含规则。&lt;/p&gt;
&lt;p&gt;1 编译C程序的隐含规则 “.o”的目标的依赖目标会自动推导为“.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”&lt;/p&gt;
&lt;p&gt;2 编译C++程序的隐含规则 “.o”的目标的依赖目标会自动推导为“.cc”或是“.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）&lt;/p&gt;
&lt;p&gt;3 链接Object文件的隐含规则 “”目标依赖于“.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：&lt;/p&gt;
&lt;p&gt;    x : y.o z.o&lt;/p&gt;
&lt;p&gt;并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：&lt;/p&gt;
&lt;p&gt;    cc -c x.c -o x.o     cc -c y.c -o y.o     cc -c z.c -o z.o     cc x.o y.o z.o -o x     rm -f x.o     rm -f y.o     rm -f z.o&lt;/p&gt;
&lt;p&gt;如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
