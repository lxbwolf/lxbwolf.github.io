<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nginx-e9-85-8d-e7-bd-ae-e4-b8-ad-e7-9a-84location" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/02/nginx-e9-85-8d-e7-bd-ae-e4-b8-ad-e7-9a-84location/" class="article-date">
  <time datetime="2018-06-02T14:30:30.000Z" itemprop="datePublished">2018-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/02/nginx-e9-85-8d-e7-bd-ae-e4-b8-ad-e7-9a-84location/">nginx配置中的location</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>语法</strong><br><code>location [=|~|~*|^~] /uri/ {...}</code> 上下文: <code>server</code> 此命令随URL 不同而接受不同的结构. 可以配置使用常规字符串和正则表达式. 若使用正则表达式, 则必须使用<code>~*</code>前缀(选择不区分大小写的匹配) 或<code>~</code>前缀(区分大小写的匹配)</p>
<ol>
<li><code>=</code> 表示<code>uri</code> 以某个常规字符串开头, 理解为匹配url 路径即可. nginx 不对url 做编码, 因此请求为<code>/static/%20%/aa</code> 可以被规则<code>^~ /static/ /aa</code> (有空格) 匹配到.</li>
<li><code>~</code> 表示区分大小写的正则匹配</li>
<li><code>~*</code> 表示不区分大小写的正则匹配</li>
<li><code>!~</code> 和 <code>!~*</code> 分别为区分大小写不匹配 和 不区分大小写不匹配 的正则</li>
<li><code>/</code> 通用匹配, 任何请求都会匹配到</li>
</ol>
<p>多个<code>location</code> 配置的情况下, 匹配顺序为: 先匹配<code>=</code>, 其次匹配<code>^~</code>, 再匹配按文件中顺序的正则匹配, 最后匹配<code>/</code>. 当有匹配成功的时候, 停止匹配, 按当前匹配规则处理请求. <strong>例1:</strong></p>
<pre><code>location = / {
    # 规则A
}

location = /login {
    # 规则B
}

location ^~ /static {
    # 规则C
}

location ~ \.(gif|jpg|png|js|css)$ {
    # 规则D
}

location ~* \.png$ {
    # 规则E
}

location !~ \.xhtml$ {
    # 规则F
}

location !~* \.xhtml$ {
    # 规则G
}

location / {
    # 规则H
}</code></pre><p>产生效果如下: 1. 访问<code>/</code> 根目录, 如<code>http://localhost/</code> 将匹配规则A 2. 访问<code>http://localhost/login</code> 将匹配规则B; <code>http://localhost/register</code> 将匹配规则H 3. 访问<code>http://localhost/static/a.html</code> 将匹配规则C 4. 访问<code>http://localhost/a.png</code> 讲匹配规则D 和规则E, 但规则D 顺序优先, 规则E 不起作用 5. 访问<code>http://localhost/static/c.png</code> 优先匹配到规则C 6. 访问<code>http://localhost/a.PNG</code> 将匹配规则E 7. 访问<code>http://localhost/a.xhtml</code> 不会匹配到规则F 和规则G, <code>http://localhost/a.XHTML</code> 不会匹配到规则G 8. 访问<code>http://localhost/category/id/1111</code> 匹配到规则H, 因为以上规则都不匹配, 这个时候应该是nginx 转发给后端应用服务器, 如FastCGI(php), tomcat(jsp), nginx 作为反向代理服务器存在. 所以实际使用中, 通常有至少三个匹配规则定义, 如下:</p>
<pre><code># 第一个必选规则 直接匹配网站根, 通过域名访问网站首页比较频繁, 使用这个会加速处理; 这里直接转发给后端应用服务器了, 也可以是一个静态首页
location = / {
    proxy_pass http://tomcat:8080/index
}

# 第二个必选规则 处理静态文件请求, 这是nginx 作为http 服务器的强项. 有如下两种配置模式, 目录匹配或后缀匹配, 任选其一或搭配使用
location ^~ /static/ {
    root /webroot/static/;
}
location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ {
    root /webroot/res/;
}

# 第三个必选规则 通用规则, 用来转发动态请求到后端应用服务器. 非静态文件请求就默认是动态请求. 
location / {
    proxy_pass http://tomcat:8080/
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/02/nginx-e9-85-8d-e7-bd-ae-e4-b8-ad-e7-9a-84location/" data-id="ck10vany3002kzxz2cl46oc85" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx-e5-af-bb-e6-89-beindex-e5-8e-9f-e7-90-86" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/01/nginx-e5-af-bb-e6-89-beindex-e5-8e-9f-e7-90-86/" class="article-date">
  <time datetime="2018-06-01T14:32:04.000Z" itemprop="datePublished">2018-06-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/01/nginx-e5-af-bb-e6-89-beindex-e5-8e-9f-e7-90-86/">nginx 寻找index 原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1. nginx 是怎么找index.php 文件的</strong><br>当nginx发现需要<code>/web/echo/index.php</code> 文件时, 就会向内核发起 IO 系统调用(因为要跟硬件打交道, 这里的硬件是指硬盘, 通常需要靠内核来操作, 而内核提供的这些功能是通过系统调用来实现的), 告诉内核, 我需要这个文件, 内核从<code>/</code> 开始找到<code>web</code> 目录, 再在<code>web</code> 目录下找到<code>echo</code> 目录, 最后在<code>echo</code> 目录下找到<code>index.php</code> 文件, 于是把这个<code>index.php</code> 从硬盘上读取到内核自身的内存空间, 然后再把这个文件复制到nginx进程所在的内存空间, 于是 nginx就得到了自己想要的文件了 <strong>2. 寻找文件在文件系统层面是怎么操作的</strong><br>如, nginx 需要得到<code>/web/echo/index.php</code> 这个文件 每个分区(像ext3 等文件系统, block块是文件存储的最小单元, 默认是4096字节) 都是包含元数据区和数据区, 每个文件在元数据区都有元数据条目(一般是128字节大小), 每个条目都有一个编号, 称之为 inode(index node), 这个inode 里包含 文件类型, 权限, 连接次数, 属主和数组的 ID&amp;时间戳, 这个文件占据了哪些磁盘块也就是块的编号(block, 每个文件可以占用多个 block, 且 block 不一定是连续的, 每个 block 都有编号), 如下图:<img src="https://img-blog.csdn.net/20180616013228714?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4YndvbGY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> 目录其实也是普通文件, 也需要占用磁盘块, 目录不是一个容器. 默认创建的目录大小为4096字节, 即只需要占用一个磁盘块, 但这是不确定的. 所以要找到目录也是需要到元数据区里找到对应的条目, 只要找到对应的inode就可以找到目录所占用的磁盘块. 目录里存着一张表(映射表), 里面放着 目录或文件的名称和对应的inode号, 如下:</p>
<p>-</p>
<p>-</p>
<p>文件名称(只是字符串)</p>
<p>inode 号</p>
<p>test.txt</p>
<p>100</p>
<p>假如</p>
<pre><code>/           在数据区占据1, 2号 block, `/` 其实也是一个目录, 里面有两个目录, web 和 111
web         占据5号 block, 是目录, 里面有2个目录 echo 和 data
echo        占据11号 block, 是目录, 里面有一个文件 index.php
index.php   占据15, 16号 block, 是文件</code></pre><p>其在文件系统中分布如下图: <img src="https://img-blog.csdn.net/2018061601462786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4YndvbGY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"> 那么内核究竟是怎么找到<code>index.php</code> 这个文件的呢? 内核拿到 nginx 的 IO 系统调用要获取<code>/web/echo/index.php</code> 这个文件请求之后,</p>
<pre><code>1. 内核读取元数据区 / 的inode, 从 inode 里读取 / 所对应的数据块的编号, 然后在数据区找到其对应的块(1, 2号块), 读取1号块上的映射表找到 web 这个名称在元数据区对应的 inode 号
2. 内核读取 web 对应的 inode(3号), 从中得到 web 在数据区对应的块是5号块, 于是到数据区找到5号块, 从中读取映射表, 知道 echo 对应的 inode 是5号, 于是到元数据区找到5号 inode
3. 内核读取5号 inode, 得到 echo 在数据区对应的事11号块, 于是到数据区读取11号块得到映射表, 得到index.php 对应的 inode 事9号
4. 内核到元数据区读取9号 inode, 得到 index.php 对应的事15号和16号数据块, 于是就到数据区域找到15 16号块, 读取其中的内容, 得到 index.php 的完整内容</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/01/nginx-e5-af-bb-e6-89-beindex-e5-8e-9f-e7-90-86/" data-id="ck10vany2002izxz2w9ks0vn3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http-e5-8d-8f-e8-ae-ae-e7-ac-94-e8-ae-b0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/30/http-e5-8d-8f-e8-ae-ae-e7-ac-94-e8-ae-b0/" class="article-date">
  <time datetime="2018-05-30T15:11:26.000Z" itemprop="datePublished">2018-05-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/http-e5-8d-8f-e8-ae-ae-e7-ac-94-e8-ae-b0/">HTTP协议笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP协议的特点: 1. 支持客户端/服务器模式 2. 简单快速: 客户端向服务器请求服务时, 只需传送请求方法和路径. 请求方法常用的有GET, HEAD, POST. 每种方法规定了客户端与服务器联系的类型. 由于HTTP协议简单, 使得HTTP服务器的程序规模小, 因而通信速度很快. 3. 灵活: HTTP 允许传输任意类型的数据对象. 正在传输的类型由Content-Type加以标记. 4. 无连接: 限制每次连接只处理一个请求. 服务器处理完客户端的请求, 并收到客户端的应答后, 即断开连接. 采用着用方式可以节省传输时间. 5. 无状态: 无状态是指协议对于事务处理没有记忆能力. 缺少状态意味着如果后续处理需要前面的信息, 则它必须重传, 这样可能导致每次传送的数据量增大. 另一方面, 在服务器不需要先前信息时, 它的应答就较快.</p>
<h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>HTTP是一种基于请求与响应模式的, 无状态的, 应用层的协议, 常基于TCP的连接方式, HTTP1.1版本中给出一种持续连接的机制, 绝大多数的web开发, 都是构建在HTTP协议之上的web应用.</p>
<p>HTTP URL(URL是一种特殊类型的URI, 包含了用于查找某个资源的足够的信息)的格式如下: <code>http://host[:port][abs_path]</code></p>
<ul>
<li>http 表示要通过HTTP协议来定位网络资源</li>
<li>host 表示合法的Internet主机域名或者IP地址</li>
<li>port 指定端口号, 缺省端口为80</li>
<li>abs_path 指定请求资源的URI</li>
<li>若URI 中没有给出abs_path, 那当它作为请求URI时, 必须以”/“ 的形式给出, 通常这个工作浏览器会自动完成</li>
</ul>
<h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><p>HTTP请求由三部分组成: 请求行, 消息报头, 请求正文</p>
<h6 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h6><p>以一个方法符号开头, 以空格分开, 后面跟请求的URI和协议的版本, 格式如下: <code>Method Request-URI HTTP-Version CRLF</code></p>
<p>请求方法有以下几种 - GET 请求获取Request-URI 所标识的资源 - POST 在Request-URI 表标识的资源后附加新的数据 - HEAD 请求获取由Request-URI 所标识的资源的响应消息报头 - PUT 请求服务器存储一个资源, 并用Request-URI 作为其标识 - DELETE 请求服务器删除Request-URI 所标识的资源 - TRACE 请求服务器会送收到的请求信息, 主要用于测试或诊断 - CONNECT 保留将来使用 - OPTIONS 请求查询服务器的性能, 或查询与资源相关的选项和需求</p>
<h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><p>HTTP响应由三部分组成: 状态行, 消息报头, 响应正文</p>
<h6 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h6><p>格式: <code>HTTP-Version Status-Code Reason-Phrase CRLF</code></p>
<p>状态码由三位数字组成, 第一个数字定义了响应的类别: - 1xx: 指示信息 – 表示请求已接受, 继续处理 - 2xx: 成功 – 表示请求已被成功接收, 理解, 接受 - 3xx: 重定向 – 要完成请求必须进行更进一步的操作 - 4xx: 客户端错误 – 请求有语法错误或请求无法实现 - 5xx: 服务器端错误 – 服务器未能实现合法的请求</p>
<h5 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h5><p>HTTP 消息由客户端到服务器的请求和服务器到客户端的响应组成. 请求消息和相应消息都是由开始行(对于请求消息, 开始行就是请求行, 对于响应消息, 开始行就是状态行), 消息报头(可选), 空行(只有CRLF的行), 消息正文(可选) 组成</p>
<p>HTTP 消息报头包括 普通报头, 请求报头, 响应报头, 实体报头 每一个报头域都是由<code>名字 + &quot;:&quot; + 空格 + 值</code> 组成, 消息报头域的名字是大小写无关的.</p>
<h6 id="普通报头"><a href="#普通报头" class="headerlink" title="普通报头"></a>普通报头</h6><p>在普通报头中, 有少数报头域用于所有的请求和响应消息, 但并用于被传输的实体, 只用于传输的消息 <strong>例:</strong> Cache-Control 用于指定缓存指令, 缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现), 且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制), HTTP1.0使用类似的报头域为Pragma. 请求时的缓存指令包括: no-cache(用于指示请求或相应消息不能缓存), no-store, max-age, max-stale, min-fresh, only-if-cached; 响应时的缓存指令包括: public, private, no-cache, no-store, no-transform, must-revalidate, proxy-revalidate, max-age, s-maxage <strong>eg:</strong> 为了指示IE浏览器(客户端)不要缓存页面, 服务器端的JSP程序可以编写如下: <code>response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</code> 或 <code>response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</code> 两者作用相同, 在发送的响应消息中设置普通报头域: Cache-Control: no-cache.</p>
<h6 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h6><p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息.</p>
<p>常用的请求报头域: <em>Accept</em> Accept 请求报头域用于指定客户端接收哪些类型的信息. 如: <code>Accept:image/gif</code>, 表明客户端希望接收GIF图像格式的资源; <code>Accept:text/html</code>, 表明客户端希望接受html 文本</p>
<p><em>Accept-Charset</em> 指定客户端接受的字符集. 如: <code>Accept-Charset:iso-8859-1,GB2312</code>. 如果请求消息中没有设置这个域, 缺省是任何字符集都可以接受.</p>
<p><em>Accept-Encoding</em> 指定可接受的内容编码. 如<code>Accept-Encoding:gzip.deflate</code> 缺省是任何内容编码都可以接受</p>
<p><em>Accept-Language</em> 指定一种自然语言. 如 <code>Accept-Language:zh-cn</code> 缺省是任何语言都可以接受</p>
<p><em>Authorization</em> 用于证明客户端有权查看某个资源. 当浏览器访问一个页面时, 如果收到服务器的响应代码为401, 可以发送一个包含Authorization请求报头域的请求, 要求服务器对其进行验证</p>
<p><em>Host</em>(发送请求时, 该报头域是必需的) 指定被请求资源的Internet主机和端口号, 通常从HTTP URL中提取出来</p>
<p><em>User-Agent</em> 允许客户端将它的操作系统, 浏览器和其他属性告诉服务器. 不过这个报头域不是必需的, 如果我们自己写一个浏览器, 不使用User-Agent 请求报头域, 那么服务器端就无法得知我们的信息了.</p>
<p><em>请求报头示例</em></p>
<pre><code>GET /form.html HTTP/1.1 (CRLF)
Accept:image/gif,image/x-xbigmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)
Accept-Language:zh-cn (CRLF)
Acdept-Encoding:gzip,deflate (CRLF)
If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)
If-None-Match:Mozilla/4.0(compatible;MSIE6.0,Windows NT 5.0) (CRLF)
Host:www.guet.edu.cn (CRLF)
Connection:Keep-Alive (CRLF)
(CRLF)</code></pre><h6 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h6><p>响应报头允许服务器传递不能放在状态行中的附加响应信息, 以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息</p>
<p><em>Location</em> 重定向接受者到一个新的位置. Location响应报头域常用在更换域名的时候</p>
<p><em>Server</em> 包含了服务器用来处理请求的软件信息. 与<code>User-Agent</code> 请求报头域是相对应的 例: <code>Server:Apache-Coyote/1.1</code></p>
<p><em>WWW-Authenticate</em> WWW-Authenticate 响应报头域必须包含在401响应消息中, 客户端收到401响应消息的时候, 并发送Authorization报头域请求服务器对其进行验证时, 服务端响应报头就包含该报头域 例: <code>WWW-Authenticate:Basic realm=&quot;Basic Auth Test!</code></p>
<h6 id="实体报头"><a href="#实体报头" class="headerlink" title="实体报头"></a>实体报头</h6><p>请求和响应消息都可以传送一个实体. 一个实体由实体报头域和实体正文组成, 但并不是实体报头域和实体正文要在一起发送, 可以只发送实体报头域. 实体报头定义了关于实体正文(如: 有无实体正文) 和请求所标识的资源的元信息.</p>
<p><em>Content-Encoding</em> 被用作媒体类型的修饰符, 它的值指示了已经被应用到实体正文的附加内容的编码, 因而要获得Content-Type 报头域中所引用的媒体类型, 必须采用相应的解码机制.</p>
<p><em>Content-Language</em> 描述了资源所用的自然语言. 没有设置该域则认为实体内容将提供给所有的语言阅读</p>
<p><em>Content-Length</em> 指明实体正文的长度, 以字节方式存储的十进制数字来表示</p>
<p><em>Content-Type</em> 指明发送给接受者的实体正文的媒体类型 例: <code>Content-Type:text/html;charset=ISO-8859-1</code> <code>Content-Type:text/html;charset=GB2312</code></p>
<p><em>Last-Modified</em> 指示资源的最后修改日期和时间</p>
<p><em>Expires</em> 给出响应国企的日期和时间. 为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时, 直接从缓存中加载, 缩短响应时间和降低服务器负载) 的页面, 我们可以使用Expires 实体报头域指定页面过期的时间. 例: <code>Expires:Thu, 15 Sep 2006 16:23:12 GMT</code></p>
<p>HTTP1.1 的客户端和缓存必须将其他非法的日期格式(包括0) 看作已经过期 为了让浏览器不要缓存页面, 我们也可以利用Expires 实体报头域设置为0, jsp中程序如下: <code>response.setDateHeader(&quot;Expires&quot;, &quot;0&quot;);</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/30/http-e5-8d-8f-e8-ae-ae-e7-ac-94-e8-ae-b0/" data-id="ck10vanzy004yzxz27i8jicij" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qt-e5-90-8c-e6-ad-a5-e6-96-b9-e5-bc-8f-e5-8f-91-e9-80-81post-e8-af-b7-e6-b1-82" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/22/qt-e5-90-8c-e6-ad-a5-e6-96-b9-e5-bc-8f-e5-8f-91-e9-80-81post-e8-af-b7-e6-b1-82/" class="article-date">
  <time datetime="2018-05-22T03:12:38.000Z" itemprop="datePublished">2018-05-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/22/qt-e5-90-8c-e6-ad-a5-e6-96-b9-e5-bc-8f-e5-8f-91-e9-80-81post-e8-af-b7-e6-b1-82/">qt 同步方式发送post 请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不成功的方式: 1. QNetworkReply的isFinished()函数, 通过while循环判断reply是否已经结束, 结束后再调用readAll()读取响应信息, 结果与判断isRunning() 方式结果一样, 都会进入死循环, 没有响应. 2. QNetworkReply继承自QIODevice, 尝试调用QIODevice的waitForReadyRead()方法, 结果不阻塞, 直接返回</p>
<p>成功的方式: 使用QEventLoop来阻塞运行, 知道信号发出</p>
<pre><code>QNetworkReply *reply = _manager-&gt;post(QNetworkRequest(QUrl(SERVER_URL)), data);
QByteArray responseData;
QEventLoop eventLoop;
connect(_manager, SIGNAL(finished(QNetworkReply*)), &amp;eventLoop, SLOT(quit()));
eventLoop.exec();       //block until finish
responseData = reply-&gt;readAll();</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/22/qt-e5-90-8c-e6-ad-a5-e6-96-b9-e5-bc-8f-e5-8f-91-e9-80-81post-e8-af-b7-e6-b1-82/" data-id="ck10vany7002rzxz2qlkhux1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qt-e7-a8-8b-e5-ba-8f-e6-89-93-e5-8c-85" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/03/qt-e7-a8-8b-e5-ba-8f-e6-89-93-e5-8c-85/" class="article-date">
  <time datetime="2018-05-03T15:03:09.000Z" itemprop="datePublished">2018-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Qt/">Qt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/03/qt-e7-a8-8b-e5-ba-8f-e6-89-93-e5-8c-85/">qt 程序打包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="设置程序图标"><a href="#设置程序图标" class="headerlink" title="设置程序图标"></a>设置程序图标</h6><ol>
<li>把ico文件放到源文件目录下, 命名为”test.ico”</li>
<li>创建一个<code>myico.rc</code> 文件, 输入如下内容 <code>IDI_ICON1 ICON DISCARDABLE &quot;test.ico&quot;</code></li>
<li>在pro文件写入 <code>RC_FILE = myico.rc</code></li>
<li>执行qmake, 编译</li>
</ol>
<h6 id="编译-打包"><a href="#编译-打包" class="headerlink" title="编译, 打包"></a>编译, 打包</h6><ol>
<li>选择release编译运行</li>
<li>将生成的exe文件放到某个路径下, 如 <code>Desktop/Test</code></li>
<li>在cmd里, 进入到exe存放路径, 使用wendeployqt工具拷贝exe运行需要的dll</li>
<li>使用Inno Setup Compiler生成安装文件</li>
</ol>
<h6 id="Inno-Setup-工具使用注意事项"><a href="#Inno-Setup-工具使用注意事项" class="headerlink" title="Inno Setup 工具使用注意事项"></a>Inno Setup 工具使用注意事项</h6><ul>
<li>添加主执行文件外的其他应用程序文件夹下的文件时, 需要编辑一次, 重新指定目标子文件夹</li>
<li>编译脚本为<code>*.iss</code> 文件, 编译后默认在源exe的Base 目录下生成Output文件夹, 指定的setup.exe文件生成在Output 文件夹下</li>
<li>Inno Setup 工具基础版不支持中文. 如需显示中文, 需要找汉化版</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/03/qt-e7-a8-8b-e5-ba-8f-e6-89-93-e5-8c-85/" data-id="ck10vanyb0030zxz2n3vrnhjs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-gerrit-apache-e5-ae-89-e8-a3-85" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/02/gerrit-apache-e5-ae-89-e8-a3-85/" class="article-date">
  <time datetime="2018-05-02T15:56:55.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/02/gerrit-apache-e5-ae-89-e8-a3-85/">Gerrit + apache 安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用gerrit自带的数据库h2, 验证方式为HTTP, SMTP 服务器未配置</p>
<h6 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h6><p>可直接从yum 源安装</p>
<h6 id="gerrit-安装"><a href="#gerrit-安装" class="headerlink" title="gerrit 安装"></a>gerrit 安装</h6><p>先添加gerrit 用户. gerrit 从2.10开始, 换成了新版界面. 几乎国内所有的镜像都会下载失败, 需要翻墙下载. 下载完成后, 初始化命令为: <code>java -jar gerrrit-war init -d /home/gerrit/repository</code></p>
<p>初始化启动时, “Authentication method” 设为”http” ,其他默认 “Listen on port [8080]“ 可用默认, 如端口被占用, 初始化后也可在配置文件修改</p>
<h6 id="apache-安装"><a href="#apache-安装" class="headerlink" title="apache 安装"></a>apache 安装</h6><p>直接从yum源安装 apache名字为httpd, 服务名也是httpd. 服务启动后, 默认以apache用户运行. 如需访问其他用户的文件, 如<code>/home/gerrit/repository/htpasswd</code>, 需要确保apache 用户有足够的权限</p>
<h6 id="配置-apache"><a href="#配置-apache" class="headerlink" title="配置 apache"></a>配置 apache</h6><p>修改 apache 的conf 文件, 一般路径为<code>/etc/httpd/conf/httpd.conf</code> windows 下的配置文件路径为 <code>INSTALL_DIR/conf/httpd.conf</code></p>
<p>去掉下面几行的注释</p>
<pre><code>LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_connect_module modules/mod_proxy_connect.so
LoadModule proxy_http_module modules/mod_proxy_http.so
LoadModule proxy_ftp_module modules/mod_proxy_ftp.so
LoadModule negotiation_module modules/mod_negotiation.so</code></pre><p>在最后追加下面配置</p>
<pre><code>&lt;VirtualHost *:8080&gt;  
  ServerName v3server
  ProxyRequests Off  
  ProxyVia Off  
  ProxyPreserveHost On  


  &lt;Proxy *:8080&gt;  
        Order deny,allow  
        Allow from all  
  &lt;/Proxy&gt;  


    &lt;Location /login/&gt;
      AuthType Basic
      AuthName &quot;Gerrit Code Review&quot;
      Require valid-user
     AuthUserFile D:/git/htpasswd
    &lt;/Location&gt;


  ProxyPass / http://10.14.132.179:9080/
  ProxyPassReverse / http://10.14.132.179:9080/
&lt;/VirtualHost&gt;</code></pre><p>如端口被占用, 修改conf文件的”Listen 8080” 字段, 换成其他的端口 查看某个端口是否被占用 : <code>netstat -lnp | grep 8080</code> <code>ProxyPass</code> 和 <code>proxyPassReverse</code> 的端口需与gerrit的conf文件里端口一致</p>
<h6 id="配置-gerrit"><a href="#配置-gerrit" class="headerlink" title="配置 gerrit"></a>配置 gerrit</h6><p>修改<code>GERRIT_DIR/etc/gerrit.config</code> 文件</p>
<pre><code>[gerrit]
basePath = git
canonicalWebUrl = http://10.14.132.179:9080/
[database]
type = H2
database = db/ReviewDB
[auth]
type = HTTP
logoutUrl = http://aa:aa@10.14.132.179:8080/
[sendemail]
smtpServer = smtp.163.com
smtpUser = useremail@163.com
  smtpPass = userpass
  from = useremail@163.com
[container]
user = admin
javaHome = C:\\Program Files\\Java\\jdk1.6.0_27\\jre
[sshd]
listenAddress = *:29418
[httpd]
listenUrl = http://10.14.132.179:9080/
[cache]
directory = cache</code></pre><p>需要修改的内容: - canonicalWebUrl - auth/type</p>
<p>需要注意: canonicalWebUrl 和 listenAddress 不是8080. apache 的端口和 gerrit 的端口是不同的, 用户访问地址为 apache 的地址</p>
<h6 id="启动-gerrit"><a href="#启动-gerrit" class="headerlink" title="启动 gerrit"></a>启动 gerrit</h6><p><code>GERRIT_DIR/bin/gerrit.sh start</code></p>
<h6 id="启动-apache"><a href="#启动-apache" class="headerlink" title="启动 apache"></a>启动 apache</h6><p><code>service httpd start</code></p>
<h6 id="添加账号和密码"><a href="#添加账号和密码" class="headerlink" title="添加账号和密码"></a>添加账号和密码</h6><p><code>htpasswd -cm /home/gerrit/repository/htpasswd USER_NAME</code></p>
<ul>
<li>htpasswd 为apache 的命令工具</li>
<li>参数c 意为新建文件, 即 <code>/home/gerrit/repository/htpasswd</code> 文件不存在时, 新建名为htpasswd的文件</li>
<li>参数m 为使用md5 加密</li>
<li>当htpasswd文件存在时, 可以使用<code>htpasswd -m /PATH_TO_HTPASSWD USER_NAME</code> 添加账号</li>
<li>保存账号密码信息的文件(htpasswd), 名字为自定义的, 但需要与apache 的conf 配置文件里 <code>AuthUserFile</code> 一致</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/02/gerrit-apache-e5-ae-89-e8-a3-85/" data-id="ck10vanxa001gzxz233gu1lcs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qt-e5-b7-a5-e7-a8-8b-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-87-e4-bb-b6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/qt-e5-b7-a5-e7-a8-8b-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-87-e4-bb-b6/" class="article-date">
  <time datetime="2018-04-20T14:25:51.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Qt/">Qt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/qt-e5-b7-a5-e7-a8-8b-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-87-e4-bb-b6/">Qt 工程的几种文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="pro"><a href="#pro" class="headerlink" title="*.pro"></a><code>*.pro</code></h4><p>qmake的工程(project)文件 例子:</p>
<pre><code>TEMPLATE = app
CONFIG += QT
QT += core gui

TARGET = somename

SOURCES += main.cpp \
          widget.cpp
HEADERS += widget.h
FORMS += widget.ui</code></pre><ul>
<li>前三行是qmake的默认值, 都可以省略</li>
<li>TARGET 行指定工程名, 也可以省略</li>
</ul>
<h4 id="pri"><a href="#pri" class="headerlink" title="*.pri"></a><code>*.pri</code></h4><p>include 文件 接上面的例子, 我们可以将源文件的设置独立处理, 放到somename.pri文件内:</p>
<pre><code>SOURCES += main.cpp \
          widget.cpp
HEADERS += widget.h
FORMS += widget.ui</code></pre><p>这时, pro 文件就可以简化为:</p>
<pre><code>TEMPLATE = app
CONFIG += QT
QT += core gui

TARGET = somename
include(somename.pri)</code></pre><h4 id="prf"><a href="#prf" class="headerlink" title="*.prf"></a><code>*.prf</code></h4><p>特性(feature) 文件 和pri文件类似, prf文件也是要被包含进pro文件. 只是它更隐蔽.</p>
<p>在上面的例子中, 其实已经用到了prf, 就是 <code>CONFIG += QT</code></p>
<p>当在CONFIG 中指定一个值时, qmake就会尝试去加载相应的feature文件: - Qt安装目录下的<code>mkspecs/features/qt.prf</code> - features 文件的文件名必须小写</p>
<p>例子:</p>
<pre><code>win32:CONFIG += console // 为win32程序添加控制台</code></pre><p>把该文件命名为<code>a.prf</code>, 放到前面提到的目录中, 然后在pro文件内添加 <code>CONFIG += a</code></p>
<p>也可以使用load命令来加载prf文件 <code>load(a)</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/qt-e5-b7-a5-e7-a8-8b-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-87-e4-bb-b6/" data-id="ck10vany8002uzxz2t7f20b9x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qt-ui-e7-bc-96-e7-a0-81-e8-a7-84-e8-8c-83" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/02/qt-ui-e7-bc-96-e7-a0-81-e8-a7-84-e8-8c-83/" class="article-date">
  <time datetime="2018-04-02T03:27:52.000Z" itemprop="datePublished">2018-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Qt/">Qt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/02/qt-ui-e7-bc-96-e7-a0-81-e8-a7-84-e8-8c-83/">Qt UI 编码规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><ul>
<li><p>每行只声明一个变量</p>
</li>
<li><p>避免使用短的/无意义的命名</p>
</li>
<li><p>当一个变量被用到时再声明</p>
<pre><code>// Wrong
int a, b;
char* c, * d;

// Correct
int height;
int width;
char* nameOfOne;
char* nameOfOther;</code></pre></li>
</ul>
<h5 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h5><ul>
<li><p>变量名/函数名采用驼峰命名法(lowerCaseCamel), 首字母缩写词出现的命名中, 缩写也用驼峰命名</p>
<pre><code>// Wrong 
short Cntr;
char ITEM_DELIM = &apos;&apos;;

void myXMLStreamReader();

// Correct
short counter;
char itemDelimiter = &apos;&apos;;

void myXmlStreamReader();</code></pre></li>
</ul>
<h5 id="空行-空格"><a href="#空行-空格" class="headerlink" title="空行/空格"></a>空行/空格</h5><ul>
<li><p>用一个且仅用一个空行在适当的地方划分代码块</p>
</li>
<li><p>在关键词和小括号之间总是只用一个空格符</p>
<pre><code>// Wrong
if(foo)
{
}

// Correct
if (foo)
{
}</code></pre></li>
</ul>
<h5 id="指针-引用"><a href="#指针-引用" class="headerlink" title="指针/引用"></a>指针/引用</h5><ul>
<li><p>在类型名和<code>*</code>或<code>&amp;</code>之间没有空格, 在<code>*</code>或<code>&amp;</code>与变量名之间有一个空格</p>
<pre><code>char* someValue;
const QString&amp; myString;
const char* const WOR = &quot;hello&quot;;</code></pre></li>
</ul>
<h5 id="符号与空格"><a href="#符号与空格" class="headerlink" title="符号与空格"></a>符号与空格</h5><ul>
<li>二元操作符左右两边都有一个空格</li>
<li>一元操作符与变量之间不留空格</li>
<li>逗号左右没有空格, 右边一个空格</li>
<li>分号左边没有空格; 分号作为语句的结束符, 右边一般不再有内容</li>
<li><code>#</code>号右边没有空格</li>
<li>左引号的左边和右引号的各一个空格, 左引号的右边和右引号的左边没有空格</li>
<li>如果右引号右边是右括号, 它们之间没有空格</li>
</ul>
<h5 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h5><ul>
<li><p>避免C语言的cast, 尽量用C++的cast(static_cast, const_cast, reinterpret_cast). reinterpret_cast 和 C风格的cast用起来都是危险的，但至少 reinterpret_cast 不会把const修饰符去掉</p>
</li>
<li><p>涉及到QObjects或重构自己的代码时，不要使用dynamic_cast,而是用qobject_cast，例如在引进一个类型的方法时</p>
</li>
<li><p>用构造函数去cast简单类型,例如：用int(myFloat)代替(int)myFloat</p>
<pre><code>// Wrong
char* blockOfMemory = (char* ) malloc(data.size());

// Correct
char *blockOfMemory = reinterpret_cast&lt;char *&gt;(malloc(data.size()));</code></pre></li>
</ul>
<h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><ul>
<li>不要在一行写多条语句</li>
</ul>
<h5 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h5><ul>
<li><p>每个大括号单独一行</p>
</li>
<li><p>不论条件语句的执行部分有几行, 必须使用大括号</p>
</li>
<li><p>小括号用来给语句分组</p>
<p> // Wrong<br> if (address.isEmpty()) {</p>
<pre><code>return false;</code></pre><p> }</p>
<p> for (int i = 0; i &lt; 10; +’’i) {</p>
<pre><code>qDebug(&quot;%i&quot;, i);</code></pre><p> }</p>
<p> // Correct<br> if (address.isEmpty())<br> {</p>
<pre><code>return false;</code></pre><p> }<br> else<br> {</p>
<pre><code>return true;</code></pre><p> }</p>
<p> for (int i = 0; i &lt; 10;i)<br> {</p>
<pre><code>qDebug(&quot;%i&quot;, i);</code></pre><p> }</p>
</li>
</ul>
<pre><code>// Wrong
if (a &amp;&amp; b || c)

// Correct
if ((a &amp;&amp; b) || c)

// Wrong
a + b &amp; c

// Correct
(a + b) &amp; c</code></pre><h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h5><ul>
<li><p>case缩进</p>
</li>
<li><p>除enum外, 每组case最后都要加default;</p>
<p> switch (myEnum)<br> {</p>
<pre><code>case Value1:
    doSomething();
break;
case Value2:
case Value3:
    doSomethingElse();
    // fall through
break;
default:
    defaultHandling();
break;</code></pre><p> }</p>
</li>
</ul>
<h5 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h5><ul>
<li>禁止使用goto</li>
</ul>
<h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><ul>
<li><p>每行代码不多于120字符</p>
</li>
<li><p>逗号在行尾. 操作符在新行的开头位置</p>
</li>
<li><p>换行时尽量避免行与行之间看起来参差不齐</p>
<p> // Wrong<br> if (longExpression +</p>
<pre><code>otherLongExpression +
otherOtherLongExpression) {</code></pre><p> }</p>
<p> // Correct<br> if (longExpression</p>
<pre><code>+ otherLongExpression
+ otherOtherLongExpression) {</code></pre><p> }</p>
</li>
</ul>
<h5 id="C-特性"><a href="#C-特性" class="headerlink" title="C++特性"></a><code>C++</code>特性</h5><ul>
<li>不要使用异常处理</li>
<li>不要使用运行时类型识别</li>
<li>理智地使用模板</li>
</ul>
<h5 id="Qt源码中的规范"><a href="#Qt源码中的规范" class="headerlink" title="Qt源码中的规范"></a>Qt源码中的规范</h5><ul>
<li>所有代码都是ascii，使用者如果不确定的话，只可能是7字节</li>
<li>每一个QObject的子类都必须有Q_OBJECT宏，即使这个类没用到信号或槽。否则qobject_cast将不能使用</li>
<li>在connect语句中，使信号和槽的参数规范化（参看 QMetaObject::normalizedSignature），可以加快信号/槽的查找速度。可以使用qtrepotools/util/normalize规范已有代码</li>
</ul>
<h5 id="包含头文件顺序"><a href="#包含头文件顺序" class="headerlink" title="包含头文件顺序"></a>包含头文件顺序</h5><ol>
<li>源文件对应的头文件</li>
<li>&lt;分隔&gt;</li>
<li>C系统文件</li>
<li>&lt;分隔&gt;</li>
<li>C++系统文件</li>
<li>&lt;分隔&gt;</li>
<li>Qt库文件</li>
<li>&lt;分隔&gt;</li>
<li>其他目录</li>
</ol>
<p>每组文件按字母升序排列</p>
<h5 id="编译器-平台"><a href="#编译器-平台" class="headerlink" title="编译器/平台"></a>编译器/平台</h5><ol>
<li><p>使用三目运算符 ？时要特别小心，如果每次的返回值的类型可能不一样的话，一些编译器会在运行时生成冲突的代码（此时编译器甚至不会报错） <code>QString s; return condition ? s : &quot;nothing&quot;; // crash at runtime - QString vs. const char *</code></p>
</li>
<li><p>要特别小心对齐问题。无论何时，当一个指针被cast后的对齐数是增加的时候，它都可能会崩溃。例如一个const char 被cast成了cons int，当cast之后的数字不得不在2或4个字节之间对齐时，指针就会在机器上崩溃</p>
</li>
<li><p>任何需要需要执行构造函数或相关代码进行初始化的实例，都不能用作库代码中的全局实例。因为当构造函数或代码将要运行的时候，该实例还没有被定义（在第一次调用该实例时，在加载库时，在执行main()之前） <code>// global scope static const QString x; // Wrong - default constructor needs to be run to initialize x static const QString y = &quot;Hello&quot;; // Wrong - constructor that takes a const char * has to be run QString z; // super wrong static const int i = foo(); // wrong - call time of foo() undefined, might not be called at all</code> 可以使用下面方法: <code>// global scope static const char x[] = &quot;someText&quot;; // Works - no constructor must be run, x set at compile time static int y = 7; // Works - y will be set at compile time static MyStruct s = {1, 2, 3}; // Works - will be initialized statically, no code being run static QString *ptr = 0; // Pointers to objects are ok - no code needed to be run to initialize ptr</code></p>
</li>
<li><p>用Q_GLOBAL_STATIC定义全局实例</p>
<pre><code> Q_GLOBAL_STATIC(QString, s)

void foo()
{
 s()-&gt;append(&quot;moo&quot;);
}</code></pre></li>
</ol>
<ol start="5">
<li>char型变量是有符号的还是无符号的取决于它运行环境的架构。如果你明确地想使用一个signed或unsinged char，就使用signed char或unsigned char。以下代码运行在把char默认为无符号的平台上时，其条件判断恒为真 <code>char c; // c can&#39;t be negative if it is unsigned /********/ /*******/ if (c &gt; 0) { … } // WRONG - condition is always true on platforms where the default is unsigned</code></li>
<li>避免64位的枚举值<ul>
<li>嵌入式应用系统二进制接口将所有的枚举类型的值硬编码成32位int值</li>
<li>微软的编译器不支持64位的枚举值</li>
</ul>
</li>
</ol>
<h5 id="编程偏好"><a href="#编程偏好" class="headerlink" title="编程偏好"></a>编程偏好</h5><ul>
<li>用枚举值定义常量而非用const int或defines<ul>
<li>枚举值会在编译时被编译器用实际值替换掉，因而运行时得出结果的速度更快</li>
<li>defines不是命名空间安全的（并且看起来很丑）</li>
</ul>
</li>
<li>当重新实现一个虚方法时，在Qt5中，用 Q_DECL_OVERRIDE宏在函数声明之后，分号之前注解它</li>
<li>不要把const-iterator和none-const iterator搞混 <code>for (Container::const_iterator it = c.begin(); it != c.end(); ++it) // Wrong for (Container::const_iterator it = c.cbegin(); it != c.cend(); ++it) // Right</code></li>
</ul>
<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><ul>
<li>除跟UI直接交互的类外, 其他类必须处在命名空间内</li>
</ul>
<h5 id="float值"><a href="#float值" class="headerlink" title="float值"></a>float值</h5><ul>
<li>用qFuzzyCompare去和delta比较其值</li>
<li>用qIsNull去判断float值是不是二进制0，而不是和0.0比较 <code>[static] bool qFuzzyCompare(double p1, double p2) // Instead of comparing with 0.0 qFuzzyCompare(0.0,1.0e-200); // This will return false // Compare adding 1 to both values will fix the problem qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true</code></li>
</ul>
<h5 id="类的成员命名"><a href="#类的成员命名" class="headerlink" title="类的成员命名"></a>类的成员命名</h5><ul>
<li><p>成员变量一般为名词</p>
</li>
<li><p>函数成员一般为动词/动词+名词，但是当动词为get时，get常常省略。当返回值为Bool型变量时，函数名一般以前缀’is’开头</p>
<pre><code>public:
    void setColor(const QColor&amp; c);
    QColor color() const;
    void setDirty(bool b);
    bool isDirty() const;

private Q_SLOTS:
    void onParentChanged();</code></pre></li>
</ul>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul>
<li>为了使构造函数被错误使用的可能性降到最小，每一个构造函数（除了拷贝构函数）都应该检查自己是否需要加上explicit 符号</li>
</ul>
<h5 id="注意代码陷阱"><a href="#注意代码陷阱" class="headerlink" title="注意代码陷阱"></a>注意代码陷阱</h5><ul>
<li>不要为了图方便少些一些代码。因为代码是一次书写，后期不止一次地要去理解。例如 <code>QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, &quot;volume&quot;);</code></li>
<li>改成下面的方式会更容易理解 <code>QSlider *slider = new QSlider(Qt::Vertical); slider-&gt;setRange(12, 18); slider-&gt;setPageStep(3); slider-&gt;setValue(13); slider-&gt;setObjectName(&quot;volume&quot;);</code></li>
</ul>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ol>
<li><a href="https://wiki.qt.io/Qt\_Contribution\_Guidelines" target="_blank" rel="noopener">https://wiki.qt.io/Qt\_Contribution\_Guidelines</a></li>
<li><a href="https://wiki.qt.io/Qt\_Coding\_Style" target="_blank" rel="noopener">https://wiki.qt.io/Qt\_Coding\_Style</a></li>
<li><a href="https://wiki.qt.io/Coding_Conventions" target="_blank" rel="noopener">https://wiki.qt.io/Coding_Conventions</a></li>
<li><a href="https://community.kde.org/Policies/Library\_Code\_Policy" target="_blank" rel="noopener">https://community.kde.org/Policies/Library\_Code\_Policy</a></li>
<li><a href="https://wiki.qt.io/UI\_Text\_Conventions" target="_blank" rel="noopener">https://wiki.qt.io/UI\_Text\_Conventions</a></li>
<li><a href="https://wiki.qt.io/API\_Design\_Principles" target="_blank" rel="noopener">https://wiki.qt.io/API\_Design\_Principles</a></li>
<li><a href="http://doc.qt.io/qt-5/qml-codingconventions.html" target="_blank" rel="noopener">http://doc.qt.io/qt-5/qml-codingconventions.html</a></li>
<li><a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">https://google.github.io/styleguide/cppguide.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/02/qt-ui-e7-bc-96-e7-a0-81-e8-a7-84-e8-8c-83/" data-id="ck10vao020052zxz28i80ji5y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-centos7-e5-8d-87-e7-ba-a7gcc-e5-92-8cgdb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/28/centos7-e5-8d-87-e7-ba-a7gcc-e5-92-8cgdb/" class="article-date">
  <time datetime="2018-03-28T03:37:20.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/centos7-e5-8d-87-e7-ba-a7gcc-e5-92-8cgdb/">CentOS7升级gcc 和gdb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>升级后版本: gcc-5.4.0 gdb-7.11.1</p>
<h4 id="安装开发必备环境"><a href="#安装开发必备环境" class="headerlink" title="安装开发必备环境"></a>安装开发必备环境</h4><pre><code>yum groupinstall &quot;Development Tools&quot;
yum install glibc-static libstdc++-static</code></pre><h4 id="编译安装gcc-5-4-0"><a href="#编译安装gcc-5-4-0" class="headerlink" title="编译安装gcc-5.4.0"></a>编译安装gcc-5.4.0</h4><p><a href="http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/" target="_blank" rel="noopener">gcc下载地址</a></p>
<pre><code>tar -xvf gcc-5.4.0.tar.bz2
cd gcc-5.4.0
./contrib/download_prerequisits
mkdir build
cd build
../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib
make（建议不要使用make -j来编译，虽然可以缩短编译时间，但极大可能会编译失败）
make install</code></pre><p>其中执行<code>./contrib/download_prerequisits</code>将自动下载以下几个文件，这个几个文件在gcc编译时需要： - mpfr-2.4.2.tar.bz2 - gmp-4.3.2.tar.bz2 - mpc-0.8.1.tar.gz - isl-0.15.tar.bz2</p>
<p><code>make install</code> 时, 自动安装到<code>/usr/local/gcc-5.40</code></p>
<h4 id="解决运行程序时-gcc-报错’GLIBCXX-3-4-21’-not-found"><a href="#解决运行程序时-gcc-报错’GLIBCXX-3-4-21’-not-found" class="headerlink" title="解决运行程序时, gcc 报错’GLIBCXX_3.4.21’ not found"></a>解决运行程序时, gcc 报错’GLIBCXX_3.4.21’ not found</h4><p>这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决，运行以下命令检查动态库： <code>strings /lib64/libstdc++.so.6 | grep GLIBC</code></p>
<p>以下是输出结果：</p>
<pre><code>GLIBCXX_3.4
GLIBCXX_3.4.1
GLIBCXX_3.4.2
GLIBCXX_3.4.3
GLIBCXX_3.4.4
GLIBCXX_3.4.5
GLIBCXX_3.4.6
GLIBCXX_3.4.7
GLIBCXX_3.4.8
GLIBCXX_3.4.9
GLIBCXX_3.4.10
GLIBCXX_3.4.11
GLIBCXX_3.4.12
GLIBCXX_3.4.13
GLIBCXX_3.4.14
GLIBCXX_3.4.15
GLIBCXX_3.4.16
GLIBCXX_3.4.17
GLIBCXX_3.4.18
GLIBCXX_3.4.19
GLIBC_2.3
GLIBC_2.2.5
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3.2
GLIBCXX_DEBUG_MESSAGE_LENGTH</code></pre><p>从输出结果可以看到并没有“GLIBCXX_3.4.21“,所以可以断定我们的程序运行时动态加载的是老的动态库，解决这个问题需要将当前链接文件的链接指向改成最新的动态库地址：</p>
<pre><code>cp /usr/local/lib64/libstdc++.so.6.0.21 /lib64
cd /lib64
rm -rf libstdc++.so.6
ln -s libstdc++.so.6.0.21 libstdc++.so.6</code></pre><p>然后你可以执行以下命令来查看’GLIBCXX_3.4.21’已经可以找到了: <code>strings /lib64/libstdc++.so.6 | grep GLIBC</code></p>
<p>解决了这个问题终于可以执行程序了，然后又测试了-g选项来编译程序，编译好程序调试程序时并不能够设置断点以及print变量的值，gdb调试中出现：Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.e17_2.6.x86_4 libgcc-4.8.5-4.e17.x86_64的问题，通过上网查阅资料，是因为gcc版本和gdb版本并不匹配，或者说gdb版本过低</p>
<h4 id="编译安装gdb-7-11-1"><a href="#编译安装gdb-7-11-1" class="headerlink" title="编译安装gdb-7.11.1"></a>编译安装gdb-7.11.1</h4><p><a href="http://ftp.gnu.org/gnu/gdb/" target="_blank" rel="noopener">gdb下载地址</a></p>
<pre><code>tar -xvf gdb-7.11.1.tar.gz
cd gdb-7.11.1
./configure
make
make install</code></pre><p>当执行make install时gdb安装出现了错误：<code>WARNING: &#39;makeinfo&#39; is missing on your sysem</code>，则需安装相关依赖程序: <code>yum install texinfo libncurses5-dev</code></p>
<p>如果调试程序时出现下面信息时：</p>
<pre><code>warning: File &quot;/usr/local/lib64/libstdc++.so.6.0.21-gdb.py&quot; auto-loading has been declined by your `auto-load safe-path&apos; set to &quot;$debugdir:$datadir/auto-load&quot;.
To enable execution of this file add
    add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.py
line to your configuration file &quot;/root/.gdbinit&quot;.
To completely disable this security protection add
    set auto-load safe-path /
line to your configuration file &quot;/root/.gdbinit&quot;.</code></pre><p>解决方法: 将以下信息放入<code>~/.gdbinit</code></p>
<pre><code>add-auto-load-safe-path /usr/local/lib64/libstdc++.so.6.0.21-gdb.py
set auto-load safe-path /</code></pre><p>若想通过gdb来调试STL容器，则还需要做一些配置，可以通过<code>GDB Python pretty printers</code>来解决这个问题：</p>
<pre><code>svn checkout svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python stlPrettyPrinter
mv stlPrettyPrinter /usr/local</code></pre><p>然后将下面的配置信息放入<code>~/.gdbinit</code></p>
<pre><code>python
import sys
sys.path.insert(0, &apos;/usr/local/stlPrettyPrinter&apos;)
from libstdcxx.v6.printers import register_libstdcxx_printers
register_libstdcxx_printers (None)
end</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/28/centos7-e5-8d-87-e7-ba-a7gcc-e5-92-8cgdb/" data-id="ck10vanwl0008zxz29s8f78os" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ffmpeg-e8-a7-86-e9-9f-b3-e9-a2-91-e5-90-8c-e6-ad-a5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/27/ffmpeg-e8-a7-86-e9-9f-b3-e9-a2-91-e5-90-8c-e6-ad-a5/" class="article-date">
  <time datetime="2018-03-27T06:41:52.000Z" itemprop="datePublished">2018-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/A-amp-V/">A&amp;V</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/27/ffmpeg-e8-a7-86-e9-9f-b3-e9-a2-91-e5-90-8c-e6-ad-a5/">ffmpeg 视音频同步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址: <a href="https://blog.csdn.net/nonmarking/article/details/50522413" target="_blank" rel="noopener">https://blog.csdn.net/nonmarking/article/details/50522413</a></p>
<p>对于直播流来说, 只考虑发送端的同步问题, 原理如下: 1. 解析视音频, 讲视频流和音频流的时间戳用同样的时间基准表示 2. 比较转换后的两个时间戳, 找出较小值, 对应发送偏慢的流 3. 读取, 转码, 发送相应的流, 同时, 若该流的转码时间很快, 超前于wall clock, 则还需要进行相应的延时 4. 重复以上过程</p>
<p>下文包括两部分, 一是音频转码部分, 二是视音频同步</p>
<h6 id="音频转码基本流程"><a href="#音频转码基本流程" class="headerlink" title="音频转码基本流程"></a>音频转码基本流程</h6><p>首先是一些音频输入输出的基本设置</p>
<pre><code>//Set own audio device&apos;s name
    if (avformat_open_input(&amp;ifmt_ctx_a, device_name_a, ifmt, &amp;device_param) != 0){

        printf(&quot;Couldn&apos;t open input audio stream.（无法打开输入流）\n&quot;);
        return -1;
    }
……
//input audio initialize
    if (avformat_find_stream_info(ifmt_ctx_a, NULL) &lt; 0)
    {
        printf(&quot;Couldn&apos;t find audio stream information.（无法获取流信息）\n&quot;);
        return -1;
    }
    audioindex = -1;
    for (i = 0; i &lt; ifmt_ctx_a-&gt;nb_streams; i++)
    if (ifmt_ctx_a-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
    {
        audioindex = i;
        break;
    }
    if (audioindex == -1)
    {
        printf(&quot;Couldn&apos;t find a audio stream.（没有找到视频流）\n&quot;);
        return -1;
    }
    if (avcodec_open2(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec, avcodec_find_decoder(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;codec_id), NULL) &lt; 0)
    {
        printf(&quot;Could not open audio codec.（无法打开解码器）\n&quot;);
        return -1;
    }
……
 //output audio encoder initialize
    pCodec_a = avcodec_find_encoder(AV_CODEC_ID_AAC);
    if (!pCodec_a){
        printf(&quot;Can not find output audio encoder! (没有找到合适的编码器！)\n&quot;);
        return -1;
    }
    pCodecCtx_a = avcodec_alloc_context3(pCodec_a);
    pCodecCtx_a-&gt;channels = 2;
    pCodecCtx_a-&gt;channel_layout = av_get_default_channel_layout(2);
    pCodecCtx_a-&gt;sample_rate = ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate;
    pCodecCtx_a-&gt;sample_fmt = pCodec_a-&gt;sample_fmts[0];
    pCodecCtx_a-&gt;bit_rate = 32000;
    pCodecCtx_a-&gt;time_base.num = 1;
    pCodecCtx_a-&gt;time_base.den = pCodecCtx_a-&gt;sample_rate;
    /** Allow the use of the experimental AAC encoder */
    pCodecCtx_a-&gt;strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
    /* Some formats want stream headers to be separate. */
    if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)
        pCodecCtx_a-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;
    if (avcodec_open2(pCodecCtx_a, pCodec_a, NULL) &lt; 0){
        printf(&quot;Failed to open ouput audio encoder! (编码器打开失败！)\n&quot;);
        return -1;
    }

    //Add a new stream to output,should be called by the user before avformat_write_header() for muxing
    audio_st = avformat_new_stream(ofmt_ctx, pCodec_a);
    if (audio_st == NULL){
        return -1;
    }
    audio_st-&gt;time_base.num = 1;
    audio_st-&gt;time_base.den = pCodecCtx_a-&gt;sample_rate;
    audio_st-&gt;codec = pCodecCtx_a;</code></pre><p>接下来, 考虑到输入音频的sample format 可能需要进行转换, 需要用到swresample库的功能 先做好相应的初始化</p>
<pre><code>// Initialize the resampler to be able to convert audio sample formats
    aud_convert_ctx = swr_alloc_set_opts(NULL,
        av_get_default_channel_layout(pCodecCtx_a-&gt;channels),
        pCodecCtx_a-&gt;sample_fmt,
        pCodecCtx_a-&gt;sample_rate,
        av_get_default_channel_layout(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;channels),
        ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_fmt,
        ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate,
        0, NULL);
swr_init(aud_convert_ctx);</code></pre><p>此外, 参照transcode_aac.c的做法, 使用FIFO buffer存储从输入端解码得到的音频采样数据, 这些数据在后续将转换sample format并进行编码, 由此即完成了一个音频转码功.</p>
<p>此外, 还需要另外的一个buffer来存储转换合适之后的音频数据</p>
<pre><code>//Initialize the FIFO buffer to store audio samples to be encoded. 
    AVAudioFifo *fifo = NULL;
    fifo = av_audio_fifo_alloc(pCodecCtx_a-&gt;sample_fmt, pCodecCtx_a-&gt;channels, 1);

    //Initialize the buffer to store converted samples to be encoded.
    uint8_t **converted_input_samples = NULL;
    /**
    * Allocate as many pointers as there are audio channels.
    * Each pointer will later point to the audio samples of the corresponding
    * channels (although it may be NULL for interleaved formats).
    */
    if (!(converted_input_samples = (uint8_t**)calloc(pCodecCtx_a-&gt;channels,
        sizeof(**converted_input_samples)))) {
        printf(&quot;Could not allocate converted input sample pointers\n&quot;);
        return AVERROR(ENOMEM);
    }</code></pre><p>至此, 一些基本的初始化工作完成.</p>
<p>音频计算pts的方法和视频类似. 即先通过sample rate算出每两个音频sample之间的时间间隔, 再通过计数当前已编码的音频sample总数(nb_samples变量的作用) 来算出当前编码音频帧的时间戳. 如果和视频的流程做类比, 大概为: framerate 相当于sample rate, framecnt相当于nb_samples.</p>
<pre><code>//audio trancoding here
        const int output_frame_size = pCodecCtx_a-&gt;frame_size;

        /**
        * Make sure that there is one frame worth of samples in the FIFO
        * buffer so that the encoder can do its work.
        * Since the decoder&apos;s and the encoder&apos;s frame size may differ, we
        * need to FIFO buffer to store as many frames worth of input samples
        * that they make up at least one frame worth of output samples.
        */
        while (av_audio_fifo_size(fifo) &lt; output_frame_size) {
            /**
            * Decode one frame worth of audio samples, convert it to the
            * output sample format and put it into the FIFO buffer.
            */
            AVFrame *input_frame = av_frame_alloc();
            if (!input_frame)
            {
                ret = AVERROR(ENOMEM);
                return ret;
            }           

            /** Decode one frame worth of audio samples. */
            /** Packet used for temporary storage. */
            AVPacket input_packet;
            av_init_packet(&amp;input_packet);
            input_packet.data = NULL;
            input_packet.size = 0;

            /** Read one audio frame from the input file into a temporary packet. */
            if ((ret = av_read_frame(ifmt_ctx_a, &amp;input_packet)) &lt; 0) {
                /** If we are at the end of the file, flush the decoder below. */
                if (ret == AVERROR_EOF)
                {
                    encode_audio = 0;
                }
                else
                {
                    printf(&quot;Could not read audio frame\n&quot;);
                    return ret;
                }                   
            }

            /**
            * Decode the audio frame stored in the temporary packet.
            * The input audio stream decoder is used to do this.
            * If we are at the end of the file, pass an empty packet to the decoder
            * to flush it.
            */
            if ((ret = avcodec_decode_audio4(ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec, input_frame,
                &amp;dec_got_frame_a, &amp;input_packet)) &lt; 0) {
                printf(&quot;Could not decode audio frame\n&quot;);
                return ret;
            }
            av_packet_unref(&amp;input_packet);
            /** If there is decoded data, convert and store it */
            if (dec_got_frame_a) {
                /**
                * Allocate memory for the samples of all channels in one consecutive
                * block for convenience.
                */
                if ((ret = av_samples_alloc(converted_input_samples, NULL,
                    pCodecCtx_a-&gt;channels,
                    input_frame-&gt;nb_samples,
                    pCodecCtx_a-&gt;sample_fmt, 0)) &lt; 0) {
                    printf(&quot;Could not allocate converted input samples\n&quot;);
                    av_freep(&amp;(*converted_input_samples)[0]);
                    free(*converted_input_samples);
                    return ret;
                }

                /**
                * Convert the input samples to the desired output sample format.
                * This requires a temporary storage provided by converted_input_samples.
                */
                /** Convert the samples using the resampler. */
                if ((ret = swr_convert(aud_convert_ctx,
                    converted_input_samples, input_frame-&gt;nb_samples,
                    (const uint8_t**)input_frame-&gt;extended_data, input_frame-&gt;nb_samples)) &lt; 0) {
                    printf(&quot;Could not convert input samples\n&quot;);
                    return ret;
                }

                /** Add the converted input samples to the FIFO buffer for later processing. */
                /**
                * Make the FIFO as large as it needs to be to hold both,
                * the old and the new samples.
                */
                if ((ret = av_audio_fifo_realloc(fifo, av_audio_fifo_size(fifo) + input_frame-&gt;nb_samples)) &lt; 0) {
                    printf(&quot;Could not reallocate FIFO\n&quot;);
                    return ret;
                }

                /** Store the new samples in the FIFO buffer. */
                if (av_audio_fifo_write(fifo, (void **)converted_input_samples,
                    input_frame-&gt;nb_samples) &lt; input_frame-&gt;nb_samples) {
                    printf(&quot;Could not write data to FIFO\n&quot;);
                    return AVERROR_EXIT;
                }               
            }
        }

        /**
        * If we have enough samples for the encoder, we encode them.
        * At the end of the file, we pass the remaining samples to
        * the encoder.
        */
        if (av_audio_fifo_size(fifo) &gt;= output_frame_size)
            /**
            * Take one frame worth of audio samples from the FIFO buffer,
            * encode it and write it to the output file.
            */
        {
            /** Temporary storage of the output samples of the frame written to the file. */
            AVFrame *output_frame=av_frame_alloc();
            if (!output_frame)
            {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            /**
            * Use the maximum number of possible samples per frame.
            * If there is less than the maximum possible frame size in the FIFO
            * buffer use this number. Otherwise, use the maximum possible frame size
            */
            const int frame_size = FFMIN(av_audio_fifo_size(fifo),
                pCodecCtx_a-&gt;frame_size);

            /** Initialize temporary storage for one output frame. */
            /**
            * Set the frame&apos;s parameters, especially its size and format.
            * av_frame_get_buffer needs this to allocate memory for the
            * audio samples of the frame.
            * Default channel layouts based on the number of channels
            * are assumed for simplicity.
            */
            output_frame-&gt;nb_samples = frame_size;
            output_frame-&gt;channel_layout = pCodecCtx_a-&gt;channel_layout;
            output_frame-&gt;format = pCodecCtx_a-&gt;sample_fmt;
            output_frame-&gt;sample_rate = pCodecCtx_a-&gt;sample_rate;

            /**
            * Allocate the samples of the created frame. This call will make
            * sure that the audio frame can hold as many samples as specified.
            */
            if ((ret = av_frame_get_buffer(output_frame, 0)) &lt; 0) {
                printf(&quot;Could not allocate output frame samples\n&quot;);
                av_frame_free(&amp;output_frame);
                return ret;
            }

            /**
            * Read as many samples from the FIFO buffer as required to fill the frame.
            * The samples are stored in the frame temporarily.
            */
            if (av_audio_fifo_read(fifo, (void **)output_frame-&gt;data, frame_size) &lt; frame_size) {
                printf(&quot;Could not read data from FIFO\n&quot;);
                return AVERROR_EXIT;
            }

            /** Encode one frame worth of audio samples. */
            /** Packet used for temporary storage. */
            AVPacket output_packet;
            av_init_packet(&amp;output_packet);
            output_packet.data = NULL;
            output_packet.size = 0;

            /** Set a timestamp based on the sample rate for the container. */
            if (output_frame) {
                nb_samples += output_frame-&gt;nb_samples;
            }

            /**
            * Encode the audio frame and store it in the temporary packet.
            * The output audio stream encoder is used to do this.
            */
            if ((ret = avcodec_encode_audio2(pCodecCtx_a, &amp;output_packet,
                output_frame, &amp;enc_got_frame_a)) &lt; 0) {
                printf(&quot;Could not encode frame\n&quot;);
                av_packet_unref(&amp;output_packet);
                return ret;
            }

            /** Write one audio frame from the temporary packet to the output file. */
            if (enc_got_frame_a) {

                output_packet.stream_index = 1;

                AVRational time_base = ofmt_ctx-&gt;streams[1]-&gt;time_base;
                AVRational r_framerate1 = { ifmt_ctx_a-&gt;streams[audioindex]-&gt;codec-&gt;sample_rate, 1 };// { 44100, 1};  
                int64_t calc_duration = (double)(AV_TIME_BASE)*(1 / av_q2d(r_framerate1));  //内部时间戳  

                output_packet.pts = av_rescale_q(nb_samples*calc_duration, time_base_q, time_base);
                output_packet.dts = output_packet.pts;
                output_packet.duration = output_frame-&gt;nb_samples;

                //printf(&quot;audio pts : %d\n&quot;, output_packet.pts);
                aud_next_pts = nb_samples*calc_duration;

                int64_t pts_time = av_rescale_q(output_packet.pts, time_base, time_base_q);
                int64_t now_time = av_gettime() - start_time;

                if ((pts_time &gt; now_time) &amp;&amp; ((aud_next_pts + pts_time - now_time)&lt;vid_next_pts))
                    av_usleep(pts_time - now_time);

                if ((ret = av_interleaved_write_frame(ofmt_ctx, &amp;output_packet)) &lt; 0) {
                    printf(&quot;Could not write frame\n&quot;);
                    av_packet_unref(&amp;output_packet);
                    return ret;
                }

                av_packet_unref(&amp;output_packet);
            }           
            av_frame_free(&amp;output_frame);       
        }     </code></pre><h6 id="视音频同步"><a href="#视音频同步" class="headerlink" title="视音频同步"></a>视音频同步</h6><p>首先定义几个变量</p>
<pre><code>int aud_next_pts = 0;//视频流目前的pts,可以理解为目前的进度
int vid_next_pts = 0;//音频流目前的pts
int encode_video = 1, encode_audio = 1;//是否要编码视频、音频</code></pre><p>则相应的视音频同步方法如下: 1. 确定视频, 音频二者中至少有一个是需要进行转码的 2. 比较两个流的进度, 使用av_compare_ts函数, 注意：此时的vid_next_pts和aud_next_pts的time base都是ffmpeg内部基准，即<code>AVRational time_base_q = { 1, AV_TIME_BASE };</code> 3. 对进度落后的流进行转码, 并相应地对进度进行更新. 对于视频，有 vid_next_pts=framecnt_calc_duration;，对于音频，有 aud_next_pts = nb_samples_calc_duration;这里framecnt和nb_samples都相当于计数器，而calc_duration是对应流每两个frame或sample之间的时间间隔，也是以ffmpeg内部时间基准为单位的 4. 若转码进度很快完成, 则不能急于写入输出流, 而是需要先进行延时, 但是也要保证延时后的时间不会超过另一个流的进度</p>
<p>综上, 流程如下:</p>
<pre><code> //start decode and encode
    int64_t start_time = av_gettime();
    while (encode_video || encode_audio)
    {
        if (encode_video &amp;&amp;
            (!encode_audio || av_compare_ts(vid_next_pts, time_base_q,
            aud_next_pts, time_base_q) &lt;= 0))
        {
              进行视频转码；
              转码完成后；
              vid_next_pts=framecnt*calc_duration; //general timebase

                        //Delay
                        int64_t pts_time = av_rescale_q(enc_pkt.pts, time_base, time_base_q);
                        int64_t now_time = av_gettime() - start_time;                       
                        if ((pts_time &gt; now_time) &amp;&amp; ((vid_next_pts + pts_time - now_time)&lt;aud_next_pts))
                            av_usleep(pts_time - now_time);
              写入流；
}
else
{
              进行音频转码；
              转码完成后；
          aud_next_pts = nb_samples*calc_duration;

                int64_t pts_time = av_rescale_q(output_packet.pts, time_base, time_base_q);
                int64_t now_time = av_gettime() - start_time;
                if ((pts_time &gt; now_time) &amp;&amp; ((aud_next_pts + pts_time - now_time)&lt;vid_next_pts))
                    av_usleep(pts_time - now_time);
              写入流；
}</code></pre><p>至此, 视音频同步完成. 最后再完成一些flush_encoder的工作即可.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/27/ffmpeg-e8-a7-86-e9-9f-b3-e9-a2-91-e5-90-8c-e6-ad-a5/" data-id="ck10vao090059zxz2mj8j1tnq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/A-amp-V/">A&amp;V</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/En/">En</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/En/JSON/">JSON</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB/">DB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/DB/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design/">Design</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rasp/">Rasp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 20px;">nginx</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/08/08/e5-8d-87-e7-ba-a7https/">升级https</a>
          </li>
        
          <li>
            <a href="/2019/07/23/docker-e6-8c-82-e8-bd-bd-e7-9b-ae-e5-bd-95-e5-a4-b1-e8-b4-a5-e6-9d-83-e9-99-90-e6-8b-92-e7-bb-9d/">docker挂载目录失败/权限拒绝</a>
          </li>
        
          <li>
            <a href="/2019/07/02/mac-iterm2-e7-99-bb-e9-99-86centos-e6-8f-90-e7-a4-bawarning-setlocale-lc-ctype-cannot-change-locale-utf-8-no-such-file-or-directory/">Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</a>
          </li>
        
          <li>
            <a href="/2019/06/12/e5-8d-87-e7-ba-a7-e5-88-b0php7-1-e4-b9-8b-e5-90-8ewordpress-e7-bd-91-e7-ab-99-e5-87-ba-e7-8e-b0error-establishing-a-database-connection-e7-9a-84-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95/">升级到php7.1之后wordpress 网站出现Error establishing a database connection的解决方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>