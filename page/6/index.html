<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-e5-9c-a8shell-e8-84-9a-e6-9c-ac-e4-b8-ad-e4-bd-bf-e7-94-a8ls-e5-91-bd-e4-bb-a4-e7-9a-84-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/05/e5-9c-a8shell-e8-84-9a-e6-9c-ac-e4-b8-ad-e4-bd-bf-e7-94-a8ls-e5-91-bd-e4-bb-a4-e7-9a-84-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9/" class="article-date">
  <time datetime="2017-09-05T07:03:02.000Z" itemprop="datePublished">2017-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Shell/">Shell</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/05/e5-9c-a8shell-e8-84-9a-e6-9c-ac-e4-b8-ad-e4-bd-bf-e7-94-a8ls-e5-91-bd-e4-bb-a4-e7-9a-84-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9/">在shell脚本中使用ls命令的注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>请对比如下两个测试：</p>
<pre><code>$ for i in `ls /etc`;do echo $i;done
adjtime
adobe
appstream.conf
arch-release
asound.conf
avahi
bash.bash_logout
bash.bashrc
bind.keys
binfmt.d
......


$ for i in /etc/*;do echo $i;done
/etc/adjtime
/etc/adobe
/etc/appstream.conf
/etc/arch-release
/etc/asound.conf
/etc/avahi
/etc/bash.bash_logout
/etc/bash.bashrc
/etc/bind.keys
/etc/binfmt.d
......</code></pre><p>像ls这样的命令很多时候是设计给人用的，它的很多显示是有特殊设定的，可能并不是纯文本。 比如可能包含一些格式化字符，也可能包含可以让终端显示出颜色的标记字符等等。 当我们在程序里面使用类似这样的命令的时候要格外小心，说不定什么时候在什么不同环境配置的系统上， 你的程序就会有意想不到的异常出现，到时候排查起来非常麻烦。 所以这里我们应该尽量避免使用ls这样的命令来做类似的行为，用通配符可能更好。</p>
<p>当然，如果你要操作的是多层目录文件的话，那么ls就更不能帮你的忙了，它遇到目录之后显示成这样：</p>
<pre><code>$ ls /etc/*
/etc/adobe:
mms.cfg

/etc/avahi:
avahi-autoipd.action  avahi-daemon.conf  avahi-dnsconfd.action  hosts  services

/etc/binfmt.d:

/etc/bluetooth:
main.conf

/etc/ca-certificates:
extracted  trust-source</code></pre><p>所以遍历一个目录还是要用两个连续的<code>**</code>，如果不是bash 4.0之后的版本的话，可以使用find。 我推荐用find，因为它更通用。 有时候你会发现，使用find之后，绝大多数原来需要写脚本解决的问题可能都用不着了，一个find命令解决很多问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/05/e5-9c-a8shell-e8-84-9a-e6-9c-ac-e4-b8-ad-e4-bd-bf-e7-94-a8ls-e5-91-bd-e4-bb-a4-e7-9a-84-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9/" data-id="ck10vanwt000gzxz2s0lzyi9o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e9-82-ae-e4-bb-b6-e5-8f-91-e9-80-81-e5-8e-9f-e7-90-86" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/08/e9-82-ae-e4-bb-b6-e5-8f-91-e9-80-81-e5-8e-9f-e7-90-86/" class="article-date">
  <time datetime="2017-06-08T02:34:08.000Z" itemprop="datePublished">2017-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/08/e9-82-ae-e4-bb-b6-e5-8f-91-e9-80-81-e5-8e-9f-e7-90-86/">邮件发送原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SMTP(Simple Mail Transfer Protocol)是电子邮件从客户机传输到服务器或从某一个服务器传输到另一个服务器使用的传输协议。SMTP 是请求/响应协议，命令和响应都是基于 ASCII 文本，并以 CR 和 LF 符结束。响应包括一个表示返回状态的三位数字代码。在 TCP 协议 25 端口监听连接请求。其命令如下：</p>
<p>SMTP命令</p>
<p>命令说明</p>
<p>HELO ＜domain＞＜CRLF＞</p>
<p>识别发送方到接收SMTP的一个HELO命令</p>
<p>AUTH LOGIN</p>
<p>登陆服务器的命令。在这条命令之后，要发送用Base64编码后的用户名与密码进行登陆</p>
<p>MAIL FROM:＜reverse-path＞＜CRLF＞</p>
<p>＜reverse-path＞为发送者地址。此命令告诉接收方一个新邮件发送的开始，并对所有的状态和缓冲区进行初始化。此命令开始一个邮件传输处理，最终完成将邮件数据传送到一个或多个邮箱中</p>
<p>RCPT TO:＜forward-path＞＜CRLF＞</p>
<p>＜forward-path＞标识各个邮件接收者的地址</p>
<p>DATA ＜CRLF＞</p>
<p>接收SMTP将把其后的行为看作邮件数据去处理，以＜CRLF＞.＜CRLF＞标识数据的结尾</p>
<p>REST ＜CRLF＞</p>
<p>退出/复位当前的邮件传输</p>
<p>NOOP ＜CRLF＞</p>
<p>要求接收SMTP仅做OK应答。（用于测试）</p>
<p>QUIT ＜CRLF＞</p>
<p>要求接收SMTP返回一个OK应答并关闭传输。</p>
<p>VRFY ＜string＞ ＜CRLF＞</p>
<p>验证指定的邮箱是否存在，由于安全因素，服务器多禁止此命令。</p>
<p>EXPN ＜string＞ ＜CRLF＞</p>
<p>验证给定的邮箱列表是否存在，扩充邮箱列表，也常禁止使用。</p>
<p>HELP ＜CRLF＞</p>
<p>查询服务器支持什么命令</p>
<hr>
<p>邮件交互图</p>
<pre><code>A-&gt;B: 1. 建立TCP连接(host:port, 默认port为25)
B-&gt;A: 220. Anti-spam GT for Coremail System
Note over A: 
A-&gt;B: 2. 向服务器标识用户身份(HELO host\r\/n)
B-&gt;A: 250 OK
Note over A: 
A-&gt;B: 3. 登录服务器(AUTH LOGIN\r\/n)
B-&gt;A: 334. username: (这里是解密后的信息)
A-&gt;B: &lt;my_username&gt;(要用Base64加密)
B-&gt;A: 334. password: (这里是解密后的信息)
A-&gt;B: &lt;my_password&gt;(要用Base64加密)
B-&gt;A: 235. Authentication successful
Note over A: 
A-&gt;B: 4. 指定发信者(MAIL FROM: &lt;my_sender@gmail.com&gt;\r\/n)
B-&gt;A: 250. Mail OK
Note over A: 
A-&gt;B: 5. 指定收信者(RCPT TO: &lt;my_receiver@gmail.com&gt;\r\/n)
B-&gt;A: 250. Mail OK
Note over A: 
A-&gt;B: 6. 发送数据(DATA\r\/n)
B-&gt;A: 354. End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
Note over A: 
A-&gt;B: 7. to: &lt;my_receiver@gmail.com\r\/nsubject:&lt;my_subject&gt;\r\/nSome Context\r\/n.\r\/n&gt;
B-&gt;A: 250. Mail OK
Note over A: 
A-&gt;B: 8. QUIT\r\/n
B-&gt;A: 221. Bye</code></pre><p><strong>因markdown里不能打出”\n”, 因此使用”\/n” 代替”\n”</strong></p>
<hr>
<p>SMTP发信操作及返回码</p>
<pre><code>[crazywill@localhost crazywill]$ telnet smtp.163.com 25 #telnet登录25端口
Trying 202.108.5.81...
Connected to smtp.163.com.
Escape character is &apos;^]&apos;.
220 163.com Coremail SMTP(Anti Spam) System
EHLO smtp.163.com # 握手 :)
250-mail
250-PIPELINING
250-AUTH LOGIN PLAIN
250-AUTH=LOGIN PLAIN
250 8BITMIME
AUTH LOGIN # 开始认证登录
334 dXNlcm5hbWU6
crazywill
334 UGFzc3dvcmQ6
mypassword
535 Error: authentication failed # 直接用户名密码不能登录
AUTH LOGIN
334 dXNlcm5hbWU6
Y3Jhenl3aWxs
334 UGFzc3dvcmQ6
bXlwYXNzd29yZA==
235 Authentication successful # 使用Base64编码则成功登录
MAIL FROM:&lt;test@163.com&gt; # 邮件发送方
553 You are not authorized to send mail, authentication is required # 不可伪造发送邮件 
MAIL FROM:&lt;crazywill@163.com&gt; # 邮件发送方
250 Mail OK
RCPT TO:&lt;crazywill@163.com&gt; # 邮件的接收方，若有多个收件人，则重复这一语句多次。
250 Mail OK
DATA # 邮件体内容
354 Please start mail input.
TO: crazywill@163.com # 此处的TO，FROM，等内容，可以随便造假 :) 可以骗人但骗不了懂得查看邮件源码的。
FROM: cccc@163.com
SUBJECT: test by telnet/smtp 

test, just a test. # 邮件正文内容，与Header部分空一行开始写
. # 邮件写完，以一个句点加回车结果。
250 Mail OK queued as smtp10,wKjADQ2ApxRnnqBE0CWaEw==.38326S3 # 返回250 表示发送成功。
NOOP # 空语句，不执行任何操作，一般用来保持和服务器连接，不要掉线
250 OK
QUIT # 退出
221 Closing connection. Good bye.
Connection closed by foreign host.
[crazywill@localhost crazywill]$</code></pre><hr>
<p>参考资料: <a href="http://www.cnblogs.com/FengYan/archive/2013/01/01/2840982.html" target="_blank" rel="noopener">用c++发邮件</a> <a href="http://blog.csdn.net/lishuhuakai/article/details/27503503" target="_blank" rel="noopener">电子邮件发送的原理以及简易实现</a> <a href="http://blog.csdn.net/lishuhuakai/article/details/27852009" target="_blank" rel="noopener">邮件正文及其附件的发送的C++实现</a> <a href="http://blog.csdn.net/zbird1988/article/details/11592137" target="_blank" rel="noopener">C++通过SMTP发送邮件总结</a> <a href="http://blog.csdn.net/zbird1988/article/details/11592137" target="_blank" rel="noopener">C++实现向多人发送邮件</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/08/e9-82-ae-e4-bb-b6-e5-8f-91-e9-80-81-e5-8e-9f-e7-90-86/" data-id="ck10vanx50015zxz28ymsorix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e8-af-91how-to-split-a-string-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/e8-af-91how-to-split-a-string-in-c/" class="article-date">
  <time datetime="2017-06-04T10:40:14.000Z" itemprop="datePublished">2017-06-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/e8-af-91how-to-split-a-string-in-c/">[译]How to split a string in C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个问题是说, 怎么得到组成一句话的各个单词, 或者得到CSV中的各个数据片段. 这在C++中是个很简单的问题, 却有很多种答案.</p>
<p>有3种方案, 每种有利有弊. 使用时请自己选择最佳方案. 这篇文章的目的是说明 迭代器的接口是如何优胜于简单的容器的, 并且阐明 <a href="http://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/" target="_blank" rel="noopener">design of the STL</a> 是何等强大.</p>
<p>方案1使用的标准组件(虽然方案1.2 做了微调). 方案2相对好点但使用了<code>boost</code>. 而方案3 更好但使用了<code>ranges</code>. 所以到底应该用哪个, 取决于你需要什么和你能使用什么.</p>
<h3 id="Solution-1-Iterating-on-a-stream"><a href="#Solution-1-Iterating-on-a-stream" class="headerlink" title="Solution 1: Iterating on a stream"></a>Solution 1: Iterating on a stream</h3><h4 id="Stepping-into-the-world-of-streams"><a href="#Stepping-into-the-world-of-streams" class="headerlink" title="Stepping into the world of streams"></a>Stepping into the world of streams</h4><p>“流” 是一个 能生成 与源或希望连接的目标 的联系 的对象. 流可以从源中获取信息(<code>std::istream</code>), 或为目标提供信息(<code>std::ostream</code>), 或者两者皆可(<code>std::iostream</code>).</p>
<p>源和目标可以是标准输入(<code>std::cin</code>), 标准输出(<code>std::cout</code>), 一个文件, 或者一个字符串, 前提是方式得当. 对流的主要操作包括: - 对于输入流: 使用操作符<code>&gt;&gt;</code> 从里面读取信息 - 对于输出流: 使用操作符<code>&lt;&lt;</code>, 向它推入信息</p>
<p>一个指向字符串的输入流, <code>std::istringstream</code>, 有个有趣的特性: 它的操作符<code>&gt;&gt;</code> 在源字符串中制造出去向下一个空格的字符串.</p>
<h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p><code>std::istream_iterator</code> 是连接输入流的迭代器. 它代表了输入迭代器的普遍接口, 但它的操作符<code>++</code> 更像是输入流.</p>
<p><code>istream_iterator</code> 以它从流里读取的类型为模板. 我们现在使用<code>istream_iterator&lt;std::string&gt;</code>, 它从流里读取字符串, 分离时为我们提供一个字符串.</p>
<p>当到达流的终点时, 流向它的迭代器发送信号, 然后迭代器被标记为结束.</p>
<h3 id="Solution-1-1"><a href="#Solution-1-1" class="headerlink" title="Solution 1.1"></a>Solution 1.1</h3><p>现在, 我们可以借迭代器的接口使用算法, 这真切地证明了<code>STL</code> 设计的灵活性. 为了使用<code>STL</code>, 我们需要一个<code>begin</code> 和一个<code>end</code> (请参考<a href="http://www.fluentcpp.com/2017/03/28/inserting-several-elements-into-an-stl-container/" target="_blank" rel="noopener">Inserting several elements into an STL container efficiently</a>). <code>begin</code> 是一个 还没开始着手分割的字符串的<code>istreamstream</code> 的迭代器: <code>std::istream_iterator&lt;std::string&gt;(iss)</code> . 按照惯例, <code>end</code> 的默认值也是个<code>istream_iterator</code> : <code>std::istream_iterator&lt;string&gt;()</code>.</p>
<p>代码如下:</p>
<pre><code>std::string text = &quot;Let me split this into words&quot;;
std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;std::string&gt;(iss)), std::istream_iterator&lt;std::string&gt;());</code></pre><p><strong>第一个参数的额外的括号是为了避免与一个函数调用的歧义–请参考Scott Meyers的著作Effective STL 条目6 “most vexing parse”</strong></p>
<p>优: - 仅使用标准组件 - 除字符串外, 对所有流都适用 劣: - 只能以空格为分隔符进行分割, 而且这在解析CSV时会是个至关重要的问题 - 在性能方面有待优化(但如果这不是影响你整个程序的瓶颈, 这也不是个大问题) - 很多人认为仅为了分割一个字符串, 写了太多代码</p>
<h3 id="Solution1-2-Pimp-my-operator-gt-gt"><a href="#Solution1-2-Pimp-my-operator-gt-gt" class="headerlink" title="Solution1.2: Pimp my operator&gt;&gt;"></a>Solution1.2: Pimp my operator&gt;&gt;</h3><p>导致上面两条劣势的原因是同一个: <code>istream_iterator</code> 从流里读取字符串时调用的操作符<code>&gt;&gt;</code>. 这个操作符做了很多事: 在下一个空格处停止(这是我们的最初的需求, 但这个不能自定义), 格式化, 读取然后设置一些标志位, 构造对象, 等等. 而以上这些, 大部分我们是不需要的. 所以我们希望自己实现下面的函数:</p>
<pre><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; is, std::string&amp; output)
{
    // ...does lots of things...
}</code></pre><p>实际上, 我们无法改变这些, 因为这是在标注库里的. 我们可以用另一个类型重载它, 但是这个类型需要是<code>string</code> 的一种.</p>
<p>所以现在的需求就是, 用另一种类型伪装成<code>string</code>. 有两种方案: 继承<code>std::string</code> 和 用显式转换封装<code>string</code>. 这里我们选择继承.</p>
<p>假如我们希望以逗号为分割符分割一个字符串:</p>
<pre><code>class WordDelimitedByCommas: pulic std::string
{};</code></pre><p>我必须承认这是有争议的. 有人会说:”<code>std::string</code> 没有虚析构函数, 所以你不应该继承它!” 这可能, 大概, 也许是有一点点点点武断. 这里我要说的是, 继承本身不会产生问题. 诚然, 当一个指向<code>WordDelimitedByCommas</code> 的指针以<code>std::string</code> 的形式被<code>delete</code> 掉时, 会产生问题. 继续读, 你会发现, 我们不会这么做. 现在我们可以阻止写代码的人借<code>WordDelimitedByCommas</code> 突发冷箭破坏程序吗? 我们不能. 但是这个险值得我们冒吗? 请继续读, 然后你自己判断.</p>
<p>现在为了仅实现我们需要的功能, 我们可以重载操作符<code>&gt;&gt;</code> : 获取下一个逗号之前的所有字符. 这个可以借用<code>getline</code> 函数实现:</p>
<pre><code>std::istream&amp; operator&gt;&gt;(std::istream* is, std::WordDelimitedByCommas&amp;)
{
    std::getline(is, output, &apos;,&apos;);
    return is;
}</code></pre><p><strong>返回值<code>is</code> 保证了可以连续调用操作符<code>&gt;&gt;</code></strong></p>
<p>现在我们可以写初级代码了:</p>
<pre><code>std::string text = &quot;Let,me,split,this,into,words&quot;;
std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedByCommas&gt;(iss)), std::istream_iterator&lt;WordDelimitedByCommas&gt;());</code></pre><p>我们可以通过模板化<code>WordDelimitedByCommas</code> 泛华所有的分隔符:</p>
<pre><code>template&lt;char delemiter&gt;
class WordDelimitedBy: pulic std::string
{};</code></pre><p>现在以分号举例:</p>
<pre><code>std::string text = &quot;Let;me;split;this;into;words&quot;;
std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedBy&lt;&apos;;&apos;&gt;&gt;(iss)), std::istream_iterator&lt;WordDelimitedBy&lt;&apos;;&apos;&gt;&gt;());</code></pre><p>优: - 编译时允许任何分隔符 - 不仅是字符串, 对任何流都可以操作 - 比方案1更快(快20%到30%) 劣: - 虽然可以很方便的复用, 但仍不是标准 - 仅仅为了分割一个字符串, 这个方案仍然使用了大量代码</p>
<h3 id="Solution2-Using-boost-split"><a href="#Solution2-Using-boost-split" class="headerlink" title="Solution2: Using boost::split"></a>Solution2: Using <code>boost::split</code></h3><p>这个方案比方案1高级, 除非你需要对所有的流都进行操作.</p>
<pre><code>#include &lt;boost/algorithm/string.hpp&gt;

std::string text = &quot;Let me split this into words&quot;;
std::vector&lt;std::string&gt; result;
boost::split&lt;results, text, [](char c){return &apos; &apos; == c;});</code></pre><p>传给<code>boost::split</code> 的第三个参数是一个函数或函数对象, 确定一个字符是不是分隔符. 上面的例子是使用<code>lambda</code> 表达式, 传入一个<code>char</code>, 返回这个<code>char</code> 是否是空格.</p>
<p><code>boost::split</code> 的实现很简单: 在到达字符串的结束位置之前, 重复地调用<code>find_if</code> .</p>
<p>优: - 非常直观的接口 - 允许任何分隔符, 甚至是多个 - 高效: 比方案1.1 快 60% 劣: - 暂不是标准: 需要用到<code>boost</code></p>
<h3 id="Solution-3-未来-Usingranges"><a href="#Solution-3-未来-Usingranges" class="headerlink" title="Solution 3(未来): Usingranges"></a>Solution 3(未来): Using<code>ranges</code></h3><p>虽然它们现在还没有像标准库甚至<code>boost</code> 里的组件一样被广泛使用, <code>ranges</code> 是<a href="http://www.fluentcpp.com/2017/01/12/ranges-stl-to-the-next-level/" target="_blank" rel="noopener">future of the STL</a> . 在未来几年, 会大量面世.</p>
<p>Eric Neiber 的 <a href="https://github.com/ericniebler/range-v3/blob/master/test/view/split.cpp" target="_blank" rel="noopener">range-v3</a> 库 提供了非常友好的接口. 为了生成一个字符串的分割<code>view</code>, 代码如下:</p>
<pre><code>std::string text = &quot;Let me split this into words&quot;;
auto splitText = text | view::split(&apos; &apos;);</code></pre><p>它有很多有趣的特性, 诸如 使用一个子字符串作为分隔符. <code>ranges</code> 会被<code>C++20</code> 引入, 所以我们应该能在几年之内就可以使用这个功能了.</p>
<h3 id="So-how-do-I-split-my-string"><a href="#So-how-do-I-split-my-string" class="headerlink" title="So, how do I split my string?"></a>So, how do I split my string?</h3><p>如果你能使用<code>boost</code>, 务必使用方案2. 或者你可以自己写算法, 像<code>boost</code> 那样基于<code>find_if</code> 分割字符串.</p>
<p>如果你不想这么做, 你可以使用标准, 即方案1.1, 如果你需要自定义分隔符, 或者发现1.1是个瓶颈, 那么你可以选择方案1.2 .</p>
<p>如果你可以使用<code>ranges</code> , 那么就应该选择方案3.</p>
<p>翻译原文: <a href="http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/" target="_blank" rel="noopener">http://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/04/e8-af-91how-to-split-a-string-in-c/" data-id="ck10vanx20010zxz2mqy5h9ok" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-strict-weak-ordering" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/27/strict-weak-ordering/" class="article-date">
  <time datetime="2017-05-27T06:42:41.000Z" itemprop="datePublished">2017-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/27/strict-weak-ordering/">strict weak ordering</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>A strict weak ordering is a <em>binary relation</em> &lt; on a set S that is a strict partial order (a transitive relation that is irreflexive, or equivalently, that is asymmetric) in which the relation <code>neither a &lt; b nor b &lt; a</code> is transitive. Therefore, a strict weak ordering has the following properties:</p>
<ul>
<li>For all x in S, it is not the case that x &lt; x (irreflexivity).</li>
<li>For all x, y in S, if x &lt; y then it is not the case that y &lt; x (asymmetry).</li>
<li>For all x, y, z in S, if x &lt; y and y &lt; z then x &lt; z (transitivity).</li>
<li>For all x, y, z in S, if x is incomparable with y (neither x &lt; y nor y &lt; x hold), and y is incomparable with z, then x is incomparable with z (transitivity of incomparability).</li>
</ul>
<p>This list of properties is somewhat redundant, as asymmetry follows readily from irreflexivity and transitivity.</p>
<p><strong>离散数学中的relation:</strong> Given a function f (which models a binary relation) over a domain D, and a, b ∈ D:</p>
<ul>
<li>Reflexivity: f (a, a) is true.</li>
<li>Asymmetry: For a ≠ b, if f(a, b) is true, f(b,a) is false</li>
<li>Anti-symmetry: If f(a, b) and f(b, a) are both true iff a ≡ b</li>
<li>Transitivity: If f(a, b) and f(b, c) are true, then f(a, c) is true</li>
<li>Incomparability: Neither f(a, b) nor f(b, a) is true</li>
<li>Transitivity of incomparability: If a and b are incomparable, and so are b and c, then a and c are incomparable.</li>
</ul>
<p>摘自WikiPedia</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/27/strict-weak-ordering/" data-id="ck10vanyo003jzxz2szns6419" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux-e7-a6-81-e6-ad-a2-e6-99-ae-e9-80-9a-e7-94-a8-e6-88-b7su-e5-88-87-e6-8d-a2root" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/linux-e7-a6-81-e6-ad-a2-e6-99-ae-e9-80-9a-e7-94-a8-e6-88-b7su-e5-88-87-e6-8d-a2root/" class="article-date">
  <time datetime="2017-05-23T01:26:31.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/linux-e7-a6-81-e6-ad-a2-e6-99-ae-e9-80-9a-e7-94-a8-e6-88-b7su-e5-88-87-e6-8d-a2root/">Linux 禁止普通用户su切换root</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一般情况下, 普通用户执行”su -“命令, 可以登录为root. 为了加强系统的安全性, 有必要建立一个管理员的组, 只允许这个组的用户执行”su -“ 命令登录为root, 而让其他组的用户即使执行”su -“ 输入了正确的密码, 也无法登录为root用户. 在Unix 和Linux 下, 这个组的名称通常为”wheel”.</p>
<p>1 添加一个用户, 把这个用户加入wheel组 2 修改/etc/pam.d/su <code>#auth required pam_wheel.so use_uid</code> 这行注释打开 3 修改/etc/login.defs 在文件末添加一行 <code>SU_WHEEL_ONLY yes</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/23/linux-e7-a6-81-e6-ad-a2-e6-99-ae-e9-80-9a-e7-94-a8-e6-88-b7su-e5-88-87-e6-8d-a2root/" data-id="ck10vanxr0022zxz2rcslnir7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e7-a6-81-e6-ad-a2root-e7-94-a8-e6-88-b7ssh-e7-99-bb-e5-bd-95-e6-9c-ba-e5-99-a8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/e7-a6-81-e6-ad-a2root-e7-94-a8-e6-88-b7ssh-e7-99-bb-e5-bd-95-e6-9c-ba-e5-99-a8/" class="article-date">
  <time datetime="2017-05-23T01:07:42.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/e7-a6-81-e6-ad-a2root-e7-94-a8-e6-88-b7ssh-e7-99-bb-e5-bd-95-e6-9c-ba-e5-99-a8/">禁止root用户ssh登录机器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 修改 /etc/ssh/sshd_config <code>#PermitRootLogin yes</code> 取消注释并改为 <code>PermitRootLogin no</code></p>
<p>2 重启ssh <code>/etc/init.d/sshd restart</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/23/e7-a6-81-e6-ad-a2root-e7-94-a8-e6-88-b7ssh-e7-99-bb-e5-bd-95-e6-9c-ba-e5-99-a8/" data-id="ck10vanwy000rzxz2mb7vpz0x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-move-semantics-of-rapidjson" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/move-semantics-of-rapidjson/" class="article-date">
  <time datetime="2017-05-10T02:10:27.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>►<a class="article-category-link" href="/categories/C/En/JSON/">JSON</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/move-semantics-of-rapidjson/">Move semantics of RapidJSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RapidJSON 的设计有一个特性, 进行赋值操作时, 不是把源value复制(copy)到目的 value, 而是转移(move)到目的value. 例如</p>
<pre><code>Value a(123);
Value b(456);
b = a; // a becomes a Null value, b becomes number 123.</code></pre><p><img src="http://img.blog.csdn.net/20170510091639158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这样的设计的目的是 为了提高性能. 对于固定大小的JSON类型(Number, True, False, Null), 复制很简单快捷. 而对于可变大小的类型(String, Array, Object), 复制时会产生大量不容易被察觉的开销. 尤其是当我们需要创建一个临时的值, 把它复制给另一个变量, 然后析构它. 若使用正常的<strong>复制</strong> 语义:</p>
<pre><code>Document d;
Value o(kObjectType);
{
    Value contacts(kArrayType);
    // Adding elements to contacts array.
    // ...
    o.AddMember(&quot;contacts&quot;, contacts, d.GetAllocator(); // deep clone contacts(may be with lots of allocations)
    // destruct contact
}</code></pre><p><img src="http://img.blog.csdn.net/20170510092703640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><code>o</code> 需要分配跟<code>contacts</code> 大小一样的缓冲区, 做深度复制, 然后析构<code>contacts</code> . 这样会产生大量不必要的内存分配/释放 和内存复制. 有一些方案可以避免实质的复制这些数据, 如引用计数, 垃圾回收等等. 为了使RapidJSON简单和快速, 我们选择使用转移语义来进行赋值. 这与<code>std::auto_ptr</code>类似, 都是在赋值时转移拥有权. 转移比复制简捷地多, 它只需 析构原来的值, 把源值<code>memcpy()</code> 到目的值, 最后再把源值 设为Null类型.</p>
<p>使用转移语义, 上面的例子变成:</p>
<pre><code>Document d;
Value o(kObjectType);
{
    Value contacts(kArraryType);
    // Adding elements to contacts array.
    o.AddMember(&quot;contacts&quot;, contacts, d.GetAllocator()); // Just memcpy() of contacts itself to the value of new member(16 bytes)
    // contacts became Null here. Its destructiong is trivial.
}</code></pre><p><img src="http://img.blog.csdn.net/20170510094606202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>转移语义和临时值</strong> 有时, 我们想直接构造一个临时变量传给”转移”函数, 如<code>PushBack()</code> , <code>AddMember()</code> . 由于临时对象不能直接转化成正常的值引用, 我们可以调用<code>Move()</code> 函数</p>
<pre><code>Value a(kArrayType);
Document::AllocatorType&amp; allocator = document.GetAllocator();
// a.PushBack(Value(42), allocator); // Compiling error
a.PushBack(Value().SetInt(42), allocator); // fluent API
a.PushBack(Value(42).Move(), allocator); // same as above</code></pre><p>翻译原文: <a href="http://rapidjson.org/md\_doc\_tutorial.html#MoveSemantics" target="_blank" rel="noopener">http://rapidjson.org/md\_doc\_tutorial.html#MoveSemantics</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/10/move-semantics-of-rapidjson/" data-id="ck10vanxv0027zxz2xr9zjyck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c11-sort-using-function-objects" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/c11-sort-using-function-objects/" class="article-date">
  <time datetime="2017-04-19T13:58:53.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/c11-sort-using-function-objects/">[译]C++11 sort using function objects</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果你用C++编码， 需要对容器内的元素进行排序， 这个容器提供任意访问的迭代器， 比如<code>std::vector</code>， 那么简单快捷的方法是使用里的<code>std::sort</code> 函数.</p>
<p><strong>Basic sorting</strong> <code>std::sort</code> 函数需要两个参数, 这两个参数分别指向你要排序的序列容器的开始(initial)和终点(final). 这个序列容易内除final指向的那个元素外 所有元素都会被排序. 下面是一个简单的排序例子:</p>
<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;&lt;/vector&gt;&lt;/algorithm&gt;

const int array[] {10, 20, 5, 15, 0};
std::vector&lt;int&gt; vec(array, array + 5);&lt;/int&gt;

std::sort(vec.begin(), vec.end());</code></pre><p>输出: <code>0 5 10 15 20</code></p>
<p><strong>More complex sorting</strong> 在某些时候, 根据数值升序排序已经足够解决问题了, 但是当我们需要按某个特定的参数进行排序, 或者降序排列时, 就需要一些其他的东西了. 对于这种需求, <code>std::sort</code> 需要引入第三个参数: 比较函数. 这个比较函数有两个参数, 分别是序列容器的两个元素, 返回值可以隐式地转为bool. 如果第一个参数应该排在第二个参数前面, 则返回true.</p>
<p>例:</p>
<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;&lt;/vector&gt;&lt;/algorithm&gt;

bool DescOrderInt(int a, int b);
...
const int array[] = {10, 20, 5, 15, 0};
std::vector&lt;int&gt; vec(array, array + 5);&lt;/int&gt;

std::sort(vec.begin(), vec.end(), DescOrderInt);</code></pre><p>DescOrderInt的实现:</p>
<pre><code>bool DescOrderInt(int a, int b)
{
return a &amp;gt; b;
}</code></pre><p>输出: <code>20 15 10 5 0</code></p>
<p><strong>C++11 sort using function objects</strong> 网上很多例子说, 为了排列元素, 可以使用<code>std::binary_function</code> 定义比较函数, 但不幸的是, <code>std::binary_function</code> 在C++11 中已经被标为 “将被弃用的”, 在C++17中会被完全移除, 所以写新的C++代码时, 最好不要用这个.</p>
<p>我们可以使用C++11中引入的<code>std::function</code> 来定义这个函数指针. 例:</p>
<pre><code>#include &lt;algorithm&gt;
#include &lt;function&gt;
#include &lt;vector&gt;&lt;/vector&gt;&lt;/function&gt;&lt;/algorithm&gt;

struct StrDescOrderInt
{
bool operator()(int a, int b) const
{
return a &amp;gt; b;
}
};
...
const int array[] = {10, 20, 5, 15, 0};
std::vector&lt;int&gt; vec(array, array + 5);&lt;/int&gt;

std::function&lt;bool(int, int)=&quot;&quot;&gt; sorter = StrDescOrderInt();&lt;/bool(int,&gt;

std::sort(vec.begin(), vec.end(), sorter);</code></pre><p>输出: <code>20 15 10 5 0</code></p>
<p><strong>A real-life example: providing multiple sorting options</strong> 我们假设有一队足球运动员, 我们想让用户按他们自己的意愿去排列这些运动员. 有一个图表的UI, 上面有几个按钮, 每个按钮对应不用的排序规则.</p>
<p>Plaer 类的代码:</p>
<pre><code>// -- Player.h --
#include &lt;string&gt;&lt;/string&gt;

class Player
{
public:
Player(const char * name, int caps, int goals);

const std::string &amp;amp; GetName() const;

int GetCaps() const;
int GetGoals() const;

private:
std::string mName;

int mCaps;
int mGoals;
};</code></pre><p>现在我们新写一个类或结构体来列出所有的比较函数. 比较函数是一个结构体并实现操作符<code>()</code>, 操作符<code>()</code> 带有两个参数, 分别为两个指向Player的指针, 返回bool值.</p>
<pre><code>class Player;

struct PlayerSorting
{
// name
struct SortPlayerByNameAsc (bool operator()(Player* p1, Player* p2) const;);
struct SortPlayerByNameDes (bool operator()(Player* p1, Player* p2) const;);

// caps
struct SortPlayerByCapsAsc (bool operator()(Player* p1, Player* p2) const;);
struct SortPlayerByCapsDes (bool operator()(Player* p1, Player* p2) const;);

// goals
struct SortPlayerByGoalsAsc (bool operator()(Player* p1, Player* p2) const;);
struct SortPlayerByGoalsDes (bool operator()(Player* p1, Player* p2) const;);
}</code></pre><p>然后, 在调用它的地方, 我们可以先把所有的<code>std::function</code> 存在一个<code>std::vector</code> 里, 使用的时候, 用索引访问vector的元素.</p>
<pre><code>std::vector&amp;lt; std::function&lt;bool(player *,=&quot;&quot; player=&quot;&quot; *)=&quot;&quot;&gt; &amp;gt; sorters;
sorters.push_back(PlayerSorting::SortPlayerByNameAsc());
sorters.push_back(PlayerSorting::SortPlayerByCapsAsc());
sorters.push_back(PlayerSorting::SortPlayerByGoalsAsc());
sorters.push_back(PlayerSorting::SortPlayerByNameDes());
sorters.push_back(PlayerSorting::SortPlayerByCapsDes());
sorters.push_back(PlayerSorting::SortPlayerByGoalsDes());&lt;/bool(player&gt;</code></pre><p>例如, 根据得分降序排列:</p>
<pre><code>std::vector&lt;player *=&quot;&quot;&gt; players;&lt;/player&gt;

// ...init players...

std::sort(players.begin(), players.end(), sorters[5]);</code></pre><p>输出:</p>
<pre><code>NAME                     CAPS  GOALS
Lionel Messi             21    20
David Villa              13    16
Asamoah Gyan             22    15
Arjen Robben             11    12
Mesut Oezil              19    10
Diego Forlan             20    10
Andres Iniesta           15    9
Wesley Sneijder          24    6
Xavi                     17    5
Bastian Schweinsteiger   23    4</code></pre><p>假如需要实现一种新的排序方式, 我们只需要在PlayerSorting类中添加一个新的仿函数即可.</p>
<p>原文地址: <a href="http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/" target="_blank" rel="noopener">http://blog.davidecoppola.com/2015/01/cpp11-sort-using-function-objects/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/19/c11-sort-using-function-objects/" data-id="ck10vanw70002zxz2y79ejsb6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-strings-interface" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/09/strings-interface/" class="article-date">
  <time datetime="2017-04-09T14:00:41.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/strings-interface/">[译]String&amp;#039;s interface</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>考虑以下代码:</p>
<pre><code>bool fun(const string&amp;amp; code)
{
assert(code.length() &amp;gt;= 2);
if (code.substr(0, 2) == string(&quot;XX&quot;))
{
// ...
}
// ...
}</code></pre><p>有没有发现什么问题? 不要纠结于assert(), 它只是为了保证 string “code” 长度大于2而已.</p>
<p>很显然, 这段代码用来检查string是否以”XX”开头. 基于它长度大于2 的前提, 这段代码能正常运行. 我们的关心的问题是, 表达式能否达到正确的结果.</p>
<p>绝大多数情况下, 我们之所以使用C++, 是希望能使我们的程序达到最优的性能. 基于这个目标, 上面的代码看起来就不是很正确了. 为了检查”code”是否以”XX”开头, 我们生成了两个临时的string, 每个string都可能潜在地申请堆上的内存. 有人可能会为此辩解: std::string应该能为一个 2字母的序列实现 短字符串最优化(SSO). 就算这个辩解是正确的, 这段代码也已经 耗费了 一些不能被优化掉的开销, 更何况, 并不是所有的都会实现SSO. 例如, 我使用的GCC 4.4.7 就不会为string实现SSO.</p>
<p>类模板<code>std::basic_string</code> 的接口很复杂. 它提供了大量的成员函数, 似乎不用它们显得不领情, 同时开发者也不会有自己一遍遍重新解析的冲动.</p>
<p>因为开发者模糊地记得应用于NTBS(null-terminated byte strings)(可以被隐式地转为<code>const char*</code> )的 操作符 <code>==</code> 会使结果出错, 所以他通过 确保参与比较的两个值都是<code>std::string</code> 类型来避开这个错误. 他可能在想, 在运行操作符<code>==</code> 前文本”XX” 已经被显式地转成了<code>std::string</code>, 那么这么做也没有坏处. <strong>但是</strong>, 这是错误的, 因为对于操作符<code>==</code>, 标准提供了两种版本:</p>
<pre><code>bool operator==(const std::string&amp;amp; lhs, const char* rhs);
bool operator==(const char* lhs, const std::string&amp;amp; rhs);</code></pre><p>当然实际上他们是带有多个参数的函数模板, 远比这个复杂. <code>std::string</code> 可以直接跟NTBS比较, 没有必要生成临时的<code>std::string</code>. 我们开头的例子, 可以通过去除显式生成的临时副本 进行优化: <code>if (code.substr(0, 2) == &quot;XX&quot;)</code></p>
<p>更进一步, 不可否认, 在有些地方使用操作符<code>==</code> 看起来很高雅, 但是仅仅为了检查一个<code>string</code> 本身的一部分而去新申请一部分资源(生成一个新的<code>string</code>) 这种做法是错误的. 开发者的初衷, 并不是要是程序看起来高雅. 实际上, 如果我们深入研究<code>std::basic_string</code> 的官方文档, 就会发现, <code>std::basic_string</code>提供了一种比较它的子字符串和NTBS的方法: <code>if(code.compare(0, 2, &quot;XX&quot;) == 0)</code> 这个比较是三方比较, 结果等于0表示相等. 它可以达到目的, 并且不需要生成任何临时的<code>string</code>.</p>
<p>尽管这个<code>compare()</code> 使性能达到了很大的优化, 但我并不满足于此. 虽然它做了正确的事情, 但如果我们是第一次遇到他, 很难抓住他的精髓. 如果你可以使用boost库, 我的建议性的解决方案是使用<code>Boost String Algorithms Library</code> 中的算法:</p>
<pre><code>#include &lt;boost algorithm=&quot;&quot; string=&quot;&quot; predicate.hpp=&quot;&quot;&gt;&lt;/boost&gt;

bool func(const string&amp;amp; code)
{
if (boost::algorithm::starts_with(code, &quot;XX&quot;))
}</code></pre><p>这段代码很好地体现了我想说的意思, 没有任何多余的开销.</p>
<p>原文地址: <a href="https://akrzemi1.wordpress.com/2015/04/15/strings-interface/" target="_blank" rel="noopener">https://akrzemi1.wordpress.com/2015/04/15/strings-interface/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/09/strings-interface/" data-id="ck10vanyq003lzxz2tb9zmfdp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e8-af-91custom-comparison-equality-and-equivalence-with-the-stl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/29/e8-af-91custom-comparison-equality-and-equivalence-with-the-stl/" class="article-date">
  <time datetime="2017-03-29T11:01:51.000Z" itemprop="datePublished">2017-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/29/e8-af-91custom-comparison-equality-and-equivalence-with-the-stl/">[译]Custom comparison, equality and equivalence with the STL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从一段代码引用开始:</p>
<pre><code>std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; v1 = ... // v1 is filled with data
std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; v2 = ... // v2 is filled with data
std::vector&amp;lt; std::pair&lt;int, std::string=&quot;&quot;&gt; &amp;gt; results;&lt;/int,&gt;&lt;/int,&gt;&lt;/int,&gt;

std::sort(v1.begin(), v1.end());
std::sort(v2.begin(), v2.end());

std::set_difference(v1.begin(), v1.end(),
v2.begin(), v2.end(),
std::back_inserter(result),
compareFirst);</code></pre><p>我们在两个排好序的vector v1 和 v2上调用<code>std::set_difference</code>. <code>std::set_difference</code> 把结果写入 <code>result</code>, <code>std::back_inserter</code> 确保输出的结果从<code>result</code> 的后面添入. 自定义的<code>compareFirst</code> 作为比较函数提供给<code>std::set_difference</code></p>
<p>默认地, <code>std::set_difference</code> 通过 <code>std::pair</code> 默认的比较函数来比较里面的元素(比较pair的first和second), 我们自定义了<code>compareFirst</code>, 希望只比较pair的first. <code>compareFirst</code>不是STL的函数, 需要我们自己实现.</p>
<p><code>std::set_difference</code> 使用的前提是input已经排好序, 倘若我们自定义比较函数C, 而通过C我们能把元素排好序, 那么我们使用这个C代替sort的默认排序也是可以的.</p>
<p>在此例中, 我们使用<code>std::set_difference</code> 只对pair的first进行排序, 尽管它们已经通过”first + second”的方式排序完了.</p>
<p>下面来实现<code>compareFirst</code>. 初版:</p>
<pre><code>bool compareFirst(const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp;amp; p1, const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp;amp; p2)
{
return p1.first == p2.first; // not final code, bug lurking here!
}</code></pre><p>实际上, 上面的代码不会得到我们预期的结果. 为什么? 毕竟<code>std::set_difference</code> 会检查元素跟另一个容器的元素是否相等(equal), 不是吗?&lt;/int,&gt;&lt;/int,&gt;</p>
<p>为了理解上面的内容, 我们把STL大概地分为两类: 操作排序元素的 和操作乱序元素的.</p>
<p><strong>Comparing elements</strong></p>
<p>C++中描述”a is the same as b” 有两种方法</p>
<pre><code>- the natural way: a == b. This is called equality. Equality is based on operator==.
- the other way: a is not smaller than b and b is not smaller than a, so !(a&lt;b) &amp;&amp;=&quot;&quot; !(b&lt;a).=&quot;&quot; this=&quot;&quot; is=&quot;&quot; called=&quot;&quot; equivalence.=&quot;&quot; equivalence=&quot;&quot; based=&quot;&quot; on=&quot;&quot; operator&lt;.=&quot;&quot; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    对于基本类型如int, 甚至实践中大多数类型, `equivalence` 和`quality` 是相通的. 但是正如*Scott Meyers* 在&amp;lt;&amp;lt; Effective STL&amp;gt;&amp;gt;  一书条目19中指出的, 对于有一些类型, 即使&quot;并非罕见&quot;, `equivalence` 和 `equality` 是不同的, 如 大小写不敏感的string类型.</span><br><span class="line">    </span><br><span class="line">    &lt;u&gt;Why such a far-fetched way to express a simple thing?&lt;/u&gt;</span><br><span class="line">    </span><br><span class="line">    当我们使用算法对容器内元素进行排序时, 很容易理解必须有独一无二的排序方法(如有多种排序方法, 会很笨重, 并可能产生不一致的结果). 所以对于一个特定的容器, 排序时, &quot;==&quot; 和&quot;&amp;lt;&quot; 只能选一个. </span><br><span class="line">    </span><br><span class="line">    对于STL中排序的部分, 我们别无选择: 排序时必须使用&quot;&amp;lt;&quot;;</span><br><span class="line">    而乱序部分, 则没有这个约束, 我们可以使用&quot;==&quot;.</span><br><span class="line">    </span><br><span class="line">    **Implementing the comparator**</span><br><span class="line">    </span><br><span class="line">    STL的乱序部分使用&quot;==&quot;, 而排序部分使用&quot;&amp;lt;&quot;. 我们自定义的比较函数也必须遵循这种逻辑. </span><br><span class="line">    </span><br><span class="line">    现在我们可以理解怎么自定义实现`std::set_difference` 的比较函数`compareFirst` 了.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">bool compareFirst(const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp; p1, const std::pair&lt;int, std::string=&quot;&quot;&gt;&amp; p2) &#123; return p1.first &lt; p2.first; // correct, STL-compatible code. &#125;</span><br></pre></td></tr></table></figure></code></pre><p>原文地址: <a href="http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/" target="_blank" rel="noopener">http://www.fluentcpp.com/2017/02/16/custom-comparison-equality-equivalence-stl/</a> &lt;/int,&gt;&lt;/int,&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/29/e8-af-91custom-comparison-equality-and-equivalence-with-the-stl/" data-id="ck10vanx0000wzxz28suvm5bc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/A-amp-V/">A&amp;V</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/En/">En</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/En/JSON/">JSON</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB/">DB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/DB/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design/">Design</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rasp/">Rasp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 20px;">nginx</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/08/08/e5-8d-87-e7-ba-a7https/">升级https</a>
          </li>
        
          <li>
            <a href="/2019/07/23/docker-e6-8c-82-e8-bd-bd-e7-9b-ae-e5-bd-95-e5-a4-b1-e8-b4-a5-e6-9d-83-e9-99-90-e6-8b-92-e7-bb-9d/">docker挂载目录失败/权限拒绝</a>
          </li>
        
          <li>
            <a href="/2019/07/02/mac-iterm2-e7-99-bb-e9-99-86centos-e6-8f-90-e7-a4-bawarning-setlocale-lc-ctype-cannot-change-locale-utf-8-no-such-file-or-directory/">Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</a>
          </li>
        
          <li>
            <a href="/2019/06/12/e5-8d-87-e7-ba-a7-e5-88-b0php7-1-e4-b9-8b-e5-90-8ewordpress-e7-bd-91-e7-ab-99-e5-87-ba-e7-8e-b0error-establishing-a-database-connection-e7-9a-84-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95/">升级到php7.1之后wordpress 网站出现Error establishing a database connection的解决方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>