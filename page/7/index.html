<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-e8-af-91how-to-stdfind-something-efficiently-with-the-stl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/e8-af-91how-to-stdfind-something-efficiently-with-the-stl/" class="article-date">
  <time datetime="2017-03-16T14:07:59.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/e8-af-91how-to-stdfind-something-efficiently-with-the-stl/">[译]How to (std::)find something efficiently with the STL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文分3部分: 1. 怎么使用STL进行高效的查找: 借用传统STL算法对元素进行范围搜索 2. 搜索STL容器: 当你有直接读取STL容器里元素的权限时, 怎么进行高效准确的搜索(与简单的范围搜索相比较) 3. STL搜索算法的秘密: 向公众展示不为人知的算法, 这些算法在已经学习过的人眼里确实是很有用的</p>
<p>STL根据查看方式的不同, 一共分为两种: 排序的和不排序的. * 排序集合的遍历, 通常需要对数时长, 而乱序集合的遍历, 需要线性时长 * 排序容器中比较元素大小的函数根据equivalence(comparing with &lt;), 而乱序容器中的函数根据equality(comparing with ==).</p>
<p>本文将展示对于在一个范围内搜索一个给定的值, C++怎么样去阐述下面3个问题: * 它存在否 * 它在哪 * 它应该在什么位置(排序容器)</p>
<h3 id="Is-it-there"><a href="#Is-it-there" class="headerlink" title="Is it there?"></a>Is it there?</h3><h4 id="乱序容器的元素"><a href="#乱序容器的元素" class="headerlink" title="乱序容器的元素"></a>乱序容器的元素</h4><p>这个问题可以用std::find来表达(需要和与范围的终点值的比较相结合):</p>
<pre><code>vector&lt;int&gt; v = ... // v filled with values
if (std::find(v.begin(), v.end(), 42) != v.end())
{
...</code></pre><p>“Is it there”这个问题也可以用std::count来表达:</p>
<pre><code>vector&lt;int&gt; v = ... // v filled with values
if (std::count(v.begin(), v.end(), 42))
{
...</code></pre><p>std::count()的返回值会被隐式地转换成if条件里的bool值: 如果该范围里有至少一个值为42, 则返回true.</p>
<p>与std::find相比, std::count的优劣: 优势:</p>
<ul>
<li>std::count避免了与范围的end值相比较</li>
</ul>
<p>弊端:</p>
<ul>
<li>std::count遍历整个集合, 而std::find在第一个与要查找的值相等的位置停下</li>
<li>可以证明, 对于”想要查找某个值”这件事, std::find 表达得更明确 基于以上, std::find用得更多.</li>
</ul>
<p><strong>Note</strong> 若要确认某个值存在而非是与要搜索的值相等, 请使用<code>std::count_if, std::find_if, std::find_if_not</code></p>
<h4 id="排序容器的元素"><a href="#排序容器的元素" class="headerlink" title="排序容器的元素"></a>排序容器的元素</h4><p>使用的算法是<code>std::binary_search</code>, 此函数返回一个bool值, 此bool值表示在集合中是否存在与搜索的值相等的元素.</p>
<pre><code>std::set&lt;int&gt; numbers = // sorted elements
bool is42InThere = std::binary_search(numbers.begin(), numbers.end(), 42);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    ### Where is it?</span><br><span class="line">    (当确定了要搜索的值存在后,) 我们想更进一步, 得到指向那个元素的迭代器.</span><br><span class="line">    </span><br><span class="line">    #### 乱序容器的元素</span><br><span class="line">    </span><br><span class="line">    使用std::find. 返回指向第一个与搜索的值相等的元素的迭代器, 如果找不到, 则返回集合的终点.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector numbers = ... auto searchResult = std::find(numbers.begin(), numbers.end(), 42);</span><br><span class="line"></span><br><span class="line">if (searchResult != numbers.end()) &#123; ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    #### 排序容器的元素</span><br><span class="line">    </span><br><span class="line">    对于排序集合, STL并没有像std::find一样直接的算法. std::find并不是为排序容器设计的, 因为它依据的是&quot;==&quot;而不是&quot;&amp;lt;&quot;, 消耗的时间为线性时长而不是对数时长.</span><br><span class="line">    对于一个给定的容器, 如果容器内元素的&quot;equality&quot;和&quot;equivalence&quot;是相同的, 且你能接受消耗的线性时长, 那么std::find会为你返回正确的结果, 你也能从它简单直接的接口中获益. **但是,** 不能忘记, std::find并不是为排序容器设计的.</span><br><span class="line">    </span><br><span class="line">    这里推荐使用`std::equal_range`. (并非`std::lower_bound`)</span><br><span class="line">    函数原型: </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">template&lt; class ForwardIt, class T &gt; std::pair&lt;forwardit,forwardit&gt; equal_range( ForwardIt first, ForwardIt last, const T&amp; value );</span><br><span class="line"></span><br><span class="line">    `std::equal_range` 返回与搜索值相等的元素的范围, 这个范围用一对集合内的迭代器表示. 这两个迭代器分别指向 与搜索值相等的范围里第一个元素和最后一个元素的下一个位置.&lt;/forwardit,forwardit&gt;</span><br><span class="line">    </span><br><span class="line">    然而, 它的接口有些笨重:</span><br><span class="line">    例A:</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector v = &#123;3, 7, 3, 11, 3, 3, 2&#125;; sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">// equal_range, attempt 1: natively clumsy std::pair&lt;std::vector::iterator, std::vector::iterator&gt; range1 = equal\_range(v.begin(), v.end(), 3); std::for\_each(range1.first, range1.second, doSomething);</span><br><span class="line"></span><br><span class="line">    用一个`typedef` 或者`using`让它更简洁:</span><br><span class="line">    例B:</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector v = &#123;3, 7, 3, 11, 3, 3, 2&#125;; sort(v.begin(), v.end());&lt;/std::vector</span><br><span class="line"></span><br><span class="line">using IteratorPair = std::pair&lt;std::vector::iterator, std::vector::iterator&gt;;&lt;/std::vector</span><br><span class="line"></span><br><span class="line">// equal\_range, attempt 2: with the classical typedef IteratorPair range2 = equal\_range(v.begin(), v.end(), 3); std::for_each(range2.first, range2.second, doSomething);</span><br><span class="line"></span><br><span class="line">    例B确实简洁了很多, 但是仍有一个根本问题: 没有考虑 抽象等级.</span><br><span class="line">    尽管返回的是一个范围, 但这对迭代器强迫我们在操作返回的范围时必须按照&quot;第一&quot;&quot;第二&quot;这种方式来写代码. 范围就应该用&quot;首&quot;&quot;尾&quot;这种方式来表达. 这不仅给我们在其他地方使用这个返回值时造成很大的麻烦, 而且使代码很别扭.</span><br><span class="line">    </span><br><span class="line">    为了解决这个问题, 我么可以把`std::equal_range` 返回的迭代器对封装进一个有&quot;范围&quot;这种语义的`object`</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">template</span><br><span class="line"></span><br><span class="line">class Range</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Range(std::pair range)</span><br><span class="line"></span><br><span class="line">m\_begin(range.first), m\_end(range.second) &#123;&#125; typename Container::iterator begin() &#123; return m\_begin; &#125; typename Container::iterator end() &#123; return m\_end; &#125;</span><br><span class="line"></span><br><span class="line">private: typename Container::iterator m\_begin; typename Container::iterator m\_end; &#125;;</span><br><span class="line"></span><br><span class="line">    注意: 尽管`std::equal_range` 返回的结果是一个&quot;范围&quot;, 但是`std::begin` 和 `std::end` 不能用在这个结果上. 而上面的封装解决了这个问题.</span><br><span class="line">    可以像下面这样使用:</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector v = &#123;3, 7, 3, 11, 3, 3, 2&#125;; sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">// equal_range, attempt 3: natural al last Range&lt;std::vector\&gt; range3 = equal\_range(v.begin(), v.end(), 3); std::for\_each(range3.begin(), range3.end(), doSomething);</span><br><span class="line"></span><br><span class="line">    不管你使用上面的哪种方式, `std::equal_range` 都会返回一个范围, 要确定它是否为空, 可以通过检查那两个迭代器(是否相等)或者使用`std::distance` 检查它的大小. &lt;/std::vector&lt;int&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">bool noElementFound = range3.begin() == range3.end(); size_t numberOfElementFound = std::distance(range3.begin(), range3.end())</span><br></pre></td></tr></table></figure></code></pre><h3 id="Where-should-it-be"><a href="#Where-should-it-be" class="headerlink" title="Where should it be?"></a>Where should it be?</h3><p>这个问题仅仅针对排序的范围, 因为对于乱序的范围, 某个元素可能会存在任何位置.</p>
<p>对于排序的范围, 这个问题可以简化为: 如果它存在, 那么它在哪儿? 如果它不存在, 那么它应该在哪儿?</p>
<p>这个问题可以用算法<code>std::lower_bound</code> 和<code>std::upper_bound</code> 来解释.</p>
<p>当你理解了<code>std::equal_range</code> 后, 上面这句话就很容易理解了: <code>std::lower_bound</code> 和<code>std::upper_bound</code> 都会返回 <code>std::equal_range</code> 返回的那个迭代器对的第一个和第二个迭代器.</p>
<p>要插入某个值x, 使用<code>std::lower_bound</code> 得到指向 在范围里与x相等的元素之前的位置的迭代器, 使用<code>std::upper_bound</code> 得到指向 在范围里与x相等的元素之后的位置的迭代器.</p>
<p>注意: 如果仅仅是搜索某个元素, 永远不要使用<code>std::lower_bound</code></p>
<p>与<code>std::find</code> 相反, 你不能根据 判断<code>std::lower_bound</code> 返回的迭代器是否与终点的迭代器相等 来判断要搜索的值是否存在于这个集合. 事实上, 如果这个值在集合里不存在, 则<code>std::lower_bound</code> 返回它应该在的位置, 而不是终点的迭代器. 所以, 你不仅需要确认返回的迭代器不是终点的迭代器, 还要确认它指向的元素跟要搜索的值是相等的.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Question to express in C++</p>
<p>NOT SORTED</p>
<p>SORTED</p>
<p>Is it there?</p>
<p>std::find != end</p>
<p>std::binary_search</p>
<p>Where is it?</p>
<p>std::find</p>
<p>std::equal_range</p>
<p>Where should it be?</p>
<p>-</p>
<p>std::lower_bound / std::upper_bound</p>
<p>原文地址: <a href="http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm\_medium=toutiao.io&amp;utm\_source=toutiao.io" target="_blank" rel="noopener">http://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/?hmsr=toutiao.io&amp;utm\_medium=toutiao.io&amp;utm\_source=toutiao.io</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/e8-af-91how-to-stdfind-something-efficiently-with-the-stl/" data-id="ck10vanx30012zxz23by7h9v0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e8-af-91effective-stl-9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/09/e8-af-91effective-stl-9/" class="article-date">
  <time datetime="2017-03-09T13:09:09.000Z" itemprop="datePublished">2017-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/e8-af-91effective-stl-9/">[译]Effective STL 9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>条款9：在删除选项中仔细选择 假定你有一个标准STL容器，c，容纳int， <code>Container&lt;int&gt; c;</code> 而你想把c中所有值为<code>1963</code>的对象都去掉。令人吃惊的是，完成这项任务的方法因不同的容 器类型而不同：没有一种方法是通用的。</p>
<p>如果你有一个连续内存容器（vector、deque或string——参见条款1），最好的方法是erase-remove惯用法（参见条款32）：</p>
<pre><code>c.erase(remove(c.begin(), c.end(), 1963),       // 当c是vector、string
c.end());                               // 或deque时，
// erase-remove惯用法
// 是去除特定值的元素
// 的最佳方法</code></pre><p>这方法也适合于list，但是，正如条款44解释的，list的成员函数remove更高效：</p>
<pre><code>c.remove(1963);     // 当c是list时，
// remove成员函数是去除
// 特定值的元素的最佳方法</code></pre><p>当c是标准关联容器（即，set、multiset、map或multimap）时，使用任何叫做remove的东 西都是完全错误的。这样的容器没有叫做remove的成员函数，而且使用remove算法可能覆 盖容器值（参见条款32），潜在地破坏容器。（关于这样的破坏的细节，参考条款22，那 个条款也解释了为什么试图在map和multimap上使用remove肯定不能编译，而试图在set和 multiset上使用可能不能编译。）</p>
<p>不，对于关联容器，解决问题的适当方法是调用erase：</p>
<pre><code>c.erase(1963);      // 当c是标准关联容器时
// erase成员函数是去除
// 特定值的元素的最佳方法</code></pre><p>这不仅是正确的，而且很高效，只花费对数时间。（序列容器的基于删除的技术需要线性 时间。）并且，关联容器的erase成员函数有基于等价而不是相等的优势，条款19解释了这 一区别的重要性。</p>
<p>让我们现在稍微修改一下这个问题。不是从c中除去每个有特定值的物体，让我们消除下面 判断式（参见条款39）返回真的每个对象：</p>
<pre><code>bool badValue(int x);   // 返回x是否是“bad”
对于序列容器（vector、string、deque和list），我们要做的只是把每个remove()替换为remove_if()，然后就完成了：

c.erase(remove_if(c.begin(), c.end(), badValue),    // 当c是vector、string
c.end());           // 或deque时这是去掉
// badValue返回真
// 的对象的最佳方法
c.remove_if(badValue);              // 当c是list时这是去掉
// badValue返回真
// 的对象的最佳方法</code></pre><p>对于标准关联容器，它不是很直截了当。有两种方法处理该问题，一个更容易编码，另一 个更高效。“更容易但效率较低”的解决方案用<code>remove_copy_if()</code>把我们需要的值拷贝到一 个新容器中，然后把原容器的内容和新的交换：</p>
<pre><code>AssocContainer&lt;int&gt; c;              // c现在是一种
...                                 // 标准关联容器
AssocContainer&lt;int&gt; goodValues;         // 用于容纳不删除
// 的值的临时容器
remove_copy_if(c.begin(), c.end(),          // 从c拷贝不删除
inserter(goodValues,        // 的值到
goodValues.end()),          // goodValues
badValue);
c.swap(goodValues);             // 交换c和goodValues
// 的内容</code></pre><p>这种方法的缺点是它拷贝了所有不删除的元素，而这样的拷贝开销可能大于我们期望的底线。</p>
<p>我们可以通过直接从原容器删除元素来避开拷贝的开销。不过，因为关联容器没有提供类似<code>remove_if()</code>的成员函数，所以我们必须写一个循环来迭代c中的元素，和原来一样删除元素.</p>
<p>看起来，这个任务很简单，而且实际上，代码也很简单。不幸的是，那些正确工作的代码 很少是跃出脑海的代码。例如，这是很多程序员首先想到的：</p>
<pre><code>AssocContainer&lt;int&gt; c;
...
for (AssocContainer&lt;int&gt;::iterator i = c.begin();   // 清晰，直截了当
i!= c.end();                                // 而漏洞百出的用于
++i) {                                      // 删除c中badValue返回真
if (badValue(*i)) c.erase(i);                   // 的每个元素的代码
}                                                   // 不要这么做！&lt;/int&gt;&lt;/int&gt;</code></pre><p>唉，这有未定义的行为。当容器的一个元素被删时，指向那个元素的所有迭代器都失效了 。当c.erase(i)返回时，i已经失效。那对于这个循环是个坏消息，因为在erase()返回后， i通过for循环的++i部分自增。</p>
<p>为了避免这个问题，我们必须保证在调用erase之前就得到了c中下一元素的迭代器。最容 易的方法是当我们调用时在i上使用后置递增：</p>
<pre><code>AssocContainer&lt;int&gt; c;
...
for (AssocContainer&lt;int&gt;::iterator i = c.begin();   // for循环的第三部分
i != c.end();                                   // 是空的；i现在在下面
/*nothing*/ ){                                 // 自增
if (badValue(*i)) c.erase(i++);     // 对于坏的值，把当前的
else ++i;                           // i传给erase，然后
}                                       // 作为副作用增加i；
// 对于好的值，
// 只增加i</code></pre><p>这种调用erase()的解决方法可以工作，因为表达式i++的值是i的旧值，但作为副作用，i增 加了。因此，我们把i的旧值（没增加的）传给erase，但在erase开始执行前i已经自增了 。那正好是我们想要的。正如我所说的，代码很简单，只不过不是大多数程序员在第一次 尝试时想到的。</p>
<p>现在让我们进一步修改该问题。不仅删除badValue返回真的每个元素，而且每当一个元素 被删掉时，我们也想把一条消息写到日志文件中。</p>
<p>对于关联容器，这说多容易就有多容易，因为只需要对我们刚才开发的循环做一个微不足 道的修改就行了：</p>
<pre><code>ofstream logFile;                   // 要写入的日志文件
AssocContainer&lt;int&gt; c;
...
for (AssocContainer&lt;int&gt;::iterator i = c.begin();   // 循环条件和前面一样
i !=c.end();){
if (badValue(*i)){
logFile &amp;lt;&amp;lt; &quot;Erasing &quot; &amp;lt;&amp;lt; *i &amp;lt;&amp;lt;&apos;\n&apos;;   // 写日志文件 
        c.erase(i++);           // 删除元素
    }
    else ++i;
}</code></pre><p>现在是vector、string和deque给我们带来麻烦。我们不能再使用<code>erase-remove</code>惯用法，因为没有办法让erase()或remove()写日志文件。而且，我们不能使用刚刚为关联容器开发的循环, 因为它为vector、string和deque产生未定义的行为！要记得对于那样的容器，调用erase不仅使所有指向被删元素的迭代器失效，也使被删元素之后的所有迭代器失效。在我们的情况里，那包括所有i之后的迭代器。我们写i++，++i或你能想起的其它任何东西都没有用，因为没有能导致迭代器有效的。</p>
<p>我们必须对vector、string和deque采用不同的战略。特别是，我们必须利用erase()的返回值。那个返回值正是我们需要的：一旦删除完成，它就是指向紧接在被删元素之后的元素的有效迭代器。换句话说，我们这么写：</p>
<pre><code>for (SeqContainer&lt;int&gt;::iterator i = c.begin();
i != c.end();){
if (badValue(*i)){
logFile &amp;lt;&amp;lt; &quot;Erasing &quot; &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &apos;\n&apos;; 
        i = c.erase(i);         // 通过把erase的返回值
    }                   // 赋给i来保持i有效
    else
        ++i;
}</code></pre><p>这可以很好地工作，但只用于标准序列容器。由于论证一个可能的问题（条款5做了），标准关联容器的erase()的返回类型是void[1]。对于那些容器，你必须使用“后置递增你要传给erase()的迭代器”技术。（顺便说说，在为序列容器编码和为关联容器编码之间的这种差别是为什么写容器无关代码一般缺乏考虑的一个例子——参见条款2。)</p>
<p>为了避免你奇怪list的适当方法是什么，事实表明对于迭代和删除，你可以像vector/str ing/deque一样或像关联容器一样对待list；两种方法都可以为list工作。</p>
<p>如果我们观察在本条款中提到的所有东西，我们得出下列结论：</p>
<p>去除一个容器中有特定值的所有对象： 如果容器是vector、string或deque，使用erase-remove惯用法。</p>
<p>如果容器是list，使用list::remove。</p>
<p>如果容器是标准关联容器，使用它的erase成员函数。</p>
<p>去除一个容器中满足一个特定判定式的所有对象： 如果容器是vector、string或deque，使用<code>erase-remove_if</code>惯用法。</p>
<p>如果容器是list，使用list::remove_if。</p>
<p>如果容器是标准关联容器，使用<code>remove_copy_if</code>和<code>swap</code>，或写一个循环来遍历容器元素， 当你把迭代器传给erase时记得后置递增它。</p>
<p>在循环内做某些事情（除了删除对象之外）： 如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。 如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</p>
<p>如你所见，与仅仅调用erase相比，有效地删除容器元素有更多的东西。解决问题的最好方法取决于你是怎样鉴别出哪个对象是要被去掉的，储存它们的容器的类型，和当你删除它们的时候你还想要做什么（如果有的话）。只要你小心而且注意了本条款的建议，你将毫不费力。如果你不小心，你将冒着产生不必要低效的代码或未定义行为的危险。</p>
<h2 id><a href="#" class="headerlink" title="------------------------------------------------------------------------------"></a>------------------------------------------------------------------------------</h2><p>[1] 这仅对带有迭代器实参的erase()形式是正确的。关联容器也提供一个带有一个值的实参 的erase()形式，而那种形式返回被删掉的元素个数。但这里，我们只关心通过迭代器删除东 西。</p>
<p><a href="https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_3%2FC%2Fnetres%2Feffstl%2Ffile10.html" target="_blank" rel="noopener">参考地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/09/e8-af-91effective-stl-9/" data-id="ck10vanzw004wzxz2me7ppzm0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-stl-e7-9a-84-erase-e9-99-b7-e9-98-b1-e8-bf-ad-e4-bb-a3-e5-99-a8-e5-a4-b1-e6-95-88-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/stl-e7-9a-84-erase-e9-99-b7-e9-98-b1-e8-bf-ad-e4-bb-a3-e5-99-a8-e5-a4-b1-e6-95-88-e6-80-bb-e7-bb-93/" class="article-date">
  <time datetime="2017-03-02T15:10:19.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>►<a class="article-category-link" href="/categories/C/En/">En</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/02/stl-e7-9a-84-erase-e9-99-b7-e9-98-b1-e8-bf-ad-e4-bb-a3-e5-99-a8-e5-a4-b1-e6-95-88-e6-80-bb-e7-bb-93/">STL 的 erase( ) 陷阱-迭代器失效总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STL中的容器按存储方式分为两类，一类是按以数组形式存储的容器（如：vector 、deque)；另一类是以不连续的节点形式存储的容器（如：list、set、map）。在使用erase方法来删除元素时，需要注意一些问题。</p>
<h4 id="1-list-set-map容器"><a href="#1-list-set-map容器" class="headerlink" title="1.list,set,map容器"></a><strong>1.list,set,map容器</strong></h4><p>在使用 list、set 或 map遍历删除某些元素时可以这样使用：</p>
<p><strong><del>1.1 正确写法 1</del></strong></p>
<pre><code>std::list&lt;int&gt; list;
std::list&lt;int&gt;::iterator it_list;
for (it_list = list.begin(); it_list != list.end();)
{
if (willDelete(*it_list))
{
it_list = list.erase(it_list);
}
else
{
++it_list;
}
}</code></pre><p><strong>Note:</strong> 以上方法仅适用于standard sequence container, 因为对于standard associative container, erase()的返回类型为void. (查阅Effective STL Item 9)以下为原文:</p>
<pre><code>This works wonderfully, but only for the standard sequence containers. Due to reasoning one might question, erase()&apos;s return type for the standard associative containers is void. For those containers, you have to use the postincrement-the-iterator-you-pass-to-erase technique.</code></pre><p><strong>1.2 正确写法2</strong> 查阅原版Effctive STL Item 9, 证实, 下面这种写法不能用于标准序列容器, 而适用于标准关联容器, 而List也可以使用这种方法.</p>
<pre><code>std::list&lt;int&gt; list;
std::list&lt;int&gt;::iterator it_list;
for (it_list = list.begin(); it_list != list.end();)
{
if (willDelete(*it_list))
{
list.erase(it_list++); // 必须使用后缀自增, 不能使用前缀自增
}
else
{
++it_list;
}
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    **1.3 错误写法 1**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::list&lt; int&gt; List; std::list&lt; int&gt;::iterator itList; for( itList = List.begin(); itList != List.end(); itList++) &#123; if( WillDelete( *itList) ) &#123; List.erase( itList); &#125; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    **1.4 错误写法 2**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::list&lt; int&gt; List; std::list&lt; int&gt;::iterator itList; for( itList = List.begin(); itList != List.end(); ) &#123; if( WillDelete( *itList) ) &#123; itList = List.erase( ++itList); &#125; else itList++; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    **1.5 分析**</span><br><span class="line">    </span><br><span class="line">    正确方法1: 通过erase()方法的返回值来获取下一个元素的位置;</span><br><span class="line">    正确方法2: 在调用erase()方法之前先使用&quot;++&quot; 来获取下一个元素的位置;</span><br><span class="line">    错误使用方法1: 在调用erase()方法之后使用&quot;++&quot; 来获取下一个元素的位置, 由于在调用erase()方法之后, 该元素的位置已经被删除, 如果再根据这个旧的位置来获取下一个位置, 则会出现异常;</span><br><span class="line">    错误使用方法2: 同上</span><br><span class="line">    </span><br><span class="line">    ####**2. vector,deque 容器**</span><br><span class="line">    在使用 vector、deque遍历删除元素时，也可以通过erase的返回值来获取下一个元素的位置：</span><br><span class="line">    </span><br><span class="line">    **2.1 正确写法:**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">std::vector vec; std::vector::iterator it\_vec; for (it\_vec = vec.begin(); it\_vec != vec.end();) &#123; if (willDelete(*it\_vec)) &#123; it\_vec = vec.erase(it\_vec); &#125; else &#123; ++it_vec; &#125; &#125;</span><br></pre></td></tr></table></figure></code></pre><p><strong>2.2 注意</strong></p>
<p>vector, deque 不能像上面的”正确方法2” 的办法来遍历删除. 原因请参考Effective STL条款9。摘录到下面： 1) 对于关联容器(如map, set, multimap, multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。</p>
<pre><code>for (iter = cont.begin(); it != cont.end();)
{
(*iter)-&amp;gt;doSomething();
if (shouldDelete(*iter))
cont.erase(iter++);
else
++iter;
}</code></pre><p>因为iter传给erase方法的是一个副本，iter++会指向下一个元素。</p>
<p>2) 对于序列式容器(如vector, deque)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor, deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase()方法可以返回下一个有效的iterator。</p>
<pre><code>for (iter = cont.begin(); iter != cont.end();)
{
(*it)-&amp;gt;doSomething();
if (shouldDelete(*iter))
iter = cont.erase(iter);
else
++iter;
}</code></pre><p>3)对于list来说，它使用了不连续分配的内存，并且它的erase()方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。</p>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a><strong>3. 其他</strong></h4><p><strong>set</strong> 键和值相等。 键唯一。 元素默认按升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</p>
<p><strong>map</strong> 键唯一。 元素默认按键的升序排列。 如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</p>
<p><a href="http://mp.weixin.qq.com/s/qonNrKKZLladvIwvurQCTA" target="_blank" rel="noopener">作成参考地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/02/stl-e7-9a-84-erase-e9-99-b7-e9-98-b1-e8-bf-ad-e4-bb-a3-e5-99-a8-e5-a4-b1-e6-95-88-e6-80-bb-e7-bb-93/" data-id="ck10vanyn003gzxz2r6q8qnga" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e7-94-a8gdb-e8-b0-83-e8-af-95-e7-a8-8b-e5-ba-8f" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/23/e7-94-a8gdb-e8-b0-83-e8-af-95-e7-a8-8b-e5-ba-8f/" class="article-date">
  <time datetime="2017-02-23T11:12:02.000Z" itemprop="datePublished">2017-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/23/e7-94-a8gdb-e8-b0-83-e8-af-95-e7-a8-8b-e5-ba-8f/">用GDB调试程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="使用GDB"><a href="#使用GDB" class="headerlink" title="使用GDB"></a>使用GDB</h3><p>一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p>
<pre><code>$gcc -g -Wall hello.c -o hello
$g++ -g -Wall hello.cpp -o hello</code></pre><p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 启动GDB的方法有以下几种： <code>gdb &lt;program&gt;</code> program也就是你的执行文件，一般在当前目录下。 <code>gdb &lt;program&gt; core</code> 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。 <code>gdb &lt;program&gt; &lt;pid&gt;</code> 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 以上三种都是进入gdb环境和加载被调试程序同时进行的。也可以先进入gdb环境，在加载被调试程序，方法如下：</p>
<pre><code>*在终端输入：gdb
*在gdb环境中：file &lt;program&gt;
这两步等价于：gdb &lt;program&gt;</code></pre><p>GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下面只例举一些比较常用的参数：</p>
<pre><code>-symbols &lt;file&gt;
-s &lt;file&gt;
从指定文件中读取符号表。
-se file
从指定文件中读取符号表信息，并把他用在可执行文件中。
-core &lt;file&gt;
-c &lt;file&gt;
调试时core dump的core文件。
-directory &lt;directory&gt;
-d &lt;directory&gt;
加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
```&lt;/directory&gt;&lt;/directory&gt;&lt;/file&gt;&lt;/file&gt;&lt;/file&gt;&lt;/file&gt;&lt;/program&gt;&lt;/program&gt;&lt;/pid&gt;&lt;/program&gt;&lt;/program&gt;&lt;/program&gt;

###GDB的命令概貌

启动gdb后，你就被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb的命令可以使用help命令来查看，如下所示：
```bash
$ gdb
GNU gdb 6.7.1-debian
Copyright (C) 2007 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http: gnu.org=&quot;&quot; licenses=&quot;&quot; gpl.html=&quot;&quot;&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;i486-linux-gnu&quot;.
(gdb) help
List of classes of commands:&lt;/http:&gt;

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
stack -- Examining the stack
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands

Type &quot;help&quot; followed by a class name for a list of commands in that class.
Type &quot;help all&quot; for the list of all commands.
Type &quot;help&quot; followed by command name for full documentation.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.
Command name abbreviations are allowed if unambiguous.
(gdb)</code></pre><p>gdb 的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用<code>help &lt;class&gt;</code>命令，如：help breakpoints，查看设置断点的所有命令。也可以直接<code>help &lt;command&gt;&lt;/command&gt;</code>来查看命令的帮助。 gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其列出来。</p>
<p><strong>示例一</strong>：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func</p>
<pre><code>(gdb) b func
Breakpoint 1 at 0x804837a: file tst.c, line 5.</code></pre><p><strong>示例二</strong>：敲入b按两次TAB键，你会看到所有b打头的命令：</p>
<pre><code>(gdb) b
backtrace break bt
(gdb)</code></pre><p><strong>示例三</strong>：只记得函数的前缀，可以这样：</p>
<pre><code>(gdb) b make_ &amp;lt;按TAB键&amp;gt;
（再按下一次TAB键，你会看到:）
make_a_section_from_file make_environ
make_abs_section make_function_type
make_blockvector make_pointer_type
make_cleanup make_reference_type
make_command make_symbol_completion_list
(gdb) b make_
GDB把所有make开头的函数全部列出来给你查看。</code></pre><p><strong>示例四</strong>：调试C++的程序时，有可以函数名一样。如：</p>
<pre><code>(gdb) b &apos;bubble( M-?
bubble(double,double) bubble(int,int)
(gdb) b &apos;bubble(</code></pre><p>你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思） 要退出gdb时，只用发quit或命令简称q就行了</p>
<h3 id="GDB中运行UNIX的shell程序"><a href="#GDB中运行UNIX的shell程序" class="headerlink" title="GDB中运行UNIX的shell程序"></a>GDB中运行UNIX的shell程序</h3><p>在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成： <code>shell &lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code> 调用UNIX的shell来执行<code>&lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code>，环境变量SHELL中定义的UNIX的shell将会被用来执行<code>&lt;command string=&quot;&quot;&gt;&lt;/command&gt;</code>，如果SHELL没有定义，那就使用UNIX的标准<code>shell：/bin/sh</code>。（在Windows中使用Command.com或cmd.exe） 还有一个gdb命令是make： <code>make &lt;make-args&gt;</code> 可以在gdb中执行make命令来重新build自己的程序。这个命令等价于<code>shell make &lt;make-args&gt;</code>。</p>
<h3 id="在GDB中运行程序"><a href="#在GDB中运行程序" class="headerlink" title="在GDB中运行程序"></a>在GDB中运行程序</h3><p>当以<code>gdb &lt;program&gt;</code>方式启动gdb后，gdb会在PATH路径和当前目录中搜索<code>&lt;program&gt;</code>的源文件。如要确认gdb是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。 在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。 <strong>1、程序运行参数。</strong> set args 可指定运行时参数。（如：set args 10 20 30 40 50） show args 命令可以查看设置好的运行参数。 <strong>2、运行环境。</strong> `path</p>
<p><code>可设定程序的运行路径。 show paths 查看程序的运行路径。 set environment varname [=value] 设置环境变量。如：set env USER=hchen show environment [varname] 查看环境变量。 **3、工作目录。**</code>cd</p>
<p>` 相当于shell的cd命令。 pwd 显示当前的所在目录。 <strong>4、程序的输入输出。</strong> info terminal 显示你程序用到的终端的模式。 使用重定向控制程序输出。如：run &gt; outfile tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb</p>
<h3 id="调试已运行的程序"><a href="#调试已运行的程序" class="headerlink" title="调试已运行的程序"></a>调试已运行的程序</h3><p>两种方法： 1. 在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用<code>gdb &lt;program&gt; PID</code>格式挂接正在运行的程序。 2. 先用<code>gdb &lt;program&gt;</code>关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。</p>
<h3 id="暂停-恢复程序运行"><a href="#暂停-恢复程序运行" class="headerlink" title="暂停/恢复程序运行"></a>暂停/恢复程序运行</h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。 当进程被gdb停住时，你可以使用<code>info program</code> 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（Watch Point）、捕捉点（Catch Point）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可以使用c或是 continue命令。</p>
<p><strong>下面为重要的使用步骤, 只摘抄了部分必要的信息, 如设置断点, 查看栈信息, 其余操作, 可以在<a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">wiki.ubuntu</a>查看</strong></p>
<p><strong>设置断点（Break Points）</strong> 我们用break命令来设置断点。下面有几点设置断点的方法： <code>break &lt;function&gt;</code> 在进入指定函数时停住。C++中可以使用<code>class::function</code>或<code>function(type,type)</code>格式来指定函数名。 <code>break &lt;linenum&gt;</code> 在指定行号停住。 <code>break +offset</code> <code>break -offset</code> 在当前行号的前面或后面的offset行停住。offiset为自然数。 <code>break filename：linenum</code> 在源文件filename的linenum行处停住。 <code>break filename：function</code> 在源文件filename的function函数的入口处停住。 <code>break *address</code> 在程序运行的内存地址处停住。 <code>break</code> break命令没有参数时，表示在下一条指令处停住。 <code>break ... if &lt;condition&gt;</code> …可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置<code>break if i==100</code>，表示当i为100时停住程序。 查看断点时，可使用info命令，如下所示：（注：n表示断点号） <code>info breakpoints [n]</code> <code>info break [n]</code></p>
<p><strong>维护停止点</strong> 上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用<code>delete</code>、<code>clear</code>、<code>disable</code>、<code>enable</code>这几个命令来进行维护。 <code>clear</code> 清除所有的已定义的停止点。 <code>clear &lt;function&gt;</code> <code>clear &lt;filename：function&gt;</code> 清除所有设置在函数上的停止点。 <code>clear &lt;linenum&gt;</code> <code>clear &lt;filename：linenum&gt;</code> 清除所有设置在指定行上的停止点。 <code>delete [breakpoints] [range...]</code> 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。&lt;/filename：linenum&gt;&lt;/filename：function&gt;</p>
<p>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。 <code>disable [breakpoints] [range...]</code> disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis. <code>enable [breakpoints] [range...]</code> enable所指定的停止点，breakpoints为停止点号。 <code>enable [breakpoints] once range...</code> enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。 <code>enable [breakpoints] delete range...</code> enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p>
<p><strong>恢复程序运行和单步调试</strong> 当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用step或next命令单步跟踪程序。 <code>continue [ignore-count]</code> <code>c [ignore-count]</code> <code>fg [ignore-count]</code> 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。 <code>step &lt;count&gt;</code> 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 <code>next &lt;count&gt;</code> 同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 <code>set step-mode</code> <code>set step-mode on</code> 打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数很有利于查看机器码。 <code>set step-mode off</code> 关闭step-mode模式。 <code>finish</code> 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。 <code>until 或 u</code> 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 <code>stepi 或 si</code> <code>nexti 或 ni</code> 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是<code>“display/i $pc”</code> ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p>
<p><strong>查看栈信息</strong> 当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。 下面是一些查看函数调用栈信息的GDB命令： <code>backtrace</code> <code>bt</code> 打印当前的函数调用栈的所有信息。如：</p>
<pre><code>(gdb) bt
#0  func (n=250) at tst.c:6
#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2  0x400409ed in __libc_start_main () from /lib/libc.so.6</code></pre><p>从上可以看出函数的调用栈信息：<code>__libc_start_main --&amp;gt; main() --&amp;gt; func()</code></p>
<p><code>backtrace &lt;n&gt;</code> <code>bt &lt;n&gt;</code> n是一个正整数，表示只打印栈顶上n层的栈信息。 <code>backtrace &amp;lt;-n&amp;gt;</code> <code>bt &amp;lt;-n&amp;gt;</code> -n表一个负整数，表示只打印栈底下n层的栈信息。 如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。 <code>frame &lt;n&gt;</code> <code>f &lt;n&gt;</code> n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。 <code>up &lt;n&gt;</code> 表示向栈的上面移动n层，可以不打n，表示向上移动一层。 <code>down &lt;n&gt;</code> 表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p>
<p>上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令： <code>select-frame &lt;n&gt;</code> 对应于 frame 命令。 <code>up-silently &lt;n&gt;</code>对应于 up 命令。 <code>down-silently &lt;n&gt;</code> 对应于 down 命令。 查看当前栈层的信息，你可以用以下GDB命令： <code>frame</code> 或 <code>f</code> 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。 <code>info frame</code> <code>info f</code> 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。如： <code>bash (gdb) info f Stack level 0, frame at 0xbffff5d4: eip = 0x804845d in func (tst.c:6); saved eip 0x8048524 called by frame at 0xbffff60c source language c. Arglist at 0xbffff5d4, args: n=250 Locals at 0xbffff5d4, Previous frame&#39;s sp is 0x0 Saved registers: ebp at 0xbffff5d4, eip at 0xbffff5d8</code></p>
<p><code>info args</code> 打印出当前函数的参数名及其值。 <code>info locals</code> 打印出当前函数中所有局部变量及其值。 <code>info catch</code> 打印出当前的函数中的异常处理信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/23/e7-94-a8gdb-e8-b0-83-e8-af-95-e7-a8-8b-e5-ba-8f/" data-id="ck10vanzr004szxz2m0i9lxdy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e7-bc-96-e8-af-91-e5-99-a8-e5-b7-a5-e4-bd-9c-e8-bf-87-e7-a8-8b" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/09/e7-bc-96-e8-af-91-e5-99-a8-e5-b7-a5-e4-bd-9c-e8-bf-87-e7-a8-8b/" class="article-date">
  <time datetime="2017-02-09T14:13:33.000Z" itemprop="datePublished">2017-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/09/e7-bc-96-e8-af-91-e5-99-a8-e5-b7-a5-e4-bd-9c-e8-bf-87-e7-a8-8b/">编译器工作过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>代码要运行，必须先转成二进制的机器码。这是编译器的任务。</p>
<p>比如，下面这段源码（假定文件名叫做test.c）。</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
fputs(&quot;Hello, world!\n&quot;, stdout);
return 0;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    要先用编译器处理一下，才能运行。</span><br><span class="line">    </span><br><span class="line">    ```bash</span><br><span class="line">    $ gcc test.c</span><br><span class="line">    $ ./a.out</span><br><span class="line">    Hello, world!</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">对于复杂的项目，编译过程还必须分成三步。</span><br><span class="line"></span><br><span class="line">    $ ./configure</span><br><span class="line">    $ make</span><br><span class="line">    $ make install</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。</span><br><span class="line"></span><br><span class="line">本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了Alex Smith的文章《Building C Projects》。需要声明的是，本文主要针对gcc编译器，也就是针对C和C++，不一定适用于其他语言的编译。</span><br><span class="line"></span><br><span class="line">![这里写图片描述](http://img.blog.csdn.net/20170105233325494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHhid29sZg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br><span class="line"></span><br><span class="line">#### 第一步 配置（configure）</span><br><span class="line"></span><br><span class="line">编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。</span><br><span class="line"></span><br><span class="line">这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。</span><br><span class="line"></span><br><span class="line">configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。</span><br><span class="line"></span><br><span class="line">`$ ./configure --prefix=/www --with-mysql`</span><br><span class="line"></span><br><span class="line">上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。</span><br><span class="line"></span><br><span class="line">#### 第二步 确定标准库和头文件的位置</span><br><span class="line"></span><br><span class="line">源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。</span><br><span class="line"></span><br><span class="line">编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</span><br><span class="line"></span><br><span class="line">#### 第三步 确定依赖关系</span><br><span class="line"></span><br><span class="line">对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。</span><br><span class="line"></span><br><span class="line">（1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。</span><br><span class="line"></span><br><span class="line">编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。</span><br><span class="line"></span><br><span class="line">在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</span><br><span class="line"></span><br><span class="line">#### 第四步 头文件的预编译（precompilation）</span><br><span class="line"></span><br><span class="line">不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。</span><br><span class="line"></span><br><span class="line">不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。</span><br><span class="line"></span><br><span class="line">#### 第五步 预处理（Preprocessing）</span><br><span class="line"></span><br><span class="line">预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。</span><br><span class="line"></span><br><span class="line">    extern int fputs(const char *, FILE *);</span><br><span class="line">    extern FILE *stdout;</span><br><span class="line">    int main(void)</span><br><span class="line">    &#123;</span><br><span class="line">    fputs(&quot;Hello, world!\n&quot;, stdout);</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，省略了stdio.h的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。</span><br><span class="line"></span><br><span class="line">这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。</span><br><span class="line"></span><br><span class="line">#### 第六步 编译（Compilation）</span><br><span class="line"></span><br><span class="line">预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。</span><br><span class="line"></span><br><span class="line">下面是本文开头的那段源码转成的汇编码。</span><br><span class="line"></span><br><span class="line">```` .file &quot;test.c&quot; .section .rodata .LC0: .string &quot;Hello, world!\\n&quot; .text .globl main .type main, @function main: .LFB0: .cfi\_startproc pushq %rbp .cfi\_def\_cfa\_offset 16 .cfi\_offset 6, -16 movq %rsp, %rbp .cfi\_def\_cfa\_register 6 movq stdout(%rip), %rax movq %rax, %rcx movl $14, %edx movl $1, %esi movl $.LC0, %edi call fwrite movl $0, %eax popq %rbp .cfi\_def\_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident &quot;GCC: (Debian 4.9.1-19) 4.9.1&quot; .section .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></code></pre><p>这种转码后的文件称为对象文件（object file）。</p>
<h4 id="第七步-连接（Linking）"><a href="#第七步-连接（Linking）" class="headerlink" title="第七步 连接（Linking）"></a>第七步 连接（Linking）</h4><p>对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了stdout函数和fwrite函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有stdout和fwrite这两个函数的代码，它们是由C语言的标准库提供的。</p>
<p>编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接（dynamic linking）。</p>
<p><strong>make命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。</strong></p>
<h4 id="第八步-安装（Installation）"><a href="#第八步-安装（Installation）" class="headerlink" title="第八步 安装（Installation）"></a>第八步 安装（Installation）</h4><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。</p>
<p>表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。</p>
<h4 id="第九步-操作系统连接"><a href="#第九步-操作系统连接" class="headerlink" title="第九步 操作系统连接"></a>第九步 操作系统连接</h4><p>可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。</p>
<p>这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在<code>/usr/share/applications</code>目录下的<code>.desktop</code>文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。</p>
<p>这些事情就叫做”操作系统连接”。make install命令，就用来完成”安装”和”操作系统连接”这两步。</p>
<h4 id="第十步-生成安装包"><a href="#第十步-生成安装包" class="headerlink" title="第十步 生成安装包"></a>第十步 生成安装包</h4><p>写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。</p>
<p>所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。</p>
<h4 id="第十一步-动态连接（Dynamic-linking）"><a href="#第十一步-动态连接（Dynamic-linking）" class="headerlink" title="第十一步 动态连接（Dynamic linking）"></a>第十一步 动态连接（Dynamic linking）</h4><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p>
<p>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</p>
<p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/09/e7-bc-96-e8-af-91-e5-99-a8-e5-b7-a5-e4-bd-9c-e8-bf-87-e7-a8-8b/" data-id="ck10vanzs004uzxz2gjl232cp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-unordered-map-e7-ac-94-e8-ae-b0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/unordered-map-e7-ac-94-e8-ae-b0/" class="article-date">
  <time datetime="2017-01-12T12:05:01.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/unordered-map-e7-ac-94-e8-ae-b0/">unordered_map笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>unordered_map与map的区别 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。 而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。 用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator== 或者hash_value()了。 最后，说，当不需要结果排好序时，最好用unordered_map。</p>
<p>linux下使用 普通的key就不说了和map一样 看一下用sockaddr_in 作为key的方法</p>
<pre><code>#ifndef CSESSION_H  
#define CSESSION_H  

#include &lt;netinet in.h=&quot;&quot;&gt;
#include &lt;time.h&gt;
#include &lt;/time.h&gt;&lt;/netinet&gt;

&lt;map&gt;
#include &lt;string.h&gt;
#include &lt;tr1 unordered_map=&quot;&quot;&gt;  //头文件
#include &lt;iostream&gt;

using namespace std;
using namespace std::tr1;

struct Terminal
{
int             nid ; //id  the key for terminal
sockaddr_in     addr; //ip  the key for Client
time_t          tm;   //last alive time
enTerminalStat  enStat;//status
Terminal();
~Terminal();
Terminal &amp;amp;operator =(const Terminal&amp;amp; term);
};

struct hash_func  //hash 函数
{
size_t operator()(const sockaddr_in &amp;amp;addr) const
{
return addr.sin_port*9999 + addr.sin_addr.s_addr;
}
};
struct cmp_fun //比较函数 ==
{
bool operator()(const sockaddr_in &amp;amp;addr1, const sockaddr_in &amp;amp;addr2) const
{
return memcmp(&amp;amp;addr1, &amp;amp;addr2, sizeof(sockaddr_in)) == 0 ? true:false;
}
};

//typedef unordered_map&lt;int,terminal*&gt; MapTerminal; // Terminal socket 作为key
//typedef unordered_map&lt;int,terminal*&gt;::iterator MapTerminal_It; //  &lt;/int,terminal*&gt;&lt;/int,terminal*&gt;

typedef unordered_map&lt;sockaddr_in, terminal*,hash_func,=&quot;&quot; cmp_fun=&quot;&quot;&gt; MapClientSession; // sockaddr_in作为key
typedef unordered_map&lt;sockaddr_in, terminal*,hash_func,=&quot;&quot; cmp_fun=&quot;&quot;&gt;::iterator MapClientSession_It; //  &lt;/sockaddr_in,&gt;&lt;/sockaddr_in,&gt;

#endif // CSESSION_H</code></pre><p><code>operator==</code>有两种方式 一种是</p>
<pre><code>struct st
{
bool operator==(const st &amp;amp;s) const
...
}；</code></pre><p>另一种就是自定义函数体，代码中</p>
<pre><code>struct cmp_fun
{
bool operator()(...)
...
}</code></pre><p>必须要自定义<code>operator==</code>和<code>hash_value</code>。 重载<code>operator==</code>是因为，如果两个元素的<code>hash_value</code>的值相同，并不能断定这两个元素就相同，必须再调用<code>operator==</code>。 当然，如果<code>hash_value</code>的值不同，就不需要调用<code>operator==</code>了。</p>
<p>&lt;/string.h&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/12/unordered-map-e7-ac-94-e8-ae-b0/" data-id="ck10vanyv003ozxz25rywm64s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-unordered-set-e7-ac-94-e8-ae-b0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/unordered-set-e7-ac-94-e8-ae-b0/" class="article-date">
  <time datetime="2017-01-05T15:14:47.000Z" itemprop="datePublished">2017-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/unordered-set-e7-ac-94-e8-ae-b0/">unordered_set笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.cplusplus.com/reference/unordered\_set/unordered\_set/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/unordered\_set/unordered\_set/</a></p>
<p><strong>unordered_set</strong> 模板原型:</p>
<pre><code>[cpp]
template &amp;lt; class Key,  
    class Hash = hash&lt;key&gt;,
class Pred = equal_to&lt;key&gt;,
class Alloc = allocator&lt;key&gt;
&amp;gt; class unordered_set;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    当比较unordered_set中某两个元素时, 先调用`hash&lt;key&gt;`, 如果`hash&lt;key&gt;`  不相等, 说明两个元素不同, 如果`hash&lt;key&gt;` 值相等, 则调用`equal_to&lt;key&gt;`, 判断两个元素是否完全相等. (Hash函数和Compare函数都可以自定义)&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;</span><br><span class="line">    </span><br><span class="line">    C++ 11中对unordered_set描述大体如下：无序集合容器（unordered_set）是一个存储唯一(unique，即无重复）的关联容器（Associative container），容器中的元素无特别的秩序关系，该容器允许基于值的快速元素检索，同时也支持正向迭代。</span><br><span class="line">    在一个unordered_set内部，元素不会按任何顺序排序，而是通过元素值的hash值将元素分组放置到各个槽(Bucker，也可以译为“桶”），这样就能通过元素值快速访问各个对应的元素（均摊耗时为O（1））。</span><br><span class="line">    原型中的Key代表要存储的类型，而hash&lt;key&gt;也就是你的hash函数，equal_to&lt;key&gt;用来判断两个元素是否相等，allocator&lt;key&gt;是内存的分配策略。一般情况下，我们只关心hash&lt;key&gt;和equal_to&lt;key&gt;参数，下面将介绍这两部分。&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/key&gt;</span><br><span class="line">    </span><br><span class="line">    **`hash&lt;key&gt;`**</span><br><span class="line">    ` hash&lt;key&gt;`通过相应的hash函数，将传入的参数转换为一个size_t类型值，然后用该值对当前hashtable的bucket取模算得其对应的hash值。而C++标准库，为我们提供了基本数据类型的hash函数：&lt;/key&gt;&lt;/key&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">\[cpp\] /// Primary class template hash. template struct hash;</span><br><span class="line"></span><br><span class="line">/// Partial specializations for pointer types. template struct hash&lt;\_Tp*&gt; : public \_\_hash\_base&lt;size\_t, \_tp*=&quot;&quot;&gt; &#123; size\_t operator()(\_Tp* \_\_p) const noexcept &#123; return reinterpret_cast(__p); &#125; &#125;; &lt;/size_t,&gt;</span><br><span class="line"></span><br><span class="line">// Explicit specializations for integer types.</span><br><span class="line"></span><br><span class="line">define \_Cxx\_hashtable\_define\_trivial\_hash(\_Tp) \</span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line">template&lt;&gt; \ struct hash&lt;\_Tp&gt; : public \_\_hash\_base&lt;size\_t, \_tp=&quot;&quot;&gt; \ &#123; \ size\_t \ operator()(\_Tp \_\_val) const noexcept \ &#123; return static_cast(__val); &#125; \ &#125;; &lt;/size_t,&gt;</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for bool. \_Cxx\_hashtable\_define\_trivial_hash(bool)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for char. \_Cxx\_hashtable\_define\_trivial_hash(char)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for signed char. \_Cxx\_hashtable\_define\_trivial_hash(signed char)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned char. \_Cxx\_hashtable\_define\_trivial_hash(unsigned char)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for wchar\_t. \_Cxx\_hashtable\_define\_trivial\_hash(wchar_t)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for char16\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char16_t)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for char32\_t. \_Cxx\_hashtable\_define\_trivial\_hash(char32_t)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for short. \_Cxx\_hashtable\_define\_trivial_hash(short)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for int. \_Cxx\_hashtable\_define\_trivial_hash(int)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for long. \_Cxx\_hashtable\_define\_trivial_hash(long)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for long long. \_Cxx\_hashtable\_define\_trivial_hash(long long)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned short. \_Cxx\_hashtable\_define\_trivial_hash(unsigned short)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned int. \_Cxx\_hashtable\_define\_trivial_hash(unsigned int)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long)</span><br><span class="line"></span><br><span class="line">/// Explicit specialization for unsigned long long. \_Cxx\_hashtable\_define\_trivial_hash(unsigned long long)</span><br><span class="line"></span><br><span class="line">    对于指针类型，标准库只是单一将地址转换为一个size_t值作为hash值，这里特别需要注意的是`char *`类型的指针，其标准库提供的hash函数只是将指针所指地址转换为一个sieze_t值，如果，你需要用`char *`所指的内容做hash，那么，你需要自己写hash函数或者调用系统提供的`hash&lt;string&gt;`。</span><br><span class="line">    标准库为string类型对象提供了一个hash函数，即：Murmur hash，。对于float、double、long double标准库也有相应的hash函数，这里，不做过多的解释，相应的可以参看functional_hash.h头文件。</span><br><span class="line">    上述只是介绍了基本数据类型，而在实际应用中，有时，我们需要使用自己写的hash函数，那怎么自定义hash函数？参考标准库基本数据类型的hash函数，我们会发现这些hash函数有个共同的特点：通过定义函数对象，实现相应的hash函数，这也就意味我们可以通过自定义相应的函数对象，来实现自定义hash函数。比如：已知平面上有N，每个点的x轴、y轴范围为[0，100]，现在需要统计有多少个不同点？hash函数设计为：将每个点的x、y值看成是101进制，如下所示:&lt;/string&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">\[cpp\]</span><br><span class="line"></span><br><span class="line">include&lt;bits\\stdc++.h&gt;</span><br><span class="line">=======================</span><br><span class="line"></span><br><span class="line">using namespace std; struct myHash &#123; size\_t operator()(pair&lt;int, int=&quot;&quot;&gt; \_\_val) const &#123; return static_cast(\_\_val.first * 101 + \_\_val.second); &#125; &#125;; int main() &#123; unordered\_set&lt;pair&lt;int, int=&quot;&quot;&gt;, myHash&gt; S; int x, y; while (cin &gt;&gt; x &gt;&gt; y) S.insert(make\_pair(x, y)); for (auto it = S.begin(); it != S.end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;  </span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    **`equal_to&lt;key&gt;`**</span><br><span class="line">    该参数用于实现比较两个关键字是否相等，至于为什么需要这个参数？这里做点解释，前面我们说过，当不同关键字，通过hash函数，可能会得到相同的关键字值，每当我们在unordered_set里面做数据插入、删除时，由于unordered_set关键字唯一性，所以我们得确保唯一性。标准库定义了基本类型的比较函数，而对于自定义的数据类型，我们需要自定义比较函数。这里有两种方法:重载==操作符和使用函数对象，下面是STL中实现`equal_to&lt;key&gt;`的源代码：&lt;/key&gt;&lt;/key&gt;&lt;/pair&lt;int,&gt;&lt;/size_t&gt;&lt;/int,&gt;&lt;/bits\stdc++.h&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">\[cpp\] template struct unary\_function &#123; /// @c argument\_type is the type of the argument typedef \_Arg argument\_type;</span><br><span class="line"></span><br><span class="line">/// @c result\_type is the return type typedef \_Result result_type; &#125;; template struct equal\_to : public binary\_function&lt;\_Tp, \_Tp, bool&gt; &#123; bool operator()(const \_Tp&amp; \_\_x, const \_Tp&amp; \_\_y) const &#123; return \_\_x == \_\_y; &#125; &#125;;</span><br></pre></td></tr></table></figure></code></pre><p><strong>扩容与缩容</strong> 在vector中，每当我们插入一个新元素时，如果当前的容量（capacity)已不足，需要向系统申请一个更大的空间，然后将原始数据拷贝到新空间中。这种现象在unordered_set中也存在，比如当前的表长为100，而真实存在表中的数据已经大于1000个元素，此时，每个bucker均摊有10个元素，这样就会影响到unordered_set的存取效率，而标准库通过采用某种策略来对当前空间进行扩容，以此来提高存取效率。当然，这里也存在缩容，原理和扩容类似，不过，需要注意的是，每当unordered_set内部进行一次扩容或者缩容，都需要对表中的数据重新计算，也就是说，扩容或者缩容的时间复杂度至少为。 code：</p>
<pre><code>[cpp]
// unordered_set::find
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;  &lt;/unordered_set&gt;&lt;/string&gt;&lt;/iostream&gt;

int main ()
{
std::unordered_set&lt;std::string&gt; myset = { &quot;red&quot;,&quot;green&quot;,&quot;blue&quot; };  &lt;/std::string&gt;

std::string input;
std::cout &amp;lt;&amp;lt; &quot;color? &quot;;  
  getline (std::cin,input);  

  std::unordered_set&lt;std::string&gt;::const_iterator got = myset.find (input);  &lt;/std::string&gt;

if ( got == myset.end() )
std::cout &amp;lt;&amp;lt; &quot;not found in myset&quot;;  
  else  
    std::cout &amp;lt;&amp;lt; *got &amp;lt;&amp;lt; &quot; is in myset&quot;;  

  std::cout &amp;lt;&amp;lt; std::endl;  

  return 0;  
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/05/unordered-set-e7-ac-94-e8-ae-b0/" data-id="ck10vanyx003qzxz2wr22qiu9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-e4-bb-a3-e7-a0-81-e4-bc-98-e5-8c-96-e5-bb-ba-e8-ae-ae" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/17/c-e4-bb-a3-e7-a0-81-e4-bc-98-e5-8c-96-e5-bb-ba-e8-ae-ae/" class="article-date">
  <time datetime="2016-12-17T14:02:36.000Z" itemprop="datePublished">2016-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/17/c-e4-bb-a3-e7-a0-81-e4-bc-98-e5-8c-96-e5-bb-ba-e8-ae-ae/">c++代码优化建议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>记住阿姆达尔定律： Ahmdal’s rule $$Speedup =\dfrac{ time_{old}}{time_{new}} = \dfrac{1}{(1-func_{cost})+func_{cost}/func_{speedup}}$$</li>
</ol>
<ul>
<li>func_cost是函数func运行时间百分比，func_speedup是你优化函数的运行的系数。</li>
<li>所以，如果你优化了函数TriangleIntersect执行40%的运行时间，使它运行快了近两倍，而你的程序会运行快25%。</li>
<li>这意味着不经常使用的代码不需要做较多优化考虑（或者完全不优化）。</li>
<li>这里有句俗语：让经常执行的路径运行更加高效，而运行稀少的路径正确运行。</li>
</ul>
<ol>
<li><p>代码先保证正确，然后再考虑优化 这并不意味着用8周时间写一个全功能的射线追踪算法，然后用8周时间去优化它。 分多步来做性能优化。 先写正确的代码，当你意识到这个函数可能会被经常调用，进行明显的优化。 然后再寻找算法的瓶颈，并解决（通过优化或者改进算法）。通常，改进算法能显著地改进瓶颈——也许是采用一个你还没有预想到的方法。所有频繁调用的函数，都需要优化。</p>
</li>
<li><p>我所了解的那些写出非常高效代码的人说，他们优化代码的时间，是写代码时间的两倍。</p>
</li>
<li><p>跳转和分支执行代价高，如果可能，尽量少用。</p>
</li>
</ol>
<p>函数调用需要两次跳转，外加栈内存操作。 优先使用迭代而不是递归。 使用内联函数处理短小的函数来消除函数调用开销。 将循环内的函数调用移动到循环外(例如，将for(i=0;i&lt;100;i++) DoSomething();改为DoSomething() { for(i=0;i&lt;100;i++) { … }})。 if…else if…else if…else if…很长的分支链执行到最后的分支需要很多的跳转。如果可能，将其转换为一个switch声明语句，编译器有时候会将其转换为一个表查询单次跳转。如果switch声明不可行，将最常见的场景放在if分支链的最前面。 5. 仔细思考函数下标的顺序。</p>
<pre><code>两阶或更高阶的数组在内存中还是以一维的方式在存储在内存中，这意味着（对于C/C++数组）array[i][j] 和 array[i][j+1]是相邻的，但是array[i][j] 和array[i+1][j]可能相距很远。</code></pre><p>以适当的方式访问存储实际内存中的数据，可以显著地提升你代码的执行效率（有时候可以提升一个数量级甚至更多）。 现代处理器从主内存中加载数据到处理器cache，会加载比单个值更多的数据。该操作会获取请求数据和相邻数据（一个cache行大小）的整块数据。这意味着，一旦array[i][j]已经在处理器cache中，array[i][j+1]很大可能也已经在cache中了，而array[i+1][j]可能还在内存中。 6. 使用指令层的并行机制</p>
<pre><code>尽管许多程序还是依赖单线程的执行，现代处理器在单核中也提供了不少的并行性。例如：单个CPU可以同时执行4个浮点数乘，等待4个内存请求并执行一个分支预判。</code></pre><p>为了最大化利用这种并行性，代码块（在跳转之间的）需要足够的独立指令来允许处理器被充分利用。 考虑展开循环来改进这一点。 这也是使用内联函数的一个好理由。 7. 避免或减少使用本地变量。</p>
<pre><code>本地变量通常都存储在栈上。不过如果数量比较少，它们可以存储在CPU寄存器中。在这种情况下，函数不但得到了更快访问存储在寄存器中的数据的好处，也避免了初始化一个栈帧的开销。</code></pre><p>不要将大量数据转换为全局变量。 8. 减少函数参数的个数。</p>
<pre><code>和减少使用本地变量的理由一样——它们也是存放在栈上。</code></pre><p>9. 通过引用传递结构体而不是传值</p>
<pre><code>我在射线追踪中还找不到一个场景需要将结构体使用传值方式（包括一些简单结构如：Vector，Point和Color）。</code></pre><p>10. 如果你的函数不需要返回值，不要定义。</p>
<ol>
<li><p>尽量避免数据转换。</p>
<p>整数和浮点数指令通常操作不同的寄存器，所以转换需要进行一次拷贝操作。 短整型（char和short）仍然使用一整个寄存器，并且它们需要被填充为32/64位，然后在存储回内存时需要再次转换为小字节（不过，这个开销一定比一个更大的数据类型的内存开销要多一点）。</p>
</li>
<li><p>定义C++对象时需要注意。</p>
<p>使用类初始化而不是使用赋值（Color c(black); 比Color c; c = black;更快）</p>
</li>
<li><p>使类构造函数尽可能轻量。 尤其是常用的简单类型（比如，color，vector，point等等），这些类经常被复制。 这些默认构造函数通常都是在隐式执行的，这或许不是你所期望的。 使用类初始化列表(Use Color::Color() : r(0), g(0), b(0) {}，而不是初始化函数Color::Color() { r= g = b = 0; } .)</p>
</li>
<li><p>如果可以的话，使用位移操作&gt;&gt;和&lt;&lt;来代替整数乘除法</p>
</li>
<li><p>小心使用表查找函数</p>
<p>许多人都鼓励将复杂的函数（比如：三角函数）转化为使用预编译的查找表。对于射线追踪功能来说，这通常导致了不必要的内存查找，这很昂贵（并不断增长），并且这和计算一个三角函数并从内存中获取值一样快（尤其你考虑到三角查找打乱了cpu的cache存取）。 在其他情况下，查找表会很有用。对于GPU编程通常优先使用表查找而不是复杂函数。</p>
</li>
<li><p>对大多数类，优先使用+= 、 -= 、 *= 和 /=，而不是使用+ 、 – 、 * 、 和?/</p>
<p>这些简单操作需要创建一个匿名临时中间变量。 例如：Vector v = Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1);?创建了五个匿名临时Vector: Vector(1,0,0), Vector(0,1,0), Vector(0,0,1), Vector(1,0,0) + Vector(0,1,0), 和 Vector(1,0,0) + Vector(0,1,0) + Vector(0,0,1). 对上述代码进行简单转换：Vector v(1,0,0); v+= Vector(0,1,0); v+= Vector(0,0,1);仅仅创建了两个临时Vector: Vector(0,1,0) 和 Vector(0,0,1)。这节约了6次函数调用（3次构造函数和3次析构函数）。</p>
</li>
<li><p>对于基本数据类型，优先使用+?、?-?、?<em>?、?和?/，而不是+=?、?-=?、?</em>= 和 /=</p>
</li>
<li><p>推迟定义本地变量</p>
<p>定义一个对象变量通常需要调用一次函数（构造函数）。 如果一个变量只在某些情况下需要（例如在一个if声明语句内），仅在其需要的时候定义，这样，构造函数仅在其被使用的时候调用。</p>
</li>
<li><p>对于对象，使用前缀操作符（++obj），而不是后缀操作符（obj++）</p>
<p>这在你的射线追踪算法中可能不是一个问题 使用后缀操作符需要执行一次对象拷贝（这也导致了额外的构造和析构函数调用），而前缀的构造函数不需要一个临时的拷贝。</p>
</li>
<li><p>小心使用模板</p>
<p>对不同的是实例实现进行不同的优化。 标准模板库已经经过良好的优化，不过我建议你在实现一个交互式射线追踪算法时避免使用它。 使用自己的实现，你知道它如何使用算法，所以你知道如何最有效的实现它。 最重要的是，我的经历告诉我：调试STL库非常低效。通常这也不是一个问题，除非你使用debug版本做性能分析。你会发现STL的构造函数，迭代器和其他一些操作，占用了你15%的运行时间，这会导致你分析性能输出更加费劲。</p>
</li>
<li><p>避免在计算时进行动态内存分配</p>
<p>动态内存对于存储场景和运行期间其他数据都很有用。 但是，在许多（大多数）的系统动态内存分配需要获取控制访问分配器的锁。对于多线程应用程序，现实中使用动态内存由于额外的处理器导致了性能下降，因为需要等待分配器锁和释放内存。 即便对于单线程应用，在堆上分配内存也比在栈上分配内存开销大得多。操作系统还需要执行一些操作来计算并找到适合尺寸的内存块。</p>
</li>
<li><p>找到你系统内存cache的信息并利用它们</p>
<p>如果一个是数据结构正好适合一个cache行，处理整个类从内存中只需要做一次获取操作。 确保所有的数据结构都是cache行大小对齐（如果你的数据结构和一个cache行大小都是128字节，仍有可能因为你的结构体中的一个字节在一个cache行中，而其他127字节在另外一个cahce行中）。</p>
</li>
<li><p>避免不需要的数据初始化</p>
<p>如果你需要初始化一大段的内存，考虑使用memset。</p>
</li>
<li><p>尽早结束循环和尽早返回函数调用</p>
<p>考虑一个射线和三角形交叉，通常的情况是射线会越过三角，所以这里可以优化。 如果你决定将射线和三角面板交叉。如果射线和面板交叉t值是负数，你可以立即返回。这允许你跳过射线三角交叉一大半的质心坐标计算。这是一个大的节约，一旦你知道这个交叉不存在，你就应该立即返回交叉计算函数。 同样的，一些循环也应该尽早结束。例如，当设置阴影射线，对于近处的交叉通常都是不必须的，一旦有类似的的交叉，交叉计算就应该尽早返回。（这里的交叉含义不太明白，可能是专业词汇，译者注）</p>
</li>
<li><p>在稿纸上简化你的方程式</p>
<p>许多方程式中，通常都可以或者在某些条件中取消计算。 编译器不能发现这些简化，但是你可以。取消一个内部循环的一些昂贵操作可以抵消你在其他地方的好几天的优化工作。</p>
</li>
<li><p>整数、定点数、32位浮点数和64位双精度数字的数学运算差异，没有你想象的那么大</p>
<p>在现代CPU，浮点数运算和整数运算差不多拥有同样的效率。在计算密集型应用（比如射线追踪），这意味这可以忽略整数和浮点数计算的开销差异。这也就是说，你不必要对算数进行整数处理优化。 双精度浮点数运算也不比单精度浮点数运算更慢，尤其是在64位机器上。我在同一台机器测试射线追踪算法全部使用double比全部使用floats运行有时候更快，反过来测试也看到了一样的现象（这里的原文是：I have seen ray tracers run faster using all doubles than all floats on the same machine. I have also seen the reverse）。</p>
</li>
<li><p>不断改进你的数学计算，以消除昂贵的操作</p>
<p>sqrt()经常可以被优化掉，尤其是在比较两个值的平方根是否一致时。 如果你重复地需要处理 除x 操作，考虑计算1/x的值，乘以它。这在向量规范化（3次除法）运算中赢得了大的改进，不过我最近发现也有点难以确定的。不过，这仍然有所改进，如果你要进行三次或更多除法运算。 如果你在执行一个循环，那些在循环中执行不发生变化的部分，确保提取到循环外部。 考虑看看你的计算值是否可以在循环中修改得到（而不每次都重新开始循环计算）。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/17/c-e4-bb-a3-e7-a0-81-e4-bc-98-e5-8c-96-e5-bb-ba-e8-ae-ae/" data-id="ck10vanzl004nzxz2s3da1oc5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-x-x" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/19/x-x/" class="article-date">
  <time datetime="2016-11-19T12:40:58.000Z" itemprop="datePublished">2016-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/19/x-x/">x == x</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C的表达式 x == x，何时为假呢？即下面的代码：</p>
<pre><code>if (x == x)
{
printf(&quot;Equal\n&quot;);
}
else
{
printf(&quot;Not equal\n&quot;);
}</code></pre><p>什么时候输出为”Not equal”呢？</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;&lt;/string.h&gt;&lt;/stdio.h&gt;&lt;/stdlib.h&gt;

int main(void)
{
float x = 0xffffffff;

if (x == x)
{
printf(&quot;Equal\n&quot;);
}
else
{
printf(&quot;Not equal\n&quot;);
}

if (x &amp;gt;= 0)
{
printf(&quot;x(%f) &amp;gt;= 0\n&quot;, x);
}
else if (x &amp;lt; 0) 
    {
        printf(&quot;x(%f) &amp;lt; 0\n&quot;, x);
    }

    int a = 0xffffffff;
    memcpy(&amp;amp;x, &amp;amp;a, sizeof(x));
    if (x == x) 
    {
        printf(&quot;Equal\n&quot;);
    }
    else 
    {
        printf(&quot;Not equal\n&quot;);
    }

    if (x &amp;gt;= 0)
{
printf(&quot;x(%f) &amp;gt;= 0\n&quot;, x);
}
else if (x &amp;lt; 0) 
    {
        printf(&quot;x(%f) &amp;lt; 0\n&quot;, x);
    }
    else 
    {
        printf(&quot;Surprise x(%f)!!!\n&quot;, x);
    }

    return 0;
}</code></pre><p>编译<code>gcc -g -Wall test.c</code>，看执行结果：</p>
<pre><code>$ ./a.out
Equal
x(4294967296.000000) &amp;gt;= 0
Not equal
Surprise x(-nan)!!!</code></pre><p>最后两行输出是不是有点surprise啊。</p>
<p>下面先简单解释一下： 1. 当<code>float x = 0xffffffff</code>：这时将整数赋给一个浮点数，由于float和int的size都是4，而浮点数的存储格式与整数不同，其需要将某些位作为小数位，所以float的范围要小于int的范围。因此这里涉及到了整数转换浮点的规定。因为这个转换其实很少用到，我也就不查了。但是总之，这个转换是合法的。但是最终的值很可能不是你想要的结果——尤其是当浮点的范围小于整数的范围时。 2. 即使整数转换成浮点，数值再不是期望值，但它也一定是一个合法的浮点数值。所以第一个<code>x == x</code>，一定为true，且x不是大于0，就是小于0。这时x存的并不是0xffffffff。 3. 当使用memcpy将0xff填充到x的地址时，这时x存的保证为0xffffffff。但是这个不是一个合法的float的值。因此奇怪的现象发生了，x并不等于x。原因则是与cpu的浮点指令相关. 4. 作为一个非法的float值，当它与其它任何数值比较时，都会返回false。这也就造成了，后面惊奇的结果，x既不大于等于0，也不小于0。</p>
<p>总结一下：一般来说，浮点类型很少被使用，也不应该在程序中鼓励使用。不仅其效率比整数低，且由于浮点类型特殊的存储格式，很容易造成一些意想不到的错误。如果真的无法避免时，一定要小心小心再小心。特别要注意今天的主题，这种非法的浮点值，会导致任何比较判断都失败。而判断这种浮点值的方法也很简单，如果x != x，那么该浮点即为非法浮点值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/19/x-x/" data-id="ck10vanyy003tzxz2xyloonto" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-e5-9c-a8-e9-87-8d-e8-bd-bdoperator-e4-b8-ba-e5-b8-a6-e6-a8-a1-e6-9d-bf-e7-9a-84-e5-87-bd-e6-95-b0-e7-9a-84-e6-97-b6-e5-80-99-e7-9a-84-e9-99-b7-e9-98-b1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/29/c-e5-9c-a8-e9-87-8d-e8-bd-bdoperator-e4-b8-ba-e5-b8-a6-e6-a8-a1-e6-9d-bf-e7-9a-84-e5-87-bd-e6-95-b0-e7-9a-84-e6-97-b6-e5-80-99-e7-9a-84-e9-99-b7-e9-98-b1/" class="article-date">
  <time datetime="2016-10-29T12:20:32.000Z" itemprop="datePublished">2016-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/29/c-e5-9c-a8-e9-87-8d-e8-bd-bdoperator-e4-b8-ba-e5-b8-a6-e6-a8-a1-e6-9d-bf-e7-9a-84-e5-87-bd-e6-95-b0-e7-9a-84-e6-97-b6-e5-80-99-e7-9a-84-e9-99-b7-e9-98-b1/">C++在重载operator=为带模板的函数的时候的陷阱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址 <a href="https://segmentfault.com/a/1190000004467381" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004467381</a></p>
<p>最近被一个语法问题缠了半天，终于找到了原因。不仔细思考一下写的时候真的很容易忽略。先看代码：</p>
<p>template class A { public: const T t = 0;</p>
<p>template A&amp; operator=(const A&amp; a) { return *this; } };</p>
<p>int main() { A a, b;</p>
<p>b = a; // error } 这会带来一个编译错误，然而横睇掂睇都看不出问题。于是我就试了一下这样的代码：A c; b = c;居然通过了编译。F**k，这个模板居然胳膊肘往外拐。</p>
<p>其实我在写这个代码的时候忽略了一点，就是default assignment operator，它是你在定义类的时候编译器默认给你加上去的，行为是对所有成员变量赋值。它的声明是A&amp; operator=(const A&amp; a);，跟我们自己定义的放在一起：</p>
<p>template A&amp; operator=(const A&amp; a) { return *this; }</p>
<p>A&amp; operator=(const A&amp; a) /<em>= delete</em>/; 恰好构成了模板特化，这就糟了。一旦构成了特化，OtherT可以匹配的类型就会除去int，用A赋值时只能调用系统给我们定义的那个。然而它也不起作用，因为成员里面有常量（这样它就会被标记为= delete，留意delete并不会令OtherT可以匹配到int，反而令它匹配不到）。</p>
<p>知道了原因之后，解决就很方便了，只要重新定义这个默认赋值运算符就好：</p>
<p>A&amp; operator=(const A&amp; a) { /<em>…</em>/ }</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/29/c-e5-9c-a8-e9-87-8d-e8-bd-bdoperator-e4-b8-ba-e5-b8-a6-e6-a8-a1-e6-9d-bf-e7-9a-84-e5-87-bd-e6-95-b0-e7-9a-84-e6-97-b6-e5-80-99-e7-9a-84-e9-99-b7-e9-98-b1/" data-id="ck10vanw00001zxz2tm27rirz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/A-amp-V/">A&amp;V</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/En/">En</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/En/JSON/">JSON</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DB/">DB</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/DB/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design/">Design</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rasp/">Rasp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 20px;">nginx</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/08/08/e5-8d-87-e7-ba-a7https/">升级https</a>
          </li>
        
          <li>
            <a href="/2019/07/23/docker-e6-8c-82-e8-bd-bd-e7-9b-ae-e5-bd-95-e5-a4-b1-e8-b4-a5-e6-9d-83-e9-99-90-e6-8b-92-e7-bb-9d/">docker挂载目录失败/权限拒绝</a>
          </li>
        
          <li>
            <a href="/2019/07/02/mac-iterm2-e7-99-bb-e9-99-86centos-e6-8f-90-e7-a4-bawarning-setlocale-lc-ctype-cannot-change-locale-utf-8-no-such-file-or-directory/">Mac iTerm2登陆CentOS提示warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</a>
          </li>
        
          <li>
            <a href="/2019/06/12/e5-8d-87-e7-ba-a7-e5-88-b0php7-1-e4-b9-8b-e5-90-8ewordpress-e7-bd-91-e7-ab-99-e5-87-ba-e7-8e-b0error-establishing-a-database-connection-e7-9a-84-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95/">升级到php7.1之后wordpress 网站出现Error establishing a database connection的解决方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>